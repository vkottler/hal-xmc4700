/**
 * \file
 * \brief Generated by ifgen (3.1.2).
 */
#pragma once

#include <cstdint>
#include <cstring>

namespace XMC4700
{

enum class USIC0_CH0_DX0CR_INSW : uint8_t
{
    trolled_by_protocol__cont /*!< The input of the data shift unit is
                                 controlled by the protocol pre-processor. */
        ,
    nected_selected_data_cont =
        1 /*!< The input of the data shift unit is connected to the selected
             data input line. This setting is used if the signals are directly
             derived from an input pin without treatment by the protocol
             pre-processor. */
};
static_assert(sizeof(USIC0_CH0_DX0CR_INSW) == 1);

/**
 * Converts USIC0_CH0_DX0CR_INSW to a C string.
 *
 * \param[in] instance Value to convert.
 * \return             A C string representation of the value.
 */
inline const char *to_string(USIC0_CH0_DX0CR_INSW instance)
{
    const char *result = "UNKNOWN USIC0_CH0_DX0CR_INSW";

    switch (instance)
    {
    case USIC0_CH0_DX0CR_INSW::trolled_by_protocol__cont:
        result = "trolled_by_protocol__cont";
        break;
    case USIC0_CH0_DX0CR_INSW::nected_selected_data_cont:
        result = "nected_selected_data_cont";
        break;
    }

    return result;
}

/**
 * Converts a C string to USIC0_CH0_DX0CR_INSW.
 *
 * \param[in]  data   A C string to convert.
 * \param[out] output The enumeration element to write.
 * \return            Whether or not the output was written.
 */
inline bool from_string(const char *data, USIC0_CH0_DX0CR_INSW &output)
{
    bool result = false;

    if ((result = !strncmp(data, "trolled_by_protocol__cont", 25)))
    {
        output = USIC0_CH0_DX0CR_INSW::trolled_by_protocol__cont;
    }
    else if ((result = !strncmp(data, "nected_selected_data_cont", 25)))
    {
        output = USIC0_CH0_DX0CR_INSW::nected_selected_data_cont;
    }

    return result;
}

}; // namespace XMC4700
