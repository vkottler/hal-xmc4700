/**
 * \file
 * \brief Generated by ifgen (3.1.0).
 */
#pragma once

#include "../enums/CAN_ID_MOD_TYPE.h"
#include "../enums/CAN_LIST_EMPTY.h"
#include "../enums/CAN_MCR_CLKSEL.h"
#include "../enums/CAN_PANCTR_BUSY.h"
#include "../enums/CAN_PANCTR_RBUSY.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * Controller Area Networks
 */
struct [[gnu::packed]] can
{
    /* Constant attributes. */
    static constexpr std::size_t size = 464; /*!< can's size in bytes. */

    /* Fields. */
    uint32_t CLC;                                                    /*!< (read-write) CAN Clock Control Register */
    const uint32_t reserved_padding0 = {};
    const uint32_t ID = {};                                          /*!< (read-only) Module Identification Register */
    uint32_t FDR;                                                    /*!< (read-write) CAN Fractional Divider Register */
    static constexpr std::size_t reserved_padding1_length = 60;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    static constexpr std::size_t LIST_length = 16;
    const uint32_t LIST[LIST_length] = {};                           /*!< (read-only) List Register */
    static constexpr std::size_t MSPND_length = 8;
    uint32_t MSPND[MSPND_length];                                    /*!< (read-write) Message Pending Register */
    static constexpr std::size_t reserved_padding2_length = 8;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    static constexpr std::size_t MSID_length = 8;
    const uint32_t MSID[MSID_length] = {};                           /*!< (read-only) Message Index Register */
    static constexpr std::size_t reserved_padding3_length = 8;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t MSIMASK;                                                /*!< (read-write) Message Index Mask Register */
    uint32_t PANCTR;                                                 /*!< (read-write) Panel Control Register */
    uint32_t MCR;                                                    /*!< (read-write) Module Control Register */
    uint32_t MITR;                                                   /*!< (write-only) Module Interrupt Trigger Register */

    /* Methods. */

    /**
     * Get CLC's EDIS bit.
     */
    inline bool get_CLC_EDIS()
    {
        return CLC & (1u << 3u);
    }

    /**
     * Set CLC's EDIS bit.
     */
    inline void set_CLC_EDIS()
    {
        CLC |= 1u << 3u;
    }

    /**
     * Clear CLC's EDIS bit.
     */
    inline void clear_CLC_EDIS()
    {
        CLC &= ~(1u << 3u);
    }

    /**
     * Toggle CLC's EDIS bit.
     */
    inline void toggle_CLC_EDIS()
    {
        CLC ^= 1u << 3u;
    }

    /**
     * Get CLC's DISS bit.
     */
    inline bool get_CLC_DISS()
    {
        return CLC & (1u << 1u);
    }

    /**
     * Get CLC's DISR bit.
     */
    inline bool get_CLC_DISR()
    {
        return CLC & (1u << 0u);
    }

    /**
     * Set CLC's DISR bit.
     */
    inline void set_CLC_DISR()
    {
        CLC |= 1u << 0u;
    }

    /**
     * Clear CLC's DISR bit.
     */
    inline void clear_CLC_DISR()
    {
        CLC &= ~(1u << 0u);
    }

    /**
     * Toggle CLC's DISR bit.
     */
    inline void toggle_CLC_DISR()
    {
        CLC ^= 1u << 0u;
    }

    /**
     * Get all of CLC's bit fields.
     */
    inline void get_CLC(bool &EDIS, bool &DISS, bool &DISR)
    {
        uint32_t curr = CLC;

        EDIS = curr & (1u << 3u);
        DISS = curr & (1u << 1u);
        DISR = curr & (1u << 0u);
    }

    /**
     * Set all of CLC's bit fields.
     */
    inline void set_CLC(bool EDIS, bool DISR)
    {
        uint32_t curr = CLC;

        curr &= ~(0b1u << 3u);
        curr |= (EDIS & 0b1u) << 3u;
        curr &= ~(0b1u << 0u);
        curr |= (DISR & 0b1u) << 0u;

        CLC = curr;
    }

    /**
     * Get ID's MOD_NUMBER field.
     */
    inline uint16_t get_ID_MOD_NUMBER()
    {
        return (ID >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get ID's MOD_TYPE field.
     */
    inline CAN_ID_MOD_TYPE get_ID_MOD_TYPE()
    {
        return CAN_ID_MOD_TYPE((ID >> 8u) & 0b11111111u);
    }

    /**
     * Get ID's MOD_REV field.
     */
    inline uint8_t get_ID_MOD_REV()
    {
        return (ID >> 0u) & 0b11111111u;
    }

    /**
     * Get all of ID's bit fields.
     */
    inline void get_ID(uint16_t &MOD_NUMBER, CAN_ID_MOD_TYPE &MOD_TYPE, uint8_t &MOD_REV)
    {
        uint32_t curr = ID;

        MOD_NUMBER = (curr >> 16u) & 0b1111111111111111u;
        MOD_TYPE = CAN_ID_MOD_TYPE((curr >> 8u) & 0b11111111u);
        MOD_REV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get FDR's DM field.
     */
    inline uint8_t get_FDR_DM()
    {
        return (FDR >> 14u) & 0b11u;
    }

    /**
     * Set FDR's DM field.
     */
    inline void set_FDR_DM(uint8_t value)
    {
        uint32_t curr = FDR;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        FDR = curr;
    }

    /**
     * Get FDR's STEP field.
     */
    inline uint16_t get_FDR_STEP()
    {
        return (FDR >> 0u) & 0b1111111111u;
    }

    /**
     * Set FDR's STEP field.
     */
    inline void set_FDR_STEP(uint16_t value)
    {
        uint32_t curr = FDR;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        FDR = curr;
    }

    /**
     * Get all of FDR's bit fields.
     */
    inline void get_FDR(uint8_t &DM, uint16_t &STEP)
    {
        uint32_t curr = FDR;

        DM = (curr >> 14u) & 0b11u;
        STEP = (curr >> 0u) & 0b1111111111u;
    }

    /**
     * Set all of FDR's bit fields.
     */
    inline void set_FDR(uint8_t DM, uint16_t STEP)
    {
        uint32_t curr = FDR;

        curr &= ~(0b11u << 14u);
        curr |= (DM & 0b11u) << 14u;
        curr &= ~(0b1111111111u << 0u);
        curr |= (STEP & 0b1111111111u) << 0u;

        FDR = curr;
    }

    /**
     * Get LIST's EMPTY bit.
     */
    inline CAN_LIST_EMPTY get_LIST_EMPTY(std::size_t index)
    {
        return CAN_LIST_EMPTY(LIST[index] & (1u << 24u));
    }

    /**
     * Get LIST's SIZE field.
     */
    inline uint8_t get_LIST_SIZE(std::size_t index)
    {
        return (LIST[index] >> 16u) & 0b11111111u;
    }

    /**
     * Get LIST's END field.
     */
    inline uint8_t get_LIST_END(std::size_t index)
    {
        return (LIST[index] >> 8u) & 0b11111111u;
    }

    /**
     * Get LIST's BEGIN field.
     */
    inline uint8_t get_LIST_BEGIN(std::size_t index)
    {
        return (LIST[index] >> 0u) & 0b11111111u;
    }

    /**
     * Get all of LIST's bit fields.
     */
    inline void get_LIST(std::size_t index, CAN_LIST_EMPTY &EMPTY, uint8_t &SIZE, uint8_t &END, uint8_t &BEGIN)
    {
        uint32_t curr = LIST[index];

        EMPTY = CAN_LIST_EMPTY(curr & (1u << 24u));
        SIZE = (curr >> 16u) & 0b11111111u;
        END = (curr >> 8u) & 0b11111111u;
        BEGIN = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get MSPND's PND field.
     */
    inline uint32_t get_MSPND_PND(std::size_t index)
    {
        return (MSPND[index] >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MSPND's PND field.
     */
    inline void set_MSPND_PND(std::size_t index, uint32_t value)
    {
        uint32_t curr = MSPND[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MSPND[index] = curr;
    }

    /**
     * Get MSID's INDEX field.
     */
    inline uint8_t get_MSID_INDEX(std::size_t index)
    {
        return (MSID[index] >> 0u) & 0b111111u;
    }

    /**
     * Get MSIMASK's IM field.
     */
    inline uint32_t get_MSIMASK_IM()
    {
        return (MSIMASK >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MSIMASK's IM field.
     */
    inline void set_MSIMASK_IM(uint32_t value)
    {
        uint32_t curr = MSIMASK;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MSIMASK = curr;
    }

    /**
     * Get PANCTR's PANAR2 field.
     */
    inline uint8_t get_PANCTR_PANAR2()
    {
        return (PANCTR >> 24u) & 0b11111111u;
    }

    /**
     * Set PANCTR's PANAR2 field.
     */
    inline void set_PANCTR_PANAR2(uint8_t value)
    {
        uint32_t curr = PANCTR;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        PANCTR = curr;
    }

    /**
     * Get PANCTR's PANAR1 field.
     */
    inline uint8_t get_PANCTR_PANAR1()
    {
        return (PANCTR >> 16u) & 0b11111111u;
    }

    /**
     * Set PANCTR's PANAR1 field.
     */
    inline void set_PANCTR_PANAR1(uint8_t value)
    {
        uint32_t curr = PANCTR;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        PANCTR = curr;
    }

    /**
     * Get PANCTR's RBUSY bit.
     */
    inline CAN_PANCTR_RBUSY get_PANCTR_RBUSY()
    {
        return CAN_PANCTR_RBUSY(PANCTR & (1u << 9u));
    }

    /**
     * Get PANCTR's BUSY bit.
     */
    inline CAN_PANCTR_BUSY get_PANCTR_BUSY()
    {
        return CAN_PANCTR_BUSY(PANCTR & (1u << 8u));
    }

    /**
     * Get PANCTR's PANCMD field.
     */
    inline uint8_t get_PANCTR_PANCMD()
    {
        return (PANCTR >> 0u) & 0b11111111u;
    }

    /**
     * Set PANCTR's PANCMD field.
     */
    inline void set_PANCTR_PANCMD(uint8_t value)
    {
        uint32_t curr = PANCTR;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        PANCTR = curr;
    }

    /**
     * Get all of PANCTR's bit fields.
     */
    inline void get_PANCTR(uint8_t &PANAR2, uint8_t &PANAR1, CAN_PANCTR_RBUSY &RBUSY, CAN_PANCTR_BUSY &BUSY, uint8_t &PANCMD)
    {
        uint32_t curr = PANCTR;

        PANAR2 = (curr >> 24u) & 0b11111111u;
        PANAR1 = (curr >> 16u) & 0b11111111u;
        RBUSY = CAN_PANCTR_RBUSY(curr & (1u << 9u));
        BUSY = CAN_PANCTR_BUSY(curr & (1u << 8u));
        PANCMD = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of PANCTR's bit fields.
     */
    inline void set_PANCTR(uint8_t PANAR2, uint8_t PANAR1, uint8_t PANCMD)
    {
        uint32_t curr = PANCTR;

        curr &= ~(0b11111111u << 24u);
        curr |= (PANAR2 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PANAR1 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PANCMD & 0b11111111u) << 0u;

        PANCTR = curr;
    }

    /**
     * Get MCR's MPSEL field.
     */
    inline uint8_t get_MCR_MPSEL()
    {
        return (MCR >> 12u) & 0b1111u;
    }

    /**
     * Set MCR's MPSEL field.
     */
    inline void set_MCR_MPSEL(uint8_t value)
    {
        uint32_t curr = MCR;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        MCR = curr;
    }

    /**
     * Get MCR's CLKSEL field.
     */
    inline CAN_MCR_CLKSEL get_MCR_CLKSEL()
    {
        return CAN_MCR_CLKSEL((MCR >> 0u) & 0b1111u);
    }

    /**
     * Set MCR's CLKSEL field.
     */
    inline void set_MCR_CLKSEL(CAN_MCR_CLKSEL value)
    {
        uint32_t curr = MCR;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        MCR = curr;
    }

    /**
     * Get all of MCR's bit fields.
     */
    inline void get_MCR(uint8_t &MPSEL, CAN_MCR_CLKSEL &CLKSEL)
    {
        uint32_t curr = MCR;

        MPSEL = (curr >> 12u) & 0b1111u;
        CLKSEL = CAN_MCR_CLKSEL((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of MCR's bit fields.
     */
    inline void set_MCR(uint8_t MPSEL, CAN_MCR_CLKSEL CLKSEL)
    {
        uint32_t curr = MCR;

        curr &= ~(0b1111u << 12u);
        curr |= (MPSEL & 0b1111u) << 12u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(CLKSEL) & 0b1111u) << 0u;

        MCR = curr;
    }

    /**
     * Set MITR's IT field.
     */
    inline void set_MITR_IT(uint8_t value)
    {
        uint32_t curr = MITR;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        MITR = curr;
    }
};

static_assert(sizeof(can) == can::size);

static volatile can *const CAN = reinterpret_cast<can *>(0x48014000);

}; // namespace XMC4700
