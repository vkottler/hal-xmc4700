/**
 * \file
 * \brief Generated by ifgen (2.6.3).
 */
#pragma once

#include "../enums/CAN_ID_MOD_TYPE.h"
#include "../enums/CAN_LIST_EMPTY.h"
#include "../enums/CAN_MCR_CLKSEL.h"
#include "../enums/CAN_PANCTR_BUSY.h"
#include "../enums/CAN_PANCTR_RBUSY.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * Controller Area Networks
 */
struct [[gnu::packed]] can
{
    /* Constant attributes. */
    static constexpr uint16_t id = 1;        /*!< can's identifier. */
    static constexpr std::size_t size = 464; /*!< can's size in bytes. */

    /* Fields. */
    uint32_t CLC; /*!< (read-write) CAN Clock Control Register */
    const uint32_t reserved_padding0 = {};
    const uint32_t ID = {}; /*!< (read-only) Module Identification Register */
    uint32_t FDR; /*!< (read-write) CAN Fractional Divider Register */
    static constexpr std::size_t reserved_padding1_length = 60;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    static constexpr std::size_t LIST_length = 16;
    const uint32_t LIST[LIST_length] = {}; /*!< (read-only) List Register */
    static constexpr std::size_t MSPND_length = 8;
    uint32_t MSPND[MSPND_length]; /*!< (read-write) Message Pending Register */
    static constexpr std::size_t reserved_padding2_length = 8;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    static constexpr std::size_t MSID_length = 8;
    const uint32_t MSID[MSID_length] =
        {}; /*!< (read-only) Message Index Register */
    static constexpr std::size_t reserved_padding3_length = 8;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t MSIMASK; /*!< (read-write) Message Index Mask Register */
    uint32_t PANCTR;  /*!< (read-write) Panel Control Register */
    uint32_t MCR;     /*!< (read-write) Module Control Register */
    uint32_t MITR;    /*!< (write-only) Module Interrupt Trigger Register */

    /* Methods. */

    /**
     * Get CLC's EDIS bit.
     */
    bool get_CLC_EDIS()
    {
        return CLC & (1u << 3u);
    }

    /**
     * Set CLC's EDIS bit.
     */
    inline void set_CLC_EDIS()
    {
        CLC |= 1u << 3u;
    }

    /**
     * Clear CLC's EDIS bit.
     */
    inline void clear_CLC_EDIS()
    {
        CLC &= ~(1u << 3u);
    }

    /**
     * Toggle CLC's EDIS bit.
     */
    inline void toggle_CLC_EDIS()
    {
        CLC ^= 1u << 3u;
    }

    /**
     * Get CLC's DISS bit.
     */
    bool get_CLC_DISS()
    {
        return CLC & (1u << 1u);
    }

    /**
     * Get CLC's DISR bit.
     */
    bool get_CLC_DISR()
    {
        return CLC & (1u << 0u);
    }

    /**
     * Set CLC's DISR bit.
     */
    inline void set_CLC_DISR()
    {
        CLC |= 1u << 0u;
    }

    /**
     * Clear CLC's DISR bit.
     */
    inline void clear_CLC_DISR()
    {
        CLC &= ~(1u << 0u);
    }

    /**
     * Toggle CLC's DISR bit.
     */
    inline void toggle_CLC_DISR()
    {
        CLC ^= 1u << 0u;
    }

    /**
     * Get ID's MOD_NUMBER field.
     */
    uint16_t get_ID_MOD_NUMBER()
    {
        return (ID >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get ID's MOD_TYPE field.
     */
    CAN_ID_MOD_TYPE get_ID_MOD_TYPE()
    {
        return CAN_ID_MOD_TYPE((ID >> 8u) & 0b11111111u);
    }

    /**
     * Get ID's MOD_REV field.
     */
    uint8_t get_ID_MOD_REV()
    {
        return (ID >> 0u) & 0b11111111u;
    }

    /**
     * Get FDR's DM field.
     */
    uint8_t get_FDR_DM()
    {
        return (FDR >> 14u) & 0b11u;
    }

    /**
     * Set FDR's DM field.
     */
    inline void set_FDR_DM(uint8_t value)
    {
        uint32_t curr = FDR;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        FDR = curr;
    }

    /**
     * Get FDR's STEP field.
     */
    uint16_t get_FDR_STEP()
    {
        return (FDR >> 0u) & 0b1111111111u;
    }

    /**
     * Set FDR's STEP field.
     */
    inline void set_FDR_STEP(uint16_t value)
    {
        uint32_t curr = FDR;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        FDR = curr;
    }

    /**
     * Get LIST's EMPTY bit.
     */
    CAN_LIST_EMPTY get_LIST_EMPTY(std::size_t index)
    {
        return CAN_LIST_EMPTY(LIST[index] & (1u << 24u));
    }

    /**
     * Get LIST's SIZE field.
     */
    uint8_t get_LIST_SIZE(std::size_t index)
    {
        return (LIST[index] >> 16u) & 0b11111111u;
    }

    /**
     * Get LIST's END field.
     */
    uint8_t get_LIST_END(std::size_t index)
    {
        return (LIST[index] >> 8u) & 0b11111111u;
    }

    /**
     * Get LIST's BEGIN field.
     */
    uint8_t get_LIST_BEGIN(std::size_t index)
    {
        return (LIST[index] >> 0u) & 0b11111111u;
    }

    /**
     * Get MSPND's PND field.
     */
    uint32_t get_MSPND_PND(std::size_t index)
    {
        return (MSPND[index] >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MSPND's PND field.
     */
    inline void set_MSPND_PND(std::size_t index, uint32_t value)
    {
        uint32_t curr = MSPND[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MSPND[index] = curr;
    }

    /**
     * Get MSID's INDEX field.
     */
    uint8_t get_MSID_INDEX(std::size_t index)
    {
        return (MSID[index] >> 0u) & 0b111111u;
    }

    /**
     * Get MSIMASK's IM field.
     */
    uint32_t get_MSIMASK_IM()
    {
        return (MSIMASK >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MSIMASK's IM field.
     */
    inline void set_MSIMASK_IM(uint32_t value)
    {
        uint32_t curr = MSIMASK;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MSIMASK = curr;
    }

    /**
     * Get PANCTR's PANAR2 field.
     */
    uint8_t get_PANCTR_PANAR2()
    {
        return (PANCTR >> 24u) & 0b11111111u;
    }

    /**
     * Set PANCTR's PANAR2 field.
     */
    inline void set_PANCTR_PANAR2(uint8_t value)
    {
        uint32_t curr = PANCTR;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        PANCTR = curr;
    }

    /**
     * Get PANCTR's PANAR1 field.
     */
    uint8_t get_PANCTR_PANAR1()
    {
        return (PANCTR >> 16u) & 0b11111111u;
    }

    /**
     * Set PANCTR's PANAR1 field.
     */
    inline void set_PANCTR_PANAR1(uint8_t value)
    {
        uint32_t curr = PANCTR;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        PANCTR = curr;
    }

    /**
     * Get PANCTR's RBUSY bit.
     */
    CAN_PANCTR_RBUSY get_PANCTR_RBUSY()
    {
        return CAN_PANCTR_RBUSY(PANCTR & (1u << 9u));
    }

    /**
     * Get PANCTR's BUSY bit.
     */
    CAN_PANCTR_BUSY get_PANCTR_BUSY()
    {
        return CAN_PANCTR_BUSY(PANCTR & (1u << 8u));
    }

    /**
     * Get PANCTR's PANCMD field.
     */
    uint8_t get_PANCTR_PANCMD()
    {
        return (PANCTR >> 0u) & 0b11111111u;
    }

    /**
     * Set PANCTR's PANCMD field.
     */
    inline void set_PANCTR_PANCMD(uint8_t value)
    {
        uint32_t curr = PANCTR;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        PANCTR = curr;
    }

    /**
     * Get MCR's MPSEL field.
     */
    uint8_t get_MCR_MPSEL()
    {
        return (MCR >> 12u) & 0b1111u;
    }

    /**
     * Set MCR's MPSEL field.
     */
    inline void set_MCR_MPSEL(uint8_t value)
    {
        uint32_t curr = MCR;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        MCR = curr;
    }

    /**
     * Get MCR's CLKSEL field.
     */
    CAN_MCR_CLKSEL get_MCR_CLKSEL()
    {
        return CAN_MCR_CLKSEL((MCR >> 0u) & 0b1111u);
    }

    /**
     * Set MCR's CLKSEL field.
     */
    inline void set_MCR_CLKSEL(CAN_MCR_CLKSEL value)
    {
        uint32_t curr = MCR;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        MCR = curr;
    }

    /**
     * Set MITR's IT field.
     */
    inline void set_MITR_IT(uint8_t value)
    {
        uint32_t curr = MITR;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        MITR = curr;
    }
};

static_assert(sizeof(can) == can::size);

static volatile can *const CAN = reinterpret_cast<can *>(0x48014000);

}; // namespace XMC4700
