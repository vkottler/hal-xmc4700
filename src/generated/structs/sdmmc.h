/**
 * \file
 * \brief Generated by ifgen (3.2.0).
 */
#pragma once

#include "../enums/SDMMC_CAPABILITIES_BASE_SD_CLOCK_FREQ.h"
#include "../enums/SDMMC_CAPABILITIES_HI_CLK_MULT.h"
#include "../enums/SDMMC_CAPABILITIES_HI_RE_TUNING_MODES.h"
#include "../enums/SDMMC_CAPABILITIES_HI_TIM_CNT_RETUNE.h"
#include "../enums/SDMMC_CAPABILITIES_MAX_BLOCK_LENGTH.h"
#include "../enums/SDMMC_CAPABILITIES_SLOT_TYPE.h"
#include "../enums/SDMMC_CLOCK_CTRL_SDCLK_FREQ_SEL.h"
#include "../enums/SDMMC_COMMAND_CMD_TYPE.h"
#include "../enums/SDMMC_COMMAND_RESP_TYPE_SELECT.h"
#include "../enums/SDMMC_POWER_CTRL_SD_BUS_VOLTAGE_SEL.h"
#include "../enums/SDMMC_SLOT_INT_STATUS_SLOT_INT_STATUS.h"
#include "../enums/SDMMC_TIMEOUT_CTRL_DAT_TIMEOUT_CNT_VAL.h"
#include "../enums/SDMMC_TRANSFER_MODE_ACMD_EN.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * SD and Multimediacard Interface
 */
struct [[gnu::packed]] sdmmc
{
    /* Constant attributes. */
    static constexpr std::size_t size = 254; /*!< sdmmc's size in bytes. */

    /* Fields. */
    const uint32_t reserved_padding0 = {};
    uint16_t BLOCK_SIZE;           /*!< (read-write) Block Size Register */
    uint16_t BLOCK_COUNT;          /*!< (read-write) Block Count Register */
    uint32_t ARGUMENT1;            /*!< (read-write) Argument1 Register */
    uint16_t TRANSFER_MODE;        /*!< (read-write) Transfer Mode Register */
    uint16_t COMMAND;              /*!< (read-write) Command Register */
    const uint32_t RESPONSE0 = {}; /*!< (read-only) Response 0 Register */
    const uint32_t RESPONSE2 = {}; /*!< (read-only) Response 2 Register */
    const uint32_t RESPONSE4 = {}; /*!< (read-only) Response 4 Register */
    const uint32_t RESPONSE6 = {}; /*!< (read-only) Response 6 Register */
    uint32_t DATA_BUFFER;          /*!< (read-write) Data Buffer Register */
    const uint32_t PRESENT_STATE =
        {};                 /*!< (read-only) Present State Register */
    uint8_t HOST_CTRL;      /*!< (read-write) Host Control Register */
    uint8_t POWER_CTRL;     /*!< (read-write) Power Control Register */
    uint8_t BLOCK_GAP_CTRL; /*!< (read-write) Block Gap Control Register */
    uint8_t WAKEUP_CTRL;    /*!< (read-write) Wake-up Control Register */
    uint16_t CLOCK_CTRL;    /*!< (read-write) Clock Control Register */
    uint8_t TIMEOUT_CTRL;   /*!< (read-write) Timeout Control Register */
    uint8_t SW_RESET;       /*!< (read-write) Software Reset Register */
    uint16_t
        INT_STATUS_NORM; /*!< (read-write) Normal Interrupt Status Register */
    uint16_t
        INT_STATUS_ERR; /*!< (read-write) Error Interrupt Status Register */
    uint16_t EN_INT_STATUS_NORM; /*!< (read-write) Normal Interrupt Status
                                    Enable Register */
    uint16_t EN_INT_STATUS_ERR; /*!< (read-write) Error Interrupt Status Enable
                                   Register */
    uint16_t EN_INT_SIGNAL_NORM; /*!< (read-write) Normal Interrupt Signal
                                    Enable Register */
    uint16_t EN_INT_SIGNAL_ERR; /*!< (read-write) Error Interrupt Signal Enable
                                   Register */
    const uint16_t ACMD_ERR_STATUS =
        {}; /*!< (read-only) Auto CMD Error Status Register */
    static constexpr std::size_t reserved_padding1_length = 2;
    const uint8_t reserved_padding1[reserved_padding1_length] = {};
    const uint32_t CAPABILITIES = {}; /*!< (read-only) Capabilities Register */
    const uint32_t CAPABILITIES_HI =
        {}; /*!< (read-only) Capabilities Register High */
    const uint32_t MAX_CURRENT_CAP =
        {}; /*!< (read-only) Maximum Current Capabilities Register */
    const uint32_t reserved_padding2 = {};
    uint16_t
        FORCE_EVENT_ACMD_ERR_STATUS; /*!< (write-only) Force Event Register for
                                        Auto CMD Error Status */
    uint16_t FORCE_EVENT_ERR_STATUS; /*!< (write-only) Force Event Register for
                                        Error Interrupt Status */
    static constexpr std::size_t reserved_padding3_length = 8;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t DEBUG_SEL; /*!< (write-only) Debug Selection Register */
    static constexpr std::size_t reserved_padding4_length = 33;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    const uint16_t SLOT_INT_STATUS =
        {}; /*!< (read-only) Slot Interrupt Status Register */

    /* Methods. */

    /**
     * Get BLOCK_SIZE's TX_BLOCK_SIZE field.
     *
     * Transfer Block Size
     */
    inline uint16_t get_BLOCK_SIZE_TX_BLOCK_SIZE() volatile
    {
        return (BLOCK_SIZE >> 0u) & 0b111111111111u;
    }

    /**
     * Set BLOCK_SIZE's TX_BLOCK_SIZE field.
     *
     * Transfer Block Size
     */
    inline void set_BLOCK_SIZE_TX_BLOCK_SIZE(uint16_t value) volatile
    {
        uint16_t curr = BLOCK_SIZE;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        BLOCK_SIZE = curr;
    }

    /**
     * Get BLOCK_SIZE's TX_BLOCK_SIZE_12 bit.
     *
     * Transfer Block Size 12th bit.
     */
    inline bool get_BLOCK_SIZE_TX_BLOCK_SIZE_12() volatile
    {
        return BLOCK_SIZE & (1u << 15u);
    }

    /**
     * Set BLOCK_SIZE's TX_BLOCK_SIZE_12 bit.
     *
     * Transfer Block Size 12th bit.
     */
    inline void set_BLOCK_SIZE_TX_BLOCK_SIZE_12() volatile
    {
        BLOCK_SIZE |= 1u << 15u;
    }

    /**
     * Clear BLOCK_SIZE's TX_BLOCK_SIZE_12 bit.
     *
     * Transfer Block Size 12th bit.
     */
    inline void clear_BLOCK_SIZE_TX_BLOCK_SIZE_12() volatile
    {
        BLOCK_SIZE &= ~(1u << 15u);
    }

    /**
     * Toggle BLOCK_SIZE's TX_BLOCK_SIZE_12 bit.
     *
     * Transfer Block Size 12th bit.
     */
    inline void toggle_BLOCK_SIZE_TX_BLOCK_SIZE_12() volatile
    {
        BLOCK_SIZE ^= 1u << 15u;
    }

    /**
     * Get all of BLOCK_SIZE's bit fields.
     *
     * (read-write) Block Size Register
     */
    inline void get_BLOCK_SIZE(uint16_t &TX_BLOCK_SIZE,
                               bool &TX_BLOCK_SIZE_12) volatile
    {
        uint16_t curr = BLOCK_SIZE;

        TX_BLOCK_SIZE = (curr >> 0u) & 0b111111111111u;
        TX_BLOCK_SIZE_12 = curr & (1u << 15u);
    }

    /**
     * Set all of BLOCK_SIZE's bit fields.
     *
     * (read-write) Block Size Register
     */
    inline void set_BLOCK_SIZE(uint16_t TX_BLOCK_SIZE,
                               bool TX_BLOCK_SIZE_12) volatile
    {
        uint16_t curr = BLOCK_SIZE;

        curr &= ~(0b111111111111u << 0u);
        curr |= (TX_BLOCK_SIZE & 0b111111111111u) << 0u;
        curr &= ~(0b1u << 15u);
        curr |= (TX_BLOCK_SIZE_12 & 0b1u) << 15u;

        BLOCK_SIZE = curr;
    }

    /**
     * Get BLOCK_COUNT's BLOCK_COUNT field.
     *
     * Blocks Count for Current Transfer
     */
    inline uint16_t get_BLOCK_COUNT_BLOCK_COUNT() volatile
    {
        return (BLOCK_COUNT >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set BLOCK_COUNT's BLOCK_COUNT field.
     *
     * Blocks Count for Current Transfer
     */
    inline void set_BLOCK_COUNT_BLOCK_COUNT(uint16_t value) volatile
    {
        uint16_t curr = BLOCK_COUNT;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        BLOCK_COUNT = curr;
    }

    /**
     * Get ARGUMENT1's ARGUMENT1 field.
     *
     * Command Argument
     */
    inline uint32_t get_ARGUMENT1_ARGUMENT1() volatile
    {
        return (ARGUMENT1 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set ARGUMENT1's ARGUMENT1 field.
     *
     * Command Argument
     */
    inline void set_ARGUMENT1_ARGUMENT1(uint32_t value) volatile
    {
        uint32_t curr = ARGUMENT1;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        ARGUMENT1 = curr;
    }

    /**
     * Get TRANSFER_MODE's BLOCK_COUNT_EN bit.
     *
     * Block Count Enable
     */
    inline bool get_TRANSFER_MODE_BLOCK_COUNT_EN() volatile
    {
        return TRANSFER_MODE & (1u << 1u);
    }

    /**
     * Set TRANSFER_MODE's BLOCK_COUNT_EN bit.
     *
     * Block Count Enable
     */
    inline void set_TRANSFER_MODE_BLOCK_COUNT_EN() volatile
    {
        TRANSFER_MODE |= 1u << 1u;
    }

    /**
     * Clear TRANSFER_MODE's BLOCK_COUNT_EN bit.
     *
     * Block Count Enable
     */
    inline void clear_TRANSFER_MODE_BLOCK_COUNT_EN() volatile
    {
        TRANSFER_MODE &= ~(1u << 1u);
    }

    /**
     * Toggle TRANSFER_MODE's BLOCK_COUNT_EN bit.
     *
     * Block Count Enable
     */
    inline void toggle_TRANSFER_MODE_BLOCK_COUNT_EN() volatile
    {
        TRANSFER_MODE ^= 1u << 1u;
    }

    /**
     * Get TRANSFER_MODE's ACMD_EN field.
     *
     * Auto CMD Enable
     */
    inline SDMMC_TRANSFER_MODE_ACMD_EN get_TRANSFER_MODE_ACMD_EN() volatile
    {
        return SDMMC_TRANSFER_MODE_ACMD_EN((TRANSFER_MODE >> 2u) & 0b11u);
    }

    /**
     * Set TRANSFER_MODE's ACMD_EN field.
     *
     * Auto CMD Enable
     */
    inline void set_TRANSFER_MODE_ACMD_EN(
        SDMMC_TRANSFER_MODE_ACMD_EN value) volatile
    {
        uint16_t curr = TRANSFER_MODE;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        TRANSFER_MODE = curr;
    }

    /**
     * Get TRANSFER_MODE's TX_DIR_SELECT bit.
     *
     * Data Transfer Direction Select
     */
    inline bool get_TRANSFER_MODE_TX_DIR_SELECT() volatile
    {
        return TRANSFER_MODE & (1u << 4u);
    }

    /**
     * Set TRANSFER_MODE's TX_DIR_SELECT bit.
     *
     * Data Transfer Direction Select
     */
    inline void set_TRANSFER_MODE_TX_DIR_SELECT() volatile
    {
        TRANSFER_MODE |= 1u << 4u;
    }

    /**
     * Clear TRANSFER_MODE's TX_DIR_SELECT bit.
     *
     * Data Transfer Direction Select
     */
    inline void clear_TRANSFER_MODE_TX_DIR_SELECT() volatile
    {
        TRANSFER_MODE &= ~(1u << 4u);
    }

    /**
     * Toggle TRANSFER_MODE's TX_DIR_SELECT bit.
     *
     * Data Transfer Direction Select
     */
    inline void toggle_TRANSFER_MODE_TX_DIR_SELECT() volatile
    {
        TRANSFER_MODE ^= 1u << 4u;
    }

    /**
     * Get TRANSFER_MODE's MULTI_BLOCK_SELECT bit.
     *
     * Multi / Single Block Select
     */
    inline bool get_TRANSFER_MODE_MULTI_BLOCK_SELECT() volatile
    {
        return TRANSFER_MODE & (1u << 5u);
    }

    /**
     * Set TRANSFER_MODE's MULTI_BLOCK_SELECT bit.
     *
     * Multi / Single Block Select
     */
    inline void set_TRANSFER_MODE_MULTI_BLOCK_SELECT() volatile
    {
        TRANSFER_MODE |= 1u << 5u;
    }

    /**
     * Clear TRANSFER_MODE's MULTI_BLOCK_SELECT bit.
     *
     * Multi / Single Block Select
     */
    inline void clear_TRANSFER_MODE_MULTI_BLOCK_SELECT() volatile
    {
        TRANSFER_MODE &= ~(1u << 5u);
    }

    /**
     * Toggle TRANSFER_MODE's MULTI_BLOCK_SELECT bit.
     *
     * Multi / Single Block Select
     */
    inline void toggle_TRANSFER_MODE_MULTI_BLOCK_SELECT() volatile
    {
        TRANSFER_MODE ^= 1u << 5u;
    }

    /**
     * Get TRANSFER_MODE's CMD_COMP_ATA bit.
     *
     * Command Completion Signal Enable for CE-ATA Device
     */
    inline bool get_TRANSFER_MODE_CMD_COMP_ATA() volatile
    {
        return TRANSFER_MODE & (1u << 6u);
    }

    /**
     * Set TRANSFER_MODE's CMD_COMP_ATA bit.
     *
     * Command Completion Signal Enable for CE-ATA Device
     */
    inline void set_TRANSFER_MODE_CMD_COMP_ATA() volatile
    {
        TRANSFER_MODE |= 1u << 6u;
    }

    /**
     * Clear TRANSFER_MODE's CMD_COMP_ATA bit.
     *
     * Command Completion Signal Enable for CE-ATA Device
     */
    inline void clear_TRANSFER_MODE_CMD_COMP_ATA() volatile
    {
        TRANSFER_MODE &= ~(1u << 6u);
    }

    /**
     * Toggle TRANSFER_MODE's CMD_COMP_ATA bit.
     *
     * Command Completion Signal Enable for CE-ATA Device
     */
    inline void toggle_TRANSFER_MODE_CMD_COMP_ATA() volatile
    {
        TRANSFER_MODE ^= 1u << 6u;
    }

    /**
     * Get all of TRANSFER_MODE's bit fields.
     *
     * (read-write) Transfer Mode Register
     */
    inline void get_TRANSFER_MODE(bool &BLOCK_COUNT_EN,
                                  SDMMC_TRANSFER_MODE_ACMD_EN &ACMD_EN,
                                  bool &TX_DIR_SELECT,
                                  bool &MULTI_BLOCK_SELECT,
                                  bool &CMD_COMP_ATA) volatile
    {
        uint16_t curr = TRANSFER_MODE;

        BLOCK_COUNT_EN = curr & (1u << 1u);
        ACMD_EN = SDMMC_TRANSFER_MODE_ACMD_EN((curr >> 2u) & 0b11u);
        TX_DIR_SELECT = curr & (1u << 4u);
        MULTI_BLOCK_SELECT = curr & (1u << 5u);
        CMD_COMP_ATA = curr & (1u << 6u);
    }

    /**
     * Set all of TRANSFER_MODE's bit fields.
     *
     * (read-write) Transfer Mode Register
     */
    inline void set_TRANSFER_MODE(bool BLOCK_COUNT_EN,
                                  SDMMC_TRANSFER_MODE_ACMD_EN ACMD_EN,
                                  bool TX_DIR_SELECT, bool MULTI_BLOCK_SELECT,
                                  bool CMD_COMP_ATA) volatile
    {
        uint16_t curr = TRANSFER_MODE;

        curr &= ~(0b1u << 1u);
        curr |= (BLOCK_COUNT_EN & 0b1u) << 1u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(ACMD_EN) & 0b11u) << 2u;
        curr &= ~(0b1u << 4u);
        curr |= (TX_DIR_SELECT & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (MULTI_BLOCK_SELECT & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (CMD_COMP_ATA & 0b1u) << 6u;

        TRANSFER_MODE = curr;
    }

    /**
     * Get COMMAND's RESP_TYPE_SELECT field.
     *
     * Response Type Select
     */
    inline SDMMC_COMMAND_RESP_TYPE_SELECT
    get_COMMAND_RESP_TYPE_SELECT() volatile
    {
        return SDMMC_COMMAND_RESP_TYPE_SELECT((COMMAND >> 0u) & 0b11u);
    }

    /**
     * Set COMMAND's RESP_TYPE_SELECT field.
     *
     * Response Type Select
     */
    inline void set_COMMAND_RESP_TYPE_SELECT(
        SDMMC_COMMAND_RESP_TYPE_SELECT value) volatile
    {
        uint16_t curr = COMMAND;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        COMMAND = curr;
    }

    /**
     * Get COMMAND's CMD_CRC_CHECK_EN bit.
     *
     * Command CRC Check Enable
     */
    inline bool get_COMMAND_CMD_CRC_CHECK_EN() volatile
    {
        return COMMAND & (1u << 3u);
    }

    /**
     * Set COMMAND's CMD_CRC_CHECK_EN bit.
     *
     * Command CRC Check Enable
     */
    inline void set_COMMAND_CMD_CRC_CHECK_EN() volatile
    {
        COMMAND |= 1u << 3u;
    }

    /**
     * Clear COMMAND's CMD_CRC_CHECK_EN bit.
     *
     * Command CRC Check Enable
     */
    inline void clear_COMMAND_CMD_CRC_CHECK_EN() volatile
    {
        COMMAND &= ~(1u << 3u);
    }

    /**
     * Toggle COMMAND's CMD_CRC_CHECK_EN bit.
     *
     * Command CRC Check Enable
     */
    inline void toggle_COMMAND_CMD_CRC_CHECK_EN() volatile
    {
        COMMAND ^= 1u << 3u;
    }

    /**
     * Get COMMAND's CMD_IND_CHECK_EN bit.
     *
     * Command Index Check Enable
     */
    inline bool get_COMMAND_CMD_IND_CHECK_EN() volatile
    {
        return COMMAND & (1u << 4u);
    }

    /**
     * Set COMMAND's CMD_IND_CHECK_EN bit.
     *
     * Command Index Check Enable
     */
    inline void set_COMMAND_CMD_IND_CHECK_EN() volatile
    {
        COMMAND |= 1u << 4u;
    }

    /**
     * Clear COMMAND's CMD_IND_CHECK_EN bit.
     *
     * Command Index Check Enable
     */
    inline void clear_COMMAND_CMD_IND_CHECK_EN() volatile
    {
        COMMAND &= ~(1u << 4u);
    }

    /**
     * Toggle COMMAND's CMD_IND_CHECK_EN bit.
     *
     * Command Index Check Enable
     */
    inline void toggle_COMMAND_CMD_IND_CHECK_EN() volatile
    {
        COMMAND ^= 1u << 4u;
    }

    /**
     * Get COMMAND's DATA_PRESENT_SELECT bit.
     *
     * Data Present Select
     */
    inline bool get_COMMAND_DATA_PRESENT_SELECT() volatile
    {
        return COMMAND & (1u << 5u);
    }

    /**
     * Set COMMAND's DATA_PRESENT_SELECT bit.
     *
     * Data Present Select
     */
    inline void set_COMMAND_DATA_PRESENT_SELECT() volatile
    {
        COMMAND |= 1u << 5u;
    }

    /**
     * Clear COMMAND's DATA_PRESENT_SELECT bit.
     *
     * Data Present Select
     */
    inline void clear_COMMAND_DATA_PRESENT_SELECT() volatile
    {
        COMMAND &= ~(1u << 5u);
    }

    /**
     * Toggle COMMAND's DATA_PRESENT_SELECT bit.
     *
     * Data Present Select
     */
    inline void toggle_COMMAND_DATA_PRESENT_SELECT() volatile
    {
        COMMAND ^= 1u << 5u;
    }

    /**
     * Get COMMAND's CMD_TYPE field.
     *
     * Command Type
     */
    inline SDMMC_COMMAND_CMD_TYPE get_COMMAND_CMD_TYPE() volatile
    {
        return SDMMC_COMMAND_CMD_TYPE((COMMAND >> 6u) & 0b11u);
    }

    /**
     * Set COMMAND's CMD_TYPE field.
     *
     * Command Type
     */
    inline void set_COMMAND_CMD_TYPE(SDMMC_COMMAND_CMD_TYPE value) volatile
    {
        uint16_t curr = COMMAND;

        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(value) & 0b11u) << 6u;

        COMMAND = curr;
    }

    /**
     * Get COMMAND's CMD_IND field.
     *
     * Command Index
     */
    inline uint8_t get_COMMAND_CMD_IND() volatile
    {
        return (COMMAND >> 8u) & 0b111111u;
    }

    /**
     * Set COMMAND's CMD_IND field.
     *
     * Command Index
     */
    inline void set_COMMAND_CMD_IND(uint8_t value) volatile
    {
        uint16_t curr = COMMAND;

        curr &= ~(0b111111u << 8u);
        curr |= (value & 0b111111u) << 8u;

        COMMAND = curr;
    }

    /**
     * Get all of COMMAND's bit fields.
     *
     * (read-write) Command Register
     */
    inline void get_COMMAND(SDMMC_COMMAND_RESP_TYPE_SELECT &RESP_TYPE_SELECT,
                            bool &CMD_CRC_CHECK_EN, bool &CMD_IND_CHECK_EN,
                            bool &DATA_PRESENT_SELECT,
                            SDMMC_COMMAND_CMD_TYPE &CMD_TYPE,
                            uint8_t &CMD_IND) volatile
    {
        uint16_t curr = COMMAND;

        RESP_TYPE_SELECT =
            SDMMC_COMMAND_RESP_TYPE_SELECT((curr >> 0u) & 0b11u);
        CMD_CRC_CHECK_EN = curr & (1u << 3u);
        CMD_IND_CHECK_EN = curr & (1u << 4u);
        DATA_PRESENT_SELECT = curr & (1u << 5u);
        CMD_TYPE = SDMMC_COMMAND_CMD_TYPE((curr >> 6u) & 0b11u);
        CMD_IND = (curr >> 8u) & 0b111111u;
    }

    /**
     * Set all of COMMAND's bit fields.
     *
     * (read-write) Command Register
     */
    inline void set_COMMAND(SDMMC_COMMAND_RESP_TYPE_SELECT RESP_TYPE_SELECT,
                            bool CMD_CRC_CHECK_EN, bool CMD_IND_CHECK_EN,
                            bool DATA_PRESENT_SELECT,
                            SDMMC_COMMAND_CMD_TYPE CMD_TYPE,
                            uint8_t CMD_IND) volatile
    {
        uint16_t curr = COMMAND;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(RESP_TYPE_SELECT) & 0b11u) << 0u;
        curr &= ~(0b1u << 3u);
        curr |= (CMD_CRC_CHECK_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (CMD_IND_CHECK_EN & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (DATA_PRESENT_SELECT & 0b1u) << 5u;
        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(CMD_TYPE) & 0b11u) << 6u;
        curr &= ~(0b111111u << 8u);
        curr |= (CMD_IND & 0b111111u) << 8u;

        COMMAND = curr;
    }

    /**
     * Get RESPONSE0's RESPONSE0 field.
     *
     * Response0
     */
    inline uint16_t get_RESPONSE0_RESPONSE0() volatile
    {
        return (RESPONSE0 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RESPONSE0's RESPONSE1 field.
     *
     * Response1
     */
    inline uint16_t get_RESPONSE0_RESPONSE1() volatile
    {
        return (RESPONSE0 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get all of RESPONSE0's bit fields.
     *
     * (read-only) Response 0 Register
     */
    inline void get_RESPONSE0(uint16_t &RESPONSE0,
                              uint16_t &RESPONSE1) volatile
    {
        uint32_t curr = RESPONSE0;

        RESPONSE0 = (curr >> 0u) & 0b1111111111111111u;
        RESPONSE1 = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get RESPONSE2's RESPONSE2 field.
     *
     * Response2
     */
    inline uint16_t get_RESPONSE2_RESPONSE2() volatile
    {
        return (RESPONSE2 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RESPONSE2's RESPONSE3 field.
     *
     * Response3
     */
    inline uint16_t get_RESPONSE2_RESPONSE3() volatile
    {
        return (RESPONSE2 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get all of RESPONSE2's bit fields.
     *
     * (read-only) Response 2 Register
     */
    inline void get_RESPONSE2(uint16_t &RESPONSE2,
                              uint16_t &RESPONSE3) volatile
    {
        uint32_t curr = RESPONSE2;

        RESPONSE2 = (curr >> 0u) & 0b1111111111111111u;
        RESPONSE3 = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get RESPONSE4's RESPONSE4 field.
     *
     * Response4
     */
    inline uint16_t get_RESPONSE4_RESPONSE4() volatile
    {
        return (RESPONSE4 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RESPONSE4's RESPONSE5 field.
     *
     * Response5
     */
    inline uint16_t get_RESPONSE4_RESPONSE5() volatile
    {
        return (RESPONSE4 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get all of RESPONSE4's bit fields.
     *
     * (read-only) Response 4 Register
     */
    inline void get_RESPONSE4(uint16_t &RESPONSE4,
                              uint16_t &RESPONSE5) volatile
    {
        uint32_t curr = RESPONSE4;

        RESPONSE4 = (curr >> 0u) & 0b1111111111111111u;
        RESPONSE5 = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get RESPONSE6's RESPONSE6 field.
     *
     * Response6
     */
    inline uint16_t get_RESPONSE6_RESPONSE6() volatile
    {
        return (RESPONSE6 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RESPONSE6's RESPONSE7 field.
     *
     * Response7
     */
    inline uint16_t get_RESPONSE6_RESPONSE7() volatile
    {
        return (RESPONSE6 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get all of RESPONSE6's bit fields.
     *
     * (read-only) Response 6 Register
     */
    inline void get_RESPONSE6(uint16_t &RESPONSE6,
                              uint16_t &RESPONSE7) volatile
    {
        uint32_t curr = RESPONSE6;

        RESPONSE6 = (curr >> 0u) & 0b1111111111111111u;
        RESPONSE7 = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get DATA_BUFFER's DATA_BUFFER field.
     *
     * Data Buffer
     */
    inline uint32_t get_DATA_BUFFER_DATA_BUFFER() volatile
    {
        return (DATA_BUFFER >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set DATA_BUFFER's DATA_BUFFER field.
     *
     * Data Buffer
     */
    inline void set_DATA_BUFFER_DATA_BUFFER(uint32_t value) volatile
    {
        uint32_t curr = DATA_BUFFER;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DATA_BUFFER = curr;
    }

    /**
     * Get PRESENT_STATE's COMMAND_INHIBIT_CMD bit.
     *
     * Command Inhibit (CMD)
     */
    inline bool get_PRESENT_STATE_COMMAND_INHIBIT_CMD() volatile
    {
        return PRESENT_STATE & (1u << 0u);
    }

    /**
     * Get PRESENT_STATE's COMMAND_INHIBIT_DAT bit.
     *
     * Command Inhibit (DAT)
     */
    inline bool get_PRESENT_STATE_COMMAND_INHIBIT_DAT() volatile
    {
        return PRESENT_STATE & (1u << 1u);
    }

    /**
     * Get PRESENT_STATE's DAT_LINE_ACTIVE bit.
     *
     * DAT Line Active
     */
    inline bool get_PRESENT_STATE_DAT_LINE_ACTIVE() volatile
    {
        return PRESENT_STATE & (1u << 2u);
    }

    /**
     * Get PRESENT_STATE's WRITE_TRANSFER_ACTIVE bit.
     *
     * Write Transfer Active
     */
    inline bool get_PRESENT_STATE_WRITE_TRANSFER_ACTIVE() volatile
    {
        return PRESENT_STATE & (1u << 8u);
    }

    /**
     * Get PRESENT_STATE's READ_TRANSFER_ACTIVE bit.
     *
     * Read Transfer Active
     */
    inline bool get_PRESENT_STATE_READ_TRANSFER_ACTIVE() volatile
    {
        return PRESENT_STATE & (1u << 9u);
    }

    /**
     * Get PRESENT_STATE's BUFFER_WRITE_ENABLE bit.
     *
     * Buffer Write Enable
     */
    inline bool get_PRESENT_STATE_BUFFER_WRITE_ENABLE() volatile
    {
        return PRESENT_STATE & (1u << 10u);
    }

    /**
     * Get PRESENT_STATE's BUFFER_READ_ENABLE bit.
     *
     * Buffer Read Enable
     */
    inline bool get_PRESENT_STATE_BUFFER_READ_ENABLE() volatile
    {
        return PRESENT_STATE & (1u << 11u);
    }

    /**
     * Get PRESENT_STATE's CARD_INSERTED bit.
     *
     * Card Inserted
     */
    inline bool get_PRESENT_STATE_CARD_INSERTED() volatile
    {
        return PRESENT_STATE & (1u << 16u);
    }

    /**
     * Get PRESENT_STATE's CARD_STATE_STABLE bit.
     *
     * Card State Stable
     */
    inline bool get_PRESENT_STATE_CARD_STATE_STABLE() volatile
    {
        return PRESENT_STATE & (1u << 17u);
    }

    /**
     * Get PRESENT_STATE's CARD_DETECT_PIN_LEVEL bit.
     *
     * Card Detect Pin Level
     */
    inline bool get_PRESENT_STATE_CARD_DETECT_PIN_LEVEL() volatile
    {
        return PRESENT_STATE & (1u << 18u);
    }

    /**
     * Get PRESENT_STATE's WRITE_PROTECT_PIN_LEVEL bit.
     *
     * Write Protect Switch Pin Level
     */
    inline bool get_PRESENT_STATE_WRITE_PROTECT_PIN_LEVEL() volatile
    {
        return PRESENT_STATE & (1u << 19u);
    }

    /**
     * Get PRESENT_STATE's DAT_3_0_PIN_LEVEL field.
     *
     * Line Signal Level
     */
    inline uint8_t get_PRESENT_STATE_DAT_3_0_PIN_LEVEL() volatile
    {
        return (PRESENT_STATE >> 20u) & 0b1111u;
    }

    /**
     * Get PRESENT_STATE's CMD_LINE_LEVEL bit.
     *
     * CMD Line Signal Level
     */
    inline bool get_PRESENT_STATE_CMD_LINE_LEVEL() volatile
    {
        return PRESENT_STATE & (1u << 24u);
    }

    /**
     * Get PRESENT_STATE's DAT_7_4_PIN_LEVEL field.
     *
     * Line Signal Level
     */
    inline uint8_t get_PRESENT_STATE_DAT_7_4_PIN_LEVEL() volatile
    {
        return (PRESENT_STATE >> 25u) & 0b1111u;
    }

    /**
     * Get all of PRESENT_STATE's bit fields.
     *
     * (read-only) Present State Register
     */
    inline void get_PRESENT_STATE(
        bool &COMMAND_INHIBIT_CMD, bool &COMMAND_INHIBIT_DAT,
        bool &DAT_LINE_ACTIVE, bool &WRITE_TRANSFER_ACTIVE,
        bool &READ_TRANSFER_ACTIVE, bool &BUFFER_WRITE_ENABLE,
        bool &BUFFER_READ_ENABLE, bool &CARD_INSERTED, bool &CARD_STATE_STABLE,
        bool &CARD_DETECT_PIN_LEVEL, bool &WRITE_PROTECT_PIN_LEVEL,
        uint8_t &DAT_3_0_PIN_LEVEL, bool &CMD_LINE_LEVEL,
        uint8_t &DAT_7_4_PIN_LEVEL) volatile
    {
        uint32_t curr = PRESENT_STATE;

        COMMAND_INHIBIT_CMD = curr & (1u << 0u);
        COMMAND_INHIBIT_DAT = curr & (1u << 1u);
        DAT_LINE_ACTIVE = curr & (1u << 2u);
        WRITE_TRANSFER_ACTIVE = curr & (1u << 8u);
        READ_TRANSFER_ACTIVE = curr & (1u << 9u);
        BUFFER_WRITE_ENABLE = curr & (1u << 10u);
        BUFFER_READ_ENABLE = curr & (1u << 11u);
        CARD_INSERTED = curr & (1u << 16u);
        CARD_STATE_STABLE = curr & (1u << 17u);
        CARD_DETECT_PIN_LEVEL = curr & (1u << 18u);
        WRITE_PROTECT_PIN_LEVEL = curr & (1u << 19u);
        DAT_3_0_PIN_LEVEL = (curr >> 20u) & 0b1111u;
        CMD_LINE_LEVEL = curr & (1u << 24u);
        DAT_7_4_PIN_LEVEL = (curr >> 25u) & 0b1111u;
    }

    /**
     * Get HOST_CTRL's LED_CTRL bit.
     *
     * LED Control
     */
    inline bool get_HOST_CTRL_LED_CTRL() volatile
    {
        return HOST_CTRL & (1u << 0u);
    }

    /**
     * Set HOST_CTRL's LED_CTRL bit.
     *
     * LED Control
     */
    inline void set_HOST_CTRL_LED_CTRL() volatile
    {
        HOST_CTRL |= 1u << 0u;
    }

    /**
     * Clear HOST_CTRL's LED_CTRL bit.
     *
     * LED Control
     */
    inline void clear_HOST_CTRL_LED_CTRL() volatile
    {
        HOST_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle HOST_CTRL's LED_CTRL bit.
     *
     * LED Control
     */
    inline void toggle_HOST_CTRL_LED_CTRL() volatile
    {
        HOST_CTRL ^= 1u << 0u;
    }

    /**
     * Get HOST_CTRL's DATA_TX_WIDTH bit.
     *
     * Data Transfer Width (SD1 or SD4)
     */
    inline bool get_HOST_CTRL_DATA_TX_WIDTH() volatile
    {
        return HOST_CTRL & (1u << 1u);
    }

    /**
     * Set HOST_CTRL's DATA_TX_WIDTH bit.
     *
     * Data Transfer Width (SD1 or SD4)
     */
    inline void set_HOST_CTRL_DATA_TX_WIDTH() volatile
    {
        HOST_CTRL |= 1u << 1u;
    }

    /**
     * Clear HOST_CTRL's DATA_TX_WIDTH bit.
     *
     * Data Transfer Width (SD1 or SD4)
     */
    inline void clear_HOST_CTRL_DATA_TX_WIDTH() volatile
    {
        HOST_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle HOST_CTRL's DATA_TX_WIDTH bit.
     *
     * Data Transfer Width (SD1 or SD4)
     */
    inline void toggle_HOST_CTRL_DATA_TX_WIDTH() volatile
    {
        HOST_CTRL ^= 1u << 1u;
    }

    /**
     * Get HOST_CTRL's HIGH_SPEED_EN bit.
     *
     * High Speed Enable
     */
    inline bool get_HOST_CTRL_HIGH_SPEED_EN() volatile
    {
        return HOST_CTRL & (1u << 2u);
    }

    /**
     * Set HOST_CTRL's HIGH_SPEED_EN bit.
     *
     * High Speed Enable
     */
    inline void set_HOST_CTRL_HIGH_SPEED_EN() volatile
    {
        HOST_CTRL |= 1u << 2u;
    }

    /**
     * Clear HOST_CTRL's HIGH_SPEED_EN bit.
     *
     * High Speed Enable
     */
    inline void clear_HOST_CTRL_HIGH_SPEED_EN() volatile
    {
        HOST_CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle HOST_CTRL's HIGH_SPEED_EN bit.
     *
     * High Speed Enable
     */
    inline void toggle_HOST_CTRL_HIGH_SPEED_EN() volatile
    {
        HOST_CTRL ^= 1u << 2u;
    }

    /**
     * Get HOST_CTRL's SD_8BIT_MODE bit.
     *
     * Extended Data Transfer Width
     */
    inline bool get_HOST_CTRL_SD_8BIT_MODE() volatile
    {
        return HOST_CTRL & (1u << 5u);
    }

    /**
     * Set HOST_CTRL's SD_8BIT_MODE bit.
     *
     * Extended Data Transfer Width
     */
    inline void set_HOST_CTRL_SD_8BIT_MODE() volatile
    {
        HOST_CTRL |= 1u << 5u;
    }

    /**
     * Clear HOST_CTRL's SD_8BIT_MODE bit.
     *
     * Extended Data Transfer Width
     */
    inline void clear_HOST_CTRL_SD_8BIT_MODE() volatile
    {
        HOST_CTRL &= ~(1u << 5u);
    }

    /**
     * Toggle HOST_CTRL's SD_8BIT_MODE bit.
     *
     * Extended Data Transfer Width
     */
    inline void toggle_HOST_CTRL_SD_8BIT_MODE() volatile
    {
        HOST_CTRL ^= 1u << 5u;
    }

    /**
     * Get HOST_CTRL's CARD_DETECT_TEST_LEVEL bit.
     *
     * Card Detect Test Level
     */
    inline bool get_HOST_CTRL_CARD_DETECT_TEST_LEVEL() volatile
    {
        return HOST_CTRL & (1u << 6u);
    }

    /**
     * Set HOST_CTRL's CARD_DETECT_TEST_LEVEL bit.
     *
     * Card Detect Test Level
     */
    inline void set_HOST_CTRL_CARD_DETECT_TEST_LEVEL() volatile
    {
        HOST_CTRL |= 1u << 6u;
    }

    /**
     * Clear HOST_CTRL's CARD_DETECT_TEST_LEVEL bit.
     *
     * Card Detect Test Level
     */
    inline void clear_HOST_CTRL_CARD_DETECT_TEST_LEVEL() volatile
    {
        HOST_CTRL &= ~(1u << 6u);
    }

    /**
     * Toggle HOST_CTRL's CARD_DETECT_TEST_LEVEL bit.
     *
     * Card Detect Test Level
     */
    inline void toggle_HOST_CTRL_CARD_DETECT_TEST_LEVEL() volatile
    {
        HOST_CTRL ^= 1u << 6u;
    }

    /**
     * Get HOST_CTRL's CARD_DET_SIGNAL_DETECT bit.
     *
     * Card detect signal detetction
     */
    inline bool get_HOST_CTRL_CARD_DET_SIGNAL_DETECT() volatile
    {
        return HOST_CTRL & (1u << 7u);
    }

    /**
     * Set HOST_CTRL's CARD_DET_SIGNAL_DETECT bit.
     *
     * Card detect signal detetction
     */
    inline void set_HOST_CTRL_CARD_DET_SIGNAL_DETECT() volatile
    {
        HOST_CTRL |= 1u << 7u;
    }

    /**
     * Clear HOST_CTRL's CARD_DET_SIGNAL_DETECT bit.
     *
     * Card detect signal detetction
     */
    inline void clear_HOST_CTRL_CARD_DET_SIGNAL_DETECT() volatile
    {
        HOST_CTRL &= ~(1u << 7u);
    }

    /**
     * Toggle HOST_CTRL's CARD_DET_SIGNAL_DETECT bit.
     *
     * Card detect signal detetction
     */
    inline void toggle_HOST_CTRL_CARD_DET_SIGNAL_DETECT() volatile
    {
        HOST_CTRL ^= 1u << 7u;
    }

    /**
     * Get all of HOST_CTRL's bit fields.
     *
     * (read-write) Host Control Register
     */
    inline void get_HOST_CTRL(bool &LED_CTRL, bool &DATA_TX_WIDTH,
                              bool &HIGH_SPEED_EN, bool &SD_8BIT_MODE,
                              bool &CARD_DETECT_TEST_LEVEL,
                              bool &CARD_DET_SIGNAL_DETECT) volatile
    {
        uint8_t curr = HOST_CTRL;

        LED_CTRL = curr & (1u << 0u);
        DATA_TX_WIDTH = curr & (1u << 1u);
        HIGH_SPEED_EN = curr & (1u << 2u);
        SD_8BIT_MODE = curr & (1u << 5u);
        CARD_DETECT_TEST_LEVEL = curr & (1u << 6u);
        CARD_DET_SIGNAL_DETECT = curr & (1u << 7u);
    }

    /**
     * Set all of HOST_CTRL's bit fields.
     *
     * (read-write) Host Control Register
     */
    inline void set_HOST_CTRL(bool LED_CTRL, bool DATA_TX_WIDTH,
                              bool HIGH_SPEED_EN, bool SD_8BIT_MODE,
                              bool CARD_DETECT_TEST_LEVEL,
                              bool CARD_DET_SIGNAL_DETECT) volatile
    {
        uint8_t curr = HOST_CTRL;

        curr &= ~(0b1u << 0u);
        curr |= (LED_CTRL & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (DATA_TX_WIDTH & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (HIGH_SPEED_EN & 0b1u) << 2u;
        curr &= ~(0b1u << 5u);
        curr |= (SD_8BIT_MODE & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (CARD_DETECT_TEST_LEVEL & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (CARD_DET_SIGNAL_DETECT & 0b1u) << 7u;

        HOST_CTRL = curr;
    }

    /**
     * Get POWER_CTRL's SD_BUS_POWER bit.
     *
     * SD Bus Power
     */
    inline bool get_POWER_CTRL_SD_BUS_POWER() volatile
    {
        return POWER_CTRL & (1u << 0u);
    }

    /**
     * Set POWER_CTRL's SD_BUS_POWER bit.
     *
     * SD Bus Power
     */
    inline void set_POWER_CTRL_SD_BUS_POWER() volatile
    {
        POWER_CTRL |= 1u << 0u;
    }

    /**
     * Clear POWER_CTRL's SD_BUS_POWER bit.
     *
     * SD Bus Power
     */
    inline void clear_POWER_CTRL_SD_BUS_POWER() volatile
    {
        POWER_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle POWER_CTRL's SD_BUS_POWER bit.
     *
     * SD Bus Power
     */
    inline void toggle_POWER_CTRL_SD_BUS_POWER() volatile
    {
        POWER_CTRL ^= 1u << 0u;
    }

    /**
     * Get POWER_CTRL's SD_BUS_VOLTAGE_SEL field.
     *
     * SD Bus Voltage Select
     */
    inline SDMMC_POWER_CTRL_SD_BUS_VOLTAGE_SEL
    get_POWER_CTRL_SD_BUS_VOLTAGE_SEL() volatile
    {
        return SDMMC_POWER_CTRL_SD_BUS_VOLTAGE_SEL((POWER_CTRL >> 1u) &
                                                   0b111u);
    }

    /**
     * Set POWER_CTRL's SD_BUS_VOLTAGE_SEL field.
     *
     * SD Bus Voltage Select
     */
    inline void set_POWER_CTRL_SD_BUS_VOLTAGE_SEL(
        SDMMC_POWER_CTRL_SD_BUS_VOLTAGE_SEL value) volatile
    {
        uint8_t curr = POWER_CTRL;

        curr &= ~(0b111u << 1u);
        curr |= (std::to_underlying(value) & 0b111u) << 1u;

        POWER_CTRL = curr;
    }

    /**
     * Get POWER_CTRL's HARDWARE_RESET bit.
     *
     * Hardware reset
     */
    inline bool get_POWER_CTRL_HARDWARE_RESET() volatile
    {
        return POWER_CTRL & (1u << 4u);
    }

    /**
     * Set POWER_CTRL's HARDWARE_RESET bit.
     *
     * Hardware reset
     */
    inline void set_POWER_CTRL_HARDWARE_RESET() volatile
    {
        POWER_CTRL |= 1u << 4u;
    }

    /**
     * Clear POWER_CTRL's HARDWARE_RESET bit.
     *
     * Hardware reset
     */
    inline void clear_POWER_CTRL_HARDWARE_RESET() volatile
    {
        POWER_CTRL &= ~(1u << 4u);
    }

    /**
     * Toggle POWER_CTRL's HARDWARE_RESET bit.
     *
     * Hardware reset
     */
    inline void toggle_POWER_CTRL_HARDWARE_RESET() volatile
    {
        POWER_CTRL ^= 1u << 4u;
    }

    /**
     * Get all of POWER_CTRL's bit fields.
     *
     * (read-write) Power Control Register
     */
    inline void get_POWER_CTRL(
        bool &SD_BUS_POWER,
        SDMMC_POWER_CTRL_SD_BUS_VOLTAGE_SEL &SD_BUS_VOLTAGE_SEL,
        bool &HARDWARE_RESET) volatile
    {
        uint8_t curr = POWER_CTRL;

        SD_BUS_POWER = curr & (1u << 0u);
        SD_BUS_VOLTAGE_SEL =
            SDMMC_POWER_CTRL_SD_BUS_VOLTAGE_SEL((curr >> 1u) & 0b111u);
        HARDWARE_RESET = curr & (1u << 4u);
    }

    /**
     * Set all of POWER_CTRL's bit fields.
     *
     * (read-write) Power Control Register
     */
    inline void set_POWER_CTRL(
        bool SD_BUS_POWER,
        SDMMC_POWER_CTRL_SD_BUS_VOLTAGE_SEL SD_BUS_VOLTAGE_SEL,
        bool HARDWARE_RESET) volatile
    {
        uint8_t curr = POWER_CTRL;

        curr &= ~(0b1u << 0u);
        curr |= (SD_BUS_POWER & 0b1u) << 0u;
        curr &= ~(0b111u << 1u);
        curr |= (std::to_underlying(SD_BUS_VOLTAGE_SEL) & 0b111u) << 1u;
        curr &= ~(0b1u << 4u);
        curr |= (HARDWARE_RESET & 0b1u) << 4u;

        POWER_CTRL = curr;
    }

    /**
     * Get BLOCK_GAP_CTRL's STOP_AT_BLOCK_GAP bit.
     *
     * Stop At Block Gap Request
     */
    inline bool get_BLOCK_GAP_CTRL_STOP_AT_BLOCK_GAP() volatile
    {
        return BLOCK_GAP_CTRL & (1u << 0u);
    }

    /**
     * Set BLOCK_GAP_CTRL's STOP_AT_BLOCK_GAP bit.
     *
     * Stop At Block Gap Request
     */
    inline void set_BLOCK_GAP_CTRL_STOP_AT_BLOCK_GAP() volatile
    {
        BLOCK_GAP_CTRL |= 1u << 0u;
    }

    /**
     * Clear BLOCK_GAP_CTRL's STOP_AT_BLOCK_GAP bit.
     *
     * Stop At Block Gap Request
     */
    inline void clear_BLOCK_GAP_CTRL_STOP_AT_BLOCK_GAP() volatile
    {
        BLOCK_GAP_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle BLOCK_GAP_CTRL's STOP_AT_BLOCK_GAP bit.
     *
     * Stop At Block Gap Request
     */
    inline void toggle_BLOCK_GAP_CTRL_STOP_AT_BLOCK_GAP() volatile
    {
        BLOCK_GAP_CTRL ^= 1u << 0u;
    }

    /**
     * Get BLOCK_GAP_CTRL's CONTINUE_REQ bit.
     *
     * Continue Request
     */
    inline bool get_BLOCK_GAP_CTRL_CONTINUE_REQ() volatile
    {
        return BLOCK_GAP_CTRL & (1u << 1u);
    }

    /**
     * Set BLOCK_GAP_CTRL's CONTINUE_REQ bit.
     *
     * Continue Request
     */
    inline void set_BLOCK_GAP_CTRL_CONTINUE_REQ() volatile
    {
        BLOCK_GAP_CTRL |= 1u << 1u;
    }

    /**
     * Clear BLOCK_GAP_CTRL's CONTINUE_REQ bit.
     *
     * Continue Request
     */
    inline void clear_BLOCK_GAP_CTRL_CONTINUE_REQ() volatile
    {
        BLOCK_GAP_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle BLOCK_GAP_CTRL's CONTINUE_REQ bit.
     *
     * Continue Request
     */
    inline void toggle_BLOCK_GAP_CTRL_CONTINUE_REQ() volatile
    {
        BLOCK_GAP_CTRL ^= 1u << 1u;
    }

    /**
     * Get BLOCK_GAP_CTRL's READ_WAIT_CTRL bit.
     *
     * Read Wait Control
     */
    inline bool get_BLOCK_GAP_CTRL_READ_WAIT_CTRL() volatile
    {
        return BLOCK_GAP_CTRL & (1u << 2u);
    }

    /**
     * Set BLOCK_GAP_CTRL's READ_WAIT_CTRL bit.
     *
     * Read Wait Control
     */
    inline void set_BLOCK_GAP_CTRL_READ_WAIT_CTRL() volatile
    {
        BLOCK_GAP_CTRL |= 1u << 2u;
    }

    /**
     * Clear BLOCK_GAP_CTRL's READ_WAIT_CTRL bit.
     *
     * Read Wait Control
     */
    inline void clear_BLOCK_GAP_CTRL_READ_WAIT_CTRL() volatile
    {
        BLOCK_GAP_CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle BLOCK_GAP_CTRL's READ_WAIT_CTRL bit.
     *
     * Read Wait Control
     */
    inline void toggle_BLOCK_GAP_CTRL_READ_WAIT_CTRL() volatile
    {
        BLOCK_GAP_CTRL ^= 1u << 2u;
    }

    /**
     * Get BLOCK_GAP_CTRL's INT_AT_BLOCK_GAP bit.
     *
     * Interrupt At Block Gap
     */
    inline bool get_BLOCK_GAP_CTRL_INT_AT_BLOCK_GAP() volatile
    {
        return BLOCK_GAP_CTRL & (1u << 3u);
    }

    /**
     * Set BLOCK_GAP_CTRL's INT_AT_BLOCK_GAP bit.
     *
     * Interrupt At Block Gap
     */
    inline void set_BLOCK_GAP_CTRL_INT_AT_BLOCK_GAP() volatile
    {
        BLOCK_GAP_CTRL |= 1u << 3u;
    }

    /**
     * Clear BLOCK_GAP_CTRL's INT_AT_BLOCK_GAP bit.
     *
     * Interrupt At Block Gap
     */
    inline void clear_BLOCK_GAP_CTRL_INT_AT_BLOCK_GAP() volatile
    {
        BLOCK_GAP_CTRL &= ~(1u << 3u);
    }

    /**
     * Toggle BLOCK_GAP_CTRL's INT_AT_BLOCK_GAP bit.
     *
     * Interrupt At Block Gap
     */
    inline void toggle_BLOCK_GAP_CTRL_INT_AT_BLOCK_GAP() volatile
    {
        BLOCK_GAP_CTRL ^= 1u << 3u;
    }

    /**
     * Get all of BLOCK_GAP_CTRL's bit fields.
     *
     * (read-write) Block Gap Control Register
     */
    inline void get_BLOCK_GAP_CTRL(bool &STOP_AT_BLOCK_GAP, bool &CONTINUE_REQ,
                                   bool &READ_WAIT_CTRL,
                                   bool &INT_AT_BLOCK_GAP) volatile
    {
        uint8_t curr = BLOCK_GAP_CTRL;

        STOP_AT_BLOCK_GAP = curr & (1u << 0u);
        CONTINUE_REQ = curr & (1u << 1u);
        READ_WAIT_CTRL = curr & (1u << 2u);
        INT_AT_BLOCK_GAP = curr & (1u << 3u);
    }

    /**
     * Set all of BLOCK_GAP_CTRL's bit fields.
     *
     * (read-write) Block Gap Control Register
     */
    inline void set_BLOCK_GAP_CTRL(bool STOP_AT_BLOCK_GAP, bool CONTINUE_REQ,
                                   bool READ_WAIT_CTRL,
                                   bool INT_AT_BLOCK_GAP) volatile
    {
        uint8_t curr = BLOCK_GAP_CTRL;

        curr &= ~(0b1u << 0u);
        curr |= (STOP_AT_BLOCK_GAP & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (CONTINUE_REQ & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (READ_WAIT_CTRL & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (INT_AT_BLOCK_GAP & 0b1u) << 3u;

        BLOCK_GAP_CTRL = curr;
    }

    /**
     * Get WAKEUP_CTRL's WAKEUP_EVENT_EN_INT bit.
     *
     * Wakeup Event Enable On Card Interrupt
     */
    inline bool get_WAKEUP_CTRL_WAKEUP_EVENT_EN_INT() volatile
    {
        return WAKEUP_CTRL & (1u << 0u);
    }

    /**
     * Set WAKEUP_CTRL's WAKEUP_EVENT_EN_INT bit.
     *
     * Wakeup Event Enable On Card Interrupt
     */
    inline void set_WAKEUP_CTRL_WAKEUP_EVENT_EN_INT() volatile
    {
        WAKEUP_CTRL |= 1u << 0u;
    }

    /**
     * Clear WAKEUP_CTRL's WAKEUP_EVENT_EN_INT bit.
     *
     * Wakeup Event Enable On Card Interrupt
     */
    inline void clear_WAKEUP_CTRL_WAKEUP_EVENT_EN_INT() volatile
    {
        WAKEUP_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle WAKEUP_CTRL's WAKEUP_EVENT_EN_INT bit.
     *
     * Wakeup Event Enable On Card Interrupt
     */
    inline void toggle_WAKEUP_CTRL_WAKEUP_EVENT_EN_INT() volatile
    {
        WAKEUP_CTRL ^= 1u << 0u;
    }

    /**
     * Get WAKEUP_CTRL's WAKEUP_EVENT_EN_INS bit.
     *
     * Wakeup Event Enable On SD Card Insertion
     */
    inline bool get_WAKEUP_CTRL_WAKEUP_EVENT_EN_INS() volatile
    {
        return WAKEUP_CTRL & (1u << 1u);
    }

    /**
     * Set WAKEUP_CTRL's WAKEUP_EVENT_EN_INS bit.
     *
     * Wakeup Event Enable On SD Card Insertion
     */
    inline void set_WAKEUP_CTRL_WAKEUP_EVENT_EN_INS() volatile
    {
        WAKEUP_CTRL |= 1u << 1u;
    }

    /**
     * Clear WAKEUP_CTRL's WAKEUP_EVENT_EN_INS bit.
     *
     * Wakeup Event Enable On SD Card Insertion
     */
    inline void clear_WAKEUP_CTRL_WAKEUP_EVENT_EN_INS() volatile
    {
        WAKEUP_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle WAKEUP_CTRL's WAKEUP_EVENT_EN_INS bit.
     *
     * Wakeup Event Enable On SD Card Insertion
     */
    inline void toggle_WAKEUP_CTRL_WAKEUP_EVENT_EN_INS() volatile
    {
        WAKEUP_CTRL ^= 1u << 1u;
    }

    /**
     * Get WAKEUP_CTRL's WAKEUP_EVENT_EN_REM bit.
     *
     * Wakeup Event Enable On SD Card Removal
     */
    inline bool get_WAKEUP_CTRL_WAKEUP_EVENT_EN_REM() volatile
    {
        return WAKEUP_CTRL & (1u << 2u);
    }

    /**
     * Set WAKEUP_CTRL's WAKEUP_EVENT_EN_REM bit.
     *
     * Wakeup Event Enable On SD Card Removal
     */
    inline void set_WAKEUP_CTRL_WAKEUP_EVENT_EN_REM() volatile
    {
        WAKEUP_CTRL |= 1u << 2u;
    }

    /**
     * Clear WAKEUP_CTRL's WAKEUP_EVENT_EN_REM bit.
     *
     * Wakeup Event Enable On SD Card Removal
     */
    inline void clear_WAKEUP_CTRL_WAKEUP_EVENT_EN_REM() volatile
    {
        WAKEUP_CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle WAKEUP_CTRL's WAKEUP_EVENT_EN_REM bit.
     *
     * Wakeup Event Enable On SD Card Removal
     */
    inline void toggle_WAKEUP_CTRL_WAKEUP_EVENT_EN_REM() volatile
    {
        WAKEUP_CTRL ^= 1u << 2u;
    }

    /**
     * Get all of WAKEUP_CTRL's bit fields.
     *
     * (read-write) Wake-up Control Register
     */
    inline void get_WAKEUP_CTRL(bool &WAKEUP_EVENT_EN_INT,
                                bool &WAKEUP_EVENT_EN_INS,
                                bool &WAKEUP_EVENT_EN_REM) volatile
    {
        uint8_t curr = WAKEUP_CTRL;

        WAKEUP_EVENT_EN_INT = curr & (1u << 0u);
        WAKEUP_EVENT_EN_INS = curr & (1u << 1u);
        WAKEUP_EVENT_EN_REM = curr & (1u << 2u);
    }

    /**
     * Set all of WAKEUP_CTRL's bit fields.
     *
     * (read-write) Wake-up Control Register
     */
    inline void set_WAKEUP_CTRL(bool WAKEUP_EVENT_EN_INT,
                                bool WAKEUP_EVENT_EN_INS,
                                bool WAKEUP_EVENT_EN_REM) volatile
    {
        uint8_t curr = WAKEUP_CTRL;

        curr &= ~(0b1u << 0u);
        curr |= (WAKEUP_EVENT_EN_INT & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (WAKEUP_EVENT_EN_INS & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (WAKEUP_EVENT_EN_REM & 0b1u) << 2u;

        WAKEUP_CTRL = curr;
    }

    /**
     * Get CLOCK_CTRL's INTERNAL_CLOCK_EN bit.
     *
     * Internal Clock Enable
     */
    inline bool get_CLOCK_CTRL_INTERNAL_CLOCK_EN() volatile
    {
        return CLOCK_CTRL & (1u << 0u);
    }

    /**
     * Set CLOCK_CTRL's INTERNAL_CLOCK_EN bit.
     *
     * Internal Clock Enable
     */
    inline void set_CLOCK_CTRL_INTERNAL_CLOCK_EN() volatile
    {
        CLOCK_CTRL |= 1u << 0u;
    }

    /**
     * Clear CLOCK_CTRL's INTERNAL_CLOCK_EN bit.
     *
     * Internal Clock Enable
     */
    inline void clear_CLOCK_CTRL_INTERNAL_CLOCK_EN() volatile
    {
        CLOCK_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle CLOCK_CTRL's INTERNAL_CLOCK_EN bit.
     *
     * Internal Clock Enable
     */
    inline void toggle_CLOCK_CTRL_INTERNAL_CLOCK_EN() volatile
    {
        CLOCK_CTRL ^= 1u << 0u;
    }

    /**
     * Get CLOCK_CTRL's INTERNAL_CLOCK_STABLE bit.
     *
     * Internal Clock Stable
     */
    inline bool get_CLOCK_CTRL_INTERNAL_CLOCK_STABLE() volatile
    {
        return CLOCK_CTRL & (1u << 1u);
    }

    /**
     * Get CLOCK_CTRL's SDCLOCK_EN bit.
     *
     * SD Clock Enable
     */
    inline bool get_CLOCK_CTRL_SDCLOCK_EN() volatile
    {
        return CLOCK_CTRL & (1u << 2u);
    }

    /**
     * Set CLOCK_CTRL's SDCLOCK_EN bit.
     *
     * SD Clock Enable
     */
    inline void set_CLOCK_CTRL_SDCLOCK_EN() volatile
    {
        CLOCK_CTRL |= 1u << 2u;
    }

    /**
     * Clear CLOCK_CTRL's SDCLOCK_EN bit.
     *
     * SD Clock Enable
     */
    inline void clear_CLOCK_CTRL_SDCLOCK_EN() volatile
    {
        CLOCK_CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle CLOCK_CTRL's SDCLOCK_EN bit.
     *
     * SD Clock Enable
     */
    inline void toggle_CLOCK_CTRL_SDCLOCK_EN() volatile
    {
        CLOCK_CTRL ^= 1u << 2u;
    }

    /**
     * Get CLOCK_CTRL's SDCLK_FREQ_SEL field.
     *
     * SDCLK Frequency Select
     */
    inline SDMMC_CLOCK_CTRL_SDCLK_FREQ_SEL
    get_CLOCK_CTRL_SDCLK_FREQ_SEL() volatile
    {
        return SDMMC_CLOCK_CTRL_SDCLK_FREQ_SEL((CLOCK_CTRL >> 8u) &
                                               0b11111111u);
    }

    /**
     * Set CLOCK_CTRL's SDCLK_FREQ_SEL field.
     *
     * SDCLK Frequency Select
     */
    inline void set_CLOCK_CTRL_SDCLK_FREQ_SEL(
        SDMMC_CLOCK_CTRL_SDCLK_FREQ_SEL value) volatile
    {
        uint16_t curr = CLOCK_CTRL;

        curr &= ~(0b11111111u << 8u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 8u;

        CLOCK_CTRL = curr;
    }

    /**
     * Get all of CLOCK_CTRL's bit fields.
     *
     * (read-write) Clock Control Register
     */
    inline void get_CLOCK_CTRL(
        bool &INTERNAL_CLOCK_EN, bool &INTERNAL_CLOCK_STABLE, bool &SDCLOCK_EN,
        SDMMC_CLOCK_CTRL_SDCLK_FREQ_SEL &SDCLK_FREQ_SEL) volatile
    {
        uint16_t curr = CLOCK_CTRL;

        INTERNAL_CLOCK_EN = curr & (1u << 0u);
        INTERNAL_CLOCK_STABLE = curr & (1u << 1u);
        SDCLOCK_EN = curr & (1u << 2u);
        SDCLK_FREQ_SEL =
            SDMMC_CLOCK_CTRL_SDCLK_FREQ_SEL((curr >> 8u) & 0b11111111u);
    }

    /**
     * Set all of CLOCK_CTRL's bit fields.
     *
     * (read-write) Clock Control Register
     */
    inline void set_CLOCK_CTRL(
        bool INTERNAL_CLOCK_EN, bool SDCLOCK_EN,
        SDMMC_CLOCK_CTRL_SDCLK_FREQ_SEL SDCLK_FREQ_SEL) volatile
    {
        uint16_t curr = CLOCK_CTRL;

        curr &= ~(0b1u << 0u);
        curr |= (INTERNAL_CLOCK_EN & 0b1u) << 0u;
        curr &= ~(0b1u << 2u);
        curr |= (SDCLOCK_EN & 0b1u) << 2u;
        curr &= ~(0b11111111u << 8u);
        curr |= (std::to_underlying(SDCLK_FREQ_SEL) & 0b11111111u) << 8u;

        CLOCK_CTRL = curr;
    }

    /**
     * Get TIMEOUT_CTRL's DAT_TIMEOUT_CNT_VAL field.
     *
     * Data Timeout Counter Value
     */
    inline SDMMC_TIMEOUT_CTRL_DAT_TIMEOUT_CNT_VAL
    get_TIMEOUT_CTRL_DAT_TIMEOUT_CNT_VAL() volatile
    {
        return SDMMC_TIMEOUT_CTRL_DAT_TIMEOUT_CNT_VAL((TIMEOUT_CTRL >> 0u) &
                                                      0b1111u);
    }

    /**
     * Set TIMEOUT_CTRL's DAT_TIMEOUT_CNT_VAL field.
     *
     * Data Timeout Counter Value
     */
    inline void set_TIMEOUT_CTRL_DAT_TIMEOUT_CNT_VAL(
        SDMMC_TIMEOUT_CTRL_DAT_TIMEOUT_CNT_VAL value) volatile
    {
        uint8_t curr = TIMEOUT_CTRL;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        TIMEOUT_CTRL = curr;
    }

    /**
     * Get SW_RESET's SW_RST_ALL bit.
     *
     * Software Reset for All
     */
    inline bool get_SW_RESET_SW_RST_ALL() volatile
    {
        return SW_RESET & (1u << 0u);
    }

    /**
     * Set SW_RESET's SW_RST_ALL bit.
     *
     * Software Reset for All
     */
    inline void set_SW_RESET_SW_RST_ALL() volatile
    {
        SW_RESET |= 1u << 0u;
    }

    /**
     * Clear SW_RESET's SW_RST_ALL bit.
     *
     * Software Reset for All
     */
    inline void clear_SW_RESET_SW_RST_ALL() volatile
    {
        SW_RESET &= ~(1u << 0u);
    }

    /**
     * Toggle SW_RESET's SW_RST_ALL bit.
     *
     * Software Reset for All
     */
    inline void toggle_SW_RESET_SW_RST_ALL() volatile
    {
        SW_RESET ^= 1u << 0u;
    }

    /**
     * Get SW_RESET's SW_RST_CMD_LINE bit.
     *
     * Software Reset for CMD Line
     */
    inline bool get_SW_RESET_SW_RST_CMD_LINE() volatile
    {
        return SW_RESET & (1u << 1u);
    }

    /**
     * Set SW_RESET's SW_RST_CMD_LINE bit.
     *
     * Software Reset for CMD Line
     */
    inline void set_SW_RESET_SW_RST_CMD_LINE() volatile
    {
        SW_RESET |= 1u << 1u;
    }

    /**
     * Clear SW_RESET's SW_RST_CMD_LINE bit.
     *
     * Software Reset for CMD Line
     */
    inline void clear_SW_RESET_SW_RST_CMD_LINE() volatile
    {
        SW_RESET &= ~(1u << 1u);
    }

    /**
     * Toggle SW_RESET's SW_RST_CMD_LINE bit.
     *
     * Software Reset for CMD Line
     */
    inline void toggle_SW_RESET_SW_RST_CMD_LINE() volatile
    {
        SW_RESET ^= 1u << 1u;
    }

    /**
     * Get SW_RESET's SW_RST_DAT_LINE bit.
     *
     * Software Reset for DAT Line
     */
    inline bool get_SW_RESET_SW_RST_DAT_LINE() volatile
    {
        return SW_RESET & (1u << 2u);
    }

    /**
     * Set SW_RESET's SW_RST_DAT_LINE bit.
     *
     * Software Reset for DAT Line
     */
    inline void set_SW_RESET_SW_RST_DAT_LINE() volatile
    {
        SW_RESET |= 1u << 2u;
    }

    /**
     * Clear SW_RESET's SW_RST_DAT_LINE bit.
     *
     * Software Reset for DAT Line
     */
    inline void clear_SW_RESET_SW_RST_DAT_LINE() volatile
    {
        SW_RESET &= ~(1u << 2u);
    }

    /**
     * Toggle SW_RESET's SW_RST_DAT_LINE bit.
     *
     * Software Reset for DAT Line
     */
    inline void toggle_SW_RESET_SW_RST_DAT_LINE() volatile
    {
        SW_RESET ^= 1u << 2u;
    }

    /**
     * Get all of SW_RESET's bit fields.
     *
     * (read-write) Software Reset Register
     */
    inline void get_SW_RESET(bool &SW_RST_ALL, bool &SW_RST_CMD_LINE,
                             bool &SW_RST_DAT_LINE) volatile
    {
        uint8_t curr = SW_RESET;

        SW_RST_ALL = curr & (1u << 0u);
        SW_RST_CMD_LINE = curr & (1u << 1u);
        SW_RST_DAT_LINE = curr & (1u << 2u);
    }

    /**
     * Set all of SW_RESET's bit fields.
     *
     * (read-write) Software Reset Register
     */
    inline void set_SW_RESET(bool SW_RST_ALL, bool SW_RST_CMD_LINE,
                             bool SW_RST_DAT_LINE) volatile
    {
        uint8_t curr = SW_RESET;

        curr &= ~(0b1u << 0u);
        curr |= (SW_RST_ALL & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (SW_RST_CMD_LINE & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (SW_RST_DAT_LINE & 0b1u) << 2u;

        SW_RESET = curr;
    }

    /**
     * Get INT_STATUS_NORM's CMD_COMPLETE bit.
     *
     * Command Complete
     */
    inline bool get_INT_STATUS_NORM_CMD_COMPLETE() volatile
    {
        return INT_STATUS_NORM & (1u << 0u);
    }

    /**
     * Set INT_STATUS_NORM's CMD_COMPLETE bit.
     *
     * Command Complete
     */
    inline void set_INT_STATUS_NORM_CMD_COMPLETE() volatile
    {
        INT_STATUS_NORM |= 1u << 0u;
    }

    /**
     * Clear INT_STATUS_NORM's CMD_COMPLETE bit.
     *
     * Command Complete
     */
    inline void clear_INT_STATUS_NORM_CMD_COMPLETE() volatile
    {
        INT_STATUS_NORM &= ~(1u << 0u);
    }

    /**
     * Toggle INT_STATUS_NORM's CMD_COMPLETE bit.
     *
     * Command Complete
     */
    inline void toggle_INT_STATUS_NORM_CMD_COMPLETE() volatile
    {
        INT_STATUS_NORM ^= 1u << 0u;
    }

    /**
     * Get INT_STATUS_NORM's TX_COMPLETE bit.
     *
     * Transfer Complete
     */
    inline bool get_INT_STATUS_NORM_TX_COMPLETE() volatile
    {
        return INT_STATUS_NORM & (1u << 1u);
    }

    /**
     * Set INT_STATUS_NORM's TX_COMPLETE bit.
     *
     * Transfer Complete
     */
    inline void set_INT_STATUS_NORM_TX_COMPLETE() volatile
    {
        INT_STATUS_NORM |= 1u << 1u;
    }

    /**
     * Clear INT_STATUS_NORM's TX_COMPLETE bit.
     *
     * Transfer Complete
     */
    inline void clear_INT_STATUS_NORM_TX_COMPLETE() volatile
    {
        INT_STATUS_NORM &= ~(1u << 1u);
    }

    /**
     * Toggle INT_STATUS_NORM's TX_COMPLETE bit.
     *
     * Transfer Complete
     */
    inline void toggle_INT_STATUS_NORM_TX_COMPLETE() volatile
    {
        INT_STATUS_NORM ^= 1u << 1u;
    }

    /**
     * Get INT_STATUS_NORM's BLOCK_GAP_EVENT bit.
     *
     * Block Gap Event
     */
    inline bool get_INT_STATUS_NORM_BLOCK_GAP_EVENT() volatile
    {
        return INT_STATUS_NORM & (1u << 2u);
    }

    /**
     * Set INT_STATUS_NORM's BLOCK_GAP_EVENT bit.
     *
     * Block Gap Event
     */
    inline void set_INT_STATUS_NORM_BLOCK_GAP_EVENT() volatile
    {
        INT_STATUS_NORM |= 1u << 2u;
    }

    /**
     * Clear INT_STATUS_NORM's BLOCK_GAP_EVENT bit.
     *
     * Block Gap Event
     */
    inline void clear_INT_STATUS_NORM_BLOCK_GAP_EVENT() volatile
    {
        INT_STATUS_NORM &= ~(1u << 2u);
    }

    /**
     * Toggle INT_STATUS_NORM's BLOCK_GAP_EVENT bit.
     *
     * Block Gap Event
     */
    inline void toggle_INT_STATUS_NORM_BLOCK_GAP_EVENT() volatile
    {
        INT_STATUS_NORM ^= 1u << 2u;
    }

    /**
     * Get INT_STATUS_NORM's BUFF_WRITE_READY bit.
     *
     * Buffer Write Ready
     */
    inline bool get_INT_STATUS_NORM_BUFF_WRITE_READY() volatile
    {
        return INT_STATUS_NORM & (1u << 4u);
    }

    /**
     * Set INT_STATUS_NORM's BUFF_WRITE_READY bit.
     *
     * Buffer Write Ready
     */
    inline void set_INT_STATUS_NORM_BUFF_WRITE_READY() volatile
    {
        INT_STATUS_NORM |= 1u << 4u;
    }

    /**
     * Clear INT_STATUS_NORM's BUFF_WRITE_READY bit.
     *
     * Buffer Write Ready
     */
    inline void clear_INT_STATUS_NORM_BUFF_WRITE_READY() volatile
    {
        INT_STATUS_NORM &= ~(1u << 4u);
    }

    /**
     * Toggle INT_STATUS_NORM's BUFF_WRITE_READY bit.
     *
     * Buffer Write Ready
     */
    inline void toggle_INT_STATUS_NORM_BUFF_WRITE_READY() volatile
    {
        INT_STATUS_NORM ^= 1u << 4u;
    }

    /**
     * Get INT_STATUS_NORM's BUFF_READ_READY bit.
     *
     * Buffer Read Ready
     */
    inline bool get_INT_STATUS_NORM_BUFF_READ_READY() volatile
    {
        return INT_STATUS_NORM & (1u << 5u);
    }

    /**
     * Set INT_STATUS_NORM's BUFF_READ_READY bit.
     *
     * Buffer Read Ready
     */
    inline void set_INT_STATUS_NORM_BUFF_READ_READY() volatile
    {
        INT_STATUS_NORM |= 1u << 5u;
    }

    /**
     * Clear INT_STATUS_NORM's BUFF_READ_READY bit.
     *
     * Buffer Read Ready
     */
    inline void clear_INT_STATUS_NORM_BUFF_READ_READY() volatile
    {
        INT_STATUS_NORM &= ~(1u << 5u);
    }

    /**
     * Toggle INT_STATUS_NORM's BUFF_READ_READY bit.
     *
     * Buffer Read Ready
     */
    inline void toggle_INT_STATUS_NORM_BUFF_READ_READY() volatile
    {
        INT_STATUS_NORM ^= 1u << 5u;
    }

    /**
     * Get INT_STATUS_NORM's CARD_INS bit.
     *
     * Card Insertion
     */
    inline bool get_INT_STATUS_NORM_CARD_INS() volatile
    {
        return INT_STATUS_NORM & (1u << 6u);
    }

    /**
     * Set INT_STATUS_NORM's CARD_INS bit.
     *
     * Card Insertion
     */
    inline void set_INT_STATUS_NORM_CARD_INS() volatile
    {
        INT_STATUS_NORM |= 1u << 6u;
    }

    /**
     * Clear INT_STATUS_NORM's CARD_INS bit.
     *
     * Card Insertion
     */
    inline void clear_INT_STATUS_NORM_CARD_INS() volatile
    {
        INT_STATUS_NORM &= ~(1u << 6u);
    }

    /**
     * Toggle INT_STATUS_NORM's CARD_INS bit.
     *
     * Card Insertion
     */
    inline void toggle_INT_STATUS_NORM_CARD_INS() volatile
    {
        INT_STATUS_NORM ^= 1u << 6u;
    }

    /**
     * Get INT_STATUS_NORM's CARD_REMOVAL bit.
     *
     * Card Removal
     */
    inline bool get_INT_STATUS_NORM_CARD_REMOVAL() volatile
    {
        return INT_STATUS_NORM & (1u << 7u);
    }

    /**
     * Set INT_STATUS_NORM's CARD_REMOVAL bit.
     *
     * Card Removal
     */
    inline void set_INT_STATUS_NORM_CARD_REMOVAL() volatile
    {
        INT_STATUS_NORM |= 1u << 7u;
    }

    /**
     * Clear INT_STATUS_NORM's CARD_REMOVAL bit.
     *
     * Card Removal
     */
    inline void clear_INT_STATUS_NORM_CARD_REMOVAL() volatile
    {
        INT_STATUS_NORM &= ~(1u << 7u);
    }

    /**
     * Toggle INT_STATUS_NORM's CARD_REMOVAL bit.
     *
     * Card Removal
     */
    inline void toggle_INT_STATUS_NORM_CARD_REMOVAL() volatile
    {
        INT_STATUS_NORM ^= 1u << 7u;
    }

    /**
     * Get INT_STATUS_NORM's CARD_INT bit.
     *
     * Card Interrupt
     */
    inline bool get_INT_STATUS_NORM_CARD_INT() volatile
    {
        return INT_STATUS_NORM & (1u << 8u);
    }

    /**
     * Get INT_STATUS_NORM's ERR_INT bit.
     *
     * Error Interrupt
     */
    inline bool get_INT_STATUS_NORM_ERR_INT() volatile
    {
        return INT_STATUS_NORM & (1u << 15u);
    }

    /**
     * Get all of INT_STATUS_NORM's bit fields.
     *
     * (read-write) Normal Interrupt Status Register
     */
    inline void get_INT_STATUS_NORM(bool &CMD_COMPLETE, bool &TX_COMPLETE,
                                    bool &BLOCK_GAP_EVENT,
                                    bool &BUFF_WRITE_READY,
                                    bool &BUFF_READ_READY, bool &CARD_INS,
                                    bool &CARD_REMOVAL, bool &CARD_INT,
                                    bool &ERR_INT) volatile
    {
        uint16_t curr = INT_STATUS_NORM;

        CMD_COMPLETE = curr & (1u << 0u);
        TX_COMPLETE = curr & (1u << 1u);
        BLOCK_GAP_EVENT = curr & (1u << 2u);
        BUFF_WRITE_READY = curr & (1u << 4u);
        BUFF_READ_READY = curr & (1u << 5u);
        CARD_INS = curr & (1u << 6u);
        CARD_REMOVAL = curr & (1u << 7u);
        CARD_INT = curr & (1u << 8u);
        ERR_INT = curr & (1u << 15u);
    }

    /**
     * Set all of INT_STATUS_NORM's bit fields.
     *
     * (read-write) Normal Interrupt Status Register
     */
    inline void set_INT_STATUS_NORM(bool CMD_COMPLETE, bool TX_COMPLETE,
                                    bool BLOCK_GAP_EVENT,
                                    bool BUFF_WRITE_READY,
                                    bool BUFF_READ_READY, bool CARD_INS,
                                    bool CARD_REMOVAL) volatile
    {
        uint16_t curr = INT_STATUS_NORM;

        curr &= ~(0b1u << 0u);
        curr |= (CMD_COMPLETE & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (TX_COMPLETE & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (BLOCK_GAP_EVENT & 0b1u) << 2u;
        curr &= ~(0b1u << 4u);
        curr |= (BUFF_WRITE_READY & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (BUFF_READ_READY & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (CARD_INS & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (CARD_REMOVAL & 0b1u) << 7u;

        INT_STATUS_NORM = curr;
    }

    /**
     * Get INT_STATUS_ERR's CMD_TIMEOUT_ERR bit.
     *
     * Command Timeout Error
     */
    inline bool get_INT_STATUS_ERR_CMD_TIMEOUT_ERR() volatile
    {
        return INT_STATUS_ERR & (1u << 0u);
    }

    /**
     * Set INT_STATUS_ERR's CMD_TIMEOUT_ERR bit.
     *
     * Command Timeout Error
     */
    inline void set_INT_STATUS_ERR_CMD_TIMEOUT_ERR() volatile
    {
        INT_STATUS_ERR |= 1u << 0u;
    }

    /**
     * Clear INT_STATUS_ERR's CMD_TIMEOUT_ERR bit.
     *
     * Command Timeout Error
     */
    inline void clear_INT_STATUS_ERR_CMD_TIMEOUT_ERR() volatile
    {
        INT_STATUS_ERR &= ~(1u << 0u);
    }

    /**
     * Toggle INT_STATUS_ERR's CMD_TIMEOUT_ERR bit.
     *
     * Command Timeout Error
     */
    inline void toggle_INT_STATUS_ERR_CMD_TIMEOUT_ERR() volatile
    {
        INT_STATUS_ERR ^= 1u << 0u;
    }

    /**
     * Get INT_STATUS_ERR's CMD_CRC_ERR bit.
     *
     * Command CRC Error
     */
    inline bool get_INT_STATUS_ERR_CMD_CRC_ERR() volatile
    {
        return INT_STATUS_ERR & (1u << 1u);
    }

    /**
     * Set INT_STATUS_ERR's CMD_CRC_ERR bit.
     *
     * Command CRC Error
     */
    inline void set_INT_STATUS_ERR_CMD_CRC_ERR() volatile
    {
        INT_STATUS_ERR |= 1u << 1u;
    }

    /**
     * Clear INT_STATUS_ERR's CMD_CRC_ERR bit.
     *
     * Command CRC Error
     */
    inline void clear_INT_STATUS_ERR_CMD_CRC_ERR() volatile
    {
        INT_STATUS_ERR &= ~(1u << 1u);
    }

    /**
     * Toggle INT_STATUS_ERR's CMD_CRC_ERR bit.
     *
     * Command CRC Error
     */
    inline void toggle_INT_STATUS_ERR_CMD_CRC_ERR() volatile
    {
        INT_STATUS_ERR ^= 1u << 1u;
    }

    /**
     * Get INT_STATUS_ERR's CMD_END_BIT_ERR bit.
     *
     * Command End Bit Error
     */
    inline bool get_INT_STATUS_ERR_CMD_END_BIT_ERR() volatile
    {
        return INT_STATUS_ERR & (1u << 2u);
    }

    /**
     * Set INT_STATUS_ERR's CMD_END_BIT_ERR bit.
     *
     * Command End Bit Error
     */
    inline void set_INT_STATUS_ERR_CMD_END_BIT_ERR() volatile
    {
        INT_STATUS_ERR |= 1u << 2u;
    }

    /**
     * Clear INT_STATUS_ERR's CMD_END_BIT_ERR bit.
     *
     * Command End Bit Error
     */
    inline void clear_INT_STATUS_ERR_CMD_END_BIT_ERR() volatile
    {
        INT_STATUS_ERR &= ~(1u << 2u);
    }

    /**
     * Toggle INT_STATUS_ERR's CMD_END_BIT_ERR bit.
     *
     * Command End Bit Error
     */
    inline void toggle_INT_STATUS_ERR_CMD_END_BIT_ERR() volatile
    {
        INT_STATUS_ERR ^= 1u << 2u;
    }

    /**
     * Get INT_STATUS_ERR's CMD_IND_ERR bit.
     *
     * Command Index Error
     */
    inline bool get_INT_STATUS_ERR_CMD_IND_ERR() volatile
    {
        return INT_STATUS_ERR & (1u << 3u);
    }

    /**
     * Set INT_STATUS_ERR's CMD_IND_ERR bit.
     *
     * Command Index Error
     */
    inline void set_INT_STATUS_ERR_CMD_IND_ERR() volatile
    {
        INT_STATUS_ERR |= 1u << 3u;
    }

    /**
     * Clear INT_STATUS_ERR's CMD_IND_ERR bit.
     *
     * Command Index Error
     */
    inline void clear_INT_STATUS_ERR_CMD_IND_ERR() volatile
    {
        INT_STATUS_ERR &= ~(1u << 3u);
    }

    /**
     * Toggle INT_STATUS_ERR's CMD_IND_ERR bit.
     *
     * Command Index Error
     */
    inline void toggle_INT_STATUS_ERR_CMD_IND_ERR() volatile
    {
        INT_STATUS_ERR ^= 1u << 3u;
    }

    /**
     * Get INT_STATUS_ERR's DATA_TIMEOUT_ERR bit.
     *
     * Data Timeout Error
     */
    inline bool get_INT_STATUS_ERR_DATA_TIMEOUT_ERR() volatile
    {
        return INT_STATUS_ERR & (1u << 4u);
    }

    /**
     * Set INT_STATUS_ERR's DATA_TIMEOUT_ERR bit.
     *
     * Data Timeout Error
     */
    inline void set_INT_STATUS_ERR_DATA_TIMEOUT_ERR() volatile
    {
        INT_STATUS_ERR |= 1u << 4u;
    }

    /**
     * Clear INT_STATUS_ERR's DATA_TIMEOUT_ERR bit.
     *
     * Data Timeout Error
     */
    inline void clear_INT_STATUS_ERR_DATA_TIMEOUT_ERR() volatile
    {
        INT_STATUS_ERR &= ~(1u << 4u);
    }

    /**
     * Toggle INT_STATUS_ERR's DATA_TIMEOUT_ERR bit.
     *
     * Data Timeout Error
     */
    inline void toggle_INT_STATUS_ERR_DATA_TIMEOUT_ERR() volatile
    {
        INT_STATUS_ERR ^= 1u << 4u;
    }

    /**
     * Get INT_STATUS_ERR's DATA_CRC_ERR bit.
     *
     * Data CRC Error
     */
    inline bool get_INT_STATUS_ERR_DATA_CRC_ERR() volatile
    {
        return INT_STATUS_ERR & (1u << 5u);
    }

    /**
     * Set INT_STATUS_ERR's DATA_CRC_ERR bit.
     *
     * Data CRC Error
     */
    inline void set_INT_STATUS_ERR_DATA_CRC_ERR() volatile
    {
        INT_STATUS_ERR |= 1u << 5u;
    }

    /**
     * Clear INT_STATUS_ERR's DATA_CRC_ERR bit.
     *
     * Data CRC Error
     */
    inline void clear_INT_STATUS_ERR_DATA_CRC_ERR() volatile
    {
        INT_STATUS_ERR &= ~(1u << 5u);
    }

    /**
     * Toggle INT_STATUS_ERR's DATA_CRC_ERR bit.
     *
     * Data CRC Error
     */
    inline void toggle_INT_STATUS_ERR_DATA_CRC_ERR() volatile
    {
        INT_STATUS_ERR ^= 1u << 5u;
    }

    /**
     * Get INT_STATUS_ERR's DATA_END_BIT_ERR bit.
     *
     * Data End Bit Error
     */
    inline bool get_INT_STATUS_ERR_DATA_END_BIT_ERR() volatile
    {
        return INT_STATUS_ERR & (1u << 6u);
    }

    /**
     * Set INT_STATUS_ERR's DATA_END_BIT_ERR bit.
     *
     * Data End Bit Error
     */
    inline void set_INT_STATUS_ERR_DATA_END_BIT_ERR() volatile
    {
        INT_STATUS_ERR |= 1u << 6u;
    }

    /**
     * Clear INT_STATUS_ERR's DATA_END_BIT_ERR bit.
     *
     * Data End Bit Error
     */
    inline void clear_INT_STATUS_ERR_DATA_END_BIT_ERR() volatile
    {
        INT_STATUS_ERR &= ~(1u << 6u);
    }

    /**
     * Toggle INT_STATUS_ERR's DATA_END_BIT_ERR bit.
     *
     * Data End Bit Error
     */
    inline void toggle_INT_STATUS_ERR_DATA_END_BIT_ERR() volatile
    {
        INT_STATUS_ERR ^= 1u << 6u;
    }

    /**
     * Get INT_STATUS_ERR's CURRENT_LIMIT_ERR bit.
     *
     * Current Limit Error
     */
    inline bool get_INT_STATUS_ERR_CURRENT_LIMIT_ERR() volatile
    {
        return INT_STATUS_ERR & (1u << 7u);
    }

    /**
     * Set INT_STATUS_ERR's CURRENT_LIMIT_ERR bit.
     *
     * Current Limit Error
     */
    inline void set_INT_STATUS_ERR_CURRENT_LIMIT_ERR() volatile
    {
        INT_STATUS_ERR |= 1u << 7u;
    }

    /**
     * Clear INT_STATUS_ERR's CURRENT_LIMIT_ERR bit.
     *
     * Current Limit Error
     */
    inline void clear_INT_STATUS_ERR_CURRENT_LIMIT_ERR() volatile
    {
        INT_STATUS_ERR &= ~(1u << 7u);
    }

    /**
     * Toggle INT_STATUS_ERR's CURRENT_LIMIT_ERR bit.
     *
     * Current Limit Error
     */
    inline void toggle_INT_STATUS_ERR_CURRENT_LIMIT_ERR() volatile
    {
        INT_STATUS_ERR ^= 1u << 7u;
    }

    /**
     * Get INT_STATUS_ERR's ACMD_ERR bit.
     *
     * Auto CMD Error
     */
    inline bool get_INT_STATUS_ERR_ACMD_ERR() volatile
    {
        return INT_STATUS_ERR & (1u << 8u);
    }

    /**
     * Set INT_STATUS_ERR's ACMD_ERR bit.
     *
     * Auto CMD Error
     */
    inline void set_INT_STATUS_ERR_ACMD_ERR() volatile
    {
        INT_STATUS_ERR |= 1u << 8u;
    }

    /**
     * Clear INT_STATUS_ERR's ACMD_ERR bit.
     *
     * Auto CMD Error
     */
    inline void clear_INT_STATUS_ERR_ACMD_ERR() volatile
    {
        INT_STATUS_ERR &= ~(1u << 8u);
    }

    /**
     * Toggle INT_STATUS_ERR's ACMD_ERR bit.
     *
     * Auto CMD Error
     */
    inline void toggle_INT_STATUS_ERR_ACMD_ERR() volatile
    {
        INT_STATUS_ERR ^= 1u << 8u;
    }

    /**
     * Get INT_STATUS_ERR's CEATA_ERR bit.
     *
     * Ceata Error Status
     */
    inline bool get_INT_STATUS_ERR_CEATA_ERR() volatile
    {
        return INT_STATUS_ERR & (1u << 13u);
    }

    /**
     * Set INT_STATUS_ERR's CEATA_ERR bit.
     *
     * Ceata Error Status
     */
    inline void set_INT_STATUS_ERR_CEATA_ERR() volatile
    {
        INT_STATUS_ERR |= 1u << 13u;
    }

    /**
     * Clear INT_STATUS_ERR's CEATA_ERR bit.
     *
     * Ceata Error Status
     */
    inline void clear_INT_STATUS_ERR_CEATA_ERR() volatile
    {
        INT_STATUS_ERR &= ~(1u << 13u);
    }

    /**
     * Toggle INT_STATUS_ERR's CEATA_ERR bit.
     *
     * Ceata Error Status
     */
    inline void toggle_INT_STATUS_ERR_CEATA_ERR() volatile
    {
        INT_STATUS_ERR ^= 1u << 13u;
    }

    /**
     * Get all of INT_STATUS_ERR's bit fields.
     *
     * (read-write) Error Interrupt Status Register
     */
    inline void get_INT_STATUS_ERR(bool &CMD_TIMEOUT_ERR, bool &CMD_CRC_ERR,
                                   bool &CMD_END_BIT_ERR, bool &CMD_IND_ERR,
                                   bool &DATA_TIMEOUT_ERR, bool &DATA_CRC_ERR,
                                   bool &DATA_END_BIT_ERR,
                                   bool &CURRENT_LIMIT_ERR, bool &ACMD_ERR,
                                   bool &CEATA_ERR) volatile
    {
        uint16_t curr = INT_STATUS_ERR;

        CMD_TIMEOUT_ERR = curr & (1u << 0u);
        CMD_CRC_ERR = curr & (1u << 1u);
        CMD_END_BIT_ERR = curr & (1u << 2u);
        CMD_IND_ERR = curr & (1u << 3u);
        DATA_TIMEOUT_ERR = curr & (1u << 4u);
        DATA_CRC_ERR = curr & (1u << 5u);
        DATA_END_BIT_ERR = curr & (1u << 6u);
        CURRENT_LIMIT_ERR = curr & (1u << 7u);
        ACMD_ERR = curr & (1u << 8u);
        CEATA_ERR = curr & (1u << 13u);
    }

    /**
     * Set all of INT_STATUS_ERR's bit fields.
     *
     * (read-write) Error Interrupt Status Register
     */
    inline void set_INT_STATUS_ERR(bool CMD_TIMEOUT_ERR, bool CMD_CRC_ERR,
                                   bool CMD_END_BIT_ERR, bool CMD_IND_ERR,
                                   bool DATA_TIMEOUT_ERR, bool DATA_CRC_ERR,
                                   bool DATA_END_BIT_ERR,
                                   bool CURRENT_LIMIT_ERR, bool ACMD_ERR,
                                   bool CEATA_ERR) volatile
    {
        uint16_t curr = INT_STATUS_ERR;

        curr &= ~(0b1u << 0u);
        curr |= (CMD_TIMEOUT_ERR & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (CMD_CRC_ERR & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (CMD_END_BIT_ERR & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (CMD_IND_ERR & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (DATA_TIMEOUT_ERR & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (DATA_CRC_ERR & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (DATA_END_BIT_ERR & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (CURRENT_LIMIT_ERR & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (ACMD_ERR & 0b1u) << 8u;
        curr &= ~(0b1u << 13u);
        curr |= (CEATA_ERR & 0b1u) << 13u;

        INT_STATUS_ERR = curr;
    }

    /**
     * Get EN_INT_STATUS_NORM's CMD_COMPLETE_EN bit.
     *
     * Command Complete Status Enable
     */
    inline bool get_EN_INT_STATUS_NORM_CMD_COMPLETE_EN() volatile
    {
        return EN_INT_STATUS_NORM & (1u << 0u);
    }

    /**
     * Set EN_INT_STATUS_NORM's CMD_COMPLETE_EN bit.
     *
     * Command Complete Status Enable
     */
    inline void set_EN_INT_STATUS_NORM_CMD_COMPLETE_EN() volatile
    {
        EN_INT_STATUS_NORM |= 1u << 0u;
    }

    /**
     * Clear EN_INT_STATUS_NORM's CMD_COMPLETE_EN bit.
     *
     * Command Complete Status Enable
     */
    inline void clear_EN_INT_STATUS_NORM_CMD_COMPLETE_EN() volatile
    {
        EN_INT_STATUS_NORM &= ~(1u << 0u);
    }

    /**
     * Toggle EN_INT_STATUS_NORM's CMD_COMPLETE_EN bit.
     *
     * Command Complete Status Enable
     */
    inline void toggle_EN_INT_STATUS_NORM_CMD_COMPLETE_EN() volatile
    {
        EN_INT_STATUS_NORM ^= 1u << 0u;
    }

    /**
     * Get EN_INT_STATUS_NORM's TX_COMPLETE_EN bit.
     *
     * Transfer Complete Status Enable
     */
    inline bool get_EN_INT_STATUS_NORM_TX_COMPLETE_EN() volatile
    {
        return EN_INT_STATUS_NORM & (1u << 1u);
    }

    /**
     * Set EN_INT_STATUS_NORM's TX_COMPLETE_EN bit.
     *
     * Transfer Complete Status Enable
     */
    inline void set_EN_INT_STATUS_NORM_TX_COMPLETE_EN() volatile
    {
        EN_INT_STATUS_NORM |= 1u << 1u;
    }

    /**
     * Clear EN_INT_STATUS_NORM's TX_COMPLETE_EN bit.
     *
     * Transfer Complete Status Enable
     */
    inline void clear_EN_INT_STATUS_NORM_TX_COMPLETE_EN() volatile
    {
        EN_INT_STATUS_NORM &= ~(1u << 1u);
    }

    /**
     * Toggle EN_INT_STATUS_NORM's TX_COMPLETE_EN bit.
     *
     * Transfer Complete Status Enable
     */
    inline void toggle_EN_INT_STATUS_NORM_TX_COMPLETE_EN() volatile
    {
        EN_INT_STATUS_NORM ^= 1u << 1u;
    }

    /**
     * Get EN_INT_STATUS_NORM's BLOCK_GAP_EVENT_EN bit.
     *
     * Block Gap Event Status Enable
     */
    inline bool get_EN_INT_STATUS_NORM_BLOCK_GAP_EVENT_EN() volatile
    {
        return EN_INT_STATUS_NORM & (1u << 2u);
    }

    /**
     * Set EN_INT_STATUS_NORM's BLOCK_GAP_EVENT_EN bit.
     *
     * Block Gap Event Status Enable
     */
    inline void set_EN_INT_STATUS_NORM_BLOCK_GAP_EVENT_EN() volatile
    {
        EN_INT_STATUS_NORM |= 1u << 2u;
    }

    /**
     * Clear EN_INT_STATUS_NORM's BLOCK_GAP_EVENT_EN bit.
     *
     * Block Gap Event Status Enable
     */
    inline void clear_EN_INT_STATUS_NORM_BLOCK_GAP_EVENT_EN() volatile
    {
        EN_INT_STATUS_NORM &= ~(1u << 2u);
    }

    /**
     * Toggle EN_INT_STATUS_NORM's BLOCK_GAP_EVENT_EN bit.
     *
     * Block Gap Event Status Enable
     */
    inline void toggle_EN_INT_STATUS_NORM_BLOCK_GAP_EVENT_EN() volatile
    {
        EN_INT_STATUS_NORM ^= 1u << 2u;
    }

    /**
     * Get EN_INT_STATUS_NORM's BUFF_WRITE_READY_EN bit.
     *
     * Buffer Write Ready Status Enable
     */
    inline bool get_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN() volatile
    {
        return EN_INT_STATUS_NORM & (1u << 4u);
    }

    /**
     * Set EN_INT_STATUS_NORM's BUFF_WRITE_READY_EN bit.
     *
     * Buffer Write Ready Status Enable
     */
    inline void set_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN() volatile
    {
        EN_INT_STATUS_NORM |= 1u << 4u;
    }

    /**
     * Clear EN_INT_STATUS_NORM's BUFF_WRITE_READY_EN bit.
     *
     * Buffer Write Ready Status Enable
     */
    inline void clear_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN() volatile
    {
        EN_INT_STATUS_NORM &= ~(1u << 4u);
    }

    /**
     * Toggle EN_INT_STATUS_NORM's BUFF_WRITE_READY_EN bit.
     *
     * Buffer Write Ready Status Enable
     */
    inline void toggle_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN() volatile
    {
        EN_INT_STATUS_NORM ^= 1u << 4u;
    }

    /**
     * Get EN_INT_STATUS_NORM's BUFF_READ_READY_EN bit.
     *
     * Buffer Read Ready Status Enable
     */
    inline bool get_EN_INT_STATUS_NORM_BUFF_READ_READY_EN() volatile
    {
        return EN_INT_STATUS_NORM & (1u << 5u);
    }

    /**
     * Set EN_INT_STATUS_NORM's BUFF_READ_READY_EN bit.
     *
     * Buffer Read Ready Status Enable
     */
    inline void set_EN_INT_STATUS_NORM_BUFF_READ_READY_EN() volatile
    {
        EN_INT_STATUS_NORM |= 1u << 5u;
    }

    /**
     * Clear EN_INT_STATUS_NORM's BUFF_READ_READY_EN bit.
     *
     * Buffer Read Ready Status Enable
     */
    inline void clear_EN_INT_STATUS_NORM_BUFF_READ_READY_EN() volatile
    {
        EN_INT_STATUS_NORM &= ~(1u << 5u);
    }

    /**
     * Toggle EN_INT_STATUS_NORM's BUFF_READ_READY_EN bit.
     *
     * Buffer Read Ready Status Enable
     */
    inline void toggle_EN_INT_STATUS_NORM_BUFF_READ_READY_EN() volatile
    {
        EN_INT_STATUS_NORM ^= 1u << 5u;
    }

    /**
     * Get EN_INT_STATUS_NORM's CARD_INS_EN bit.
     *
     * Card Insertion Status Enable
     */
    inline bool get_EN_INT_STATUS_NORM_CARD_INS_EN() volatile
    {
        return EN_INT_STATUS_NORM & (1u << 6u);
    }

    /**
     * Set EN_INT_STATUS_NORM's CARD_INS_EN bit.
     *
     * Card Insertion Status Enable
     */
    inline void set_EN_INT_STATUS_NORM_CARD_INS_EN() volatile
    {
        EN_INT_STATUS_NORM |= 1u << 6u;
    }

    /**
     * Clear EN_INT_STATUS_NORM's CARD_INS_EN bit.
     *
     * Card Insertion Status Enable
     */
    inline void clear_EN_INT_STATUS_NORM_CARD_INS_EN() volatile
    {
        EN_INT_STATUS_NORM &= ~(1u << 6u);
    }

    /**
     * Toggle EN_INT_STATUS_NORM's CARD_INS_EN bit.
     *
     * Card Insertion Status Enable
     */
    inline void toggle_EN_INT_STATUS_NORM_CARD_INS_EN() volatile
    {
        EN_INT_STATUS_NORM ^= 1u << 6u;
    }

    /**
     * Get EN_INT_STATUS_NORM's CARD_REMOVAL_EN bit.
     *
     * Card Removal Status Enable
     */
    inline bool get_EN_INT_STATUS_NORM_CARD_REMOVAL_EN() volatile
    {
        return EN_INT_STATUS_NORM & (1u << 7u);
    }

    /**
     * Set EN_INT_STATUS_NORM's CARD_REMOVAL_EN bit.
     *
     * Card Removal Status Enable
     */
    inline void set_EN_INT_STATUS_NORM_CARD_REMOVAL_EN() volatile
    {
        EN_INT_STATUS_NORM |= 1u << 7u;
    }

    /**
     * Clear EN_INT_STATUS_NORM's CARD_REMOVAL_EN bit.
     *
     * Card Removal Status Enable
     */
    inline void clear_EN_INT_STATUS_NORM_CARD_REMOVAL_EN() volatile
    {
        EN_INT_STATUS_NORM &= ~(1u << 7u);
    }

    /**
     * Toggle EN_INT_STATUS_NORM's CARD_REMOVAL_EN bit.
     *
     * Card Removal Status Enable
     */
    inline void toggle_EN_INT_STATUS_NORM_CARD_REMOVAL_EN() volatile
    {
        EN_INT_STATUS_NORM ^= 1u << 7u;
    }

    /**
     * Get EN_INT_STATUS_NORM's CARD_INT_EN bit.
     *
     * Card Interrupt Status Enable
     */
    inline bool get_EN_INT_STATUS_NORM_CARD_INT_EN() volatile
    {
        return EN_INT_STATUS_NORM & (1u << 8u);
    }

    /**
     * Set EN_INT_STATUS_NORM's CARD_INT_EN bit.
     *
     * Card Interrupt Status Enable
     */
    inline void set_EN_INT_STATUS_NORM_CARD_INT_EN() volatile
    {
        EN_INT_STATUS_NORM |= 1u << 8u;
    }

    /**
     * Clear EN_INT_STATUS_NORM's CARD_INT_EN bit.
     *
     * Card Interrupt Status Enable
     */
    inline void clear_EN_INT_STATUS_NORM_CARD_INT_EN() volatile
    {
        EN_INT_STATUS_NORM &= ~(1u << 8u);
    }

    /**
     * Toggle EN_INT_STATUS_NORM's CARD_INT_EN bit.
     *
     * Card Interrupt Status Enable
     */
    inline void toggle_EN_INT_STATUS_NORM_CARD_INT_EN() volatile
    {
        EN_INT_STATUS_NORM ^= 1u << 8u;
    }

    /**
     * Get EN_INT_STATUS_NORM's FIXED_TO_0 bit.
     *
     * Fixed to 0
     */
    inline bool get_EN_INT_STATUS_NORM_FIXED_TO_0() volatile
    {
        return EN_INT_STATUS_NORM & (1u << 15u);
    }

    /**
     * Get all of EN_INT_STATUS_NORM's bit fields.
     *
     * (read-write) Normal Interrupt Status Enable Register
     */
    inline void get_EN_INT_STATUS_NORM(
        bool &CMD_COMPLETE_EN, bool &TX_COMPLETE_EN, bool &BLOCK_GAP_EVENT_EN,
        bool &BUFF_WRITE_READY_EN, bool &BUFF_READ_READY_EN, bool &CARD_INS_EN,
        bool &CARD_REMOVAL_EN, bool &CARD_INT_EN, bool &FIXED_TO_0) volatile
    {
        uint16_t curr = EN_INT_STATUS_NORM;

        CMD_COMPLETE_EN = curr & (1u << 0u);
        TX_COMPLETE_EN = curr & (1u << 1u);
        BLOCK_GAP_EVENT_EN = curr & (1u << 2u);
        BUFF_WRITE_READY_EN = curr & (1u << 4u);
        BUFF_READ_READY_EN = curr & (1u << 5u);
        CARD_INS_EN = curr & (1u << 6u);
        CARD_REMOVAL_EN = curr & (1u << 7u);
        CARD_INT_EN = curr & (1u << 8u);
        FIXED_TO_0 = curr & (1u << 15u);
    }

    /**
     * Set all of EN_INT_STATUS_NORM's bit fields.
     *
     * (read-write) Normal Interrupt Status Enable Register
     */
    inline void set_EN_INT_STATUS_NORM(
        bool CMD_COMPLETE_EN, bool TX_COMPLETE_EN, bool BLOCK_GAP_EVENT_EN,
        bool BUFF_WRITE_READY_EN, bool BUFF_READ_READY_EN, bool CARD_INS_EN,
        bool CARD_REMOVAL_EN, bool CARD_INT_EN) volatile
    {
        uint16_t curr = EN_INT_STATUS_NORM;

        curr &= ~(0b1u << 0u);
        curr |= (CMD_COMPLETE_EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (TX_COMPLETE_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (BLOCK_GAP_EVENT_EN & 0b1u) << 2u;
        curr &= ~(0b1u << 4u);
        curr |= (BUFF_WRITE_READY_EN & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (BUFF_READ_READY_EN & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (CARD_INS_EN & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (CARD_REMOVAL_EN & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (CARD_INT_EN & 0b1u) << 8u;

        EN_INT_STATUS_NORM = curr;
    }

    /**
     * Get EN_INT_STATUS_ERR's CMD_TIMEOUT_ERR_EN bit.
     *
     * Command Timeout Error Status Enable
     */
    inline bool get_EN_INT_STATUS_ERR_CMD_TIMEOUT_ERR_EN() volatile
    {
        return EN_INT_STATUS_ERR & (1u << 0u);
    }

    /**
     * Set EN_INT_STATUS_ERR's CMD_TIMEOUT_ERR_EN bit.
     *
     * Command Timeout Error Status Enable
     */
    inline void set_EN_INT_STATUS_ERR_CMD_TIMEOUT_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR |= 1u << 0u;
    }

    /**
     * Clear EN_INT_STATUS_ERR's CMD_TIMEOUT_ERR_EN bit.
     *
     * Command Timeout Error Status Enable
     */
    inline void clear_EN_INT_STATUS_ERR_CMD_TIMEOUT_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR &= ~(1u << 0u);
    }

    /**
     * Toggle EN_INT_STATUS_ERR's CMD_TIMEOUT_ERR_EN bit.
     *
     * Command Timeout Error Status Enable
     */
    inline void toggle_EN_INT_STATUS_ERR_CMD_TIMEOUT_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR ^= 1u << 0u;
    }

    /**
     * Get EN_INT_STATUS_ERR's CMD_CRC_ERR_EN bit.
     *
     * Command CRC Error Status Enable
     */
    inline bool get_EN_INT_STATUS_ERR_CMD_CRC_ERR_EN() volatile
    {
        return EN_INT_STATUS_ERR & (1u << 1u);
    }

    /**
     * Set EN_INT_STATUS_ERR's CMD_CRC_ERR_EN bit.
     *
     * Command CRC Error Status Enable
     */
    inline void set_EN_INT_STATUS_ERR_CMD_CRC_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR |= 1u << 1u;
    }

    /**
     * Clear EN_INT_STATUS_ERR's CMD_CRC_ERR_EN bit.
     *
     * Command CRC Error Status Enable
     */
    inline void clear_EN_INT_STATUS_ERR_CMD_CRC_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR &= ~(1u << 1u);
    }

    /**
     * Toggle EN_INT_STATUS_ERR's CMD_CRC_ERR_EN bit.
     *
     * Command CRC Error Status Enable
     */
    inline void toggle_EN_INT_STATUS_ERR_CMD_CRC_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR ^= 1u << 1u;
    }

    /**
     * Get EN_INT_STATUS_ERR's CMD_END_BIT_ERR_EN bit.
     *
     * Command End Bit Error Status Enable
     */
    inline bool get_EN_INT_STATUS_ERR_CMD_END_BIT_ERR_EN() volatile
    {
        return EN_INT_STATUS_ERR & (1u << 2u);
    }

    /**
     * Set EN_INT_STATUS_ERR's CMD_END_BIT_ERR_EN bit.
     *
     * Command End Bit Error Status Enable
     */
    inline void set_EN_INT_STATUS_ERR_CMD_END_BIT_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR |= 1u << 2u;
    }

    /**
     * Clear EN_INT_STATUS_ERR's CMD_END_BIT_ERR_EN bit.
     *
     * Command End Bit Error Status Enable
     */
    inline void clear_EN_INT_STATUS_ERR_CMD_END_BIT_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR &= ~(1u << 2u);
    }

    /**
     * Toggle EN_INT_STATUS_ERR's CMD_END_BIT_ERR_EN bit.
     *
     * Command End Bit Error Status Enable
     */
    inline void toggle_EN_INT_STATUS_ERR_CMD_END_BIT_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR ^= 1u << 2u;
    }

    /**
     * Get EN_INT_STATUS_ERR's CMD_IND_ERR_EN bit.
     *
     * Command Index Error Status Enable
     */
    inline bool get_EN_INT_STATUS_ERR_CMD_IND_ERR_EN() volatile
    {
        return EN_INT_STATUS_ERR & (1u << 3u);
    }

    /**
     * Set EN_INT_STATUS_ERR's CMD_IND_ERR_EN bit.
     *
     * Command Index Error Status Enable
     */
    inline void set_EN_INT_STATUS_ERR_CMD_IND_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR |= 1u << 3u;
    }

    /**
     * Clear EN_INT_STATUS_ERR's CMD_IND_ERR_EN bit.
     *
     * Command Index Error Status Enable
     */
    inline void clear_EN_INT_STATUS_ERR_CMD_IND_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR &= ~(1u << 3u);
    }

    /**
     * Toggle EN_INT_STATUS_ERR's CMD_IND_ERR_EN bit.
     *
     * Command Index Error Status Enable
     */
    inline void toggle_EN_INT_STATUS_ERR_CMD_IND_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR ^= 1u << 3u;
    }

    /**
     * Get EN_INT_STATUS_ERR's DATA_TIMEOUT_ERR_EN bit.
     *
     * Data Timeout Error Status Enable
     */
    inline bool get_EN_INT_STATUS_ERR_DATA_TIMEOUT_ERR_EN() volatile
    {
        return EN_INT_STATUS_ERR & (1u << 4u);
    }

    /**
     * Set EN_INT_STATUS_ERR's DATA_TIMEOUT_ERR_EN bit.
     *
     * Data Timeout Error Status Enable
     */
    inline void set_EN_INT_STATUS_ERR_DATA_TIMEOUT_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR |= 1u << 4u;
    }

    /**
     * Clear EN_INT_STATUS_ERR's DATA_TIMEOUT_ERR_EN bit.
     *
     * Data Timeout Error Status Enable
     */
    inline void clear_EN_INT_STATUS_ERR_DATA_TIMEOUT_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR &= ~(1u << 4u);
    }

    /**
     * Toggle EN_INT_STATUS_ERR's DATA_TIMEOUT_ERR_EN bit.
     *
     * Data Timeout Error Status Enable
     */
    inline void toggle_EN_INT_STATUS_ERR_DATA_TIMEOUT_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR ^= 1u << 4u;
    }

    /**
     * Get EN_INT_STATUS_ERR's DATA_CRC_ERR_EN bit.
     *
     * Data CRC Error Status Enable
     */
    inline bool get_EN_INT_STATUS_ERR_DATA_CRC_ERR_EN() volatile
    {
        return EN_INT_STATUS_ERR & (1u << 5u);
    }

    /**
     * Set EN_INT_STATUS_ERR's DATA_CRC_ERR_EN bit.
     *
     * Data CRC Error Status Enable
     */
    inline void set_EN_INT_STATUS_ERR_DATA_CRC_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR |= 1u << 5u;
    }

    /**
     * Clear EN_INT_STATUS_ERR's DATA_CRC_ERR_EN bit.
     *
     * Data CRC Error Status Enable
     */
    inline void clear_EN_INT_STATUS_ERR_DATA_CRC_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR &= ~(1u << 5u);
    }

    /**
     * Toggle EN_INT_STATUS_ERR's DATA_CRC_ERR_EN bit.
     *
     * Data CRC Error Status Enable
     */
    inline void toggle_EN_INT_STATUS_ERR_DATA_CRC_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR ^= 1u << 5u;
    }

    /**
     * Get EN_INT_STATUS_ERR's DATA_END_BIT_ERR_EN bit.
     *
     * Data End Bit Error Status Enable
     */
    inline bool get_EN_INT_STATUS_ERR_DATA_END_BIT_ERR_EN() volatile
    {
        return EN_INT_STATUS_ERR & (1u << 6u);
    }

    /**
     * Set EN_INT_STATUS_ERR's DATA_END_BIT_ERR_EN bit.
     *
     * Data End Bit Error Status Enable
     */
    inline void set_EN_INT_STATUS_ERR_DATA_END_BIT_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR |= 1u << 6u;
    }

    /**
     * Clear EN_INT_STATUS_ERR's DATA_END_BIT_ERR_EN bit.
     *
     * Data End Bit Error Status Enable
     */
    inline void clear_EN_INT_STATUS_ERR_DATA_END_BIT_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR &= ~(1u << 6u);
    }

    /**
     * Toggle EN_INT_STATUS_ERR's DATA_END_BIT_ERR_EN bit.
     *
     * Data End Bit Error Status Enable
     */
    inline void toggle_EN_INT_STATUS_ERR_DATA_END_BIT_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR ^= 1u << 6u;
    }

    /**
     * Get EN_INT_STATUS_ERR's CURRENT_LIMIT_ERR_EN bit.
     *
     * Current Limit Error Status Enable
     */
    inline bool get_EN_INT_STATUS_ERR_CURRENT_LIMIT_ERR_EN() volatile
    {
        return EN_INT_STATUS_ERR & (1u << 7u);
    }

    /**
     * Set EN_INT_STATUS_ERR's CURRENT_LIMIT_ERR_EN bit.
     *
     * Current Limit Error Status Enable
     */
    inline void set_EN_INT_STATUS_ERR_CURRENT_LIMIT_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR |= 1u << 7u;
    }

    /**
     * Clear EN_INT_STATUS_ERR's CURRENT_LIMIT_ERR_EN bit.
     *
     * Current Limit Error Status Enable
     */
    inline void clear_EN_INT_STATUS_ERR_CURRENT_LIMIT_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR &= ~(1u << 7u);
    }

    /**
     * Toggle EN_INT_STATUS_ERR's CURRENT_LIMIT_ERR_EN bit.
     *
     * Current Limit Error Status Enable
     */
    inline void toggle_EN_INT_STATUS_ERR_CURRENT_LIMIT_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR ^= 1u << 7u;
    }

    /**
     * Get EN_INT_STATUS_ERR's ACMD_ERR_EN bit.
     *
     * Auto CMD12 Error Status Enable
     */
    inline bool get_EN_INT_STATUS_ERR_ACMD_ERR_EN() volatile
    {
        return EN_INT_STATUS_ERR & (1u << 8u);
    }

    /**
     * Set EN_INT_STATUS_ERR's ACMD_ERR_EN bit.
     *
     * Auto CMD12 Error Status Enable
     */
    inline void set_EN_INT_STATUS_ERR_ACMD_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR |= 1u << 8u;
    }

    /**
     * Clear EN_INT_STATUS_ERR's ACMD_ERR_EN bit.
     *
     * Auto CMD12 Error Status Enable
     */
    inline void clear_EN_INT_STATUS_ERR_ACMD_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR &= ~(1u << 8u);
    }

    /**
     * Toggle EN_INT_STATUS_ERR's ACMD_ERR_EN bit.
     *
     * Auto CMD12 Error Status Enable
     */
    inline void toggle_EN_INT_STATUS_ERR_ACMD_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR ^= 1u << 8u;
    }

    /**
     * Get EN_INT_STATUS_ERR's TARGET_RESP_ERR_EN bit.
     *
     * Target Response Error Status Enable
     */
    inline bool get_EN_INT_STATUS_ERR_TARGET_RESP_ERR_EN() volatile
    {
        return EN_INT_STATUS_ERR & (1u << 12u);
    }

    /**
     * Set EN_INT_STATUS_ERR's TARGET_RESP_ERR_EN bit.
     *
     * Target Response Error Status Enable
     */
    inline void set_EN_INT_STATUS_ERR_TARGET_RESP_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR |= 1u << 12u;
    }

    /**
     * Clear EN_INT_STATUS_ERR's TARGET_RESP_ERR_EN bit.
     *
     * Target Response Error Status Enable
     */
    inline void clear_EN_INT_STATUS_ERR_TARGET_RESP_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR &= ~(1u << 12u);
    }

    /**
     * Toggle EN_INT_STATUS_ERR's TARGET_RESP_ERR_EN bit.
     *
     * Target Response Error Status Enable
     */
    inline void toggle_EN_INT_STATUS_ERR_TARGET_RESP_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR ^= 1u << 12u;
    }

    /**
     * Get EN_INT_STATUS_ERR's CEATA_ERR_EN bit.
     *
     * Ceata Error Status Enable
     */
    inline bool get_EN_INT_STATUS_ERR_CEATA_ERR_EN() volatile
    {
        return EN_INT_STATUS_ERR & (1u << 13u);
    }

    /**
     * Set EN_INT_STATUS_ERR's CEATA_ERR_EN bit.
     *
     * Ceata Error Status Enable
     */
    inline void set_EN_INT_STATUS_ERR_CEATA_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR |= 1u << 13u;
    }

    /**
     * Clear EN_INT_STATUS_ERR's CEATA_ERR_EN bit.
     *
     * Ceata Error Status Enable
     */
    inline void clear_EN_INT_STATUS_ERR_CEATA_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR &= ~(1u << 13u);
    }

    /**
     * Toggle EN_INT_STATUS_ERR's CEATA_ERR_EN bit.
     *
     * Ceata Error Status Enable
     */
    inline void toggle_EN_INT_STATUS_ERR_CEATA_ERR_EN() volatile
    {
        EN_INT_STATUS_ERR ^= 1u << 13u;
    }

    /**
     * Get all of EN_INT_STATUS_ERR's bit fields.
     *
     * (read-write) Error Interrupt Status Enable Register
     */
    inline void get_EN_INT_STATUS_ERR(
        bool &CMD_TIMEOUT_ERR_EN, bool &CMD_CRC_ERR_EN,
        bool &CMD_END_BIT_ERR_EN, bool &CMD_IND_ERR_EN,
        bool &DATA_TIMEOUT_ERR_EN, bool &DATA_CRC_ERR_EN,
        bool &DATA_END_BIT_ERR_EN, bool &CURRENT_LIMIT_ERR_EN,
        bool &ACMD_ERR_EN, bool &TARGET_RESP_ERR_EN,
        bool &CEATA_ERR_EN) volatile
    {
        uint16_t curr = EN_INT_STATUS_ERR;

        CMD_TIMEOUT_ERR_EN = curr & (1u << 0u);
        CMD_CRC_ERR_EN = curr & (1u << 1u);
        CMD_END_BIT_ERR_EN = curr & (1u << 2u);
        CMD_IND_ERR_EN = curr & (1u << 3u);
        DATA_TIMEOUT_ERR_EN = curr & (1u << 4u);
        DATA_CRC_ERR_EN = curr & (1u << 5u);
        DATA_END_BIT_ERR_EN = curr & (1u << 6u);
        CURRENT_LIMIT_ERR_EN = curr & (1u << 7u);
        ACMD_ERR_EN = curr & (1u << 8u);
        TARGET_RESP_ERR_EN = curr & (1u << 12u);
        CEATA_ERR_EN = curr & (1u << 13u);
    }

    /**
     * Set all of EN_INT_STATUS_ERR's bit fields.
     *
     * (read-write) Error Interrupt Status Enable Register
     */
    inline void set_EN_INT_STATUS_ERR(
        bool CMD_TIMEOUT_ERR_EN, bool CMD_CRC_ERR_EN, bool CMD_END_BIT_ERR_EN,
        bool CMD_IND_ERR_EN, bool DATA_TIMEOUT_ERR_EN, bool DATA_CRC_ERR_EN,
        bool DATA_END_BIT_ERR_EN, bool CURRENT_LIMIT_ERR_EN, bool ACMD_ERR_EN,
        bool TARGET_RESP_ERR_EN, bool CEATA_ERR_EN) volatile
    {
        uint16_t curr = EN_INT_STATUS_ERR;

        curr &= ~(0b1u << 0u);
        curr |= (CMD_TIMEOUT_ERR_EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (CMD_CRC_ERR_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (CMD_END_BIT_ERR_EN & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (CMD_IND_ERR_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (DATA_TIMEOUT_ERR_EN & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (DATA_CRC_ERR_EN & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (DATA_END_BIT_ERR_EN & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (CURRENT_LIMIT_ERR_EN & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (ACMD_ERR_EN & 0b1u) << 8u;
        curr &= ~(0b1u << 12u);
        curr |= (TARGET_RESP_ERR_EN & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (CEATA_ERR_EN & 0b1u) << 13u;

        EN_INT_STATUS_ERR = curr;
    }

    /**
     * Get EN_INT_SIGNAL_NORM's CMD_COMPLETE_EN bit.
     *
     * Command Complete Signal Enable
     */
    inline bool get_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN() volatile
    {
        return EN_INT_SIGNAL_NORM & (1u << 0u);
    }

    /**
     * Set EN_INT_SIGNAL_NORM's CMD_COMPLETE_EN bit.
     *
     * Command Complete Signal Enable
     */
    inline void set_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN() volatile
    {
        EN_INT_SIGNAL_NORM |= 1u << 0u;
    }

    /**
     * Clear EN_INT_SIGNAL_NORM's CMD_COMPLETE_EN bit.
     *
     * Command Complete Signal Enable
     */
    inline void clear_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN() volatile
    {
        EN_INT_SIGNAL_NORM &= ~(1u << 0u);
    }

    /**
     * Toggle EN_INT_SIGNAL_NORM's CMD_COMPLETE_EN bit.
     *
     * Command Complete Signal Enable
     */
    inline void toggle_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN() volatile
    {
        EN_INT_SIGNAL_NORM ^= 1u << 0u;
    }

    /**
     * Get EN_INT_SIGNAL_NORM's TX_COMPLETE_EN bit.
     *
     * Transfer Complete Signal Enable
     */
    inline bool get_EN_INT_SIGNAL_NORM_TX_COMPLETE_EN() volatile
    {
        return EN_INT_SIGNAL_NORM & (1u << 1u);
    }

    /**
     * Set EN_INT_SIGNAL_NORM's TX_COMPLETE_EN bit.
     *
     * Transfer Complete Signal Enable
     */
    inline void set_EN_INT_SIGNAL_NORM_TX_COMPLETE_EN() volatile
    {
        EN_INT_SIGNAL_NORM |= 1u << 1u;
    }

    /**
     * Clear EN_INT_SIGNAL_NORM's TX_COMPLETE_EN bit.
     *
     * Transfer Complete Signal Enable
     */
    inline void clear_EN_INT_SIGNAL_NORM_TX_COMPLETE_EN() volatile
    {
        EN_INT_SIGNAL_NORM &= ~(1u << 1u);
    }

    /**
     * Toggle EN_INT_SIGNAL_NORM's TX_COMPLETE_EN bit.
     *
     * Transfer Complete Signal Enable
     */
    inline void toggle_EN_INT_SIGNAL_NORM_TX_COMPLETE_EN() volatile
    {
        EN_INT_SIGNAL_NORM ^= 1u << 1u;
    }

    /**
     * Get EN_INT_SIGNAL_NORM's BLOCK_GAP_EVENT_EN bit.
     *
     * Block Gap Event Signal Enable
     */
    inline bool get_EN_INT_SIGNAL_NORM_BLOCK_GAP_EVENT_EN() volatile
    {
        return EN_INT_SIGNAL_NORM & (1u << 2u);
    }

    /**
     * Set EN_INT_SIGNAL_NORM's BLOCK_GAP_EVENT_EN bit.
     *
     * Block Gap Event Signal Enable
     */
    inline void set_EN_INT_SIGNAL_NORM_BLOCK_GAP_EVENT_EN() volatile
    {
        EN_INT_SIGNAL_NORM |= 1u << 2u;
    }

    /**
     * Clear EN_INT_SIGNAL_NORM's BLOCK_GAP_EVENT_EN bit.
     *
     * Block Gap Event Signal Enable
     */
    inline void clear_EN_INT_SIGNAL_NORM_BLOCK_GAP_EVENT_EN() volatile
    {
        EN_INT_SIGNAL_NORM &= ~(1u << 2u);
    }

    /**
     * Toggle EN_INT_SIGNAL_NORM's BLOCK_GAP_EVENT_EN bit.
     *
     * Block Gap Event Signal Enable
     */
    inline void toggle_EN_INT_SIGNAL_NORM_BLOCK_GAP_EVENT_EN() volatile
    {
        EN_INT_SIGNAL_NORM ^= 1u << 2u;
    }

    /**
     * Get EN_INT_SIGNAL_NORM's BUFF_WRITE_READY_EN bit.
     *
     * Buffer Write Ready Signal Enable
     */
    inline bool get_EN_INT_SIGNAL_NORM_BUFF_WRITE_READY_EN() volatile
    {
        return EN_INT_SIGNAL_NORM & (1u << 4u);
    }

    /**
     * Set EN_INT_SIGNAL_NORM's BUFF_WRITE_READY_EN bit.
     *
     * Buffer Write Ready Signal Enable
     */
    inline void set_EN_INT_SIGNAL_NORM_BUFF_WRITE_READY_EN() volatile
    {
        EN_INT_SIGNAL_NORM |= 1u << 4u;
    }

    /**
     * Clear EN_INT_SIGNAL_NORM's BUFF_WRITE_READY_EN bit.
     *
     * Buffer Write Ready Signal Enable
     */
    inline void clear_EN_INT_SIGNAL_NORM_BUFF_WRITE_READY_EN() volatile
    {
        EN_INT_SIGNAL_NORM &= ~(1u << 4u);
    }

    /**
     * Toggle EN_INT_SIGNAL_NORM's BUFF_WRITE_READY_EN bit.
     *
     * Buffer Write Ready Signal Enable
     */
    inline void toggle_EN_INT_SIGNAL_NORM_BUFF_WRITE_READY_EN() volatile
    {
        EN_INT_SIGNAL_NORM ^= 1u << 4u;
    }

    /**
     * Get EN_INT_SIGNAL_NORM's BUFF_READ_READY_EN bit.
     *
     * Buffer Read Ready Signal Enable
     */
    inline bool get_EN_INT_SIGNAL_NORM_BUFF_READ_READY_EN() volatile
    {
        return EN_INT_SIGNAL_NORM & (1u << 5u);
    }

    /**
     * Set EN_INT_SIGNAL_NORM's BUFF_READ_READY_EN bit.
     *
     * Buffer Read Ready Signal Enable
     */
    inline void set_EN_INT_SIGNAL_NORM_BUFF_READ_READY_EN() volatile
    {
        EN_INT_SIGNAL_NORM |= 1u << 5u;
    }

    /**
     * Clear EN_INT_SIGNAL_NORM's BUFF_READ_READY_EN bit.
     *
     * Buffer Read Ready Signal Enable
     */
    inline void clear_EN_INT_SIGNAL_NORM_BUFF_READ_READY_EN() volatile
    {
        EN_INT_SIGNAL_NORM &= ~(1u << 5u);
    }

    /**
     * Toggle EN_INT_SIGNAL_NORM's BUFF_READ_READY_EN bit.
     *
     * Buffer Read Ready Signal Enable
     */
    inline void toggle_EN_INT_SIGNAL_NORM_BUFF_READ_READY_EN() volatile
    {
        EN_INT_SIGNAL_NORM ^= 1u << 5u;
    }

    /**
     * Get EN_INT_SIGNAL_NORM's CARD_INS_EN bit.
     *
     * Card Insertion Signal Enable
     */
    inline bool get_EN_INT_SIGNAL_NORM_CARD_INS_EN() volatile
    {
        return EN_INT_SIGNAL_NORM & (1u << 6u);
    }

    /**
     * Set EN_INT_SIGNAL_NORM's CARD_INS_EN bit.
     *
     * Card Insertion Signal Enable
     */
    inline void set_EN_INT_SIGNAL_NORM_CARD_INS_EN() volatile
    {
        EN_INT_SIGNAL_NORM |= 1u << 6u;
    }

    /**
     * Clear EN_INT_SIGNAL_NORM's CARD_INS_EN bit.
     *
     * Card Insertion Signal Enable
     */
    inline void clear_EN_INT_SIGNAL_NORM_CARD_INS_EN() volatile
    {
        EN_INT_SIGNAL_NORM &= ~(1u << 6u);
    }

    /**
     * Toggle EN_INT_SIGNAL_NORM's CARD_INS_EN bit.
     *
     * Card Insertion Signal Enable
     */
    inline void toggle_EN_INT_SIGNAL_NORM_CARD_INS_EN() volatile
    {
        EN_INT_SIGNAL_NORM ^= 1u << 6u;
    }

    /**
     * Get EN_INT_SIGNAL_NORM's CARD_REMOVAL_EN bit.
     *
     * Card Removal Signal Enable
     */
    inline bool get_EN_INT_SIGNAL_NORM_CARD_REMOVAL_EN() volatile
    {
        return EN_INT_SIGNAL_NORM & (1u << 7u);
    }

    /**
     * Set EN_INT_SIGNAL_NORM's CARD_REMOVAL_EN bit.
     *
     * Card Removal Signal Enable
     */
    inline void set_EN_INT_SIGNAL_NORM_CARD_REMOVAL_EN() volatile
    {
        EN_INT_SIGNAL_NORM |= 1u << 7u;
    }

    /**
     * Clear EN_INT_SIGNAL_NORM's CARD_REMOVAL_EN bit.
     *
     * Card Removal Signal Enable
     */
    inline void clear_EN_INT_SIGNAL_NORM_CARD_REMOVAL_EN() volatile
    {
        EN_INT_SIGNAL_NORM &= ~(1u << 7u);
    }

    /**
     * Toggle EN_INT_SIGNAL_NORM's CARD_REMOVAL_EN bit.
     *
     * Card Removal Signal Enable
     */
    inline void toggle_EN_INT_SIGNAL_NORM_CARD_REMOVAL_EN() volatile
    {
        EN_INT_SIGNAL_NORM ^= 1u << 7u;
    }

    /**
     * Get EN_INT_SIGNAL_NORM's CARD_INT_EN bit.
     *
     * Card Interrupt Signal Enable
     */
    inline bool get_EN_INT_SIGNAL_NORM_CARD_INT_EN() volatile
    {
        return EN_INT_SIGNAL_NORM & (1u << 8u);
    }

    /**
     * Set EN_INT_SIGNAL_NORM's CARD_INT_EN bit.
     *
     * Card Interrupt Signal Enable
     */
    inline void set_EN_INT_SIGNAL_NORM_CARD_INT_EN() volatile
    {
        EN_INT_SIGNAL_NORM |= 1u << 8u;
    }

    /**
     * Clear EN_INT_SIGNAL_NORM's CARD_INT_EN bit.
     *
     * Card Interrupt Signal Enable
     */
    inline void clear_EN_INT_SIGNAL_NORM_CARD_INT_EN() volatile
    {
        EN_INT_SIGNAL_NORM &= ~(1u << 8u);
    }

    /**
     * Toggle EN_INT_SIGNAL_NORM's CARD_INT_EN bit.
     *
     * Card Interrupt Signal Enable
     */
    inline void toggle_EN_INT_SIGNAL_NORM_CARD_INT_EN() volatile
    {
        EN_INT_SIGNAL_NORM ^= 1u << 8u;
    }

    /**
     * Get EN_INT_SIGNAL_NORM's FIXED_TO_0 bit.
     *
     * Fixed to 0
     */
    inline bool get_EN_INT_SIGNAL_NORM_FIXED_TO_0() volatile
    {
        return EN_INT_SIGNAL_NORM & (1u << 15u);
    }

    /**
     * Get all of EN_INT_SIGNAL_NORM's bit fields.
     *
     * (read-write) Normal Interrupt Signal Enable Register
     */
    inline void get_EN_INT_SIGNAL_NORM(
        bool &CMD_COMPLETE_EN, bool &TX_COMPLETE_EN, bool &BLOCK_GAP_EVENT_EN,
        bool &BUFF_WRITE_READY_EN, bool &BUFF_READ_READY_EN, bool &CARD_INS_EN,
        bool &CARD_REMOVAL_EN, bool &CARD_INT_EN, bool &FIXED_TO_0) volatile
    {
        uint16_t curr = EN_INT_SIGNAL_NORM;

        CMD_COMPLETE_EN = curr & (1u << 0u);
        TX_COMPLETE_EN = curr & (1u << 1u);
        BLOCK_GAP_EVENT_EN = curr & (1u << 2u);
        BUFF_WRITE_READY_EN = curr & (1u << 4u);
        BUFF_READ_READY_EN = curr & (1u << 5u);
        CARD_INS_EN = curr & (1u << 6u);
        CARD_REMOVAL_EN = curr & (1u << 7u);
        CARD_INT_EN = curr & (1u << 8u);
        FIXED_TO_0 = curr & (1u << 15u);
    }

    /**
     * Set all of EN_INT_SIGNAL_NORM's bit fields.
     *
     * (read-write) Normal Interrupt Signal Enable Register
     */
    inline void set_EN_INT_SIGNAL_NORM(
        bool CMD_COMPLETE_EN, bool TX_COMPLETE_EN, bool BLOCK_GAP_EVENT_EN,
        bool BUFF_WRITE_READY_EN, bool BUFF_READ_READY_EN, bool CARD_INS_EN,
        bool CARD_REMOVAL_EN, bool CARD_INT_EN) volatile
    {
        uint16_t curr = EN_INT_SIGNAL_NORM;

        curr &= ~(0b1u << 0u);
        curr |= (CMD_COMPLETE_EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (TX_COMPLETE_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (BLOCK_GAP_EVENT_EN & 0b1u) << 2u;
        curr &= ~(0b1u << 4u);
        curr |= (BUFF_WRITE_READY_EN & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (BUFF_READ_READY_EN & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (CARD_INS_EN & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (CARD_REMOVAL_EN & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (CARD_INT_EN & 0b1u) << 8u;

        EN_INT_SIGNAL_NORM = curr;
    }

    /**
     * Get EN_INT_SIGNAL_ERR's CMD_TIMEOUT_ERR_EN bit.
     *
     * Command Timeout Error Signal Enable
     */
    inline bool get_EN_INT_SIGNAL_ERR_CMD_TIMEOUT_ERR_EN() volatile
    {
        return EN_INT_SIGNAL_ERR & (1u << 0u);
    }

    /**
     * Set EN_INT_SIGNAL_ERR's CMD_TIMEOUT_ERR_EN bit.
     *
     * Command Timeout Error Signal Enable
     */
    inline void set_EN_INT_SIGNAL_ERR_CMD_TIMEOUT_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR |= 1u << 0u;
    }

    /**
     * Clear EN_INT_SIGNAL_ERR's CMD_TIMEOUT_ERR_EN bit.
     *
     * Command Timeout Error Signal Enable
     */
    inline void clear_EN_INT_SIGNAL_ERR_CMD_TIMEOUT_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR &= ~(1u << 0u);
    }

    /**
     * Toggle EN_INT_SIGNAL_ERR's CMD_TIMEOUT_ERR_EN bit.
     *
     * Command Timeout Error Signal Enable
     */
    inline void toggle_EN_INT_SIGNAL_ERR_CMD_TIMEOUT_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR ^= 1u << 0u;
    }

    /**
     * Get EN_INT_SIGNAL_ERR's CMD_CRC_ERR_EN bit.
     *
     * Command CRC Error Signal Enable
     */
    inline bool get_EN_INT_SIGNAL_ERR_CMD_CRC_ERR_EN() volatile
    {
        return EN_INT_SIGNAL_ERR & (1u << 1u);
    }

    /**
     * Set EN_INT_SIGNAL_ERR's CMD_CRC_ERR_EN bit.
     *
     * Command CRC Error Signal Enable
     */
    inline void set_EN_INT_SIGNAL_ERR_CMD_CRC_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR |= 1u << 1u;
    }

    /**
     * Clear EN_INT_SIGNAL_ERR's CMD_CRC_ERR_EN bit.
     *
     * Command CRC Error Signal Enable
     */
    inline void clear_EN_INT_SIGNAL_ERR_CMD_CRC_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR &= ~(1u << 1u);
    }

    /**
     * Toggle EN_INT_SIGNAL_ERR's CMD_CRC_ERR_EN bit.
     *
     * Command CRC Error Signal Enable
     */
    inline void toggle_EN_INT_SIGNAL_ERR_CMD_CRC_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR ^= 1u << 1u;
    }

    /**
     * Get EN_INT_SIGNAL_ERR's CMD_END_BIT_ERR_EN bit.
     *
     * Command End Bit Error Signal Enable
     */
    inline bool get_EN_INT_SIGNAL_ERR_CMD_END_BIT_ERR_EN() volatile
    {
        return EN_INT_SIGNAL_ERR & (1u << 2u);
    }

    /**
     * Set EN_INT_SIGNAL_ERR's CMD_END_BIT_ERR_EN bit.
     *
     * Command End Bit Error Signal Enable
     */
    inline void set_EN_INT_SIGNAL_ERR_CMD_END_BIT_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR |= 1u << 2u;
    }

    /**
     * Clear EN_INT_SIGNAL_ERR's CMD_END_BIT_ERR_EN bit.
     *
     * Command End Bit Error Signal Enable
     */
    inline void clear_EN_INT_SIGNAL_ERR_CMD_END_BIT_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR &= ~(1u << 2u);
    }

    /**
     * Toggle EN_INT_SIGNAL_ERR's CMD_END_BIT_ERR_EN bit.
     *
     * Command End Bit Error Signal Enable
     */
    inline void toggle_EN_INT_SIGNAL_ERR_CMD_END_BIT_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR ^= 1u << 2u;
    }

    /**
     * Get EN_INT_SIGNAL_ERR's CMD_IND_ERR_EN bit.
     *
     * Command Index Error Signal Enable
     */
    inline bool get_EN_INT_SIGNAL_ERR_CMD_IND_ERR_EN() volatile
    {
        return EN_INT_SIGNAL_ERR & (1u << 3u);
    }

    /**
     * Set EN_INT_SIGNAL_ERR's CMD_IND_ERR_EN bit.
     *
     * Command Index Error Signal Enable
     */
    inline void set_EN_INT_SIGNAL_ERR_CMD_IND_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR |= 1u << 3u;
    }

    /**
     * Clear EN_INT_SIGNAL_ERR's CMD_IND_ERR_EN bit.
     *
     * Command Index Error Signal Enable
     */
    inline void clear_EN_INT_SIGNAL_ERR_CMD_IND_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR &= ~(1u << 3u);
    }

    /**
     * Toggle EN_INT_SIGNAL_ERR's CMD_IND_ERR_EN bit.
     *
     * Command Index Error Signal Enable
     */
    inline void toggle_EN_INT_SIGNAL_ERR_CMD_IND_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR ^= 1u << 3u;
    }

    /**
     * Get EN_INT_SIGNAL_ERR's DATA_TIMEOUT_ERR_EN bit.
     *
     * Data Timeout Error Signal Enable
     */
    inline bool get_EN_INT_SIGNAL_ERR_DATA_TIMEOUT_ERR_EN() volatile
    {
        return EN_INT_SIGNAL_ERR & (1u << 4u);
    }

    /**
     * Set EN_INT_SIGNAL_ERR's DATA_TIMEOUT_ERR_EN bit.
     *
     * Data Timeout Error Signal Enable
     */
    inline void set_EN_INT_SIGNAL_ERR_DATA_TIMEOUT_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR |= 1u << 4u;
    }

    /**
     * Clear EN_INT_SIGNAL_ERR's DATA_TIMEOUT_ERR_EN bit.
     *
     * Data Timeout Error Signal Enable
     */
    inline void clear_EN_INT_SIGNAL_ERR_DATA_TIMEOUT_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR &= ~(1u << 4u);
    }

    /**
     * Toggle EN_INT_SIGNAL_ERR's DATA_TIMEOUT_ERR_EN bit.
     *
     * Data Timeout Error Signal Enable
     */
    inline void toggle_EN_INT_SIGNAL_ERR_DATA_TIMEOUT_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR ^= 1u << 4u;
    }

    /**
     * Get EN_INT_SIGNAL_ERR's DATA_CRC_ERR_EN bit.
     *
     * Data CRC Error Signal Enable
     */
    inline bool get_EN_INT_SIGNAL_ERR_DATA_CRC_ERR_EN() volatile
    {
        return EN_INT_SIGNAL_ERR & (1u << 5u);
    }

    /**
     * Set EN_INT_SIGNAL_ERR's DATA_CRC_ERR_EN bit.
     *
     * Data CRC Error Signal Enable
     */
    inline void set_EN_INT_SIGNAL_ERR_DATA_CRC_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR |= 1u << 5u;
    }

    /**
     * Clear EN_INT_SIGNAL_ERR's DATA_CRC_ERR_EN bit.
     *
     * Data CRC Error Signal Enable
     */
    inline void clear_EN_INT_SIGNAL_ERR_DATA_CRC_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR &= ~(1u << 5u);
    }

    /**
     * Toggle EN_INT_SIGNAL_ERR's DATA_CRC_ERR_EN bit.
     *
     * Data CRC Error Signal Enable
     */
    inline void toggle_EN_INT_SIGNAL_ERR_DATA_CRC_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR ^= 1u << 5u;
    }

    /**
     * Get EN_INT_SIGNAL_ERR's DATA_END_BIT_ERR_EN bit.
     *
     * Data End Bit Error Signal Enable
     */
    inline bool get_EN_INT_SIGNAL_ERR_DATA_END_BIT_ERR_EN() volatile
    {
        return EN_INT_SIGNAL_ERR & (1u << 6u);
    }

    /**
     * Set EN_INT_SIGNAL_ERR's DATA_END_BIT_ERR_EN bit.
     *
     * Data End Bit Error Signal Enable
     */
    inline void set_EN_INT_SIGNAL_ERR_DATA_END_BIT_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR |= 1u << 6u;
    }

    /**
     * Clear EN_INT_SIGNAL_ERR's DATA_END_BIT_ERR_EN bit.
     *
     * Data End Bit Error Signal Enable
     */
    inline void clear_EN_INT_SIGNAL_ERR_DATA_END_BIT_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR &= ~(1u << 6u);
    }

    /**
     * Toggle EN_INT_SIGNAL_ERR's DATA_END_BIT_ERR_EN bit.
     *
     * Data End Bit Error Signal Enable
     */
    inline void toggle_EN_INT_SIGNAL_ERR_DATA_END_BIT_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR ^= 1u << 6u;
    }

    /**
     * Get EN_INT_SIGNAL_ERR's CURRENT_LIMIT_ERR_EN bit.
     *
     * Current Limit Error Signal Enable
     */
    inline bool get_EN_INT_SIGNAL_ERR_CURRENT_LIMIT_ERR_EN() volatile
    {
        return EN_INT_SIGNAL_ERR & (1u << 7u);
    }

    /**
     * Set EN_INT_SIGNAL_ERR's CURRENT_LIMIT_ERR_EN bit.
     *
     * Current Limit Error Signal Enable
     */
    inline void set_EN_INT_SIGNAL_ERR_CURRENT_LIMIT_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR |= 1u << 7u;
    }

    /**
     * Clear EN_INT_SIGNAL_ERR's CURRENT_LIMIT_ERR_EN bit.
     *
     * Current Limit Error Signal Enable
     */
    inline void clear_EN_INT_SIGNAL_ERR_CURRENT_LIMIT_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR &= ~(1u << 7u);
    }

    /**
     * Toggle EN_INT_SIGNAL_ERR's CURRENT_LIMIT_ERR_EN bit.
     *
     * Current Limit Error Signal Enable
     */
    inline void toggle_EN_INT_SIGNAL_ERR_CURRENT_LIMIT_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR ^= 1u << 7u;
    }

    /**
     * Get EN_INT_SIGNAL_ERR's ACMD_ERR_EN bit.
     *
     * Auto CMD12 Error Signal Enable
     */
    inline bool get_EN_INT_SIGNAL_ERR_ACMD_ERR_EN() volatile
    {
        return EN_INT_SIGNAL_ERR & (1u << 8u);
    }

    /**
     * Set EN_INT_SIGNAL_ERR's ACMD_ERR_EN bit.
     *
     * Auto CMD12 Error Signal Enable
     */
    inline void set_EN_INT_SIGNAL_ERR_ACMD_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR |= 1u << 8u;
    }

    /**
     * Clear EN_INT_SIGNAL_ERR's ACMD_ERR_EN bit.
     *
     * Auto CMD12 Error Signal Enable
     */
    inline void clear_EN_INT_SIGNAL_ERR_ACMD_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR &= ~(1u << 8u);
    }

    /**
     * Toggle EN_INT_SIGNAL_ERR's ACMD_ERR_EN bit.
     *
     * Auto CMD12 Error Signal Enable
     */
    inline void toggle_EN_INT_SIGNAL_ERR_ACMD_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR ^= 1u << 8u;
    }

    /**
     * Get EN_INT_SIGNAL_ERR's TARGET_RESP_ERR_EN bit.
     *
     * Target Response Error Signal Enable
     */
    inline bool get_EN_INT_SIGNAL_ERR_TARGET_RESP_ERR_EN() volatile
    {
        return EN_INT_SIGNAL_ERR & (1u << 12u);
    }

    /**
     * Set EN_INT_SIGNAL_ERR's TARGET_RESP_ERR_EN bit.
     *
     * Target Response Error Signal Enable
     */
    inline void set_EN_INT_SIGNAL_ERR_TARGET_RESP_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR |= 1u << 12u;
    }

    /**
     * Clear EN_INT_SIGNAL_ERR's TARGET_RESP_ERR_EN bit.
     *
     * Target Response Error Signal Enable
     */
    inline void clear_EN_INT_SIGNAL_ERR_TARGET_RESP_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR &= ~(1u << 12u);
    }

    /**
     * Toggle EN_INT_SIGNAL_ERR's TARGET_RESP_ERR_EN bit.
     *
     * Target Response Error Signal Enable
     */
    inline void toggle_EN_INT_SIGNAL_ERR_TARGET_RESP_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR ^= 1u << 12u;
    }

    /**
     * Get EN_INT_SIGNAL_ERR's CEATA_ERR_EN bit.
     *
     * Ceata Error Signal Enable
     */
    inline bool get_EN_INT_SIGNAL_ERR_CEATA_ERR_EN() volatile
    {
        return EN_INT_SIGNAL_ERR & (1u << 13u);
    }

    /**
     * Set EN_INT_SIGNAL_ERR's CEATA_ERR_EN bit.
     *
     * Ceata Error Signal Enable
     */
    inline void set_EN_INT_SIGNAL_ERR_CEATA_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR |= 1u << 13u;
    }

    /**
     * Clear EN_INT_SIGNAL_ERR's CEATA_ERR_EN bit.
     *
     * Ceata Error Signal Enable
     */
    inline void clear_EN_INT_SIGNAL_ERR_CEATA_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR &= ~(1u << 13u);
    }

    /**
     * Toggle EN_INT_SIGNAL_ERR's CEATA_ERR_EN bit.
     *
     * Ceata Error Signal Enable
     */
    inline void toggle_EN_INT_SIGNAL_ERR_CEATA_ERR_EN() volatile
    {
        EN_INT_SIGNAL_ERR ^= 1u << 13u;
    }

    /**
     * Get all of EN_INT_SIGNAL_ERR's bit fields.
     *
     * (read-write) Error Interrupt Signal Enable Register
     */
    inline void get_EN_INT_SIGNAL_ERR(
        bool &CMD_TIMEOUT_ERR_EN, bool &CMD_CRC_ERR_EN,
        bool &CMD_END_BIT_ERR_EN, bool &CMD_IND_ERR_EN,
        bool &DATA_TIMEOUT_ERR_EN, bool &DATA_CRC_ERR_EN,
        bool &DATA_END_BIT_ERR_EN, bool &CURRENT_LIMIT_ERR_EN,
        bool &ACMD_ERR_EN, bool &TARGET_RESP_ERR_EN,
        bool &CEATA_ERR_EN) volatile
    {
        uint16_t curr = EN_INT_SIGNAL_ERR;

        CMD_TIMEOUT_ERR_EN = curr & (1u << 0u);
        CMD_CRC_ERR_EN = curr & (1u << 1u);
        CMD_END_BIT_ERR_EN = curr & (1u << 2u);
        CMD_IND_ERR_EN = curr & (1u << 3u);
        DATA_TIMEOUT_ERR_EN = curr & (1u << 4u);
        DATA_CRC_ERR_EN = curr & (1u << 5u);
        DATA_END_BIT_ERR_EN = curr & (1u << 6u);
        CURRENT_LIMIT_ERR_EN = curr & (1u << 7u);
        ACMD_ERR_EN = curr & (1u << 8u);
        TARGET_RESP_ERR_EN = curr & (1u << 12u);
        CEATA_ERR_EN = curr & (1u << 13u);
    }

    /**
     * Set all of EN_INT_SIGNAL_ERR's bit fields.
     *
     * (read-write) Error Interrupt Signal Enable Register
     */
    inline void set_EN_INT_SIGNAL_ERR(
        bool CMD_TIMEOUT_ERR_EN, bool CMD_CRC_ERR_EN, bool CMD_END_BIT_ERR_EN,
        bool CMD_IND_ERR_EN, bool DATA_TIMEOUT_ERR_EN, bool DATA_CRC_ERR_EN,
        bool DATA_END_BIT_ERR_EN, bool CURRENT_LIMIT_ERR_EN, bool ACMD_ERR_EN,
        bool TARGET_RESP_ERR_EN, bool CEATA_ERR_EN) volatile
    {
        uint16_t curr = EN_INT_SIGNAL_ERR;

        curr &= ~(0b1u << 0u);
        curr |= (CMD_TIMEOUT_ERR_EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (CMD_CRC_ERR_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (CMD_END_BIT_ERR_EN & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (CMD_IND_ERR_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (DATA_TIMEOUT_ERR_EN & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (DATA_CRC_ERR_EN & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (DATA_END_BIT_ERR_EN & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (CURRENT_LIMIT_ERR_EN & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (ACMD_ERR_EN & 0b1u) << 8u;
        curr &= ~(0b1u << 12u);
        curr |= (TARGET_RESP_ERR_EN & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (CEATA_ERR_EN & 0b1u) << 13u;

        EN_INT_SIGNAL_ERR = curr;
    }

    /**
     * Get ACMD_ERR_STATUS's ACMD12_NOT_EXEC_ERR bit.
     *
     * Auto CMD12 Not Executed
     */
    inline bool get_ACMD_ERR_STATUS_ACMD12_NOT_EXEC_ERR() volatile
    {
        return ACMD_ERR_STATUS & (1u << 0u);
    }

    /**
     * Get ACMD_ERR_STATUS's ACMD_TIMEOUT_ERR bit.
     *
     * Auto CMD Timeout Error
     */
    inline bool get_ACMD_ERR_STATUS_ACMD_TIMEOUT_ERR() volatile
    {
        return ACMD_ERR_STATUS & (1u << 1u);
    }

    /**
     * Get ACMD_ERR_STATUS's ACMD_CRC_ERR bit.
     *
     * Auto CMD CRC Error
     */
    inline bool get_ACMD_ERR_STATUS_ACMD_CRC_ERR() volatile
    {
        return ACMD_ERR_STATUS & (1u << 2u);
    }

    /**
     * Get ACMD_ERR_STATUS's ACMD_END_BIT_ERR bit.
     *
     * Auto CMD End Bit Error
     */
    inline bool get_ACMD_ERR_STATUS_ACMD_END_BIT_ERR() volatile
    {
        return ACMD_ERR_STATUS & (1u << 3u);
    }

    /**
     * Get ACMD_ERR_STATUS's ACMD_IND_ERR bit.
     *
     * Auto CMD Index Error
     */
    inline bool get_ACMD_ERR_STATUS_ACMD_IND_ERR() volatile
    {
        return ACMD_ERR_STATUS & (1u << 4u);
    }

    /**
     * Get ACMD_ERR_STATUS's CMD_NOT_ISSUED_BY_ACMD12_ERR bit.
     *
     * Command Not Issued By Auto CMD12 Error
     */
    inline bool get_ACMD_ERR_STATUS_CMD_NOT_ISSUED_BY_ACMD12_ERR() volatile
    {
        return ACMD_ERR_STATUS & (1u << 7u);
    }

    /**
     * Get all of ACMD_ERR_STATUS's bit fields.
     *
     * (read-only) Auto CMD Error Status Register
     */
    inline void get_ACMD_ERR_STATUS(
        bool &ACMD12_NOT_EXEC_ERR, bool &ACMD_TIMEOUT_ERR, bool &ACMD_CRC_ERR,
        bool &ACMD_END_BIT_ERR, bool &ACMD_IND_ERR,
        bool &CMD_NOT_ISSUED_BY_ACMD12_ERR) volatile
    {
        uint16_t curr = ACMD_ERR_STATUS;

        ACMD12_NOT_EXEC_ERR = curr & (1u << 0u);
        ACMD_TIMEOUT_ERR = curr & (1u << 1u);
        ACMD_CRC_ERR = curr & (1u << 2u);
        ACMD_END_BIT_ERR = curr & (1u << 3u);
        ACMD_IND_ERR = curr & (1u << 4u);
        CMD_NOT_ISSUED_BY_ACMD12_ERR = curr & (1u << 7u);
    }

    /**
     * Get CAPABILITIES's SLOT_TYPE field.
     *
     * Slot Type
     */
    inline SDMMC_CAPABILITIES_SLOT_TYPE get_CAPABILITIES_SLOT_TYPE() volatile
    {
        return SDMMC_CAPABILITIES_SLOT_TYPE((CAPABILITIES >> 30u) & 0b11u);
    }

    /**
     * Get CAPABILITIES's ASYNC_INT_SUPPORT bit.
     *
     * Asynchronous Interrupt Support
     */
    inline bool get_CAPABILITIES_ASYNC_INT_SUPPORT() volatile
    {
        return CAPABILITIES & (1u << 29u);
    }

    /**
     * Get CAPABILITIES's SYSBUS_64_SUPPORT bit.
     *
     * 64-bit System Bus Support
     */
    inline bool get_CAPABILITIES_SYSBUS_64_SUPPORT() volatile
    {
        return CAPABILITIES & (1u << 28u);
    }

    /**
     * Get CAPABILITIES's VOLTAGE_SUPPORT_1_8V bit.
     *
     * Voltage Support 1.8V
     */
    inline bool get_CAPABILITIES_VOLTAGE_SUPPORT_1_8V() volatile
    {
        return CAPABILITIES & (1u << 26u);
    }

    /**
     * Get CAPABILITIES's VOLTAGE_SUPPORT_3V bit.
     *
     * Voltage Support 3.0V
     */
    inline bool get_CAPABILITIES_VOLTAGE_SUPPORT_3V() volatile
    {
        return CAPABILITIES & (1u << 25u);
    }

    /**
     * Get CAPABILITIES's VOLTAGE_SUPPORT_3_3V bit.
     *
     * Voltage Support 3.3V
     */
    inline bool get_CAPABILITIES_VOLTAGE_SUPPORT_3_3V() volatile
    {
        return CAPABILITIES & (1u << 24u);
    }

    /**
     * Get CAPABILITIES's SUSPEND_RESUME_SUPPORT bit.
     *
     * Suspend / Resume Support
     */
    inline bool get_CAPABILITIES_SUSPEND_RESUME_SUPPORT() volatile
    {
        return CAPABILITIES & (1u << 23u);
    }

    /**
     * Get CAPABILITIES's SDMA_SUPPORT bit.
     *
     * SDMA Support
     */
    inline bool get_CAPABILITIES_SDMA_SUPPORT() volatile
    {
        return CAPABILITIES & (1u << 22u);
    }

    /**
     * Get CAPABILITIES's HIGH_SPEED_SUPPORT bit.
     *
     * High Speed Support
     */
    inline bool get_CAPABILITIES_HIGH_SPEED_SUPPORT() volatile
    {
        return CAPABILITIES & (1u << 21u);
    }

    /**
     * Get CAPABILITIES's ADMA2_SUPPORT bit.
     *
     * ADMA2 Support
     */
    inline bool get_CAPABILITIES_ADMA2_SUPPORT() volatile
    {
        return CAPABILITIES & (1u << 19u);
    }

    /**
     * Get CAPABILITIES's EXT_MEDIA_BUS_SUPPORT bit.
     *
     * Extended Media Bus Support
     */
    inline bool get_CAPABILITIES_EXT_MEDIA_BUS_SUPPORT() volatile
    {
        return CAPABILITIES & (1u << 18u);
    }

    /**
     * Get CAPABILITIES's MAX_BLOCK_LENGTH field.
     *
     * Max Block Length
     */
    inline SDMMC_CAPABILITIES_MAX_BLOCK_LENGTH
    get_CAPABILITIES_MAX_BLOCK_LENGTH() volatile
    {
        return SDMMC_CAPABILITIES_MAX_BLOCK_LENGTH((CAPABILITIES >> 16u) &
                                                   0b11u);
    }

    /**
     * Get CAPABILITIES's BASE_SD_CLOCK_FREQ field.
     *
     * Base Clock Frequency for SD Clock
     */
    inline SDMMC_CAPABILITIES_BASE_SD_CLOCK_FREQ
    get_CAPABILITIES_BASE_SD_CLOCK_FREQ() volatile
    {
        return SDMMC_CAPABILITIES_BASE_SD_CLOCK_FREQ((CAPABILITIES >> 8u) &
                                                     0b11111111u);
    }

    /**
     * Get CAPABILITIES's TIMEOUT_CLOCK_UNIT bit.
     *
     * Timeout Clock Unit
     */
    inline bool get_CAPABILITIES_TIMEOUT_CLOCK_UNIT() volatile
    {
        return CAPABILITIES & (1u << 7u);
    }

    /**
     * Get CAPABILITIES's TIMEOUT_CLOCK_FREQ field.
     *
     * Timeout Clock Frequency
     */
    inline SDMMC_CAPABILITIES_BASE_SD_CLOCK_FREQ
    get_CAPABILITIES_TIMEOUT_CLOCK_FREQ() volatile
    {
        return SDMMC_CAPABILITIES_BASE_SD_CLOCK_FREQ((CAPABILITIES >> 0u) &
                                                     0b111111u);
    }

    /**
     * Get all of CAPABILITIES's bit fields.
     *
     * (read-only) Capabilities Register
     */
    inline void get_CAPABILITIES(
        SDMMC_CAPABILITIES_SLOT_TYPE &SLOT_TYPE, bool &ASYNC_INT_SUPPORT,
        bool &SYSBUS_64_SUPPORT, bool &VOLTAGE_SUPPORT_1_8V,
        bool &VOLTAGE_SUPPORT_3V, bool &VOLTAGE_SUPPORT_3_3V,
        bool &SUSPEND_RESUME_SUPPORT, bool &SDMA_SUPPORT,
        bool &HIGH_SPEED_SUPPORT, bool &ADMA2_SUPPORT,
        bool &EXT_MEDIA_BUS_SUPPORT,
        SDMMC_CAPABILITIES_MAX_BLOCK_LENGTH &MAX_BLOCK_LENGTH,
        SDMMC_CAPABILITIES_BASE_SD_CLOCK_FREQ &BASE_SD_CLOCK_FREQ,
        bool &TIMEOUT_CLOCK_UNIT,
        SDMMC_CAPABILITIES_BASE_SD_CLOCK_FREQ &TIMEOUT_CLOCK_FREQ) volatile
    {
        uint32_t curr = CAPABILITIES;

        SLOT_TYPE = SDMMC_CAPABILITIES_SLOT_TYPE((curr >> 30u) & 0b11u);
        ASYNC_INT_SUPPORT = curr & (1u << 29u);
        SYSBUS_64_SUPPORT = curr & (1u << 28u);
        VOLTAGE_SUPPORT_1_8V = curr & (1u << 26u);
        VOLTAGE_SUPPORT_3V = curr & (1u << 25u);
        VOLTAGE_SUPPORT_3_3V = curr & (1u << 24u);
        SUSPEND_RESUME_SUPPORT = curr & (1u << 23u);
        SDMA_SUPPORT = curr & (1u << 22u);
        HIGH_SPEED_SUPPORT = curr & (1u << 21u);
        ADMA2_SUPPORT = curr & (1u << 19u);
        EXT_MEDIA_BUS_SUPPORT = curr & (1u << 18u);
        MAX_BLOCK_LENGTH =
            SDMMC_CAPABILITIES_MAX_BLOCK_LENGTH((curr >> 16u) & 0b11u);
        BASE_SD_CLOCK_FREQ =
            SDMMC_CAPABILITIES_BASE_SD_CLOCK_FREQ((curr >> 8u) & 0b11111111u);
        TIMEOUT_CLOCK_UNIT = curr & (1u << 7u);
        TIMEOUT_CLOCK_FREQ =
            SDMMC_CAPABILITIES_BASE_SD_CLOCK_FREQ((curr >> 0u) & 0b111111u);
    }

    /**
     * Get CAPABILITIES_HI's CLK_MULT field.
     *
     * Clock Multiplier
     */
    inline SDMMC_CAPABILITIES_HI_CLK_MULT
    get_CAPABILITIES_HI_CLK_MULT() volatile
    {
        return SDMMC_CAPABILITIES_HI_CLK_MULT((CAPABILITIES_HI >> 16u) &
                                              0b11111111u);
    }

    /**
     * Get CAPABILITIES_HI's RE_TUNING_MODES field.
     *
     * Re-tuning modes
     */
    inline SDMMC_CAPABILITIES_HI_RE_TUNING_MODES
    get_CAPABILITIES_HI_RE_TUNING_MODES() volatile
    {
        return SDMMC_CAPABILITIES_HI_RE_TUNING_MODES((CAPABILITIES_HI >> 14u) &
                                                     0b11u);
    }

    /**
     * Get CAPABILITIES_HI's USE_TUNING_SDR50 bit.
     *
     * Use Tuning for SDR50
     */
    inline bool get_CAPABILITIES_HI_USE_TUNING_SDR50() volatile
    {
        return CAPABILITIES_HI & (1u << 13u);
    }

    /**
     * Get CAPABILITIES_HI's TIM_CNT_RETUNE field.
     *
     * Timer count for Re-Tuning
     */
    inline SDMMC_CAPABILITIES_HI_TIM_CNT_RETUNE
    get_CAPABILITIES_HI_TIM_CNT_RETUNE() volatile
    {
        return SDMMC_CAPABILITIES_HI_TIM_CNT_RETUNE((CAPABILITIES_HI >> 8u) &
                                                    0b1111u);
    }

    /**
     * Get CAPABILITIES_HI's DRV_D_SUPPORT bit.
     *
     * Driver Type D Support
     */
    inline bool get_CAPABILITIES_HI_DRV_D_SUPPORT() volatile
    {
        return CAPABILITIES_HI & (1u << 6u);
    }

    /**
     * Get CAPABILITIES_HI's DRV_C_SUPPORT bit.
     *
     * Driver Type C Support
     */
    inline bool get_CAPABILITIES_HI_DRV_C_SUPPORT() volatile
    {
        return CAPABILITIES_HI & (1u << 5u);
    }

    /**
     * Get CAPABILITIES_HI's DRV_A_SUPPORT bit.
     *
     * Driver Type A Support
     */
    inline bool get_CAPABILITIES_HI_DRV_A_SUPPORT() volatile
    {
        return CAPABILITIES_HI & (1u << 4u);
    }

    /**
     * Get CAPABILITIES_HI's DDR50_SUPPORT bit.
     *
     * DDR50 Support
     */
    inline bool get_CAPABILITIES_HI_DDR50_SUPPORT() volatile
    {
        return CAPABILITIES_HI & (1u << 2u);
    }

    /**
     * Get CAPABILITIES_HI's SDR104_SUPPORT bit.
     *
     * SDR104 Support
     */
    inline bool get_CAPABILITIES_HI_SDR104_SUPPORT() volatile
    {
        return CAPABILITIES_HI & (1u << 1u);
    }

    /**
     * Get CAPABILITIES_HI's SDR50_SUPPORT bit.
     *
     * SDR50 Support
     */
    inline bool get_CAPABILITIES_HI_SDR50_SUPPORT() volatile
    {
        return CAPABILITIES_HI & (1u << 0u);
    }

    /**
     * Get all of CAPABILITIES_HI's bit fields.
     *
     * (read-only) Capabilities Register High
     */
    inline void get_CAPABILITIES_HI(
        SDMMC_CAPABILITIES_HI_CLK_MULT &CLK_MULT,
        SDMMC_CAPABILITIES_HI_RE_TUNING_MODES &RE_TUNING_MODES,
        bool &USE_TUNING_SDR50,
        SDMMC_CAPABILITIES_HI_TIM_CNT_RETUNE &TIM_CNT_RETUNE,
        bool &DRV_D_SUPPORT, bool &DRV_C_SUPPORT, bool &DRV_A_SUPPORT,
        bool &DDR50_SUPPORT, bool &SDR104_SUPPORT,
        bool &SDR50_SUPPORT) volatile
    {
        uint32_t curr = CAPABILITIES_HI;

        CLK_MULT = SDMMC_CAPABILITIES_HI_CLK_MULT((curr >> 16u) & 0b11111111u);
        RE_TUNING_MODES =
            SDMMC_CAPABILITIES_HI_RE_TUNING_MODES((curr >> 14u) & 0b11u);
        USE_TUNING_SDR50 = curr & (1u << 13u);
        TIM_CNT_RETUNE =
            SDMMC_CAPABILITIES_HI_TIM_CNT_RETUNE((curr >> 8u) & 0b1111u);
        DRV_D_SUPPORT = curr & (1u << 6u);
        DRV_C_SUPPORT = curr & (1u << 5u);
        DRV_A_SUPPORT = curr & (1u << 4u);
        DDR50_SUPPORT = curr & (1u << 2u);
        SDR104_SUPPORT = curr & (1u << 1u);
        SDR50_SUPPORT = curr & (1u << 0u);
    }

    /**
     * Get MAX_CURRENT_CAP's MAX_CURRENT_FOR_3_3V field.
     *
     * Maximum Current for 3.3V
     */
    inline uint8_t get_MAX_CURRENT_CAP_MAX_CURRENT_FOR_3_3V() volatile
    {
        return (MAX_CURRENT_CAP >> 0u) & 0b11111111u;
    }

    /**
     * Set FORCE_EVENT_ACMD_ERR_STATUS's FE_ACMD_NOT_EXEC bit.
     *
     * Force Event for Auto CMD12 NOT Executed
     */
    inline void set_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD_NOT_EXEC() volatile
    {
        FORCE_EVENT_ACMD_ERR_STATUS |= 1u << 0u;
    }

    /**
     * Clear FORCE_EVENT_ACMD_ERR_STATUS's FE_ACMD_NOT_EXEC bit.
     *
     * Force Event for Auto CMD12 NOT Executed
     */
    inline void clear_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD_NOT_EXEC() volatile
    {
        FORCE_EVENT_ACMD_ERR_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle FORCE_EVENT_ACMD_ERR_STATUS's FE_ACMD_NOT_EXEC bit.
     *
     * Force Event for Auto CMD12 NOT Executed
     */
    inline void toggle_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD_NOT_EXEC() volatile
    {
        FORCE_EVENT_ACMD_ERR_STATUS ^= 1u << 0u;
    }

    /**
     * Set FORCE_EVENT_ACMD_ERR_STATUS's FE_ACMD_TIMEOUT_ERR bit.
     *
     * Force Event for Auto CMD timeout Error
     */
    inline void set_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD_TIMEOUT_ERR() volatile
    {
        FORCE_EVENT_ACMD_ERR_STATUS |= 1u << 1u;
    }

    /**
     * Clear FORCE_EVENT_ACMD_ERR_STATUS's FE_ACMD_TIMEOUT_ERR bit.
     *
     * Force Event for Auto CMD timeout Error
     */
    inline void
    clear_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD_TIMEOUT_ERR() volatile
    {
        FORCE_EVENT_ACMD_ERR_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle FORCE_EVENT_ACMD_ERR_STATUS's FE_ACMD_TIMEOUT_ERR bit.
     *
     * Force Event for Auto CMD timeout Error
     */
    inline void
    toggle_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD_TIMEOUT_ERR() volatile
    {
        FORCE_EVENT_ACMD_ERR_STATUS ^= 1u << 1u;
    }

    /**
     * Set FORCE_EVENT_ACMD_ERR_STATUS's FE_ACMD_CRC_ERR bit.
     *
     * Force Event for Auto CMD CRC Error
     */
    inline void set_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD_CRC_ERR() volatile
    {
        FORCE_EVENT_ACMD_ERR_STATUS |= 1u << 2u;
    }

    /**
     * Clear FORCE_EVENT_ACMD_ERR_STATUS's FE_ACMD_CRC_ERR bit.
     *
     * Force Event for Auto CMD CRC Error
     */
    inline void clear_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD_CRC_ERR() volatile
    {
        FORCE_EVENT_ACMD_ERR_STATUS &= ~(1u << 2u);
    }

    /**
     * Toggle FORCE_EVENT_ACMD_ERR_STATUS's FE_ACMD_CRC_ERR bit.
     *
     * Force Event for Auto CMD CRC Error
     */
    inline void toggle_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD_CRC_ERR() volatile
    {
        FORCE_EVENT_ACMD_ERR_STATUS ^= 1u << 2u;
    }

    /**
     * Set FORCE_EVENT_ACMD_ERR_STATUS's FE_ACMD_END_BIT_ERR bit.
     *
     * Force Event for Auto CMD End bit Error
     */
    inline void set_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD_END_BIT_ERR() volatile
    {
        FORCE_EVENT_ACMD_ERR_STATUS |= 1u << 3u;
    }

    /**
     * Clear FORCE_EVENT_ACMD_ERR_STATUS's FE_ACMD_END_BIT_ERR bit.
     *
     * Force Event for Auto CMD End bit Error
     */
    inline void
    clear_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD_END_BIT_ERR() volatile
    {
        FORCE_EVENT_ACMD_ERR_STATUS &= ~(1u << 3u);
    }

    /**
     * Toggle FORCE_EVENT_ACMD_ERR_STATUS's FE_ACMD_END_BIT_ERR bit.
     *
     * Force Event for Auto CMD End bit Error
     */
    inline void
    toggle_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD_END_BIT_ERR() volatile
    {
        FORCE_EVENT_ACMD_ERR_STATUS ^= 1u << 3u;
    }

    /**
     * Set FORCE_EVENT_ACMD_ERR_STATUS's FE_ACMD_IND_ERR bit.
     *
     * Force Event for Auto CMD Index Error
     */
    inline void set_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD_IND_ERR() volatile
    {
        FORCE_EVENT_ACMD_ERR_STATUS |= 1u << 4u;
    }

    /**
     * Clear FORCE_EVENT_ACMD_ERR_STATUS's FE_ACMD_IND_ERR bit.
     *
     * Force Event for Auto CMD Index Error
     */
    inline void clear_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD_IND_ERR() volatile
    {
        FORCE_EVENT_ACMD_ERR_STATUS &= ~(1u << 4u);
    }

    /**
     * Toggle FORCE_EVENT_ACMD_ERR_STATUS's FE_ACMD_IND_ERR bit.
     *
     * Force Event for Auto CMD Index Error
     */
    inline void toggle_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD_IND_ERR() volatile
    {
        FORCE_EVENT_ACMD_ERR_STATUS ^= 1u << 4u;
    }

    /**
     * Set FORCE_EVENT_ACMD_ERR_STATUS's FE_CMD_NOT_ISSUED_ACMD12_ERR bit.
     *
     * Force Event for CMD not issued by Auto CMD12 Error
     */
    inline void
    set_FORCE_EVENT_ACMD_ERR_STATUS_FE_CMD_NOT_ISSUED_ACMD12_ERR() volatile
    {
        FORCE_EVENT_ACMD_ERR_STATUS |= 1u << 7u;
    }

    /**
     * Clear FORCE_EVENT_ACMD_ERR_STATUS's FE_CMD_NOT_ISSUED_ACMD12_ERR bit.
     *
     * Force Event for CMD not issued by Auto CMD12 Error
     */
    inline void
    clear_FORCE_EVENT_ACMD_ERR_STATUS_FE_CMD_NOT_ISSUED_ACMD12_ERR() volatile
    {
        FORCE_EVENT_ACMD_ERR_STATUS &= ~(1u << 7u);
    }

    /**
     * Toggle FORCE_EVENT_ACMD_ERR_STATUS's FE_CMD_NOT_ISSUED_ACMD12_ERR bit.
     *
     * Force Event for CMD not issued by Auto CMD12 Error
     */
    inline void
    toggle_FORCE_EVENT_ACMD_ERR_STATUS_FE_CMD_NOT_ISSUED_ACMD12_ERR() volatile
    {
        FORCE_EVENT_ACMD_ERR_STATUS ^= 1u << 7u;
    }

    /**
     * Set all of FORCE_EVENT_ACMD_ERR_STATUS's bit fields.
     *
     * (write-only) Force Event Register for Auto CMD Error Status
     */
    inline void set_FORCE_EVENT_ACMD_ERR_STATUS(
        bool FE_ACMD_NOT_EXEC, bool FE_ACMD_TIMEOUT_ERR, bool FE_ACMD_CRC_ERR,
        bool FE_ACMD_END_BIT_ERR, bool FE_ACMD_IND_ERR,
        bool FE_CMD_NOT_ISSUED_ACMD12_ERR) volatile
    {
        uint16_t curr = FORCE_EVENT_ACMD_ERR_STATUS;

        curr &= ~(0b1u << 0u);
        curr |= (FE_ACMD_NOT_EXEC & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (FE_ACMD_TIMEOUT_ERR & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (FE_ACMD_CRC_ERR & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (FE_ACMD_END_BIT_ERR & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (FE_ACMD_IND_ERR & 0b1u) << 4u;
        curr &= ~(0b1u << 7u);
        curr |= (FE_CMD_NOT_ISSUED_ACMD12_ERR & 0b1u) << 7u;

        FORCE_EVENT_ACMD_ERR_STATUS = curr;
    }

    /**
     * Set FORCE_EVENT_ERR_STATUS's FE_CMD_TIMEOUT_ERR bit.
     *
     * Force Event for Command Timeout Error
     */
    inline void set_FORCE_EVENT_ERR_STATUS_FE_CMD_TIMEOUT_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS |= 1u << 0u;
    }

    /**
     * Clear FORCE_EVENT_ERR_STATUS's FE_CMD_TIMEOUT_ERR bit.
     *
     * Force Event for Command Timeout Error
     */
    inline void clear_FORCE_EVENT_ERR_STATUS_FE_CMD_TIMEOUT_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle FORCE_EVENT_ERR_STATUS's FE_CMD_TIMEOUT_ERR bit.
     *
     * Force Event for Command Timeout Error
     */
    inline void toggle_FORCE_EVENT_ERR_STATUS_FE_CMD_TIMEOUT_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS ^= 1u << 0u;
    }

    /**
     * Set FORCE_EVENT_ERR_STATUS's FE_CMD_CRC_ERR bit.
     *
     * Force Event for Command CRC Error
     */
    inline void set_FORCE_EVENT_ERR_STATUS_FE_CMD_CRC_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS |= 1u << 1u;
    }

    /**
     * Clear FORCE_EVENT_ERR_STATUS's FE_CMD_CRC_ERR bit.
     *
     * Force Event for Command CRC Error
     */
    inline void clear_FORCE_EVENT_ERR_STATUS_FE_CMD_CRC_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle FORCE_EVENT_ERR_STATUS's FE_CMD_CRC_ERR bit.
     *
     * Force Event for Command CRC Error
     */
    inline void toggle_FORCE_EVENT_ERR_STATUS_FE_CMD_CRC_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS ^= 1u << 1u;
    }

    /**
     * Set FORCE_EVENT_ERR_STATUS's FE_CMD_END_BIT_ERR bit.
     *
     * Force Event for Command End Bit Error
     */
    inline void set_FORCE_EVENT_ERR_STATUS_FE_CMD_END_BIT_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS |= 1u << 2u;
    }

    /**
     * Clear FORCE_EVENT_ERR_STATUS's FE_CMD_END_BIT_ERR bit.
     *
     * Force Event for Command End Bit Error
     */
    inline void clear_FORCE_EVENT_ERR_STATUS_FE_CMD_END_BIT_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS &= ~(1u << 2u);
    }

    /**
     * Toggle FORCE_EVENT_ERR_STATUS's FE_CMD_END_BIT_ERR bit.
     *
     * Force Event for Command End Bit Error
     */
    inline void toggle_FORCE_EVENT_ERR_STATUS_FE_CMD_END_BIT_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS ^= 1u << 2u;
    }

    /**
     * Set FORCE_EVENT_ERR_STATUS's FE_CMD_IND_ERR bit.
     *
     * Force Event for Command Index Error
     */
    inline void set_FORCE_EVENT_ERR_STATUS_FE_CMD_IND_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS |= 1u << 3u;
    }

    /**
     * Clear FORCE_EVENT_ERR_STATUS's FE_CMD_IND_ERR bit.
     *
     * Force Event for Command Index Error
     */
    inline void clear_FORCE_EVENT_ERR_STATUS_FE_CMD_IND_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS &= ~(1u << 3u);
    }

    /**
     * Toggle FORCE_EVENT_ERR_STATUS's FE_CMD_IND_ERR bit.
     *
     * Force Event for Command Index Error
     */
    inline void toggle_FORCE_EVENT_ERR_STATUS_FE_CMD_IND_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS ^= 1u << 3u;
    }

    /**
     * Set FORCE_EVENT_ERR_STATUS's FE_DATA_TIMEOUT_ERR bit.
     *
     * Force Event for Data Timeout Error
     */
    inline void set_FORCE_EVENT_ERR_STATUS_FE_DATA_TIMEOUT_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS |= 1u << 4u;
    }

    /**
     * Clear FORCE_EVENT_ERR_STATUS's FE_DATA_TIMEOUT_ERR bit.
     *
     * Force Event for Data Timeout Error
     */
    inline void clear_FORCE_EVENT_ERR_STATUS_FE_DATA_TIMEOUT_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS &= ~(1u << 4u);
    }

    /**
     * Toggle FORCE_EVENT_ERR_STATUS's FE_DATA_TIMEOUT_ERR bit.
     *
     * Force Event for Data Timeout Error
     */
    inline void toggle_FORCE_EVENT_ERR_STATUS_FE_DATA_TIMEOUT_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS ^= 1u << 4u;
    }

    /**
     * Set FORCE_EVENT_ERR_STATUS's FE_DATA_CRC_ERR bit.
     *
     * Force Event for Data CRC Error
     */
    inline void set_FORCE_EVENT_ERR_STATUS_FE_DATA_CRC_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS |= 1u << 5u;
    }

    /**
     * Clear FORCE_EVENT_ERR_STATUS's FE_DATA_CRC_ERR bit.
     *
     * Force Event for Data CRC Error
     */
    inline void clear_FORCE_EVENT_ERR_STATUS_FE_DATA_CRC_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS &= ~(1u << 5u);
    }

    /**
     * Toggle FORCE_EVENT_ERR_STATUS's FE_DATA_CRC_ERR bit.
     *
     * Force Event for Data CRC Error
     */
    inline void toggle_FORCE_EVENT_ERR_STATUS_FE_DATA_CRC_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS ^= 1u << 5u;
    }

    /**
     * Set FORCE_EVENT_ERR_STATUS's FE_DATA_END_BIT_ERR bit.
     *
     * Force Event for Data End Bit Error
     */
    inline void set_FORCE_EVENT_ERR_STATUS_FE_DATA_END_BIT_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS |= 1u << 6u;
    }

    /**
     * Clear FORCE_EVENT_ERR_STATUS's FE_DATA_END_BIT_ERR bit.
     *
     * Force Event for Data End Bit Error
     */
    inline void clear_FORCE_EVENT_ERR_STATUS_FE_DATA_END_BIT_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS &= ~(1u << 6u);
    }

    /**
     * Toggle FORCE_EVENT_ERR_STATUS's FE_DATA_END_BIT_ERR bit.
     *
     * Force Event for Data End Bit Error
     */
    inline void toggle_FORCE_EVENT_ERR_STATUS_FE_DATA_END_BIT_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS ^= 1u << 6u;
    }

    /**
     * Set FORCE_EVENT_ERR_STATUS's FE_CURRENT_LIMIT_ERR bit.
     *
     * Force Event for Current Limit Error
     */
    inline void set_FORCE_EVENT_ERR_STATUS_FE_CURRENT_LIMIT_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS |= 1u << 7u;
    }

    /**
     * Clear FORCE_EVENT_ERR_STATUS's FE_CURRENT_LIMIT_ERR bit.
     *
     * Force Event for Current Limit Error
     */
    inline void clear_FORCE_EVENT_ERR_STATUS_FE_CURRENT_LIMIT_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS &= ~(1u << 7u);
    }

    /**
     * Toggle FORCE_EVENT_ERR_STATUS's FE_CURRENT_LIMIT_ERR bit.
     *
     * Force Event for Current Limit Error
     */
    inline void toggle_FORCE_EVENT_ERR_STATUS_FE_CURRENT_LIMIT_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS ^= 1u << 7u;
    }

    /**
     * Set FORCE_EVENT_ERR_STATUS's FE_ACMD12_ERR bit.
     *
     * Force Event for Auto CMD Error
     */
    inline void set_FORCE_EVENT_ERR_STATUS_FE_ACMD12_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS |= 1u << 8u;
    }

    /**
     * Clear FORCE_EVENT_ERR_STATUS's FE_ACMD12_ERR bit.
     *
     * Force Event for Auto CMD Error
     */
    inline void clear_FORCE_EVENT_ERR_STATUS_FE_ACMD12_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS &= ~(1u << 8u);
    }

    /**
     * Toggle FORCE_EVENT_ERR_STATUS's FE_ACMD12_ERR bit.
     *
     * Force Event for Auto CMD Error
     */
    inline void toggle_FORCE_EVENT_ERR_STATUS_FE_ACMD12_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS ^= 1u << 8u;
    }

    /**
     * Set FORCE_EVENT_ERR_STATUS's FE_TARGET_RESPONSE_ERR bit.
     *
     * Force event for Target Response Error
     */
    inline void set_FORCE_EVENT_ERR_STATUS_FE_TARGET_RESPONSE_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS |= 1u << 12u;
    }

    /**
     * Clear FORCE_EVENT_ERR_STATUS's FE_TARGET_RESPONSE_ERR bit.
     *
     * Force event for Target Response Error
     */
    inline void clear_FORCE_EVENT_ERR_STATUS_FE_TARGET_RESPONSE_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS &= ~(1u << 12u);
    }

    /**
     * Toggle FORCE_EVENT_ERR_STATUS's FE_TARGET_RESPONSE_ERR bit.
     *
     * Force event for Target Response Error
     */
    inline void toggle_FORCE_EVENT_ERR_STATUS_FE_TARGET_RESPONSE_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS ^= 1u << 12u;
    }

    /**
     * Set FORCE_EVENT_ERR_STATUS's FE_CEATA_ERR bit.
     *
     * Force Event for Ceata Error
     */
    inline void set_FORCE_EVENT_ERR_STATUS_FE_CEATA_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS |= 1u << 13u;
    }

    /**
     * Clear FORCE_EVENT_ERR_STATUS's FE_CEATA_ERR bit.
     *
     * Force Event for Ceata Error
     */
    inline void clear_FORCE_EVENT_ERR_STATUS_FE_CEATA_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS &= ~(1u << 13u);
    }

    /**
     * Toggle FORCE_EVENT_ERR_STATUS's FE_CEATA_ERR bit.
     *
     * Force Event for Ceata Error
     */
    inline void toggle_FORCE_EVENT_ERR_STATUS_FE_CEATA_ERR() volatile
    {
        FORCE_EVENT_ERR_STATUS ^= 1u << 13u;
    }

    /**
     * Set all of FORCE_EVENT_ERR_STATUS's bit fields.
     *
     * (write-only) Force Event Register for Error Interrupt Status
     */
    inline void set_FORCE_EVENT_ERR_STATUS(
        bool FE_CMD_TIMEOUT_ERR, bool FE_CMD_CRC_ERR, bool FE_CMD_END_BIT_ERR,
        bool FE_CMD_IND_ERR, bool FE_DATA_TIMEOUT_ERR, bool FE_DATA_CRC_ERR,
        bool FE_DATA_END_BIT_ERR, bool FE_CURRENT_LIMIT_ERR,
        bool FE_ACMD12_ERR, bool FE_TARGET_RESPONSE_ERR,
        bool FE_CEATA_ERR) volatile
    {
        uint16_t curr = FORCE_EVENT_ERR_STATUS;

        curr &= ~(0b1u << 0u);
        curr |= (FE_CMD_TIMEOUT_ERR & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (FE_CMD_CRC_ERR & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (FE_CMD_END_BIT_ERR & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (FE_CMD_IND_ERR & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (FE_DATA_TIMEOUT_ERR & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (FE_DATA_CRC_ERR & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (FE_DATA_END_BIT_ERR & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (FE_CURRENT_LIMIT_ERR & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (FE_ACMD12_ERR & 0b1u) << 8u;
        curr &= ~(0b1u << 12u);
        curr |= (FE_TARGET_RESPONSE_ERR & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (FE_CEATA_ERR & 0b1u) << 13u;

        FORCE_EVENT_ERR_STATUS = curr;
    }

    /**
     * Set DEBUG_SEL's DEBUG_SEL bit.
     *
     * Debug_sel
     */
    inline void set_DEBUG_SEL_DEBUG_SEL() volatile
    {
        DEBUG_SEL |= 1u << 0u;
    }

    /**
     * Clear DEBUG_SEL's DEBUG_SEL bit.
     *
     * Debug_sel
     */
    inline void clear_DEBUG_SEL_DEBUG_SEL() volatile
    {
        DEBUG_SEL &= ~(1u << 0u);
    }

    /**
     * Toggle DEBUG_SEL's DEBUG_SEL bit.
     *
     * Debug_sel
     */
    inline void toggle_DEBUG_SEL_DEBUG_SEL() volatile
    {
        DEBUG_SEL ^= 1u << 0u;
    }

    /**
     * Get SLOT_INT_STATUS's SLOT_INT_STATUS field.
     *
     * Interrupt Signal for Card Slot
     */
    inline SDMMC_SLOT_INT_STATUS_SLOT_INT_STATUS
    get_SLOT_INT_STATUS_SLOT_INT_STATUS() volatile
    {
        return SDMMC_SLOT_INT_STATUS_SLOT_INT_STATUS((SLOT_INT_STATUS >> 0u) &
                                                     0b11111111u);
    }
};

static_assert(sizeof(sdmmc) == sdmmc::size);

static volatile sdmmc *const SDMMC = reinterpret_cast<sdmmc *>(0x4801C000);

}; // namespace XMC4700
