/**
 * \file
 * \brief Generated by ifgen (3.2.0).
 */
#pragma once

#include "../enums/FLASH0_FCON_WSPFLASH.h"
#include "../enums/FLASH0_MARP_MARGIN.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * Flash Memory Controller
 */
struct [[gnu::packed]] flash0
{
    /* Constant attributes. */
    static constexpr std::size_t size = 4140; /*!< flash0's size in bytes. */

    /* Fields. */
    static constexpr std::size_t reserved_padding0_length = 1026;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    const uint32_t ID =
        {}; /*!< (read-only) Flash Module Identification Register */
    const uint32_t reserved_padding1 = {};
    const uint32_t FSR = {}; /*!< (read-only) Flash Status Register */
    uint32_t FCON;           /*!< (read-write) Flash Configuration Register */
    uint32_t MARP; /*!< (read-write) Margin Control Register PFLASH */
    const uint32_t reserved_padding2 = {};
    const uint32_t PROCON0 =
        {}; /*!< (read-only) Flash Protection Configuration Register User 0 */
    const uint32_t PROCON1 =
        {}; /*!< (read-only) Flash Protection Configuration Register User 1 */
    const uint32_t PROCON2 =
        {}; /*!< (read-only) Flash Protection Configuration Register User 2 */

    /* Methods. */

    /**
     * Get ID's MOD_NUMBER field.
     *
     * Module Number Value
     */
    inline uint16_t get_ID_MOD_NUMBER() volatile
    {
        return (ID >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get ID's MOD_TYPE field.
     *
     * Module Type
     */
    inline uint8_t get_ID_MOD_TYPE() volatile
    {
        return (ID >> 8u) & 0b11111111u;
    }

    /**
     * Get ID's MOD_REV field.
     *
     * Module Revision Number
     */
    inline uint8_t get_ID_MOD_REV() volatile
    {
        return (ID >> 0u) & 0b11111111u;
    }

    /**
     * Get all of ID's bit fields.
     *
     * (read-only) Flash Module Identification Register
     */
    inline void get_ID(uint16_t &MOD_NUMBER, uint8_t &MOD_TYPE,
                       uint8_t &MOD_REV) volatile
    {
        uint32_t curr = ID;

        MOD_NUMBER = (curr >> 16u) & 0b1111111111111111u;
        MOD_TYPE = (curr >> 8u) & 0b11111111u;
        MOD_REV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get FSR's VER bit.
     *
     * Verify Error
     */
    inline bool get_FSR_VER() volatile
    {
        return FSR & (1u << 31u);
    }

    /**
     * Get FSR's SLM bit.
     *
     * Flash Sleep Mode
     */
    inline bool get_FSR_SLM() volatile
    {
        return FSR & (1u << 28u);
    }

    /**
     * Get FSR's WPRODIS1 bit.
     *
     * Sector Write Protection Disabled for User 1
     */
    inline bool get_FSR_WPRODIS1() volatile
    {
        return FSR & (1u << 26u);
    }

    /**
     * Get FSR's WPRODIS0 bit.
     *
     * Sector Write Protection Disabled for User 0
     */
    inline bool get_FSR_WPRODIS0() volatile
    {
        return FSR & (1u << 25u);
    }

    /**
     * Get FSR's WPROIN2 bit.
     *
     * Sector OTP Protection Installed for User 2
     */
    inline bool get_FSR_WPROIN2() volatile
    {
        return FSR & (1u << 23u);
    }

    /**
     * Get FSR's WPROIN1 bit.
     *
     * Sector Write Protection Installed for User 1
     */
    inline bool get_FSR_WPROIN1() volatile
    {
        return FSR & (1u << 22u);
    }

    /**
     * Get FSR's WPROIN0 bit.
     *
     * Sector Write Protection Installed for User 0
     */
    inline bool get_FSR_WPROIN0() volatile
    {
        return FSR & (1u << 21u);
    }

    /**
     * Get FSR's RPRODIS bit.
     *
     * Read Protection Disable State
     */
    inline bool get_FSR_RPRODIS() volatile
    {
        return FSR & (1u << 19u);
    }

    /**
     * Get FSR's RPROIN bit.
     *
     * Read Protection Installed
     */
    inline bool get_FSR_RPROIN() volatile
    {
        return FSR & (1u << 18u);
    }

    /**
     * Get FSR's PROIN bit.
     *
     * Protection Installed
     */
    inline bool get_FSR_PROIN() volatile
    {
        return FSR & (1u << 16u);
    }

    /**
     * Get FSR's PFDBER bit.
     *
     * PFLASH Double-Bit Error
     */
    inline bool get_FSR_PFDBER() volatile
    {
        return FSR & (1u << 14u);
    }

    /**
     * Get FSR's PFSBER bit.
     *
     * PFLASH Single-Bit Error and Correction
     */
    inline bool get_FSR_PFSBER() volatile
    {
        return FSR & (1u << 12u);
    }

    /**
     * Get FSR's PROER bit.
     *
     * Protection Error
     */
    inline bool get_FSR_PROER() volatile
    {
        return FSR & (1u << 11u);
    }

    /**
     * Get FSR's SQER bit.
     *
     * Command Sequence Error
     */
    inline bool get_FSR_SQER() volatile
    {
        return FSR & (1u << 10u);
    }

    /**
     * Get FSR's PFOPER bit.
     *
     * Program Flash Operation Error
     */
    inline bool get_FSR_PFOPER() volatile
    {
        return FSR & (1u << 8u);
    }

    /**
     * Get FSR's PFPAGE bit.
     *
     * Program Flash in Page Mode
     */
    inline bool get_FSR_PFPAGE() volatile
    {
        return FSR & (1u << 6u);
    }

    /**
     * Get FSR's ERASE bit.
     *
     * Erase State
     */
    inline bool get_FSR_ERASE() volatile
    {
        return FSR & (1u << 5u);
    }

    /**
     * Get FSR's PROG bit.
     *
     * Programming State
     */
    inline bool get_FSR_PROG() volatile
    {
        return FSR & (1u << 4u);
    }

    /**
     * Get FSR's FABUSY bit.
     *
     * Flash Array Busy
     */
    inline bool get_FSR_FABUSY() volatile
    {
        return FSR & (1u << 1u);
    }

    /**
     * Get FSR's PBUSY bit.
     *
     * Program Flash Busy
     */
    inline bool get_FSR_PBUSY() volatile
    {
        return FSR & (1u << 0u);
    }

    /**
     * Get all of FSR's bit fields.
     *
     * (read-only) Flash Status Register
     */
    inline void get_FSR(bool &VER, bool &SLM, bool &WPRODIS1, bool &WPRODIS0,
                        bool &WPROIN2, bool &WPROIN1, bool &WPROIN0,
                        bool &RPRODIS, bool &RPROIN, bool &PROIN, bool &PFDBER,
                        bool &PFSBER, bool &PROER, bool &SQER, bool &PFOPER,
                        bool &PFPAGE, bool &ERASE, bool &PROG, bool &FABUSY,
                        bool &PBUSY) volatile
    {
        uint32_t curr = FSR;

        VER = curr & (1u << 31u);
        SLM = curr & (1u << 28u);
        WPRODIS1 = curr & (1u << 26u);
        WPRODIS0 = curr & (1u << 25u);
        WPROIN2 = curr & (1u << 23u);
        WPROIN1 = curr & (1u << 22u);
        WPROIN0 = curr & (1u << 21u);
        RPRODIS = curr & (1u << 19u);
        RPROIN = curr & (1u << 18u);
        PROIN = curr & (1u << 16u);
        PFDBER = curr & (1u << 14u);
        PFSBER = curr & (1u << 12u);
        PROER = curr & (1u << 11u);
        SQER = curr & (1u << 10u);
        PFOPER = curr & (1u << 8u);
        PFPAGE = curr & (1u << 6u);
        ERASE = curr & (1u << 5u);
        PROG = curr & (1u << 4u);
        FABUSY = curr & (1u << 1u);
        PBUSY = curr & (1u << 0u);
    }

    /**
     * Get FCON's EOBM bit.
     *
     * End of Busy Interrupt Mask
     */
    inline bool get_FCON_EOBM() volatile
    {
        return FCON & (1u << 31u);
    }

    /**
     * Set FCON's EOBM bit.
     *
     * End of Busy Interrupt Mask
     */
    inline void set_FCON_EOBM() volatile
    {
        FCON |= 1u << 31u;
    }

    /**
     * Clear FCON's EOBM bit.
     *
     * End of Busy Interrupt Mask
     */
    inline void clear_FCON_EOBM() volatile
    {
        FCON &= ~(1u << 31u);
    }

    /**
     * Toggle FCON's EOBM bit.
     *
     * End of Busy Interrupt Mask
     */
    inline void toggle_FCON_EOBM() volatile
    {
        FCON ^= 1u << 31u;
    }

    /**
     * Get FCON's PFDBERM bit.
     *
     * PFLASH Double-Bit Error Interrupt Mask
     */
    inline bool get_FCON_PFDBERM() volatile
    {
        return FCON & (1u << 29u);
    }

    /**
     * Set FCON's PFDBERM bit.
     *
     * PFLASH Double-Bit Error Interrupt Mask
     */
    inline void set_FCON_PFDBERM() volatile
    {
        FCON |= 1u << 29u;
    }

    /**
     * Clear FCON's PFDBERM bit.
     *
     * PFLASH Double-Bit Error Interrupt Mask
     */
    inline void clear_FCON_PFDBERM() volatile
    {
        FCON &= ~(1u << 29u);
    }

    /**
     * Toggle FCON's PFDBERM bit.
     *
     * PFLASH Double-Bit Error Interrupt Mask
     */
    inline void toggle_FCON_PFDBERM() volatile
    {
        FCON ^= 1u << 29u;
    }

    /**
     * Get FCON's PFSBERM bit.
     *
     * PFLASH Single-Bit Error Interrupt Mask
     */
    inline bool get_FCON_PFSBERM() volatile
    {
        return FCON & (1u << 27u);
    }

    /**
     * Set FCON's PFSBERM bit.
     *
     * PFLASH Single-Bit Error Interrupt Mask
     */
    inline void set_FCON_PFSBERM() volatile
    {
        FCON |= 1u << 27u;
    }

    /**
     * Clear FCON's PFSBERM bit.
     *
     * PFLASH Single-Bit Error Interrupt Mask
     */
    inline void clear_FCON_PFSBERM() volatile
    {
        FCON &= ~(1u << 27u);
    }

    /**
     * Toggle FCON's PFSBERM bit.
     *
     * PFLASH Single-Bit Error Interrupt Mask
     */
    inline void toggle_FCON_PFSBERM() volatile
    {
        FCON ^= 1u << 27u;
    }

    /**
     * Get FCON's PROERM bit.
     *
     * Protection Error Interrupt Mask
     */
    inline bool get_FCON_PROERM() volatile
    {
        return FCON & (1u << 26u);
    }

    /**
     * Set FCON's PROERM bit.
     *
     * Protection Error Interrupt Mask
     */
    inline void set_FCON_PROERM() volatile
    {
        FCON |= 1u << 26u;
    }

    /**
     * Clear FCON's PROERM bit.
     *
     * Protection Error Interrupt Mask
     */
    inline void clear_FCON_PROERM() volatile
    {
        FCON &= ~(1u << 26u);
    }

    /**
     * Toggle FCON's PROERM bit.
     *
     * Protection Error Interrupt Mask
     */
    inline void toggle_FCON_PROERM() volatile
    {
        FCON ^= 1u << 26u;
    }

    /**
     * Get FCON's SQERM bit.
     *
     * Command Sequence Error Interrupt Mask
     */
    inline bool get_FCON_SQERM() volatile
    {
        return FCON & (1u << 25u);
    }

    /**
     * Set FCON's SQERM bit.
     *
     * Command Sequence Error Interrupt Mask
     */
    inline void set_FCON_SQERM() volatile
    {
        FCON |= 1u << 25u;
    }

    /**
     * Clear FCON's SQERM bit.
     *
     * Command Sequence Error Interrupt Mask
     */
    inline void clear_FCON_SQERM() volatile
    {
        FCON &= ~(1u << 25u);
    }

    /**
     * Toggle FCON's SQERM bit.
     *
     * Command Sequence Error Interrupt Mask
     */
    inline void toggle_FCON_SQERM() volatile
    {
        FCON ^= 1u << 25u;
    }

    /**
     * Get FCON's VOPERM bit.
     *
     * Verify and Operation Error Interrupt Mask
     */
    inline bool get_FCON_VOPERM() volatile
    {
        return FCON & (1u << 24u);
    }

    /**
     * Set FCON's VOPERM bit.
     *
     * Verify and Operation Error Interrupt Mask
     */
    inline void set_FCON_VOPERM() volatile
    {
        FCON |= 1u << 24u;
    }

    /**
     * Clear FCON's VOPERM bit.
     *
     * Verify and Operation Error Interrupt Mask
     */
    inline void clear_FCON_VOPERM() volatile
    {
        FCON &= ~(1u << 24u);
    }

    /**
     * Toggle FCON's VOPERM bit.
     *
     * Verify and Operation Error Interrupt Mask
     */
    inline void toggle_FCON_VOPERM() volatile
    {
        FCON ^= 1u << 24u;
    }

    /**
     * Get FCON's DDF bit.
     *
     * Disable Any Data Fetch from Flash
     */
    inline bool get_FCON_DDF() volatile
    {
        return FCON & (1u << 18u);
    }

    /**
     * Set FCON's DDF bit.
     *
     * Disable Any Data Fetch from Flash
     */
    inline void set_FCON_DDF() volatile
    {
        FCON |= 1u << 18u;
    }

    /**
     * Clear FCON's DDF bit.
     *
     * Disable Any Data Fetch from Flash
     */
    inline void clear_FCON_DDF() volatile
    {
        FCON &= ~(1u << 18u);
    }

    /**
     * Toggle FCON's DDF bit.
     *
     * Disable Any Data Fetch from Flash
     */
    inline void toggle_FCON_DDF() volatile
    {
        FCON ^= 1u << 18u;
    }

    /**
     * Get FCON's DCF bit.
     *
     * Disable Code Fetch from Flash Memory
     */
    inline bool get_FCON_DCF() volatile
    {
        return FCON & (1u << 17u);
    }

    /**
     * Set FCON's DCF bit.
     *
     * Disable Code Fetch from Flash Memory
     */
    inline void set_FCON_DCF() volatile
    {
        FCON |= 1u << 17u;
    }

    /**
     * Clear FCON's DCF bit.
     *
     * Disable Code Fetch from Flash Memory
     */
    inline void clear_FCON_DCF() volatile
    {
        FCON &= ~(1u << 17u);
    }

    /**
     * Toggle FCON's DCF bit.
     *
     * Disable Code Fetch from Flash Memory
     */
    inline void toggle_FCON_DCF() volatile
    {
        FCON ^= 1u << 17u;
    }

    /**
     * Get FCON's RPA bit.
     *
     * Read Protection Activated
     */
    inline bool get_FCON_RPA() volatile
    {
        return FCON & (1u << 16u);
    }

    /**
     * Get FCON's SLEEP bit.
     *
     * Flash SLEEP
     */
    inline bool get_FCON_SLEEP() volatile
    {
        return FCON & (1u << 15u);
    }

    /**
     * Set FCON's SLEEP bit.
     *
     * Flash SLEEP
     */
    inline void set_FCON_SLEEP() volatile
    {
        FCON |= 1u << 15u;
    }

    /**
     * Clear FCON's SLEEP bit.
     *
     * Flash SLEEP
     */
    inline void clear_FCON_SLEEP() volatile
    {
        FCON &= ~(1u << 15u);
    }

    /**
     * Toggle FCON's SLEEP bit.
     *
     * Flash SLEEP
     */
    inline void toggle_FCON_SLEEP() volatile
    {
        FCON ^= 1u << 15u;
    }

    /**
     * Get FCON's ESLDIS bit.
     *
     * External Sleep Request Disable
     */
    inline bool get_FCON_ESLDIS() volatile
    {
        return FCON & (1u << 14u);
    }

    /**
     * Set FCON's ESLDIS bit.
     *
     * External Sleep Request Disable
     */
    inline void set_FCON_ESLDIS() volatile
    {
        FCON |= 1u << 14u;
    }

    /**
     * Clear FCON's ESLDIS bit.
     *
     * External Sleep Request Disable
     */
    inline void clear_FCON_ESLDIS() volatile
    {
        FCON &= ~(1u << 14u);
    }

    /**
     * Toggle FCON's ESLDIS bit.
     *
     * External Sleep Request Disable
     */
    inline void toggle_FCON_ESLDIS() volatile
    {
        FCON ^= 1u << 14u;
    }

    /**
     * Get FCON's IDLE bit.
     *
     * Dynamic Flash Idle
     */
    inline bool get_FCON_IDLE() volatile
    {
        return FCON & (1u << 13u);
    }

    /**
     * Set FCON's IDLE bit.
     *
     * Dynamic Flash Idle
     */
    inline void set_FCON_IDLE() volatile
    {
        FCON |= 1u << 13u;
    }

    /**
     * Clear FCON's IDLE bit.
     *
     * Dynamic Flash Idle
     */
    inline void clear_FCON_IDLE() volatile
    {
        FCON &= ~(1u << 13u);
    }

    /**
     * Toggle FCON's IDLE bit.
     *
     * Dynamic Flash Idle
     */
    inline void toggle_FCON_IDLE() volatile
    {
        FCON ^= 1u << 13u;
    }

    /**
     * Get FCON's WSECPF bit.
     *
     * Wait State for Error Correction of PFLASH
     */
    inline bool get_FCON_WSECPF() volatile
    {
        return FCON & (1u << 4u);
    }

    /**
     * Set FCON's WSECPF bit.
     *
     * Wait State for Error Correction of PFLASH
     */
    inline void set_FCON_WSECPF() volatile
    {
        FCON |= 1u << 4u;
    }

    /**
     * Clear FCON's WSECPF bit.
     *
     * Wait State for Error Correction of PFLASH
     */
    inline void clear_FCON_WSECPF() volatile
    {
        FCON &= ~(1u << 4u);
    }

    /**
     * Toggle FCON's WSECPF bit.
     *
     * Wait State for Error Correction of PFLASH
     */
    inline void toggle_FCON_WSECPF() volatile
    {
        FCON ^= 1u << 4u;
    }

    /**
     * Get FCON's WSPFLASH field.
     *
     * Wait States for read access to PFLASH
     */
    inline FLASH0_FCON_WSPFLASH get_FCON_WSPFLASH() volatile
    {
        return FLASH0_FCON_WSPFLASH((FCON >> 0u) & 0b1111u);
    }

    /**
     * Set FCON's WSPFLASH field.
     *
     * Wait States for read access to PFLASH
     */
    inline void set_FCON_WSPFLASH(FLASH0_FCON_WSPFLASH value) volatile
    {
        uint32_t curr = FCON;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        FCON = curr;
    }

    /**
     * Get all of FCON's bit fields.
     *
     * (read-write) Flash Configuration Register
     */
    inline void get_FCON(bool &EOBM, bool &PFDBERM, bool &PFSBERM,
                         bool &PROERM, bool &SQERM, bool &VOPERM, bool &DDF,
                         bool &DCF, bool &RPA, bool &SLEEP, bool &ESLDIS,
                         bool &IDLE, bool &WSECPF,
                         FLASH0_FCON_WSPFLASH &WSPFLASH) volatile
    {
        uint32_t curr = FCON;

        EOBM = curr & (1u << 31u);
        PFDBERM = curr & (1u << 29u);
        PFSBERM = curr & (1u << 27u);
        PROERM = curr & (1u << 26u);
        SQERM = curr & (1u << 25u);
        VOPERM = curr & (1u << 24u);
        DDF = curr & (1u << 18u);
        DCF = curr & (1u << 17u);
        RPA = curr & (1u << 16u);
        SLEEP = curr & (1u << 15u);
        ESLDIS = curr & (1u << 14u);
        IDLE = curr & (1u << 13u);
        WSECPF = curr & (1u << 4u);
        WSPFLASH = FLASH0_FCON_WSPFLASH((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of FCON's bit fields.
     *
     * (read-write) Flash Configuration Register
     */
    inline void set_FCON(bool EOBM, bool PFDBERM, bool PFSBERM, bool PROERM,
                         bool SQERM, bool VOPERM, bool DDF, bool DCF,
                         bool SLEEP, bool ESLDIS, bool IDLE, bool WSECPF,
                         FLASH0_FCON_WSPFLASH WSPFLASH) volatile
    {
        uint32_t curr = FCON;

        curr &= ~(0b1u << 31u);
        curr |= (EOBM & 0b1u) << 31u;
        curr &= ~(0b1u << 29u);
        curr |= (PFDBERM & 0b1u) << 29u;
        curr &= ~(0b1u << 27u);
        curr |= (PFSBERM & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (PROERM & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (SQERM & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (VOPERM & 0b1u) << 24u;
        curr &= ~(0b1u << 18u);
        curr |= (DDF & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (DCF & 0b1u) << 17u;
        curr &= ~(0b1u << 15u);
        curr |= (SLEEP & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (ESLDIS & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (IDLE & 0b1u) << 13u;
        curr &= ~(0b1u << 4u);
        curr |= (WSECPF & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(WSPFLASH) & 0b1111u) << 0u;

        FCON = curr;
    }

    /**
     * Get MARP's TRAPDIS bit.
     *
     * PFLASH Double-Bit Error Trap Disable
     */
    inline bool get_MARP_TRAPDIS() volatile
    {
        return MARP & (1u << 15u);
    }

    /**
     * Set MARP's TRAPDIS bit.
     *
     * PFLASH Double-Bit Error Trap Disable
     */
    inline void set_MARP_TRAPDIS() volatile
    {
        MARP |= 1u << 15u;
    }

    /**
     * Clear MARP's TRAPDIS bit.
     *
     * PFLASH Double-Bit Error Trap Disable
     */
    inline void clear_MARP_TRAPDIS() volatile
    {
        MARP &= ~(1u << 15u);
    }

    /**
     * Toggle MARP's TRAPDIS bit.
     *
     * PFLASH Double-Bit Error Trap Disable
     */
    inline void toggle_MARP_TRAPDIS() volatile
    {
        MARP ^= 1u << 15u;
    }

    /**
     * Get MARP's MARGIN field.
     *
     * PFLASH Margin Selection
     */
    inline FLASH0_MARP_MARGIN get_MARP_MARGIN() volatile
    {
        return FLASH0_MARP_MARGIN((MARP >> 0u) & 0b1111u);
    }

    /**
     * Set MARP's MARGIN field.
     *
     * PFLASH Margin Selection
     */
    inline void set_MARP_MARGIN(FLASH0_MARP_MARGIN value) volatile
    {
        uint32_t curr = MARP;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        MARP = curr;
    }

    /**
     * Get all of MARP's bit fields.
     *
     * (read-write) Margin Control Register PFLASH
     */
    inline void get_MARP(bool &TRAPDIS, FLASH0_MARP_MARGIN &MARGIN) volatile
    {
        uint32_t curr = MARP;

        TRAPDIS = curr & (1u << 15u);
        MARGIN = FLASH0_MARP_MARGIN((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of MARP's bit fields.
     *
     * (read-write) Margin Control Register PFLASH
     */
    inline void set_MARP(bool TRAPDIS, FLASH0_MARP_MARGIN MARGIN) volatile
    {
        uint32_t curr = MARP;

        curr &= ~(0b1u << 15u);
        curr |= (TRAPDIS & 0b1u) << 15u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MARGIN) & 0b1111u) << 0u;

        MARP = curr;
    }

    /**
     * Get PROCON0's RPRO bit.
     *
     * Read Protection Configuration
     */
    inline bool get_PROCON0_RPRO() volatile
    {
        return PROCON0 & (1u << 15u);
    }

    /**
     * Get PROCON0's S14_S15L bit.
     *
     * Sectors 14 and 15 Locked for Write Protection by User 0
     */
    inline bool get_PROCON0_S14_S15L() volatile
    {
        return PROCON0 & (1u << 12u);
    }

    /**
     * Get PROCON0's S12_S13L bit.
     *
     * Sectors 12 and 13 Locked for Write Protection by User 0
     */
    inline bool get_PROCON0_S12_S13L() volatile
    {
        return PROCON0 & (1u << 11u);
    }

    /**
     * Get PROCON0's S10_S11L bit.
     *
     * Sectors 10 and 11 Locked for Write Protection by User 0
     */
    inline bool get_PROCON0_S10_S11L() volatile
    {
        return PROCON0 & (1u << 10u);
    }

    /**
     * Get PROCON0's S9L bit.
     *
     * Sector 9 Locked for Write Protection by User 0
     */
    inline bool get_PROCON0_S9L() volatile
    {
        return PROCON0 & (1u << 9u);
    }

    /**
     * Get PROCON0's S8L bit.
     *
     * Sector 8 Locked for Write Protection by User 0
     */
    inline bool get_PROCON0_S8L() volatile
    {
        return PROCON0 & (1u << 8u);
    }

    /**
     * Get PROCON0's S7L bit.
     *
     * Sector 7 Locked for Write Protection by User 0
     */
    inline bool get_PROCON0_S7L() volatile
    {
        return PROCON0 & (1u << 7u);
    }

    /**
     * Get PROCON0's S6L bit.
     *
     * Sector 6 Locked for Write Protection by User 0
     */
    inline bool get_PROCON0_S6L() volatile
    {
        return PROCON0 & (1u << 6u);
    }

    /**
     * Get PROCON0's S5L bit.
     *
     * Sector 5 Locked for Write Protection by User 0
     */
    inline bool get_PROCON0_S5L() volatile
    {
        return PROCON0 & (1u << 5u);
    }

    /**
     * Get PROCON0's S4L bit.
     *
     * Sector 4 Locked for Write Protection by User 0
     */
    inline bool get_PROCON0_S4L() volatile
    {
        return PROCON0 & (1u << 4u);
    }

    /**
     * Get PROCON0's S3L bit.
     *
     * Sector 3 Locked for Write Protection by User 0
     */
    inline bool get_PROCON0_S3L() volatile
    {
        return PROCON0 & (1u << 3u);
    }

    /**
     * Get PROCON0's S2L bit.
     *
     * Sector 2 Locked for Write Protection by User 0
     */
    inline bool get_PROCON0_S2L() volatile
    {
        return PROCON0 & (1u << 2u);
    }

    /**
     * Get PROCON0's S1L bit.
     *
     * Sector 1 Locked for Write Protection by User 0
     */
    inline bool get_PROCON0_S1L() volatile
    {
        return PROCON0 & (1u << 1u);
    }

    /**
     * Get PROCON0's S0L bit.
     *
     * Sector 0 Locked for Write Protection by User 0
     */
    inline bool get_PROCON0_S0L() volatile
    {
        return PROCON0 & (1u << 0u);
    }

    /**
     * Get all of PROCON0's bit fields.
     *
     * (read-only) Flash Protection Configuration Register User 0
     */
    inline void get_PROCON0(bool &RPRO, bool &S14_S15L, bool &S12_S13L,
                            bool &S10_S11L, bool &S9L, bool &S8L, bool &S7L,
                            bool &S6L, bool &S5L, bool &S4L, bool &S3L,
                            bool &S2L, bool &S1L, bool &S0L) volatile
    {
        uint32_t curr = PROCON0;

        RPRO = curr & (1u << 15u);
        S14_S15L = curr & (1u << 12u);
        S12_S13L = curr & (1u << 11u);
        S10_S11L = curr & (1u << 10u);
        S9L = curr & (1u << 9u);
        S8L = curr & (1u << 8u);
        S7L = curr & (1u << 7u);
        S6L = curr & (1u << 6u);
        S5L = curr & (1u << 5u);
        S4L = curr & (1u << 4u);
        S3L = curr & (1u << 3u);
        S2L = curr & (1u << 2u);
        S1L = curr & (1u << 1u);
        S0L = curr & (1u << 0u);
    }

    /**
     * Get PROCON1's PSR bit.
     *
     * Physical Sector Repair
     */
    inline bool get_PROCON1_PSR() volatile
    {
        return PROCON1 & (1u << 16u);
    }

    /**
     * Get PROCON1's S14_S15L bit.
     *
     * Sectors 14 and 15 Locked for Write Protection by User 1
     */
    inline bool get_PROCON1_S14_S15L() volatile
    {
        return PROCON1 & (1u << 12u);
    }

    /**
     * Get PROCON1's S12_S13L bit.
     *
     * Sectors 12 and 13 Locked for Write Protection by User 1
     */
    inline bool get_PROCON1_S12_S13L() volatile
    {
        return PROCON1 & (1u << 11u);
    }

    /**
     * Get PROCON1's S10_S11L bit.
     *
     * Sectors 10 and 11 Locked for Write Protection by User 1
     */
    inline bool get_PROCON1_S10_S11L() volatile
    {
        return PROCON1 & (1u << 10u);
    }

    /**
     * Get PROCON1's S9L bit.
     *
     * Sector 9 Locked for Write Protection by User 1
     */
    inline bool get_PROCON1_S9L() volatile
    {
        return PROCON1 & (1u << 9u);
    }

    /**
     * Get PROCON1's S8L bit.
     *
     * Sector 8 Locked for Write Protection by User 1
     */
    inline bool get_PROCON1_S8L() volatile
    {
        return PROCON1 & (1u << 8u);
    }

    /**
     * Get PROCON1's S7L bit.
     *
     * Sector 7 Locked for Write Protection by User 1
     */
    inline bool get_PROCON1_S7L() volatile
    {
        return PROCON1 & (1u << 7u);
    }

    /**
     * Get PROCON1's S6L bit.
     *
     * Sector 6 Locked for Write Protection by User 1
     */
    inline bool get_PROCON1_S6L() volatile
    {
        return PROCON1 & (1u << 6u);
    }

    /**
     * Get PROCON1's S5L bit.
     *
     * Sector 5 Locked for Write Protection by User 1
     */
    inline bool get_PROCON1_S5L() volatile
    {
        return PROCON1 & (1u << 5u);
    }

    /**
     * Get PROCON1's S4L bit.
     *
     * Sector 4 Locked for Write Protection by User 1
     */
    inline bool get_PROCON1_S4L() volatile
    {
        return PROCON1 & (1u << 4u);
    }

    /**
     * Get PROCON1's S3L bit.
     *
     * Sector 3 Locked for Write Protection by User 1
     */
    inline bool get_PROCON1_S3L() volatile
    {
        return PROCON1 & (1u << 3u);
    }

    /**
     * Get PROCON1's S2L bit.
     *
     * Sector 2 Locked for Write Protection by User 1
     */
    inline bool get_PROCON1_S2L() volatile
    {
        return PROCON1 & (1u << 2u);
    }

    /**
     * Get PROCON1's S1L bit.
     *
     * Sector 1 Locked for Write Protection by User 1
     */
    inline bool get_PROCON1_S1L() volatile
    {
        return PROCON1 & (1u << 1u);
    }

    /**
     * Get PROCON1's S0L bit.
     *
     * Sector 0 Locked for Write Protection by User 1
     */
    inline bool get_PROCON1_S0L() volatile
    {
        return PROCON1 & (1u << 0u);
    }

    /**
     * Get all of PROCON1's bit fields.
     *
     * (read-only) Flash Protection Configuration Register User 1
     */
    inline void get_PROCON1(bool &PSR, bool &S14_S15L, bool &S12_S13L,
                            bool &S10_S11L, bool &S9L, bool &S8L, bool &S7L,
                            bool &S6L, bool &S5L, bool &S4L, bool &S3L,
                            bool &S2L, bool &S1L, bool &S0L) volatile
    {
        uint32_t curr = PROCON1;

        PSR = curr & (1u << 16u);
        S14_S15L = curr & (1u << 12u);
        S12_S13L = curr & (1u << 11u);
        S10_S11L = curr & (1u << 10u);
        S9L = curr & (1u << 9u);
        S8L = curr & (1u << 8u);
        S7L = curr & (1u << 7u);
        S6L = curr & (1u << 6u);
        S5L = curr & (1u << 5u);
        S4L = curr & (1u << 4u);
        S3L = curr & (1u << 3u);
        S2L = curr & (1u << 2u);
        S1L = curr & (1u << 1u);
        S0L = curr & (1u << 0u);
    }

    /**
     * Get PROCON2's S14_S15ROM bit.
     *
     * Sectors 14 and 15 Locked Forever by User 2
     */
    inline bool get_PROCON2_S14_S15ROM() volatile
    {
        return PROCON2 & (1u << 12u);
    }

    /**
     * Get PROCON2's S12_S13ROM bit.
     *
     * Sectors 12 and 13 Locked Forever by User 2
     */
    inline bool get_PROCON2_S12_S13ROM() volatile
    {
        return PROCON2 & (1u << 11u);
    }

    /**
     * Get PROCON2's S10_S11ROM bit.
     *
     * Sectors 10 and 11 Locked Forever by User 2
     */
    inline bool get_PROCON2_S10_S11ROM() volatile
    {
        return PROCON2 & (1u << 10u);
    }

    /**
     * Get PROCON2's S9ROM bit.
     *
     * Sector 9 Locked Forever by User 2
     */
    inline bool get_PROCON2_S9ROM() volatile
    {
        return PROCON2 & (1u << 9u);
    }

    /**
     * Get PROCON2's S8ROM bit.
     *
     * Sector 8 Locked Forever by User 2
     */
    inline bool get_PROCON2_S8ROM() volatile
    {
        return PROCON2 & (1u << 8u);
    }

    /**
     * Get PROCON2's S7ROM bit.
     *
     * Sector 7 Locked Forever by User 2
     */
    inline bool get_PROCON2_S7ROM() volatile
    {
        return PROCON2 & (1u << 7u);
    }

    /**
     * Get PROCON2's S6ROM bit.
     *
     * Sector 6 Locked Forever by User 2
     */
    inline bool get_PROCON2_S6ROM() volatile
    {
        return PROCON2 & (1u << 6u);
    }

    /**
     * Get PROCON2's S5ROM bit.
     *
     * Sector 5 Locked Forever by User 2
     */
    inline bool get_PROCON2_S5ROM() volatile
    {
        return PROCON2 & (1u << 5u);
    }

    /**
     * Get PROCON2's S4ROM bit.
     *
     * Sector 4 Locked Forever by User 2
     */
    inline bool get_PROCON2_S4ROM() volatile
    {
        return PROCON2 & (1u << 4u);
    }

    /**
     * Get PROCON2's S3ROM bit.
     *
     * Sector 3 Locked Forever by User 2
     */
    inline bool get_PROCON2_S3ROM() volatile
    {
        return PROCON2 & (1u << 3u);
    }

    /**
     * Get PROCON2's S2ROM bit.
     *
     * Sector 2 Locked Forever by User 2
     */
    inline bool get_PROCON2_S2ROM() volatile
    {
        return PROCON2 & (1u << 2u);
    }

    /**
     * Get PROCON2's S1ROM bit.
     *
     * Sector 1 Locked Forever by User 2
     */
    inline bool get_PROCON2_S1ROM() volatile
    {
        return PROCON2 & (1u << 1u);
    }

    /**
     * Get PROCON2's S0ROM bit.
     *
     * Sector 0 Locked Forever by User 2
     */
    inline bool get_PROCON2_S0ROM() volatile
    {
        return PROCON2 & (1u << 0u);
    }

    /**
     * Get all of PROCON2's bit fields.
     *
     * (read-only) Flash Protection Configuration Register User 2
     */
    inline void get_PROCON2(bool &S14_S15ROM, bool &S12_S13ROM,
                            bool &S10_S11ROM, bool &S9ROM, bool &S8ROM,
                            bool &S7ROM, bool &S6ROM, bool &S5ROM, bool &S4ROM,
                            bool &S3ROM, bool &S2ROM, bool &S1ROM,
                            bool &S0ROM) volatile
    {
        uint32_t curr = PROCON2;

        S14_S15ROM = curr & (1u << 12u);
        S12_S13ROM = curr & (1u << 11u);
        S10_S11ROM = curr & (1u << 10u);
        S9ROM = curr & (1u << 9u);
        S8ROM = curr & (1u << 8u);
        S7ROM = curr & (1u << 7u);
        S6ROM = curr & (1u << 6u);
        S5ROM = curr & (1u << 5u);
        S4ROM = curr & (1u << 4u);
        S3ROM = curr & (1u << 3u);
        S2ROM = curr & (1u << 2u);
        S1ROM = curr & (1u << 1u);
        S0ROM = curr & (1u << 0u);
    }
};

static_assert(sizeof(flash0) == flash0::size);

static volatile flash0 *const FLASH0 = reinterpret_cast<flash0 *>(0x58001000);

static volatile flash0 *const PMU0 = reinterpret_cast<flash0 *>(0x58000508);

static volatile flash0 *const USIC0 = reinterpret_cast<flash0 *>(0x40030008);

}; // namespace XMC4700
