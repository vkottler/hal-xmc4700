/**
 * \file
 * \brief Generated by ifgen (3.2.0).
 */
#pragma once

#include "../enums/ERU0_EXICON_OCS.h"
#include "../enums/ERU0_EXICON_SS.h"
#include "../enums/ERU0_EXISEL_EXS3B.h"
#include "../enums/ERU0_EXOCON_GP.h"
#include "../enums/ERU0_EXOCON_ISS.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * Event Request Unit 0
 */
struct [[gnu::packed]] eru0
{
    /* Constant attributes. */
    static constexpr std::size_t size = 48; /*!< eru0's size in bytes. */

    /* Fields. */
    uint32_t EXISEL; /*!< (read-write) Event Input Select */
    static constexpr std::size_t reserved_padding0_length = 3;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    static constexpr std::size_t EXICON_length = 4;
    uint32_t EXICON[EXICON_length]; /*!< (read-write) Event Input Control */
    static constexpr std::size_t EXOCON_length = 4;
    uint32_t EXOCON[EXOCON_length]; /*!< (read-write) Event Output Trigger
                                       Control */

    /* Methods. */

    /**
     * Get EXISEL's EXS3B field.
     *
     * Event Source Select for B3 (ERS3)
     */
    inline ERU0_EXISEL_EXS3B get_EXISEL_EXS3B() volatile
    {
        return ERU0_EXISEL_EXS3B((EXISEL >> 14u) & 0b11u);
    }

    /**
     * Set EXISEL's EXS3B field.
     *
     * Event Source Select for B3 (ERS3)
     */
    inline void set_EXISEL_EXS3B(ERU0_EXISEL_EXS3B value) volatile
    {
        uint32_t curr = EXISEL;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(value) & 0b11u) << 14u;

        EXISEL = curr;
    }

    /**
     * Get EXISEL's EXS3A field.
     *
     * Event Source Select for A3 (ERS3)
     */
    inline ERU0_EXISEL_EXS3B get_EXISEL_EXS3A() volatile
    {
        return ERU0_EXISEL_EXS3B((EXISEL >> 12u) & 0b11u);
    }

    /**
     * Set EXISEL's EXS3A field.
     *
     * Event Source Select for A3 (ERS3)
     */
    inline void set_EXISEL_EXS3A(ERU0_EXISEL_EXS3B value) volatile
    {
        uint32_t curr = EXISEL;

        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(value) & 0b11u) << 12u;

        EXISEL = curr;
    }

    /**
     * Get EXISEL's EXS2B field.
     *
     * Event Source Select for B2 (ERS2)
     */
    inline ERU0_EXISEL_EXS3B get_EXISEL_EXS2B() volatile
    {
        return ERU0_EXISEL_EXS3B((EXISEL >> 10u) & 0b11u);
    }

    /**
     * Set EXISEL's EXS2B field.
     *
     * Event Source Select for B2 (ERS2)
     */
    inline void set_EXISEL_EXS2B(ERU0_EXISEL_EXS3B value) volatile
    {
        uint32_t curr = EXISEL;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(value) & 0b11u) << 10u;

        EXISEL = curr;
    }

    /**
     * Get EXISEL's EXS2A field.
     *
     * Event Source Select for A2 (ERS2)
     */
    inline ERU0_EXISEL_EXS3B get_EXISEL_EXS2A() volatile
    {
        return ERU0_EXISEL_EXS3B((EXISEL >> 8u) & 0b11u);
    }

    /**
     * Set EXISEL's EXS2A field.
     *
     * Event Source Select for A2 (ERS2)
     */
    inline void set_EXISEL_EXS2A(ERU0_EXISEL_EXS3B value) volatile
    {
        uint32_t curr = EXISEL;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        EXISEL = curr;
    }

    /**
     * Get EXISEL's EXS1B field.
     *
     * Event Source Select for B1 (ERS1)
     */
    inline ERU0_EXISEL_EXS3B get_EXISEL_EXS1B() volatile
    {
        return ERU0_EXISEL_EXS3B((EXISEL >> 6u) & 0b11u);
    }

    /**
     * Set EXISEL's EXS1B field.
     *
     * Event Source Select for B1 (ERS1)
     */
    inline void set_EXISEL_EXS1B(ERU0_EXISEL_EXS3B value) volatile
    {
        uint32_t curr = EXISEL;

        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(value) & 0b11u) << 6u;

        EXISEL = curr;
    }

    /**
     * Get EXISEL's EXS1A field.
     *
     * Event Source Select for A1 (ERS1)
     */
    inline ERU0_EXISEL_EXS3B get_EXISEL_EXS1A() volatile
    {
        return ERU0_EXISEL_EXS3B((EXISEL >> 4u) & 0b11u);
    }

    /**
     * Set EXISEL's EXS1A field.
     *
     * Event Source Select for A1 (ERS1)
     */
    inline void set_EXISEL_EXS1A(ERU0_EXISEL_EXS3B value) volatile
    {
        uint32_t curr = EXISEL;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        EXISEL = curr;
    }

    /**
     * Get EXISEL's EXS0B field.
     *
     * Event Source Select for B0 (ERS0)
     */
    inline ERU0_EXISEL_EXS3B get_EXISEL_EXS0B() volatile
    {
        return ERU0_EXISEL_EXS3B((EXISEL >> 2u) & 0b11u);
    }

    /**
     * Set EXISEL's EXS0B field.
     *
     * Event Source Select for B0 (ERS0)
     */
    inline void set_EXISEL_EXS0B(ERU0_EXISEL_EXS3B value) volatile
    {
        uint32_t curr = EXISEL;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        EXISEL = curr;
    }

    /**
     * Get EXISEL's EXS0A field.
     *
     * Event Source Select for A0 (ERS0)
     */
    inline ERU0_EXISEL_EXS3B get_EXISEL_EXS0A() volatile
    {
        return ERU0_EXISEL_EXS3B((EXISEL >> 0u) & 0b11u);
    }

    /**
     * Set EXISEL's EXS0A field.
     *
     * Event Source Select for A0 (ERS0)
     */
    inline void set_EXISEL_EXS0A(ERU0_EXISEL_EXS3B value) volatile
    {
        uint32_t curr = EXISEL;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        EXISEL = curr;
    }

    /**
     * Get all of EXISEL's bit fields.
     *
     * (read-write) Event Input Select
     */
    inline void get_EXISEL(ERU0_EXISEL_EXS3B &EXS3B, ERU0_EXISEL_EXS3B &EXS3A,
                           ERU0_EXISEL_EXS3B &EXS2B, ERU0_EXISEL_EXS3B &EXS2A,
                           ERU0_EXISEL_EXS3B &EXS1B, ERU0_EXISEL_EXS3B &EXS1A,
                           ERU0_EXISEL_EXS3B &EXS0B,
                           ERU0_EXISEL_EXS3B &EXS0A) volatile
    {
        uint32_t curr = EXISEL;

        EXS3B = ERU0_EXISEL_EXS3B((curr >> 14u) & 0b11u);
        EXS3A = ERU0_EXISEL_EXS3B((curr >> 12u) & 0b11u);
        EXS2B = ERU0_EXISEL_EXS3B((curr >> 10u) & 0b11u);
        EXS2A = ERU0_EXISEL_EXS3B((curr >> 8u) & 0b11u);
        EXS1B = ERU0_EXISEL_EXS3B((curr >> 6u) & 0b11u);
        EXS1A = ERU0_EXISEL_EXS3B((curr >> 4u) & 0b11u);
        EXS0B = ERU0_EXISEL_EXS3B((curr >> 2u) & 0b11u);
        EXS0A = ERU0_EXISEL_EXS3B((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of EXISEL's bit fields.
     *
     * (read-write) Event Input Select
     */
    inline void set_EXISEL(ERU0_EXISEL_EXS3B EXS3B, ERU0_EXISEL_EXS3B EXS3A,
                           ERU0_EXISEL_EXS3B EXS2B, ERU0_EXISEL_EXS3B EXS2A,
                           ERU0_EXISEL_EXS3B EXS1B, ERU0_EXISEL_EXS3B EXS1A,
                           ERU0_EXISEL_EXS3B EXS0B,
                           ERU0_EXISEL_EXS3B EXS0A) volatile
    {
        uint32_t curr = EXISEL;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(EXS3B) & 0b11u) << 14u;
        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(EXS3A) & 0b11u) << 12u;
        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(EXS2B) & 0b11u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(EXS2A) & 0b11u) << 8u;
        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(EXS1B) & 0b11u) << 6u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(EXS1A) & 0b11u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(EXS0B) & 0b11u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(EXS0A) & 0b11u) << 0u;

        EXISEL = curr;
    }

    /**
     * Get EXICON's NB bit.
     *
     * Input B Negation Select for ERSx
     */
    inline bool get_EXICON_NB(std::size_t index) volatile
    {
        return EXICON[index] & (1u << 11u);
    }

    /**
     * Set EXICON's NB bit.
     *
     * Input B Negation Select for ERSx
     */
    inline void set_EXICON_NB() volatile
    {
        EXICON |= 1u << 11u;
    }

    /**
     * Clear EXICON's NB bit.
     *
     * Input B Negation Select for ERSx
     */
    inline void clear_EXICON_NB() volatile
    {
        EXICON &= ~(1u << 11u);
    }

    /**
     * Toggle EXICON's NB bit.
     *
     * Input B Negation Select for ERSx
     */
    inline void toggle_EXICON_NB() volatile
    {
        EXICON ^= 1u << 11u;
    }

    /**
     * Get EXICON's NA bit.
     *
     * Input A Negation Select for ERSx
     */
    inline bool get_EXICON_NA(std::size_t index) volatile
    {
        return EXICON[index] & (1u << 10u);
    }

    /**
     * Set EXICON's NA bit.
     *
     * Input A Negation Select for ERSx
     */
    inline void set_EXICON_NA() volatile
    {
        EXICON |= 1u << 10u;
    }

    /**
     * Clear EXICON's NA bit.
     *
     * Input A Negation Select for ERSx
     */
    inline void clear_EXICON_NA() volatile
    {
        EXICON &= ~(1u << 10u);
    }

    /**
     * Toggle EXICON's NA bit.
     *
     * Input A Negation Select for ERSx
     */
    inline void toggle_EXICON_NA() volatile
    {
        EXICON ^= 1u << 10u;
    }

    /**
     * Get EXICON's SS field.
     *
     * Input Source Select for ERSx
     */
    inline ERU0_EXICON_SS get_EXICON_SS(std::size_t index) volatile
    {
        return ERU0_EXICON_SS((EXICON[index] >> 8u) & 0b11u);
    }

    /**
     * Set EXICON's SS field.
     *
     * Input Source Select for ERSx
     */
    inline void set_EXICON_SS(std::size_t index, ERU0_EXICON_SS value) volatile
    {
        uint32_t curr = EXICON[index];

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        EXICON[index] = curr;
    }

    /**
     * Get EXICON's FL bit.
     *
     * Status Flag for ETLx
     */
    inline bool get_EXICON_FL(std::size_t index) volatile
    {
        return EXICON[index] & (1u << 7u);
    }

    /**
     * Set EXICON's FL bit.
     *
     * Status Flag for ETLx
     */
    inline void set_EXICON_FL() volatile
    {
        EXICON |= 1u << 7u;
    }

    /**
     * Clear EXICON's FL bit.
     *
     * Status Flag for ETLx
     */
    inline void clear_EXICON_FL() volatile
    {
        EXICON &= ~(1u << 7u);
    }

    /**
     * Toggle EXICON's FL bit.
     *
     * Status Flag for ETLx
     */
    inline void toggle_EXICON_FL() volatile
    {
        EXICON ^= 1u << 7u;
    }

    /**
     * Get EXICON's OCS field.
     *
     * Output Channel Select for ETLx Output Trigger Pulse
     */
    inline ERU0_EXICON_OCS get_EXICON_OCS(std::size_t index) volatile
    {
        return ERU0_EXICON_OCS((EXICON[index] >> 4u) & 0b111u);
    }

    /**
     * Set EXICON's OCS field.
     *
     * Output Channel Select for ETLx Output Trigger Pulse
     */
    inline void set_EXICON_OCS(std::size_t index,
                               ERU0_EXICON_OCS value) volatile
    {
        uint32_t curr = EXICON[index];

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        EXICON[index] = curr;
    }

    /**
     * Get EXICON's FE bit.
     *
     * Falling Edge Detection Enable ETLx
     */
    inline bool get_EXICON_FE(std::size_t index) volatile
    {
        return EXICON[index] & (1u << 3u);
    }

    /**
     * Set EXICON's FE bit.
     *
     * Falling Edge Detection Enable ETLx
     */
    inline void set_EXICON_FE() volatile
    {
        EXICON |= 1u << 3u;
    }

    /**
     * Clear EXICON's FE bit.
     *
     * Falling Edge Detection Enable ETLx
     */
    inline void clear_EXICON_FE() volatile
    {
        EXICON &= ~(1u << 3u);
    }

    /**
     * Toggle EXICON's FE bit.
     *
     * Falling Edge Detection Enable ETLx
     */
    inline void toggle_EXICON_FE() volatile
    {
        EXICON ^= 1u << 3u;
    }

    /**
     * Get EXICON's RE bit.
     *
     * Rising Edge Detection Enable ETLx
     */
    inline bool get_EXICON_RE(std::size_t index) volatile
    {
        return EXICON[index] & (1u << 2u);
    }

    /**
     * Set EXICON's RE bit.
     *
     * Rising Edge Detection Enable ETLx
     */
    inline void set_EXICON_RE() volatile
    {
        EXICON |= 1u << 2u;
    }

    /**
     * Clear EXICON's RE bit.
     *
     * Rising Edge Detection Enable ETLx
     */
    inline void clear_EXICON_RE() volatile
    {
        EXICON &= ~(1u << 2u);
    }

    /**
     * Toggle EXICON's RE bit.
     *
     * Rising Edge Detection Enable ETLx
     */
    inline void toggle_EXICON_RE() volatile
    {
        EXICON ^= 1u << 2u;
    }

    /**
     * Get EXICON's LD bit.
     *
     * Rebuild Level Detection for Status Flag for ETLx
     */
    inline bool get_EXICON_LD(std::size_t index) volatile
    {
        return EXICON[index] & (1u << 1u);
    }

    /**
     * Set EXICON's LD bit.
     *
     * Rebuild Level Detection for Status Flag for ETLx
     */
    inline void set_EXICON_LD() volatile
    {
        EXICON |= 1u << 1u;
    }

    /**
     * Clear EXICON's LD bit.
     *
     * Rebuild Level Detection for Status Flag for ETLx
     */
    inline void clear_EXICON_LD() volatile
    {
        EXICON &= ~(1u << 1u);
    }

    /**
     * Toggle EXICON's LD bit.
     *
     * Rebuild Level Detection for Status Flag for ETLx
     */
    inline void toggle_EXICON_LD() volatile
    {
        EXICON ^= 1u << 1u;
    }

    /**
     * Get EXICON's PE bit.
     *
     * Output Trigger Pulse Enable for ETLx
     */
    inline bool get_EXICON_PE(std::size_t index) volatile
    {
        return EXICON[index] & (1u << 0u);
    }

    /**
     * Set EXICON's PE bit.
     *
     * Output Trigger Pulse Enable for ETLx
     */
    inline void set_EXICON_PE() volatile
    {
        EXICON |= 1u << 0u;
    }

    /**
     * Clear EXICON's PE bit.
     *
     * Output Trigger Pulse Enable for ETLx
     */
    inline void clear_EXICON_PE() volatile
    {
        EXICON &= ~(1u << 0u);
    }

    /**
     * Toggle EXICON's PE bit.
     *
     * Output Trigger Pulse Enable for ETLx
     */
    inline void toggle_EXICON_PE() volatile
    {
        EXICON ^= 1u << 0u;
    }

    /**
     * Get all of EXICON's bit fields.
     *
     * (read-write) Event Input Control
     */
    inline void get_EXICON(std::size_t index, bool &NB, bool &NA,
                           ERU0_EXICON_SS &SS, bool &FL, ERU0_EXICON_OCS &OCS,
                           bool &FE, bool &RE, bool &LD, bool &PE) volatile
    {
        uint32_t curr = EXICON[index];

        NB = curr & (1u << 11u);
        NA = curr & (1u << 10u);
        SS = ERU0_EXICON_SS((curr >> 8u) & 0b11u);
        FL = curr & (1u << 7u);
        OCS = ERU0_EXICON_OCS((curr >> 4u) & 0b111u);
        FE = curr & (1u << 3u);
        RE = curr & (1u << 2u);
        LD = curr & (1u << 1u);
        PE = curr & (1u << 0u);
    }

    /**
     * Set all of EXICON's bit fields.
     *
     * (read-write) Event Input Control
     */
    inline void set_EXICON(std::size_t index, bool NB, bool NA,
                           ERU0_EXICON_SS SS, bool FL, ERU0_EXICON_OCS OCS,
                           bool FE, bool RE, bool LD, bool PE) volatile
    {
        uint32_t curr = EXICON[index];

        curr &= ~(0b1u << 11u);
        curr |= (NB & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (NA & 0b1u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(SS) & 0b11u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (FL & 0b1u) << 7u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(OCS) & 0b111u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (FE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (RE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (LD & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PE & 0b1u) << 0u;

        EXICON[index] = curr;
    }

    /**
     * Get EXOCON's IPEN3 bit.
     *
     * Pattern Detection Enable for ETL3
     */
    inline bool get_EXOCON_IPEN3(std::size_t index) volatile
    {
        return EXOCON[index] & (1u << 15u);
    }

    /**
     * Set EXOCON's IPEN3 bit.
     *
     * Pattern Detection Enable for ETL3
     */
    inline void set_EXOCON_IPEN3() volatile
    {
        EXOCON |= 1u << 15u;
    }

    /**
     * Clear EXOCON's IPEN3 bit.
     *
     * Pattern Detection Enable for ETL3
     */
    inline void clear_EXOCON_IPEN3() volatile
    {
        EXOCON &= ~(1u << 15u);
    }

    /**
     * Toggle EXOCON's IPEN3 bit.
     *
     * Pattern Detection Enable for ETL3
     */
    inline void toggle_EXOCON_IPEN3() volatile
    {
        EXOCON ^= 1u << 15u;
    }

    /**
     * Get EXOCON's IPEN2 bit.
     *
     * Pattern Detection Enable for ETL2
     */
    inline bool get_EXOCON_IPEN2(std::size_t index) volatile
    {
        return EXOCON[index] & (1u << 14u);
    }

    /**
     * Set EXOCON's IPEN2 bit.
     *
     * Pattern Detection Enable for ETL2
     */
    inline void set_EXOCON_IPEN2() volatile
    {
        EXOCON |= 1u << 14u;
    }

    /**
     * Clear EXOCON's IPEN2 bit.
     *
     * Pattern Detection Enable for ETL2
     */
    inline void clear_EXOCON_IPEN2() volatile
    {
        EXOCON &= ~(1u << 14u);
    }

    /**
     * Toggle EXOCON's IPEN2 bit.
     *
     * Pattern Detection Enable for ETL2
     */
    inline void toggle_EXOCON_IPEN2() volatile
    {
        EXOCON ^= 1u << 14u;
    }

    /**
     * Get EXOCON's IPEN1 bit.
     *
     * Pattern Detection Enable for ETL1
     */
    inline bool get_EXOCON_IPEN1(std::size_t index) volatile
    {
        return EXOCON[index] & (1u << 13u);
    }

    /**
     * Set EXOCON's IPEN1 bit.
     *
     * Pattern Detection Enable for ETL1
     */
    inline void set_EXOCON_IPEN1() volatile
    {
        EXOCON |= 1u << 13u;
    }

    /**
     * Clear EXOCON's IPEN1 bit.
     *
     * Pattern Detection Enable for ETL1
     */
    inline void clear_EXOCON_IPEN1() volatile
    {
        EXOCON &= ~(1u << 13u);
    }

    /**
     * Toggle EXOCON's IPEN1 bit.
     *
     * Pattern Detection Enable for ETL1
     */
    inline void toggle_EXOCON_IPEN1() volatile
    {
        EXOCON ^= 1u << 13u;
    }

    /**
     * Get EXOCON's IPEN0 bit.
     *
     * Pattern Detection Enable for ETL0
     */
    inline bool get_EXOCON_IPEN0(std::size_t index) volatile
    {
        return EXOCON[index] & (1u << 12u);
    }

    /**
     * Set EXOCON's IPEN0 bit.
     *
     * Pattern Detection Enable for ETL0
     */
    inline void set_EXOCON_IPEN0() volatile
    {
        EXOCON |= 1u << 12u;
    }

    /**
     * Clear EXOCON's IPEN0 bit.
     *
     * Pattern Detection Enable for ETL0
     */
    inline void clear_EXOCON_IPEN0() volatile
    {
        EXOCON &= ~(1u << 12u);
    }

    /**
     * Toggle EXOCON's IPEN0 bit.
     *
     * Pattern Detection Enable for ETL0
     */
    inline void toggle_EXOCON_IPEN0() volatile
    {
        EXOCON ^= 1u << 12u;
    }

    /**
     * Get EXOCON's GP field.
     *
     * Gating Selection for Pattern Detection Result
     */
    inline ERU0_EXOCON_GP get_EXOCON_GP(std::size_t index) volatile
    {
        return ERU0_EXOCON_GP((EXOCON[index] >> 4u) & 0b11u);
    }

    /**
     * Set EXOCON's GP field.
     *
     * Gating Selection for Pattern Detection Result
     */
    inline void set_EXOCON_GP(std::size_t index, ERU0_EXOCON_GP value) volatile
    {
        uint32_t curr = EXOCON[index];

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        EXOCON[index] = curr;
    }

    /**
     * Get EXOCON's PDR bit.
     *
     * Pattern Detection Result Flag
     */
    inline bool get_EXOCON_PDR(std::size_t index) volatile
    {
        return EXOCON[index] & (1u << 3u);
    }

    /**
     * Get EXOCON's GEEN bit.
     *
     * Gating Event Enable
     */
    inline bool get_EXOCON_GEEN(std::size_t index) volatile
    {
        return EXOCON[index] & (1u << 2u);
    }

    /**
     * Set EXOCON's GEEN bit.
     *
     * Gating Event Enable
     */
    inline void set_EXOCON_GEEN() volatile
    {
        EXOCON |= 1u << 2u;
    }

    /**
     * Clear EXOCON's GEEN bit.
     *
     * Gating Event Enable
     */
    inline void clear_EXOCON_GEEN() volatile
    {
        EXOCON &= ~(1u << 2u);
    }

    /**
     * Toggle EXOCON's GEEN bit.
     *
     * Gating Event Enable
     */
    inline void toggle_EXOCON_GEEN() volatile
    {
        EXOCON ^= 1u << 2u;
    }

    /**
     * Get EXOCON's ISS field.
     *
     * Internal Trigger Source Selection
     */
    inline ERU0_EXOCON_ISS get_EXOCON_ISS(std::size_t index) volatile
    {
        return ERU0_EXOCON_ISS((EXOCON[index] >> 0u) & 0b11u);
    }

    /**
     * Set EXOCON's ISS field.
     *
     * Internal Trigger Source Selection
     */
    inline void set_EXOCON_ISS(std::size_t index,
                               ERU0_EXOCON_ISS value) volatile
    {
        uint32_t curr = EXOCON[index];

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        EXOCON[index] = curr;
    }

    /**
     * Get all of EXOCON's bit fields.
     *
     * (read-write) Event Output Trigger Control
     */
    inline void get_EXOCON(std::size_t index, bool &IPEN3, bool &IPEN2,
                           bool &IPEN1, bool &IPEN0, ERU0_EXOCON_GP &GP,
                           bool &PDR, bool &GEEN,
                           ERU0_EXOCON_ISS &ISS) volatile
    {
        uint32_t curr = EXOCON[index];

        IPEN3 = curr & (1u << 15u);
        IPEN2 = curr & (1u << 14u);
        IPEN1 = curr & (1u << 13u);
        IPEN0 = curr & (1u << 12u);
        GP = ERU0_EXOCON_GP((curr >> 4u) & 0b11u);
        PDR = curr & (1u << 3u);
        GEEN = curr & (1u << 2u);
        ISS = ERU0_EXOCON_ISS((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of EXOCON's bit fields.
     *
     * (read-write) Event Output Trigger Control
     */
    inline void set_EXOCON(std::size_t index, bool IPEN3, bool IPEN2,
                           bool IPEN1, bool IPEN0, ERU0_EXOCON_GP GP,
                           bool GEEN, ERU0_EXOCON_ISS ISS) volatile
    {
        uint32_t curr = EXOCON[index];

        curr &= ~(0b1u << 15u);
        curr |= (IPEN3 & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (IPEN2 & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (IPEN1 & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (IPEN0 & 0b1u) << 12u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(GP) & 0b11u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (GEEN & 0b1u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(ISS) & 0b11u) << 0u;

        EXOCON[index] = curr;
    }
};

static_assert(sizeof(eru0) == eru0::size);

static volatile eru0 *const ERU0 = reinterpret_cast<eru0 *>(0x50004800);

static volatile eru0 *const ERU1 = reinterpret_cast<eru0 *>(0x40044000);

}; // namespace XMC4700
