/**
 * \file
 * \brief Generated by ifgen (3.1.7).
 */
#pragma once

#include "../enums/CCU40_CC40_C0V_FFL.h"
#include "../enums/CCU40_CC40_CMC_CNTS.h"
#include "../enums/CCU40_CC40_CMC_OFS.h"
#include "../enums/CCU40_CC40_CMC_TCE.h"
#include "../enums/CCU40_CC40_CMC_TS.h"
#include "../enums/CCU40_CC40_ECRD0_FFL.h"
#include "../enums/CCU40_CC40_ECRD0_LCV.h"
#include "../enums/CCU40_CC40_INS_EV2EM.h"
#include "../enums/CCU40_CC40_INS_EV2IS.h"
#include "../enums/CCU40_CC40_INS_EV2LM.h"
#include "../enums/CCU40_CC40_INS_LPF2M.h"
#include "../enums/CCU40_CC40_INTS_E2AS.h"
#include "../enums/CCU40_CC40_PSL_PSL.h"
#include "../enums/CCU40_CC40_SRS_E2SR.h"
#include "../enums/CCU40_CC40_TCST_CDIR.h"
#include "../enums/CCU40_CC40_TCST_TRB.h"
#include "../enums/CCU40_CC40_TC_CAPC.h"
#include "../enums/CCU40_CC40_TC_CCS.h"
#include "../enums/CCU40_CC40_TC_CMOD.h"
#include "../enums/CCU40_CC40_TC_DIM.h"
#include "../enums/CCU40_CC40_TC_DITHE.h"
#include "../enums/CCU40_CC40_TC_ECM.h"
#include "../enums/CCU40_CC40_TC_EMS.h"
#include "../enums/CCU40_CC40_TC_EMT.h"
#include "../enums/CCU40_CC40_TC_ENDM.h"
#include "../enums/CCU40_CC40_TC_SCE.h"
#include "../enums/CCU40_CC40_TC_STRM.h"
#include "../enums/CCU40_CC40_TC_TCM.h"
#include "../enums/CCU40_CC40_TC_TRAPE.h"
#include "../enums/CCU40_CC40_TC_TRPSE.h"
#include "../enums/CCU40_CC40_TC_TRPSW.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * Capture Compare Unit 4 - Unit 0
 */
struct [[gnu::packed]] ccu40_cc40
{
    /* Constant attributes. */
    static constexpr std::size_t size =
        192; /*!< ccu40_cc40's size in bytes. */

    /* Fields. */
    uint32_t INS;             /*!< (read-write) Input Selector Configuration */
    uint32_t CMC;             /*!< (read-write) Connection Matrix Control */
    const uint32_t TCST = {}; /*!< (read-only) Slice Timer Status */
    uint32_t TCSET;           /*!< (write-only) Slice Timer Run Set */
    uint32_t TCCLR;           /*!< (write-only) Slice Timer Clear */
    uint32_t TC;              /*!< (read-write) Slice Timer Control */
    uint32_t PSL;             /*!< (read-write) Passive Level Config */
    const uint32_t DIT = {};  /*!< (read-only) Dither Config */
    uint32_t DITS;            /*!< (read-write) Dither Shadow Register */
    uint32_t PSC;             /*!< (read-write) Prescaler Control */
    uint32_t FPC;             /*!< (read-write) Floating Prescaler Control */
    uint32_t FPCS;            /*!< (read-write) Floating Prescaler Shadow */
    const uint32_t PR = {};   /*!< (read-only) Timer Period Value */
    uint32_t PRS;             /*!< (read-write) Timer Shadow Period Value */
    const uint32_t CR = {};   /*!< (read-only) Timer Compare Value */
    uint32_t CRS;             /*!< (read-write) Timer Shadow Compare Value */
    static constexpr std::size_t reserved_padding0_length = 12;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t TIMER;          /*!< (read-write) Timer Value */
    const uint32_t C0V = {}; /*!< (read-only) Capture Register 0 */
    const uint32_t C1V = {}; /*!< (read-only) Capture Register 1 */
    const uint32_t C2V = {}; /*!< (read-only) Capture Register 2 */
    const uint32_t C3V = {}; /*!< (read-only) Capture Register 3 */
    static constexpr std::size_t reserved_padding1_length = 7;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    const uint32_t INTS = {}; /*!< (read-only) Interrupt Status */
    uint32_t INTE;            /*!< (read-write) Interrupt Enable Control */
    uint32_t SRS;             /*!< (read-write) Service Request Selector */
    uint32_t SWS;             /*!< (write-only) Interrupt Status Set */
    uint32_t SWR;             /*!< (write-only) Interrupt Status Clear */
    const uint32_t reserved_padding2 = {};
    const uint32_t ECRD0 = {}; /*!< (read-only) Extended Read Back 0 */
    const uint32_t ECRD1 = {}; /*!< (read-only) Extended Read Back 1 */

    /* Methods. */

    /**
     * Get INS's LPF2M field.
     *
     * Event 2 Low Pass Filter Configuration
     */
    inline CCU40_CC40_INS_LPF2M get_INS_LPF2M() volatile
    {
        return CCU40_CC40_INS_LPF2M((INS >> 29u) & 0b11u);
    }

    /**
     * Set INS's LPF2M field.
     *
     * Event 2 Low Pass Filter Configuration
     */
    inline void set_INS_LPF2M(CCU40_CC40_INS_LPF2M value) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b11u << 29u);
        curr |= (std::to_underlying(value) & 0b11u) << 29u;

        INS = curr;
    }

    /**
     * Get INS's LPF1M field.
     *
     * Event 1 Low Pass Filter Configuration
     */
    inline CCU40_CC40_INS_LPF2M get_INS_LPF1M() volatile
    {
        return CCU40_CC40_INS_LPF2M((INS >> 27u) & 0b11u);
    }

    /**
     * Set INS's LPF1M field.
     *
     * Event 1 Low Pass Filter Configuration
     */
    inline void set_INS_LPF1M(CCU40_CC40_INS_LPF2M value) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        INS = curr;
    }

    /**
     * Get INS's LPF0M field.
     *
     * Event 0 Low Pass Filter Configuration
     */
    inline CCU40_CC40_INS_LPF2M get_INS_LPF0M() volatile
    {
        return CCU40_CC40_INS_LPF2M((INS >> 25u) & 0b11u);
    }

    /**
     * Set INS's LPF0M field.
     *
     * Event 0 Low Pass Filter Configuration
     */
    inline void set_INS_LPF0M(CCU40_CC40_INS_LPF2M value) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b11u << 25u);
        curr |= (std::to_underlying(value) & 0b11u) << 25u;

        INS = curr;
    }

    /**
     * Get INS's EV2LM bit.
     *
     * Event 2 Level Selection
     */
    inline CCU40_CC40_INS_EV2LM get_INS_EV2LM() volatile
    {
        return CCU40_CC40_INS_EV2LM(INS & (1u << 24u));
    }

    /**
     * Set INS's EV2LM bit.
     *
     * Event 2 Level Selection
     */
    inline void set_INS_EV2LM() volatile
    {
        INS |= 1u << 24u;
    }

    /**
     * Clear INS's EV2LM bit.
     *
     * Event 2 Level Selection
     */
    inline void clear_INS_EV2LM() volatile
    {
        INS &= ~(1u << 24u);
    }

    /**
     * Toggle INS's EV2LM bit.
     *
     * Event 2 Level Selection
     */
    inline void toggle_INS_EV2LM() volatile
    {
        INS ^= 1u << 24u;
    }

    /**
     * Get INS's EV1LM bit.
     *
     * Event 1 Level Selection
     */
    inline CCU40_CC40_INS_EV2LM get_INS_EV1LM() volatile
    {
        return CCU40_CC40_INS_EV2LM(INS & (1u << 23u));
    }

    /**
     * Set INS's EV1LM bit.
     *
     * Event 1 Level Selection
     */
    inline void set_INS_EV1LM() volatile
    {
        INS |= 1u << 23u;
    }

    /**
     * Clear INS's EV1LM bit.
     *
     * Event 1 Level Selection
     */
    inline void clear_INS_EV1LM() volatile
    {
        INS &= ~(1u << 23u);
    }

    /**
     * Toggle INS's EV1LM bit.
     *
     * Event 1 Level Selection
     */
    inline void toggle_INS_EV1LM() volatile
    {
        INS ^= 1u << 23u;
    }

    /**
     * Get INS's EV0LM bit.
     *
     * Event 0 Level Selection
     */
    inline CCU40_CC40_INS_EV2LM get_INS_EV0LM() volatile
    {
        return CCU40_CC40_INS_EV2LM(INS & (1u << 22u));
    }

    /**
     * Set INS's EV0LM bit.
     *
     * Event 0 Level Selection
     */
    inline void set_INS_EV0LM() volatile
    {
        INS |= 1u << 22u;
    }

    /**
     * Clear INS's EV0LM bit.
     *
     * Event 0 Level Selection
     */
    inline void clear_INS_EV0LM() volatile
    {
        INS &= ~(1u << 22u);
    }

    /**
     * Toggle INS's EV0LM bit.
     *
     * Event 0 Level Selection
     */
    inline void toggle_INS_EV0LM() volatile
    {
        INS ^= 1u << 22u;
    }

    /**
     * Get INS's EV2EM field.
     *
     * Event 2 Edge Selection
     */
    inline CCU40_CC40_INS_EV2EM get_INS_EV2EM() volatile
    {
        return CCU40_CC40_INS_EV2EM((INS >> 20u) & 0b11u);
    }

    /**
     * Set INS's EV2EM field.
     *
     * Event 2 Edge Selection
     */
    inline void set_INS_EV2EM(CCU40_CC40_INS_EV2EM value) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(value) & 0b11u) << 20u;

        INS = curr;
    }

    /**
     * Get INS's EV1EM field.
     *
     * Event 1 Edge Selection
     */
    inline CCU40_CC40_INS_EV2EM get_INS_EV1EM() volatile
    {
        return CCU40_CC40_INS_EV2EM((INS >> 18u) & 0b11u);
    }

    /**
     * Set INS's EV1EM field.
     *
     * Event 1 Edge Selection
     */
    inline void set_INS_EV1EM(CCU40_CC40_INS_EV2EM value) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(value) & 0b11u) << 18u;

        INS = curr;
    }

    /**
     * Get INS's EV0EM field.
     *
     * Event 0 Edge Selection
     */
    inline CCU40_CC40_INS_EV2EM get_INS_EV0EM() volatile
    {
        return CCU40_CC40_INS_EV2EM((INS >> 16u) & 0b11u);
    }

    /**
     * Set INS's EV0EM field.
     *
     * Event 0 Edge Selection
     */
    inline void set_INS_EV0EM(CCU40_CC40_INS_EV2EM value) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        INS = curr;
    }

    /**
     * Get INS's EV2IS field.
     *
     * Event 2 signal selection
     */
    inline CCU40_CC40_INS_EV2IS get_INS_EV2IS() volatile
    {
        return CCU40_CC40_INS_EV2IS((INS >> 8u) & 0b1111u);
    }

    /**
     * Set INS's EV2IS field.
     *
     * Event 2 signal selection
     */
    inline void set_INS_EV2IS(CCU40_CC40_INS_EV2IS value) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        INS = curr;
    }

    /**
     * Get INS's EV1IS field.
     *
     * Event 1 signal selection
     */
    inline CCU40_CC40_INS_EV2IS get_INS_EV1IS() volatile
    {
        return CCU40_CC40_INS_EV2IS((INS >> 4u) & 0b1111u);
    }

    /**
     * Set INS's EV1IS field.
     *
     * Event 1 signal selection
     */
    inline void set_INS_EV1IS(CCU40_CC40_INS_EV2IS value) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(value) & 0b1111u) << 4u;

        INS = curr;
    }

    /**
     * Get INS's EV0IS field.
     *
     * Event 0 signal selection
     */
    inline CCU40_CC40_INS_EV2IS get_INS_EV0IS() volatile
    {
        return CCU40_CC40_INS_EV2IS((INS >> 0u) & 0b1111u);
    }

    /**
     * Set INS's EV0IS field.
     *
     * Event 0 signal selection
     */
    inline void set_INS_EV0IS(CCU40_CC40_INS_EV2IS value) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        INS = curr;
    }

    /**
     * Get all of INS's bit fields.
     *
     * (read-write) Input Selector Configuration
     */
    inline void get_INS(
        CCU40_CC40_INS_LPF2M &LPF2M, CCU40_CC40_INS_LPF2M &LPF1M,
        CCU40_CC40_INS_LPF2M &LPF0M, CCU40_CC40_INS_EV2LM &EV2LM,
        CCU40_CC40_INS_EV2LM &EV1LM, CCU40_CC40_INS_EV2LM &EV0LM,
        CCU40_CC40_INS_EV2EM &EV2EM, CCU40_CC40_INS_EV2EM &EV1EM,
        CCU40_CC40_INS_EV2EM &EV0EM, CCU40_CC40_INS_EV2IS &EV2IS,
        CCU40_CC40_INS_EV2IS &EV1IS, CCU40_CC40_INS_EV2IS &EV0IS) volatile
    {
        uint32_t curr = INS;

        LPF2M = CCU40_CC40_INS_LPF2M((curr >> 29u) & 0b11u);
        LPF1M = CCU40_CC40_INS_LPF2M((curr >> 27u) & 0b11u);
        LPF0M = CCU40_CC40_INS_LPF2M((curr >> 25u) & 0b11u);
        EV2LM = CCU40_CC40_INS_EV2LM(curr & (1u << 24u));
        EV1LM = CCU40_CC40_INS_EV2LM(curr & (1u << 23u));
        EV0LM = CCU40_CC40_INS_EV2LM(curr & (1u << 22u));
        EV2EM = CCU40_CC40_INS_EV2EM((curr >> 20u) & 0b11u);
        EV1EM = CCU40_CC40_INS_EV2EM((curr >> 18u) & 0b11u);
        EV0EM = CCU40_CC40_INS_EV2EM((curr >> 16u) & 0b11u);
        EV2IS = CCU40_CC40_INS_EV2IS((curr >> 8u) & 0b1111u);
        EV1IS = CCU40_CC40_INS_EV2IS((curr >> 4u) & 0b1111u);
        EV0IS = CCU40_CC40_INS_EV2IS((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of INS's bit fields.
     *
     * (read-write) Input Selector Configuration
     */
    inline void set_INS(CCU40_CC40_INS_LPF2M LPF2M, CCU40_CC40_INS_LPF2M LPF1M,
                        CCU40_CC40_INS_LPF2M LPF0M, CCU40_CC40_INS_EV2LM EV2LM,
                        CCU40_CC40_INS_EV2LM EV1LM, CCU40_CC40_INS_EV2LM EV0LM,
                        CCU40_CC40_INS_EV2EM EV2EM, CCU40_CC40_INS_EV2EM EV1EM,
                        CCU40_CC40_INS_EV2EM EV0EM, CCU40_CC40_INS_EV2IS EV2IS,
                        CCU40_CC40_INS_EV2IS EV1IS,
                        CCU40_CC40_INS_EV2IS EV0IS) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b11u << 29u);
        curr |= (std::to_underlying(LPF2M) & 0b11u) << 29u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(LPF1M) & 0b11u) << 27u;
        curr &= ~(0b11u << 25u);
        curr |= (std::to_underlying(LPF0M) & 0b11u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (std::to_underlying(EV2LM) & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (std::to_underlying(EV1LM) & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (std::to_underlying(EV0LM) & 0b1u) << 22u;
        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(EV2EM) & 0b11u) << 20u;
        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(EV1EM) & 0b11u) << 18u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(EV0EM) & 0b11u) << 16u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(EV2IS) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(EV1IS) & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(EV0IS) & 0b1111u) << 0u;

        INS = curr;
    }

    /**
     * Get CMC's TCE bit.
     *
     * Timer Concatenation Enable
     */
    inline CCU40_CC40_CMC_TCE get_CMC_TCE() volatile
    {
        return CCU40_CC40_CMC_TCE(CMC & (1u << 20u));
    }

    /**
     * Set CMC's TCE bit.
     *
     * Timer Concatenation Enable
     */
    inline void set_CMC_TCE() volatile
    {
        CMC |= 1u << 20u;
    }

    /**
     * Clear CMC's TCE bit.
     *
     * Timer Concatenation Enable
     */
    inline void clear_CMC_TCE() volatile
    {
        CMC &= ~(1u << 20u);
    }

    /**
     * Toggle CMC's TCE bit.
     *
     * Timer Concatenation Enable
     */
    inline void toggle_CMC_TCE() volatile
    {
        CMC ^= 1u << 20u;
    }

    /**
     * Get CMC's MOS field.
     *
     * External Modulation Functionality Selector
     */
    inline uint8_t get_CMC_MOS() volatile
    {
        return (CMC >> 18u) & 0b11u;
    }

    /**
     * Set CMC's MOS field.
     *
     * External Modulation Functionality Selector
     */
    inline void set_CMC_MOS(uint8_t value) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b11u << 18u);
        curr |= (value & 0b11u) << 18u;

        CMC = curr;
    }

    /**
     * Get CMC's TS bit.
     *
     * Trap Function Selector
     */
    inline CCU40_CC40_CMC_TS get_CMC_TS() volatile
    {
        return CCU40_CC40_CMC_TS(CMC & (1u << 17u));
    }

    /**
     * Set CMC's TS bit.
     *
     * Trap Function Selector
     */
    inline void set_CMC_TS() volatile
    {
        CMC |= 1u << 17u;
    }

    /**
     * Clear CMC's TS bit.
     *
     * Trap Function Selector
     */
    inline void clear_CMC_TS() volatile
    {
        CMC &= ~(1u << 17u);
    }

    /**
     * Toggle CMC's TS bit.
     *
     * Trap Function Selector
     */
    inline void toggle_CMC_TS() volatile
    {
        CMC ^= 1u << 17u;
    }

    /**
     * Get CMC's OFS bit.
     *
     * Override Function Selector
     */
    inline CCU40_CC40_CMC_OFS get_CMC_OFS() volatile
    {
        return CCU40_CC40_CMC_OFS(CMC & (1u << 16u));
    }

    /**
     * Set CMC's OFS bit.
     *
     * Override Function Selector
     */
    inline void set_CMC_OFS() volatile
    {
        CMC |= 1u << 16u;
    }

    /**
     * Clear CMC's OFS bit.
     *
     * Override Function Selector
     */
    inline void clear_CMC_OFS() volatile
    {
        CMC &= ~(1u << 16u);
    }

    /**
     * Toggle CMC's OFS bit.
     *
     * Override Function Selector
     */
    inline void toggle_CMC_OFS() volatile
    {
        CMC ^= 1u << 16u;
    }

    /**
     * Get CMC's CNTS field.
     *
     * External Count Selector
     */
    inline CCU40_CC40_CMC_CNTS get_CMC_CNTS() volatile
    {
        return CCU40_CC40_CMC_CNTS((CMC >> 14u) & 0b11u);
    }

    /**
     * Set CMC's CNTS field.
     *
     * External Count Selector
     */
    inline void set_CMC_CNTS(CCU40_CC40_CMC_CNTS value) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(value) & 0b11u) << 14u;

        CMC = curr;
    }

    /**
     * Get CMC's LDS field.
     *
     * External Timer Load Functionality Selector
     */
    inline uint8_t get_CMC_LDS() volatile
    {
        return (CMC >> 12u) & 0b11u;
    }

    /**
     * Set CMC's LDS field.
     *
     * External Timer Load Functionality Selector
     */
    inline void set_CMC_LDS(uint8_t value) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b11u << 12u);
        curr |= (value & 0b11u) << 12u;

        CMC = curr;
    }

    /**
     * Get CMC's UDS field.
     *
     * External Up/Down Functionality Selector
     */
    inline CCU40_CC40_CMC_CNTS get_CMC_UDS() volatile
    {
        return CCU40_CC40_CMC_CNTS((CMC >> 10u) & 0b11u);
    }

    /**
     * Set CMC's UDS field.
     *
     * External Up/Down Functionality Selector
     */
    inline void set_CMC_UDS(CCU40_CC40_CMC_CNTS value) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(value) & 0b11u) << 10u;

        CMC = curr;
    }

    /**
     * Get CMC's GATES field.
     *
     * External Gate Functionality Selector
     */
    inline CCU40_CC40_CMC_CNTS get_CMC_GATES() volatile
    {
        return CCU40_CC40_CMC_CNTS((CMC >> 8u) & 0b11u);
    }

    /**
     * Set CMC's GATES field.
     *
     * External Gate Functionality Selector
     */
    inline void set_CMC_GATES(CCU40_CC40_CMC_CNTS value) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        CMC = curr;
    }

    /**
     * Get CMC's CAP1S field.
     *
     * External Capture 1 Functionality Selector
     */
    inline CCU40_CC40_CMC_CNTS get_CMC_CAP1S() volatile
    {
        return CCU40_CC40_CMC_CNTS((CMC >> 6u) & 0b11u);
    }

    /**
     * Set CMC's CAP1S field.
     *
     * External Capture 1 Functionality Selector
     */
    inline void set_CMC_CAP1S(CCU40_CC40_CMC_CNTS value) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(value) & 0b11u) << 6u;

        CMC = curr;
    }

    /**
     * Get CMC's CAP0S field.
     *
     * External Capture 0 Functionality Selector
     */
    inline CCU40_CC40_CMC_CNTS get_CMC_CAP0S() volatile
    {
        return CCU40_CC40_CMC_CNTS((CMC >> 4u) & 0b11u);
    }

    /**
     * Set CMC's CAP0S field.
     *
     * External Capture 0 Functionality Selector
     */
    inline void set_CMC_CAP0S(CCU40_CC40_CMC_CNTS value) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        CMC = curr;
    }

    /**
     * Get CMC's ENDS field.
     *
     * External Stop Functionality Selector
     */
    inline CCU40_CC40_CMC_CNTS get_CMC_ENDS() volatile
    {
        return CCU40_CC40_CMC_CNTS((CMC >> 2u) & 0b11u);
    }

    /**
     * Set CMC's ENDS field.
     *
     * External Stop Functionality Selector
     */
    inline void set_CMC_ENDS(CCU40_CC40_CMC_CNTS value) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        CMC = curr;
    }

    /**
     * Get CMC's STRTS field.
     *
     * External Start Functionality Selector
     */
    inline CCU40_CC40_CMC_CNTS get_CMC_STRTS() volatile
    {
        return CCU40_CC40_CMC_CNTS((CMC >> 0u) & 0b11u);
    }

    /**
     * Set CMC's STRTS field.
     *
     * External Start Functionality Selector
     */
    inline void set_CMC_STRTS(CCU40_CC40_CMC_CNTS value) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CMC = curr;
    }

    /**
     * Get all of CMC's bit fields.
     *
     * (read-write) Connection Matrix Control
     */
    inline void get_CMC(CCU40_CC40_CMC_TCE &TCE, uint8_t &MOS,
                        CCU40_CC40_CMC_TS &TS, CCU40_CC40_CMC_OFS &OFS,
                        CCU40_CC40_CMC_CNTS &CNTS, uint8_t &LDS,
                        CCU40_CC40_CMC_CNTS &UDS, CCU40_CC40_CMC_CNTS &GATES,
                        CCU40_CC40_CMC_CNTS &CAP1S, CCU40_CC40_CMC_CNTS &CAP0S,
                        CCU40_CC40_CMC_CNTS &ENDS,
                        CCU40_CC40_CMC_CNTS &STRTS) volatile
    {
        uint32_t curr = CMC;

        TCE = CCU40_CC40_CMC_TCE(curr & (1u << 20u));
        MOS = (curr >> 18u) & 0b11u;
        TS = CCU40_CC40_CMC_TS(curr & (1u << 17u));
        OFS = CCU40_CC40_CMC_OFS(curr & (1u << 16u));
        CNTS = CCU40_CC40_CMC_CNTS((curr >> 14u) & 0b11u);
        LDS = (curr >> 12u) & 0b11u;
        UDS = CCU40_CC40_CMC_CNTS((curr >> 10u) & 0b11u);
        GATES = CCU40_CC40_CMC_CNTS((curr >> 8u) & 0b11u);
        CAP1S = CCU40_CC40_CMC_CNTS((curr >> 6u) & 0b11u);
        CAP0S = CCU40_CC40_CMC_CNTS((curr >> 4u) & 0b11u);
        ENDS = CCU40_CC40_CMC_CNTS((curr >> 2u) & 0b11u);
        STRTS = CCU40_CC40_CMC_CNTS((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of CMC's bit fields.
     *
     * (read-write) Connection Matrix Control
     */
    inline void set_CMC(CCU40_CC40_CMC_TCE TCE, uint8_t MOS,
                        CCU40_CC40_CMC_TS TS, CCU40_CC40_CMC_OFS OFS,
                        CCU40_CC40_CMC_CNTS CNTS, uint8_t LDS,
                        CCU40_CC40_CMC_CNTS UDS, CCU40_CC40_CMC_CNTS GATES,
                        CCU40_CC40_CMC_CNTS CAP1S, CCU40_CC40_CMC_CNTS CAP0S,
                        CCU40_CC40_CMC_CNTS ENDS,
                        CCU40_CC40_CMC_CNTS STRTS) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b1u << 20u);
        curr |= (std::to_underlying(TCE) & 0b1u) << 20u;
        curr &= ~(0b11u << 18u);
        curr |= (MOS & 0b11u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(TS) & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (std::to_underlying(OFS) & 0b1u) << 16u;
        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(CNTS) & 0b11u) << 14u;
        curr &= ~(0b11u << 12u);
        curr |= (LDS & 0b11u) << 12u;
        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(UDS) & 0b11u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(GATES) & 0b11u) << 8u;
        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(CAP1S) & 0b11u) << 6u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(CAP0S) & 0b11u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(ENDS) & 0b11u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(STRTS) & 0b11u) << 0u;

        CMC = curr;
    }

    /**
     * Get TCST's CDIR bit.
     *
     * Timer Counting Direction
     */
    inline CCU40_CC40_TCST_CDIR get_TCST_CDIR() volatile
    {
        return CCU40_CC40_TCST_CDIR(TCST & (1u << 1u));
    }

    /**
     * Get TCST's TRB bit.
     *
     * Timer Run Bit
     */
    inline CCU40_CC40_TCST_TRB get_TCST_TRB() volatile
    {
        return CCU40_CC40_TCST_TRB(TCST & (1u << 0u));
    }

    /**
     * Get all of TCST's bit fields.
     *
     * (read-only) Slice Timer Status
     */
    inline void get_TCST(CCU40_CC40_TCST_CDIR &CDIR,
                         CCU40_CC40_TCST_TRB &TRB) volatile
    {
        uint32_t curr = TCST;

        CDIR = CCU40_CC40_TCST_CDIR(curr & (1u << 1u));
        TRB = CCU40_CC40_TCST_TRB(curr & (1u << 0u));
    }

    /**
     * Set TCSET's TRBS bit.
     *
     * Timer Run Bit set
     */
    inline void set_TCSET_TRBS() volatile
    {
        TCSET |= 1u << 0u;
    }

    /**
     * Clear TCSET's TRBS bit.
     *
     * Timer Run Bit set
     */
    inline void clear_TCSET_TRBS() volatile
    {
        TCSET &= ~(1u << 0u);
    }

    /**
     * Toggle TCSET's TRBS bit.
     *
     * Timer Run Bit set
     */
    inline void toggle_TCSET_TRBS() volatile
    {
        TCSET ^= 1u << 0u;
    }

    /**
     * Set TCCLR's DITC bit.
     *
     * Dither Counter Clear
     */
    inline void set_TCCLR_DITC() volatile
    {
        TCCLR |= 1u << 2u;
    }

    /**
     * Clear TCCLR's DITC bit.
     *
     * Dither Counter Clear
     */
    inline void clear_TCCLR_DITC() volatile
    {
        TCCLR &= ~(1u << 2u);
    }

    /**
     * Toggle TCCLR's DITC bit.
     *
     * Dither Counter Clear
     */
    inline void toggle_TCCLR_DITC() volatile
    {
        TCCLR ^= 1u << 2u;
    }

    /**
     * Set TCCLR's TCC bit.
     *
     * Timer Clear
     */
    inline void set_TCCLR_TCC() volatile
    {
        TCCLR |= 1u << 1u;
    }

    /**
     * Clear TCCLR's TCC bit.
     *
     * Timer Clear
     */
    inline void clear_TCCLR_TCC() volatile
    {
        TCCLR &= ~(1u << 1u);
    }

    /**
     * Toggle TCCLR's TCC bit.
     *
     * Timer Clear
     */
    inline void toggle_TCCLR_TCC() volatile
    {
        TCCLR ^= 1u << 1u;
    }

    /**
     * Set TCCLR's TRBC bit.
     *
     * Timer Run Bit Clear
     */
    inline void set_TCCLR_TRBC() volatile
    {
        TCCLR |= 1u << 0u;
    }

    /**
     * Clear TCCLR's TRBC bit.
     *
     * Timer Run Bit Clear
     */
    inline void clear_TCCLR_TRBC() volatile
    {
        TCCLR &= ~(1u << 0u);
    }

    /**
     * Toggle TCCLR's TRBC bit.
     *
     * Timer Run Bit Clear
     */
    inline void toggle_TCCLR_TRBC() volatile
    {
        TCCLR ^= 1u << 0u;
    }

    /**
     * Set all of TCCLR's bit fields.
     *
     * (write-only) Slice Timer Clear
     */
    inline void set_TCCLR(bool DITC, bool TCC, bool TRBC) volatile
    {
        uint32_t curr = TCCLR;

        curr &= ~(0b1u << 2u);
        curr |= (DITC & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TCC & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TRBC & 0b1u) << 0u;

        TCCLR = curr;
    }

    /**
     * Get TC's MCME bit.
     *
     * Multi Channel Mode Enable
     */
    inline CCU40_CC40_CMC_TCE get_TC_MCME() volatile
    {
        return CCU40_CC40_CMC_TCE(TC & (1u << 25u));
    }

    /**
     * Set TC's MCME bit.
     *
     * Multi Channel Mode Enable
     */
    inline void set_TC_MCME() volatile
    {
        TC |= 1u << 25u;
    }

    /**
     * Clear TC's MCME bit.
     *
     * Multi Channel Mode Enable
     */
    inline void clear_TC_MCME() volatile
    {
        TC &= ~(1u << 25u);
    }

    /**
     * Toggle TC's MCME bit.
     *
     * Multi Channel Mode Enable
     */
    inline void toggle_TC_MCME() volatile
    {
        TC ^= 1u << 25u;
    }

    /**
     * Get TC's EMT bit.
     *
     * External Modulation Type
     */
    inline CCU40_CC40_TC_EMT get_TC_EMT() volatile
    {
        return CCU40_CC40_TC_EMT(TC & (1u << 24u));
    }

    /**
     * Set TC's EMT bit.
     *
     * External Modulation Type
     */
    inline void set_TC_EMT() volatile
    {
        TC |= 1u << 24u;
    }

    /**
     * Clear TC's EMT bit.
     *
     * External Modulation Type
     */
    inline void clear_TC_EMT() volatile
    {
        TC &= ~(1u << 24u);
    }

    /**
     * Toggle TC's EMT bit.
     *
     * External Modulation Type
     */
    inline void toggle_TC_EMT() volatile
    {
        TC ^= 1u << 24u;
    }

    /**
     * Get TC's EMS bit.
     *
     * External Modulation Synchronization
     */
    inline CCU40_CC40_TC_EMS get_TC_EMS() volatile
    {
        return CCU40_CC40_TC_EMS(TC & (1u << 23u));
    }

    /**
     * Set TC's EMS bit.
     *
     * External Modulation Synchronization
     */
    inline void set_TC_EMS() volatile
    {
        TC |= 1u << 23u;
    }

    /**
     * Clear TC's EMS bit.
     *
     * External Modulation Synchronization
     */
    inline void clear_TC_EMS() volatile
    {
        TC &= ~(1u << 23u);
    }

    /**
     * Toggle TC's EMS bit.
     *
     * External Modulation Synchronization
     */
    inline void toggle_TC_EMS() volatile
    {
        TC ^= 1u << 23u;
    }

    /**
     * Get TC's TRPSW bit.
     *
     * TRAP State Clear Control
     */
    inline CCU40_CC40_TC_TRPSW get_TC_TRPSW() volatile
    {
        return CCU40_CC40_TC_TRPSW(TC & (1u << 22u));
    }

    /**
     * Set TC's TRPSW bit.
     *
     * TRAP State Clear Control
     */
    inline void set_TC_TRPSW() volatile
    {
        TC |= 1u << 22u;
    }

    /**
     * Clear TC's TRPSW bit.
     *
     * TRAP State Clear Control
     */
    inline void clear_TC_TRPSW() volatile
    {
        TC &= ~(1u << 22u);
    }

    /**
     * Toggle TC's TRPSW bit.
     *
     * TRAP State Clear Control
     */
    inline void toggle_TC_TRPSW() volatile
    {
        TC ^= 1u << 22u;
    }

    /**
     * Get TC's TRPSE bit.
     *
     * TRAP Synchronization Enable
     */
    inline CCU40_CC40_TC_TRPSE get_TC_TRPSE() volatile
    {
        return CCU40_CC40_TC_TRPSE(TC & (1u << 21u));
    }

    /**
     * Set TC's TRPSE bit.
     *
     * TRAP Synchronization Enable
     */
    inline void set_TC_TRPSE() volatile
    {
        TC |= 1u << 21u;
    }

    /**
     * Clear TC's TRPSE bit.
     *
     * TRAP Synchronization Enable
     */
    inline void clear_TC_TRPSE() volatile
    {
        TC &= ~(1u << 21u);
    }

    /**
     * Toggle TC's TRPSE bit.
     *
     * TRAP Synchronization Enable
     */
    inline void toggle_TC_TRPSE() volatile
    {
        TC ^= 1u << 21u;
    }

    /**
     * Get TC's TRAPE bit.
     *
     * TRAP enable
     */
    inline CCU40_CC40_TC_TRAPE get_TC_TRAPE() volatile
    {
        return CCU40_CC40_TC_TRAPE(TC & (1u << 17u));
    }

    /**
     * Set TC's TRAPE bit.
     *
     * TRAP enable
     */
    inline void set_TC_TRAPE() volatile
    {
        TC |= 1u << 17u;
    }

    /**
     * Clear TC's TRAPE bit.
     *
     * TRAP enable
     */
    inline void clear_TC_TRAPE() volatile
    {
        TC &= ~(1u << 17u);
    }

    /**
     * Toggle TC's TRAPE bit.
     *
     * TRAP enable
     */
    inline void toggle_TC_TRAPE() volatile
    {
        TC ^= 1u << 17u;
    }

    /**
     * Get TC's FPE bit.
     *
     * Floating Prescaler enable
     */
    inline CCU40_CC40_CMC_TCE get_TC_FPE() volatile
    {
        return CCU40_CC40_CMC_TCE(TC & (1u << 16u));
    }

    /**
     * Set TC's FPE bit.
     *
     * Floating Prescaler enable
     */
    inline void set_TC_FPE() volatile
    {
        TC |= 1u << 16u;
    }

    /**
     * Clear TC's FPE bit.
     *
     * Floating Prescaler enable
     */
    inline void clear_TC_FPE() volatile
    {
        TC &= ~(1u << 16u);
    }

    /**
     * Toggle TC's FPE bit.
     *
     * Floating Prescaler enable
     */
    inline void toggle_TC_FPE() volatile
    {
        TC ^= 1u << 16u;
    }

    /**
     * Get TC's DIM bit.
     *
     * Dither input selector
     */
    inline CCU40_CC40_TC_DIM get_TC_DIM() volatile
    {
        return CCU40_CC40_TC_DIM(TC & (1u << 15u));
    }

    /**
     * Set TC's DIM bit.
     *
     * Dither input selector
     */
    inline void set_TC_DIM() volatile
    {
        TC |= 1u << 15u;
    }

    /**
     * Clear TC's DIM bit.
     *
     * Dither input selector
     */
    inline void clear_TC_DIM() volatile
    {
        TC &= ~(1u << 15u);
    }

    /**
     * Toggle TC's DIM bit.
     *
     * Dither input selector
     */
    inline void toggle_TC_DIM() volatile
    {
        TC ^= 1u << 15u;
    }

    /**
     * Get TC's DITHE field.
     *
     * Dither Enable
     */
    inline CCU40_CC40_TC_DITHE get_TC_DITHE() volatile
    {
        return CCU40_CC40_TC_DITHE((TC >> 13u) & 0b11u);
    }

    /**
     * Set TC's DITHE field.
     *
     * Dither Enable
     */
    inline void set_TC_DITHE(CCU40_CC40_TC_DITHE value) volatile
    {
        uint32_t curr = TC;

        curr &= ~(0b11u << 13u);
        curr |= (std::to_underlying(value) & 0b11u) << 13u;

        TC = curr;
    }

    /**
     * Get TC's CCS bit.
     *
     * Continuous Capture Enable
     */
    inline CCU40_CC40_TC_CCS get_TC_CCS() volatile
    {
        return CCU40_CC40_TC_CCS(TC & (1u << 12u));
    }

    /**
     * Set TC's CCS bit.
     *
     * Continuous Capture Enable
     */
    inline void set_TC_CCS() volatile
    {
        TC |= 1u << 12u;
    }

    /**
     * Clear TC's CCS bit.
     *
     * Continuous Capture Enable
     */
    inline void clear_TC_CCS() volatile
    {
        TC &= ~(1u << 12u);
    }

    /**
     * Toggle TC's CCS bit.
     *
     * Continuous Capture Enable
     */
    inline void toggle_TC_CCS() volatile
    {
        TC ^= 1u << 12u;
    }

    /**
     * Get TC's SCE bit.
     *
     * Equal Capture Event enable
     */
    inline CCU40_CC40_TC_SCE get_TC_SCE() volatile
    {
        return CCU40_CC40_TC_SCE(TC & (1u << 11u));
    }

    /**
     * Set TC's SCE bit.
     *
     * Equal Capture Event enable
     */
    inline void set_TC_SCE() volatile
    {
        TC |= 1u << 11u;
    }

    /**
     * Clear TC's SCE bit.
     *
     * Equal Capture Event enable
     */
    inline void clear_TC_SCE() volatile
    {
        TC &= ~(1u << 11u);
    }

    /**
     * Toggle TC's SCE bit.
     *
     * Equal Capture Event enable
     */
    inline void toggle_TC_SCE() volatile
    {
        TC ^= 1u << 11u;
    }

    /**
     * Get TC's STRM bit.
     *
     * Extended Start Function Control
     */
    inline CCU40_CC40_TC_STRM get_TC_STRM() volatile
    {
        return CCU40_CC40_TC_STRM(TC & (1u << 10u));
    }

    /**
     * Set TC's STRM bit.
     *
     * Extended Start Function Control
     */
    inline void set_TC_STRM() volatile
    {
        TC |= 1u << 10u;
    }

    /**
     * Clear TC's STRM bit.
     *
     * Extended Start Function Control
     */
    inline void clear_TC_STRM() volatile
    {
        TC &= ~(1u << 10u);
    }

    /**
     * Toggle TC's STRM bit.
     *
     * Extended Start Function Control
     */
    inline void toggle_TC_STRM() volatile
    {
        TC ^= 1u << 10u;
    }

    /**
     * Get TC's ENDM field.
     *
     * Extended Stop Function Control
     */
    inline CCU40_CC40_TC_ENDM get_TC_ENDM() volatile
    {
        return CCU40_CC40_TC_ENDM((TC >> 8u) & 0b11u);
    }

    /**
     * Set TC's ENDM field.
     *
     * Extended Stop Function Control
     */
    inline void set_TC_ENDM(CCU40_CC40_TC_ENDM value) volatile
    {
        uint32_t curr = TC;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        TC = curr;
    }

    /**
     * Get TC's CAPC field.
     *
     * Clear on Capture Control
     */
    inline CCU40_CC40_TC_CAPC get_TC_CAPC() volatile
    {
        return CCU40_CC40_TC_CAPC((TC >> 5u) & 0b11u);
    }

    /**
     * Set TC's CAPC field.
     *
     * Clear on Capture Control
     */
    inline void set_TC_CAPC(CCU40_CC40_TC_CAPC value) volatile
    {
        uint32_t curr = TC;

        curr &= ~(0b11u << 5u);
        curr |= (std::to_underlying(value) & 0b11u) << 5u;

        TC = curr;
    }

    /**
     * Get TC's ECM bit.
     *
     * Extended Capture Mode
     */
    inline CCU40_CC40_TC_ECM get_TC_ECM() volatile
    {
        return CCU40_CC40_TC_ECM(TC & (1u << 4u));
    }

    /**
     * Set TC's ECM bit.
     *
     * Extended Capture Mode
     */
    inline void set_TC_ECM() volatile
    {
        TC |= 1u << 4u;
    }

    /**
     * Clear TC's ECM bit.
     *
     * Extended Capture Mode
     */
    inline void clear_TC_ECM() volatile
    {
        TC &= ~(1u << 4u);
    }

    /**
     * Toggle TC's ECM bit.
     *
     * Extended Capture Mode
     */
    inline void toggle_TC_ECM() volatile
    {
        TC ^= 1u << 4u;
    }

    /**
     * Get TC's CMOD bit.
     *
     * Capture Compare Mode
     */
    inline CCU40_CC40_TC_CMOD get_TC_CMOD() volatile
    {
        return CCU40_CC40_TC_CMOD(TC & (1u << 3u));
    }

    /**
     * Get TC's CLST bit.
     *
     * Shadow Transfer on Clear
     */
    inline bool get_TC_CLST() volatile
    {
        return TC & (1u << 2u);
    }

    /**
     * Set TC's CLST bit.
     *
     * Shadow Transfer on Clear
     */
    inline void set_TC_CLST() volatile
    {
        TC |= 1u << 2u;
    }

    /**
     * Clear TC's CLST bit.
     *
     * Shadow Transfer on Clear
     */
    inline void clear_TC_CLST() volatile
    {
        TC &= ~(1u << 2u);
    }

    /**
     * Toggle TC's CLST bit.
     *
     * Shadow Transfer on Clear
     */
    inline void toggle_TC_CLST() volatile
    {
        TC ^= 1u << 2u;
    }

    /**
     * Get TC's TSSM bit.
     *
     * Timer Single Shot Mode
     */
    inline CCU40_CC40_CMC_TCE get_TC_TSSM() volatile
    {
        return CCU40_CC40_CMC_TCE(TC & (1u << 1u));
    }

    /**
     * Set TC's TSSM bit.
     *
     * Timer Single Shot Mode
     */
    inline void set_TC_TSSM() volatile
    {
        TC |= 1u << 1u;
    }

    /**
     * Clear TC's TSSM bit.
     *
     * Timer Single Shot Mode
     */
    inline void clear_TC_TSSM() volatile
    {
        TC &= ~(1u << 1u);
    }

    /**
     * Toggle TC's TSSM bit.
     *
     * Timer Single Shot Mode
     */
    inline void toggle_TC_TSSM() volatile
    {
        TC ^= 1u << 1u;
    }

    /**
     * Get TC's TCM bit.
     *
     * Timer Counting Mode
     */
    inline CCU40_CC40_TC_TCM get_TC_TCM() volatile
    {
        return CCU40_CC40_TC_TCM(TC & (1u << 0u));
    }

    /**
     * Set TC's TCM bit.
     *
     * Timer Counting Mode
     */
    inline void set_TC_TCM() volatile
    {
        TC |= 1u << 0u;
    }

    /**
     * Clear TC's TCM bit.
     *
     * Timer Counting Mode
     */
    inline void clear_TC_TCM() volatile
    {
        TC &= ~(1u << 0u);
    }

    /**
     * Toggle TC's TCM bit.
     *
     * Timer Counting Mode
     */
    inline void toggle_TC_TCM() volatile
    {
        TC ^= 1u << 0u;
    }

    /**
     * Get all of TC's bit fields.
     *
     * (read-write) Slice Timer Control
     */
    inline void get_TC(CCU40_CC40_CMC_TCE &MCME, CCU40_CC40_TC_EMT &EMT,
                       CCU40_CC40_TC_EMS &EMS, CCU40_CC40_TC_TRPSW &TRPSW,
                       CCU40_CC40_TC_TRPSE &TRPSE, CCU40_CC40_TC_TRAPE &TRAPE,
                       CCU40_CC40_CMC_TCE &FPE, CCU40_CC40_TC_DIM &DIM,
                       CCU40_CC40_TC_DITHE &DITHE, CCU40_CC40_TC_CCS &CCS,
                       CCU40_CC40_TC_SCE &SCE, CCU40_CC40_TC_STRM &STRM,
                       CCU40_CC40_TC_ENDM &ENDM, CCU40_CC40_TC_CAPC &CAPC,
                       CCU40_CC40_TC_ECM &ECM, CCU40_CC40_TC_CMOD &CMOD,
                       bool &CLST, CCU40_CC40_CMC_TCE &TSSM,
                       CCU40_CC40_TC_TCM &TCM) volatile
    {
        uint32_t curr = TC;

        MCME = CCU40_CC40_CMC_TCE(curr & (1u << 25u));
        EMT = CCU40_CC40_TC_EMT(curr & (1u << 24u));
        EMS = CCU40_CC40_TC_EMS(curr & (1u << 23u));
        TRPSW = CCU40_CC40_TC_TRPSW(curr & (1u << 22u));
        TRPSE = CCU40_CC40_TC_TRPSE(curr & (1u << 21u));
        TRAPE = CCU40_CC40_TC_TRAPE(curr & (1u << 17u));
        FPE = CCU40_CC40_CMC_TCE(curr & (1u << 16u));
        DIM = CCU40_CC40_TC_DIM(curr & (1u << 15u));
        DITHE = CCU40_CC40_TC_DITHE((curr >> 13u) & 0b11u);
        CCS = CCU40_CC40_TC_CCS(curr & (1u << 12u));
        SCE = CCU40_CC40_TC_SCE(curr & (1u << 11u));
        STRM = CCU40_CC40_TC_STRM(curr & (1u << 10u));
        ENDM = CCU40_CC40_TC_ENDM((curr >> 8u) & 0b11u);
        CAPC = CCU40_CC40_TC_CAPC((curr >> 5u) & 0b11u);
        ECM = CCU40_CC40_TC_ECM(curr & (1u << 4u));
        CMOD = CCU40_CC40_TC_CMOD(curr & (1u << 3u));
        CLST = curr & (1u << 2u);
        TSSM = CCU40_CC40_CMC_TCE(curr & (1u << 1u));
        TCM = CCU40_CC40_TC_TCM(curr & (1u << 0u));
    }

    /**
     * Set all of TC's bit fields.
     *
     * (read-write) Slice Timer Control
     */
    inline void set_TC(CCU40_CC40_CMC_TCE MCME, CCU40_CC40_TC_EMT EMT,
                       CCU40_CC40_TC_EMS EMS, CCU40_CC40_TC_TRPSW TRPSW,
                       CCU40_CC40_TC_TRPSE TRPSE, CCU40_CC40_TC_TRAPE TRAPE,
                       CCU40_CC40_CMC_TCE FPE, CCU40_CC40_TC_DIM DIM,
                       CCU40_CC40_TC_DITHE DITHE, CCU40_CC40_TC_CCS CCS,
                       CCU40_CC40_TC_SCE SCE, CCU40_CC40_TC_STRM STRM,
                       CCU40_CC40_TC_ENDM ENDM, CCU40_CC40_TC_CAPC CAPC,
                       CCU40_CC40_TC_ECM ECM, bool CLST,
                       CCU40_CC40_CMC_TCE TSSM, CCU40_CC40_TC_TCM TCM) volatile
    {
        uint32_t curr = TC;

        curr &= ~(0b1u << 25u);
        curr |= (std::to_underlying(MCME) & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (std::to_underlying(EMT) & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (std::to_underlying(EMS) & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (std::to_underlying(TRPSW) & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (std::to_underlying(TRPSE) & 0b1u) << 21u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(TRAPE) & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (std::to_underlying(FPE) & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (std::to_underlying(DIM) & 0b1u) << 15u;
        curr &= ~(0b11u << 13u);
        curr |= (std::to_underlying(DITHE) & 0b11u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (std::to_underlying(CCS) & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (std::to_underlying(SCE) & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (std::to_underlying(STRM) & 0b1u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(ENDM) & 0b11u) << 8u;
        curr &= ~(0b11u << 5u);
        curr |= (std::to_underlying(CAPC) & 0b11u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (std::to_underlying(ECM) & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (CLST & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(TSSM) & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(TCM) & 0b1u) << 0u;

        TC = curr;
    }

    /**
     * Get PSL's PSL bit.
     *
     * Output Passive Level
     */
    inline CCU40_CC40_PSL_PSL get_PSL_PSL() volatile
    {
        return CCU40_CC40_PSL_PSL(PSL & (1u << 0u));
    }

    /**
     * Set PSL's PSL bit.
     *
     * Output Passive Level
     */
    inline void set_PSL_PSL() volatile
    {
        PSL |= 1u << 0u;
    }

    /**
     * Clear PSL's PSL bit.
     *
     * Output Passive Level
     */
    inline void clear_PSL_PSL() volatile
    {
        PSL &= ~(1u << 0u);
    }

    /**
     * Toggle PSL's PSL bit.
     *
     * Output Passive Level
     */
    inline void toggle_PSL_PSL() volatile
    {
        PSL ^= 1u << 0u;
    }

    /**
     * Get DIT's DCNT field.
     *
     * Dither counter actual value
     */
    inline uint8_t get_DIT_DCNT() volatile
    {
        return (DIT >> 8u) & 0b1111u;
    }

    /**
     * Get DIT's DCV field.
     *
     * Dither compare Value
     */
    inline uint8_t get_DIT_DCV() volatile
    {
        return (DIT >> 0u) & 0b1111u;
    }

    /**
     * Get all of DIT's bit fields.
     *
     * (read-only) Dither Config
     */
    inline void get_DIT(uint8_t &DCNT, uint8_t &DCV) volatile
    {
        uint32_t curr = DIT;

        DCNT = (curr >> 8u) & 0b1111u;
        DCV = (curr >> 0u) & 0b1111u;
    }

    /**
     * Get DITS's DCVS field.
     *
     * Dither Shadow Compare Value
     */
    inline uint8_t get_DITS_DCVS() volatile
    {
        return (DITS >> 0u) & 0b1111u;
    }

    /**
     * Set DITS's DCVS field.
     *
     * Dither Shadow Compare Value
     */
    inline void set_DITS_DCVS(uint8_t value) volatile
    {
        uint32_t curr = DITS;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        DITS = curr;
    }

    /**
     * Get PSC's PSIV field.
     *
     * Prescaler Initial Value
     */
    inline uint8_t get_PSC_PSIV() volatile
    {
        return (PSC >> 0u) & 0b1111u;
    }

    /**
     * Set PSC's PSIV field.
     *
     * Prescaler Initial Value
     */
    inline void set_PSC_PSIV(uint8_t value) volatile
    {
        uint32_t curr = PSC;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        PSC = curr;
    }

    /**
     * Get FPC's PVAL field.
     *
     * Actual Prescaler Value
     */
    inline uint8_t get_FPC_PVAL() volatile
    {
        return (FPC >> 8u) & 0b1111u;
    }

    /**
     * Set FPC's PVAL field.
     *
     * Actual Prescaler Value
     */
    inline void set_FPC_PVAL(uint8_t value) volatile
    {
        uint32_t curr = FPC;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        FPC = curr;
    }

    /**
     * Get FPC's PCMP field.
     *
     * Floating Prescaler Compare Value
     */
    inline uint8_t get_FPC_PCMP() volatile
    {
        return (FPC >> 0u) & 0b1111u;
    }

    /**
     * Get all of FPC's bit fields.
     *
     * (read-write) Floating Prescaler Control
     */
    inline void get_FPC(uint8_t &PVAL, uint8_t &PCMP) volatile
    {
        uint32_t curr = FPC;

        PVAL = (curr >> 8u) & 0b1111u;
        PCMP = (curr >> 0u) & 0b1111u;
    }

    /**
     * Get FPCS's PCMP field.
     *
     * Floating Prescaler Shadow Compare Value
     */
    inline uint8_t get_FPCS_PCMP() volatile
    {
        return (FPCS >> 0u) & 0b1111u;
    }

    /**
     * Set FPCS's PCMP field.
     *
     * Floating Prescaler Shadow Compare Value
     */
    inline void set_FPCS_PCMP(uint8_t value) volatile
    {
        uint32_t curr = FPCS;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        FPCS = curr;
    }

    /**
     * Get PR's PR field.
     *
     * Period Register
     */
    inline uint16_t get_PR_PR() volatile
    {
        return (PR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get PRS's PRS field.
     *
     * Period Register
     */
    inline uint16_t get_PRS_PRS() volatile
    {
        return (PRS >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set PRS's PRS field.
     *
     * Period Register
     */
    inline void set_PRS_PRS(uint16_t value) volatile
    {
        uint32_t curr = PRS;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        PRS = curr;
    }

    /**
     * Get CR's CR field.
     *
     * Compare Register
     */
    inline uint16_t get_CR_CR() volatile
    {
        return (CR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get CRS's CRS field.
     *
     * Compare Register
     */
    inline uint16_t get_CRS_CRS() volatile
    {
        return (CRS >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CRS's CRS field.
     *
     * Compare Register
     */
    inline void set_CRS_CRS(uint16_t value) volatile
    {
        uint32_t curr = CRS;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CRS = curr;
    }

    /**
     * Get TIMER's TVAL field.
     *
     * Timer Value
     */
    inline uint16_t get_TIMER_TVAL() volatile
    {
        return (TIMER >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set TIMER's TVAL field.
     *
     * Timer Value
     */
    inline void set_TIMER_TVAL(uint16_t value) volatile
    {
        uint32_t curr = TIMER;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        TIMER = curr;
    }

    /**
     * Get C0V's FFL bit.
     *
     * Full Flag
     */
    inline CCU40_CC40_C0V_FFL get_C0V_FFL() volatile
    {
        return CCU40_CC40_C0V_FFL(C0V & (1u << 20u));
    }

    /**
     * Get C0V's FPCV field.
     *
     * Prescaler Value
     */
    inline uint8_t get_C0V_FPCV() volatile
    {
        return (C0V >> 16u) & 0b1111u;
    }

    /**
     * Get C0V's CAPTV field.
     *
     * Capture Value
     */
    inline uint16_t get_C0V_CAPTV() volatile
    {
        return (C0V >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of C0V's bit fields.
     *
     * (read-only) Capture Register 0
     */
    inline void get_C0V(CCU40_CC40_C0V_FFL &FFL, uint8_t &FPCV,
                        uint16_t &CAPTV) volatile
    {
        uint32_t curr = C0V;

        FFL = CCU40_CC40_C0V_FFL(curr & (1u << 20u));
        FPCV = (curr >> 16u) & 0b1111u;
        CAPTV = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get C1V's FFL bit.
     *
     * Full Flag
     */
    inline CCU40_CC40_C0V_FFL get_C1V_FFL() volatile
    {
        return CCU40_CC40_C0V_FFL(C1V & (1u << 20u));
    }

    /**
     * Get C1V's FPCV field.
     *
     * Prescaler Value
     */
    inline uint8_t get_C1V_FPCV() volatile
    {
        return (C1V >> 16u) & 0b1111u;
    }

    /**
     * Get C1V's CAPTV field.
     *
     * Capture Value
     */
    inline uint16_t get_C1V_CAPTV() volatile
    {
        return (C1V >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of C1V's bit fields.
     *
     * (read-only) Capture Register 1
     */
    inline void get_C1V(CCU40_CC40_C0V_FFL &FFL, uint8_t &FPCV,
                        uint16_t &CAPTV) volatile
    {
        uint32_t curr = C1V;

        FFL = CCU40_CC40_C0V_FFL(curr & (1u << 20u));
        FPCV = (curr >> 16u) & 0b1111u;
        CAPTV = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get C2V's FFL bit.
     *
     * Full Flag
     */
    inline CCU40_CC40_C0V_FFL get_C2V_FFL() volatile
    {
        return CCU40_CC40_C0V_FFL(C2V & (1u << 20u));
    }

    /**
     * Get C2V's FPCV field.
     *
     * Prescaler Value
     */
    inline uint8_t get_C2V_FPCV() volatile
    {
        return (C2V >> 16u) & 0b1111u;
    }

    /**
     * Get C2V's CAPTV field.
     *
     * Capture Value
     */
    inline uint16_t get_C2V_CAPTV() volatile
    {
        return (C2V >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of C2V's bit fields.
     *
     * (read-only) Capture Register 2
     */
    inline void get_C2V(CCU40_CC40_C0V_FFL &FFL, uint8_t &FPCV,
                        uint16_t &CAPTV) volatile
    {
        uint32_t curr = C2V;

        FFL = CCU40_CC40_C0V_FFL(curr & (1u << 20u));
        FPCV = (curr >> 16u) & 0b1111u;
        CAPTV = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get C3V's FFL bit.
     *
     * Full Flag
     */
    inline CCU40_CC40_C0V_FFL get_C3V_FFL() volatile
    {
        return CCU40_CC40_C0V_FFL(C3V & (1u << 20u));
    }

    /**
     * Get C3V's FPCV field.
     *
     * Prescaler Value
     */
    inline uint8_t get_C3V_FPCV() volatile
    {
        return (C3V >> 16u) & 0b1111u;
    }

    /**
     * Get C3V's CAPTV field.
     *
     * Capture Value
     */
    inline uint16_t get_C3V_CAPTV() volatile
    {
        return (C3V >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of C3V's bit fields.
     *
     * (read-only) Capture Register 3
     */
    inline void get_C3V(CCU40_CC40_C0V_FFL &FFL, uint8_t &FPCV,
                        uint16_t &CAPTV) volatile
    {
        uint32_t curr = C3V;

        FFL = CCU40_CC40_C0V_FFL(curr & (1u << 20u));
        FPCV = (curr >> 16u) & 0b1111u;
        CAPTV = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get INTS's TRPF bit.
     *
     * Trap Flag Status
     */
    inline bool get_INTS_TRPF() volatile
    {
        return INTS & (1u << 11u);
    }

    /**
     * Get INTS's E2AS bit.
     *
     * Event 2 Detection Status
     */
    inline CCU40_CC40_INTS_E2AS get_INTS_E2AS() volatile
    {
        return CCU40_CC40_INTS_E2AS(INTS & (1u << 10u));
    }

    /**
     * Get INTS's E1AS bit.
     *
     * Event 1 Detection Status
     */
    inline CCU40_CC40_INTS_E2AS get_INTS_E1AS() volatile
    {
        return CCU40_CC40_INTS_E2AS(INTS & (1u << 9u));
    }

    /**
     * Get INTS's E0AS bit.
     *
     * Event 0 Detection Status
     */
    inline CCU40_CC40_INTS_E2AS get_INTS_E0AS() volatile
    {
        return CCU40_CC40_INTS_E2AS(INTS & (1u << 8u));
    }

    /**
     * Get INTS's CMDS bit.
     *
     * Compare Match while Counting Down
     */
    inline CCU40_CC40_INTS_E2AS get_INTS_CMDS() volatile
    {
        return CCU40_CC40_INTS_E2AS(INTS & (1u << 3u));
    }

    /**
     * Get INTS's CMUS bit.
     *
     * Compare Match while Counting Up
     */
    inline CCU40_CC40_INTS_E2AS get_INTS_CMUS() volatile
    {
        return CCU40_CC40_INTS_E2AS(INTS & (1u << 2u));
    }

    /**
     * Get INTS's OMDS bit.
     *
     * One Match while Counting Down
     */
    inline CCU40_CC40_INTS_E2AS get_INTS_OMDS() volatile
    {
        return CCU40_CC40_INTS_E2AS(INTS & (1u << 1u));
    }

    /**
     * Get INTS's PMUS bit.
     *
     * Period Match while Counting Up
     */
    inline CCU40_CC40_INTS_E2AS get_INTS_PMUS() volatile
    {
        return CCU40_CC40_INTS_E2AS(INTS & (1u << 0u));
    }

    /**
     * Get all of INTS's bit fields.
     *
     * (read-only) Interrupt Status
     */
    inline void get_INTS(bool &TRPF, CCU40_CC40_INTS_E2AS &E2AS,
                         CCU40_CC40_INTS_E2AS &E1AS,
                         CCU40_CC40_INTS_E2AS &E0AS,
                         CCU40_CC40_INTS_E2AS &CMDS,
                         CCU40_CC40_INTS_E2AS &CMUS,
                         CCU40_CC40_INTS_E2AS &OMDS,
                         CCU40_CC40_INTS_E2AS &PMUS) volatile
    {
        uint32_t curr = INTS;

        TRPF = curr & (1u << 11u);
        E2AS = CCU40_CC40_INTS_E2AS(curr & (1u << 10u));
        E1AS = CCU40_CC40_INTS_E2AS(curr & (1u << 9u));
        E0AS = CCU40_CC40_INTS_E2AS(curr & (1u << 8u));
        CMDS = CCU40_CC40_INTS_E2AS(curr & (1u << 3u));
        CMUS = CCU40_CC40_INTS_E2AS(curr & (1u << 2u));
        OMDS = CCU40_CC40_INTS_E2AS(curr & (1u << 1u));
        PMUS = CCU40_CC40_INTS_E2AS(curr & (1u << 0u));
    }

    /**
     * Get INTE's E2AE bit.
     *
     * Event 2 interrupt enable
     */
    inline CCU40_CC40_CMC_TCE get_INTE_E2AE() volatile
    {
        return CCU40_CC40_CMC_TCE(INTE & (1u << 10u));
    }

    /**
     * Set INTE's E2AE bit.
     *
     * Event 2 interrupt enable
     */
    inline void set_INTE_E2AE() volatile
    {
        INTE |= 1u << 10u;
    }

    /**
     * Clear INTE's E2AE bit.
     *
     * Event 2 interrupt enable
     */
    inline void clear_INTE_E2AE() volatile
    {
        INTE &= ~(1u << 10u);
    }

    /**
     * Toggle INTE's E2AE bit.
     *
     * Event 2 interrupt enable
     */
    inline void toggle_INTE_E2AE() volatile
    {
        INTE ^= 1u << 10u;
    }

    /**
     * Get INTE's E1AE bit.
     *
     * Event 1 interrupt enable
     */
    inline CCU40_CC40_CMC_TCE get_INTE_E1AE() volatile
    {
        return CCU40_CC40_CMC_TCE(INTE & (1u << 9u));
    }

    /**
     * Set INTE's E1AE bit.
     *
     * Event 1 interrupt enable
     */
    inline void set_INTE_E1AE() volatile
    {
        INTE |= 1u << 9u;
    }

    /**
     * Clear INTE's E1AE bit.
     *
     * Event 1 interrupt enable
     */
    inline void clear_INTE_E1AE() volatile
    {
        INTE &= ~(1u << 9u);
    }

    /**
     * Toggle INTE's E1AE bit.
     *
     * Event 1 interrupt enable
     */
    inline void toggle_INTE_E1AE() volatile
    {
        INTE ^= 1u << 9u;
    }

    /**
     * Get INTE's E0AE bit.
     *
     * Event 0 interrupt enable
     */
    inline CCU40_CC40_CMC_TCE get_INTE_E0AE() volatile
    {
        return CCU40_CC40_CMC_TCE(INTE & (1u << 8u));
    }

    /**
     * Set INTE's E0AE bit.
     *
     * Event 0 interrupt enable
     */
    inline void set_INTE_E0AE() volatile
    {
        INTE |= 1u << 8u;
    }

    /**
     * Clear INTE's E0AE bit.
     *
     * Event 0 interrupt enable
     */
    inline void clear_INTE_E0AE() volatile
    {
        INTE &= ~(1u << 8u);
    }

    /**
     * Toggle INTE's E0AE bit.
     *
     * Event 0 interrupt enable
     */
    inline void toggle_INTE_E0AE() volatile
    {
        INTE ^= 1u << 8u;
    }

    /**
     * Get INTE's CMDE bit.
     *
     * Compare match while counting down enable
     */
    inline CCU40_CC40_CMC_TCE get_INTE_CMDE() volatile
    {
        return CCU40_CC40_CMC_TCE(INTE & (1u << 3u));
    }

    /**
     * Set INTE's CMDE bit.
     *
     * Compare match while counting down enable
     */
    inline void set_INTE_CMDE() volatile
    {
        INTE |= 1u << 3u;
    }

    /**
     * Clear INTE's CMDE bit.
     *
     * Compare match while counting down enable
     */
    inline void clear_INTE_CMDE() volatile
    {
        INTE &= ~(1u << 3u);
    }

    /**
     * Toggle INTE's CMDE bit.
     *
     * Compare match while counting down enable
     */
    inline void toggle_INTE_CMDE() volatile
    {
        INTE ^= 1u << 3u;
    }

    /**
     * Get INTE's CMUE bit.
     *
     * Compare match while counting up enable
     */
    inline CCU40_CC40_CMC_TCE get_INTE_CMUE() volatile
    {
        return CCU40_CC40_CMC_TCE(INTE & (1u << 2u));
    }

    /**
     * Set INTE's CMUE bit.
     *
     * Compare match while counting up enable
     */
    inline void set_INTE_CMUE() volatile
    {
        INTE |= 1u << 2u;
    }

    /**
     * Clear INTE's CMUE bit.
     *
     * Compare match while counting up enable
     */
    inline void clear_INTE_CMUE() volatile
    {
        INTE &= ~(1u << 2u);
    }

    /**
     * Toggle INTE's CMUE bit.
     *
     * Compare match while counting up enable
     */
    inline void toggle_INTE_CMUE() volatile
    {
        INTE ^= 1u << 2u;
    }

    /**
     * Get INTE's OME bit.
     *
     * One match while counting down enable
     */
    inline CCU40_CC40_CMC_TCE get_INTE_OME() volatile
    {
        return CCU40_CC40_CMC_TCE(INTE & (1u << 1u));
    }

    /**
     * Set INTE's OME bit.
     *
     * One match while counting down enable
     */
    inline void set_INTE_OME() volatile
    {
        INTE |= 1u << 1u;
    }

    /**
     * Clear INTE's OME bit.
     *
     * One match while counting down enable
     */
    inline void clear_INTE_OME() volatile
    {
        INTE &= ~(1u << 1u);
    }

    /**
     * Toggle INTE's OME bit.
     *
     * One match while counting down enable
     */
    inline void toggle_INTE_OME() volatile
    {
        INTE ^= 1u << 1u;
    }

    /**
     * Get INTE's PME bit.
     *
     * Period match while counting up enable
     */
    inline CCU40_CC40_CMC_TCE get_INTE_PME() volatile
    {
        return CCU40_CC40_CMC_TCE(INTE & (1u << 0u));
    }

    /**
     * Set INTE's PME bit.
     *
     * Period match while counting up enable
     */
    inline void set_INTE_PME() volatile
    {
        INTE |= 1u << 0u;
    }

    /**
     * Clear INTE's PME bit.
     *
     * Period match while counting up enable
     */
    inline void clear_INTE_PME() volatile
    {
        INTE &= ~(1u << 0u);
    }

    /**
     * Toggle INTE's PME bit.
     *
     * Period match while counting up enable
     */
    inline void toggle_INTE_PME() volatile
    {
        INTE ^= 1u << 0u;
    }

    /**
     * Get all of INTE's bit fields.
     *
     * (read-write) Interrupt Enable Control
     */
    inline void get_INTE(CCU40_CC40_CMC_TCE &E2AE, CCU40_CC40_CMC_TCE &E1AE,
                         CCU40_CC40_CMC_TCE &E0AE, CCU40_CC40_CMC_TCE &CMDE,
                         CCU40_CC40_CMC_TCE &CMUE, CCU40_CC40_CMC_TCE &OME,
                         CCU40_CC40_CMC_TCE &PME) volatile
    {
        uint32_t curr = INTE;

        E2AE = CCU40_CC40_CMC_TCE(curr & (1u << 10u));
        E1AE = CCU40_CC40_CMC_TCE(curr & (1u << 9u));
        E0AE = CCU40_CC40_CMC_TCE(curr & (1u << 8u));
        CMDE = CCU40_CC40_CMC_TCE(curr & (1u << 3u));
        CMUE = CCU40_CC40_CMC_TCE(curr & (1u << 2u));
        OME = CCU40_CC40_CMC_TCE(curr & (1u << 1u));
        PME = CCU40_CC40_CMC_TCE(curr & (1u << 0u));
    }

    /**
     * Set all of INTE's bit fields.
     *
     * (read-write) Interrupt Enable Control
     */
    inline void set_INTE(CCU40_CC40_CMC_TCE E2AE, CCU40_CC40_CMC_TCE E1AE,
                         CCU40_CC40_CMC_TCE E0AE, CCU40_CC40_CMC_TCE CMDE,
                         CCU40_CC40_CMC_TCE CMUE, CCU40_CC40_CMC_TCE OME,
                         CCU40_CC40_CMC_TCE PME) volatile
    {
        uint32_t curr = INTE;

        curr &= ~(0b1u << 10u);
        curr |= (std::to_underlying(E2AE) & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (std::to_underlying(E1AE) & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (std::to_underlying(E0AE) & 0b1u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(CMDE) & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (std::to_underlying(CMUE) & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(OME) & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(PME) & 0b1u) << 0u;

        INTE = curr;
    }

    /**
     * Get SRS's E2SR field.
     *
     * Event 2 Service request selector
     */
    inline CCU40_CC40_SRS_E2SR get_SRS_E2SR() volatile
    {
        return CCU40_CC40_SRS_E2SR((SRS >> 12u) & 0b11u);
    }

    /**
     * Set SRS's E2SR field.
     *
     * Event 2 Service request selector
     */
    inline void set_SRS_E2SR(CCU40_CC40_SRS_E2SR value) volatile
    {
        uint32_t curr = SRS;

        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(value) & 0b11u) << 12u;

        SRS = curr;
    }

    /**
     * Get SRS's E1SR field.
     *
     * Event 1 Service request selector
     */
    inline CCU40_CC40_SRS_E2SR get_SRS_E1SR() volatile
    {
        return CCU40_CC40_SRS_E2SR((SRS >> 10u) & 0b11u);
    }

    /**
     * Set SRS's E1SR field.
     *
     * Event 1 Service request selector
     */
    inline void set_SRS_E1SR(CCU40_CC40_SRS_E2SR value) volatile
    {
        uint32_t curr = SRS;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(value) & 0b11u) << 10u;

        SRS = curr;
    }

    /**
     * Get SRS's E0SR field.
     *
     * Event 0 Service request selector
     */
    inline CCU40_CC40_SRS_E2SR get_SRS_E0SR() volatile
    {
        return CCU40_CC40_SRS_E2SR((SRS >> 8u) & 0b11u);
    }

    /**
     * Set SRS's E0SR field.
     *
     * Event 0 Service request selector
     */
    inline void set_SRS_E0SR(CCU40_CC40_SRS_E2SR value) volatile
    {
        uint32_t curr = SRS;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        SRS = curr;
    }

    /**
     * Get SRS's CMSR field.
     *
     * Compare match Service request selector
     */
    inline CCU40_CC40_SRS_E2SR get_SRS_CMSR() volatile
    {
        return CCU40_CC40_SRS_E2SR((SRS >> 2u) & 0b11u);
    }

    /**
     * Set SRS's CMSR field.
     *
     * Compare match Service request selector
     */
    inline void set_SRS_CMSR(CCU40_CC40_SRS_E2SR value) volatile
    {
        uint32_t curr = SRS;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SRS = curr;
    }

    /**
     * Get SRS's POSR field.
     *
     * Period/One match Service request selector
     */
    inline CCU40_CC40_SRS_E2SR get_SRS_POSR() volatile
    {
        return CCU40_CC40_SRS_E2SR((SRS >> 0u) & 0b11u);
    }

    /**
     * Set SRS's POSR field.
     *
     * Period/One match Service request selector
     */
    inline void set_SRS_POSR(CCU40_CC40_SRS_E2SR value) volatile
    {
        uint32_t curr = SRS;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        SRS = curr;
    }

    /**
     * Get all of SRS's bit fields.
     *
     * (read-write) Service Request Selector
     */
    inline void get_SRS(CCU40_CC40_SRS_E2SR &E2SR, CCU40_CC40_SRS_E2SR &E1SR,
                        CCU40_CC40_SRS_E2SR &E0SR, CCU40_CC40_SRS_E2SR &CMSR,
                        CCU40_CC40_SRS_E2SR &POSR) volatile
    {
        uint32_t curr = SRS;

        E2SR = CCU40_CC40_SRS_E2SR((curr >> 12u) & 0b11u);
        E1SR = CCU40_CC40_SRS_E2SR((curr >> 10u) & 0b11u);
        E0SR = CCU40_CC40_SRS_E2SR((curr >> 8u) & 0b11u);
        CMSR = CCU40_CC40_SRS_E2SR((curr >> 2u) & 0b11u);
        POSR = CCU40_CC40_SRS_E2SR((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of SRS's bit fields.
     *
     * (read-write) Service Request Selector
     */
    inline void set_SRS(CCU40_CC40_SRS_E2SR E2SR, CCU40_CC40_SRS_E2SR E1SR,
                        CCU40_CC40_SRS_E2SR E0SR, CCU40_CC40_SRS_E2SR CMSR,
                        CCU40_CC40_SRS_E2SR POSR) volatile
    {
        uint32_t curr = SRS;

        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(E2SR) & 0b11u) << 12u;
        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(E1SR) & 0b11u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(E0SR) & 0b11u) << 8u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(CMSR) & 0b11u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(POSR) & 0b11u) << 0u;

        SRS = curr;
    }

    /**
     * Set SWS's STRPF bit.
     *
     * Trap Flag status set
     */
    inline void set_SWS_STRPF() volatile
    {
        SWS |= 1u << 11u;
    }

    /**
     * Clear SWS's STRPF bit.
     *
     * Trap Flag status set
     */
    inline void clear_SWS_STRPF() volatile
    {
        SWS &= ~(1u << 11u);
    }

    /**
     * Toggle SWS's STRPF bit.
     *
     * Trap Flag status set
     */
    inline void toggle_SWS_STRPF() volatile
    {
        SWS ^= 1u << 11u;
    }

    /**
     * Set SWS's SE2A bit.
     *
     * Event 2 detection set
     */
    inline void set_SWS_SE2A() volatile
    {
        SWS |= 1u << 10u;
    }

    /**
     * Clear SWS's SE2A bit.
     *
     * Event 2 detection set
     */
    inline void clear_SWS_SE2A() volatile
    {
        SWS &= ~(1u << 10u);
    }

    /**
     * Toggle SWS's SE2A bit.
     *
     * Event 2 detection set
     */
    inline void toggle_SWS_SE2A() volatile
    {
        SWS ^= 1u << 10u;
    }

    /**
     * Set SWS's SE1A bit.
     *
     * Event 1 detection set
     */
    inline void set_SWS_SE1A() volatile
    {
        SWS |= 1u << 9u;
    }

    /**
     * Clear SWS's SE1A bit.
     *
     * Event 1 detection set
     */
    inline void clear_SWS_SE1A() volatile
    {
        SWS &= ~(1u << 9u);
    }

    /**
     * Toggle SWS's SE1A bit.
     *
     * Event 1 detection set
     */
    inline void toggle_SWS_SE1A() volatile
    {
        SWS ^= 1u << 9u;
    }

    /**
     * Set SWS's SE0A bit.
     *
     * Event 0 detection set
     */
    inline void set_SWS_SE0A() volatile
    {
        SWS |= 1u << 8u;
    }

    /**
     * Clear SWS's SE0A bit.
     *
     * Event 0 detection set
     */
    inline void clear_SWS_SE0A() volatile
    {
        SWS &= ~(1u << 8u);
    }

    /**
     * Toggle SWS's SE0A bit.
     *
     * Event 0 detection set
     */
    inline void toggle_SWS_SE0A() volatile
    {
        SWS ^= 1u << 8u;
    }

    /**
     * Set SWS's SCMD bit.
     *
     * Compare match while counting down set
     */
    inline void set_SWS_SCMD() volatile
    {
        SWS |= 1u << 3u;
    }

    /**
     * Clear SWS's SCMD bit.
     *
     * Compare match while counting down set
     */
    inline void clear_SWS_SCMD() volatile
    {
        SWS &= ~(1u << 3u);
    }

    /**
     * Toggle SWS's SCMD bit.
     *
     * Compare match while counting down set
     */
    inline void toggle_SWS_SCMD() volatile
    {
        SWS ^= 1u << 3u;
    }

    /**
     * Set SWS's SCMU bit.
     *
     * Compare match while counting up set
     */
    inline void set_SWS_SCMU() volatile
    {
        SWS |= 1u << 2u;
    }

    /**
     * Clear SWS's SCMU bit.
     *
     * Compare match while counting up set
     */
    inline void clear_SWS_SCMU() volatile
    {
        SWS &= ~(1u << 2u);
    }

    /**
     * Toggle SWS's SCMU bit.
     *
     * Compare match while counting up set
     */
    inline void toggle_SWS_SCMU() volatile
    {
        SWS ^= 1u << 2u;
    }

    /**
     * Set SWS's SOM bit.
     *
     * One match while counting down set
     */
    inline void set_SWS_SOM() volatile
    {
        SWS |= 1u << 1u;
    }

    /**
     * Clear SWS's SOM bit.
     *
     * One match while counting down set
     */
    inline void clear_SWS_SOM() volatile
    {
        SWS &= ~(1u << 1u);
    }

    /**
     * Toggle SWS's SOM bit.
     *
     * One match while counting down set
     */
    inline void toggle_SWS_SOM() volatile
    {
        SWS ^= 1u << 1u;
    }

    /**
     * Set SWS's SPM bit.
     *
     * Period match while counting up set
     */
    inline void set_SWS_SPM() volatile
    {
        SWS |= 1u << 0u;
    }

    /**
     * Clear SWS's SPM bit.
     *
     * Period match while counting up set
     */
    inline void clear_SWS_SPM() volatile
    {
        SWS &= ~(1u << 0u);
    }

    /**
     * Toggle SWS's SPM bit.
     *
     * Period match while counting up set
     */
    inline void toggle_SWS_SPM() volatile
    {
        SWS ^= 1u << 0u;
    }

    /**
     * Set all of SWS's bit fields.
     *
     * (write-only) Interrupt Status Set
     */
    inline void set_SWS(bool STRPF, bool SE2A, bool SE1A, bool SE0A, bool SCMD,
                        bool SCMU, bool SOM, bool SPM) volatile
    {
        uint32_t curr = SWS;

        curr &= ~(0b1u << 11u);
        curr |= (STRPF & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (SE2A & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (SE1A & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (SE0A & 0b1u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (SCMD & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (SCMU & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (SOM & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SPM & 0b1u) << 0u;

        SWS = curr;
    }

    /**
     * Set SWR's RTRPF bit.
     *
     * Trap Flag status clear
     */
    inline void set_SWR_RTRPF() volatile
    {
        SWR |= 1u << 11u;
    }

    /**
     * Clear SWR's RTRPF bit.
     *
     * Trap Flag status clear
     */
    inline void clear_SWR_RTRPF() volatile
    {
        SWR &= ~(1u << 11u);
    }

    /**
     * Toggle SWR's RTRPF bit.
     *
     * Trap Flag status clear
     */
    inline void toggle_SWR_RTRPF() volatile
    {
        SWR ^= 1u << 11u;
    }

    /**
     * Set SWR's RE2A bit.
     *
     * Event 2 detection clear
     */
    inline void set_SWR_RE2A() volatile
    {
        SWR |= 1u << 10u;
    }

    /**
     * Clear SWR's RE2A bit.
     *
     * Event 2 detection clear
     */
    inline void clear_SWR_RE2A() volatile
    {
        SWR &= ~(1u << 10u);
    }

    /**
     * Toggle SWR's RE2A bit.
     *
     * Event 2 detection clear
     */
    inline void toggle_SWR_RE2A() volatile
    {
        SWR ^= 1u << 10u;
    }

    /**
     * Set SWR's RE1A bit.
     *
     * Event 1 detection clear
     */
    inline void set_SWR_RE1A() volatile
    {
        SWR |= 1u << 9u;
    }

    /**
     * Clear SWR's RE1A bit.
     *
     * Event 1 detection clear
     */
    inline void clear_SWR_RE1A() volatile
    {
        SWR &= ~(1u << 9u);
    }

    /**
     * Toggle SWR's RE1A bit.
     *
     * Event 1 detection clear
     */
    inline void toggle_SWR_RE1A() volatile
    {
        SWR ^= 1u << 9u;
    }

    /**
     * Set SWR's RE0A bit.
     *
     * Event 0 detection clear
     */
    inline void set_SWR_RE0A() volatile
    {
        SWR |= 1u << 8u;
    }

    /**
     * Clear SWR's RE0A bit.
     *
     * Event 0 detection clear
     */
    inline void clear_SWR_RE0A() volatile
    {
        SWR &= ~(1u << 8u);
    }

    /**
     * Toggle SWR's RE0A bit.
     *
     * Event 0 detection clear
     */
    inline void toggle_SWR_RE0A() volatile
    {
        SWR ^= 1u << 8u;
    }

    /**
     * Set SWR's RCMD bit.
     *
     * Compare match while counting down clear
     */
    inline void set_SWR_RCMD() volatile
    {
        SWR |= 1u << 3u;
    }

    /**
     * Clear SWR's RCMD bit.
     *
     * Compare match while counting down clear
     */
    inline void clear_SWR_RCMD() volatile
    {
        SWR &= ~(1u << 3u);
    }

    /**
     * Toggle SWR's RCMD bit.
     *
     * Compare match while counting down clear
     */
    inline void toggle_SWR_RCMD() volatile
    {
        SWR ^= 1u << 3u;
    }

    /**
     * Set SWR's RCMU bit.
     *
     * Compare match while counting up clear
     */
    inline void set_SWR_RCMU() volatile
    {
        SWR |= 1u << 2u;
    }

    /**
     * Clear SWR's RCMU bit.
     *
     * Compare match while counting up clear
     */
    inline void clear_SWR_RCMU() volatile
    {
        SWR &= ~(1u << 2u);
    }

    /**
     * Toggle SWR's RCMU bit.
     *
     * Compare match while counting up clear
     */
    inline void toggle_SWR_RCMU() volatile
    {
        SWR ^= 1u << 2u;
    }

    /**
     * Set SWR's ROM bit.
     *
     * One match while counting down clear
     */
    inline void set_SWR_ROM() volatile
    {
        SWR |= 1u << 1u;
    }

    /**
     * Clear SWR's ROM bit.
     *
     * One match while counting down clear
     */
    inline void clear_SWR_ROM() volatile
    {
        SWR &= ~(1u << 1u);
    }

    /**
     * Toggle SWR's ROM bit.
     *
     * One match while counting down clear
     */
    inline void toggle_SWR_ROM() volatile
    {
        SWR ^= 1u << 1u;
    }

    /**
     * Set SWR's RPM bit.
     *
     * Period match while counting up clear
     */
    inline void set_SWR_RPM() volatile
    {
        SWR |= 1u << 0u;
    }

    /**
     * Clear SWR's RPM bit.
     *
     * Period match while counting up clear
     */
    inline void clear_SWR_RPM() volatile
    {
        SWR &= ~(1u << 0u);
    }

    /**
     * Toggle SWR's RPM bit.
     *
     * Period match while counting up clear
     */
    inline void toggle_SWR_RPM() volatile
    {
        SWR ^= 1u << 0u;
    }

    /**
     * Set all of SWR's bit fields.
     *
     * (write-only) Interrupt Status Clear
     */
    inline void set_SWR(bool RTRPF, bool RE2A, bool RE1A, bool RE0A, bool RCMD,
                        bool RCMU, bool ROM, bool RPM) volatile
    {
        uint32_t curr = SWR;

        curr &= ~(0b1u << 11u);
        curr |= (RTRPF & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (RE2A & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (RE1A & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RE0A & 0b1u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (RCMD & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (RCMU & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ROM & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (RPM & 0b1u) << 0u;

        SWR = curr;
    }

    /**
     * Get ECRD0's LCV bit.
     *
     * Lost Capture Value
     */
    inline CCU40_CC40_ECRD0_LCV get_ECRD0_LCV() volatile
    {
        return CCU40_CC40_ECRD0_LCV(ECRD0 & (1u << 25u));
    }

    /**
     * Get ECRD0's FFL bit.
     *
     * Full Flag
     */
    inline CCU40_CC40_ECRD0_FFL get_ECRD0_FFL() volatile
    {
        return CCU40_CC40_ECRD0_FFL(ECRD0 & (1u << 24u));
    }

    /**
     * Get ECRD0's VPTR field.
     *
     * Capture register pointer
     */
    inline CCU40_CC40_SRS_E2SR get_ECRD0_VPTR() volatile
    {
        return CCU40_CC40_SRS_E2SR((ECRD0 >> 22u) & 0b11u);
    }

    /**
     * Get ECRD0's SPTR field.
     *
     * Slice pointer
     */
    inline CCU40_CC40_SRS_E2SR get_ECRD0_SPTR() volatile
    {
        return CCU40_CC40_SRS_E2SR((ECRD0 >> 20u) & 0b11u);
    }

    /**
     * Get ECRD0's FPCV field.
     *
     * Prescaler Capture value
     */
    inline uint8_t get_ECRD0_FPCV() volatile
    {
        return (ECRD0 >> 16u) & 0b1111u;
    }

    /**
     * Get ECRD0's CAPV field.
     *
     * Timer Capture Value
     */
    inline uint16_t get_ECRD0_CAPV() volatile
    {
        return (ECRD0 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of ECRD0's bit fields.
     *
     * (read-only) Extended Read Back 0
     */
    inline void get_ECRD0(CCU40_CC40_ECRD0_LCV &LCV, CCU40_CC40_ECRD0_FFL &FFL,
                          CCU40_CC40_SRS_E2SR &VPTR, CCU40_CC40_SRS_E2SR &SPTR,
                          uint8_t &FPCV, uint16_t &CAPV) volatile
    {
        uint32_t curr = ECRD0;

        LCV = CCU40_CC40_ECRD0_LCV(curr & (1u << 25u));
        FFL = CCU40_CC40_ECRD0_FFL(curr & (1u << 24u));
        VPTR = CCU40_CC40_SRS_E2SR((curr >> 22u) & 0b11u);
        SPTR = CCU40_CC40_SRS_E2SR((curr >> 20u) & 0b11u);
        FPCV = (curr >> 16u) & 0b1111u;
        CAPV = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get ECRD1's LCV bit.
     *
     * Lost Capture Value
     */
    inline CCU40_CC40_ECRD0_LCV get_ECRD1_LCV() volatile
    {
        return CCU40_CC40_ECRD0_LCV(ECRD1 & (1u << 25u));
    }

    /**
     * Get ECRD1's FFL bit.
     *
     * Full Flag
     */
    inline CCU40_CC40_ECRD0_FFL get_ECRD1_FFL() volatile
    {
        return CCU40_CC40_ECRD0_FFL(ECRD1 & (1u << 24u));
    }

    /**
     * Get ECRD1's VPTR field.
     *
     * Capture register pointer
     */
    inline CCU40_CC40_SRS_E2SR get_ECRD1_VPTR() volatile
    {
        return CCU40_CC40_SRS_E2SR((ECRD1 >> 22u) & 0b11u);
    }

    /**
     * Get ECRD1's SPTR field.
     *
     * Slice pointer
     */
    inline CCU40_CC40_SRS_E2SR get_ECRD1_SPTR() volatile
    {
        return CCU40_CC40_SRS_E2SR((ECRD1 >> 20u) & 0b11u);
    }

    /**
     * Get ECRD1's FPCV field.
     *
     * Prescaler Capture value
     */
    inline uint8_t get_ECRD1_FPCV() volatile
    {
        return (ECRD1 >> 16u) & 0b1111u;
    }

    /**
     * Get ECRD1's CAPV field.
     *
     * Timer Capture Value
     */
    inline uint16_t get_ECRD1_CAPV() volatile
    {
        return (ECRD1 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of ECRD1's bit fields.
     *
     * (read-only) Extended Read Back 1
     */
    inline void get_ECRD1(CCU40_CC40_ECRD0_LCV &LCV, CCU40_CC40_ECRD0_FFL &FFL,
                          CCU40_CC40_SRS_E2SR &VPTR, CCU40_CC40_SRS_E2SR &SPTR,
                          uint8_t &FPCV, uint16_t &CAPV) volatile
    {
        uint32_t curr = ECRD1;

        LCV = CCU40_CC40_ECRD0_LCV(curr & (1u << 25u));
        FFL = CCU40_CC40_ECRD0_FFL(curr & (1u << 24u));
        VPTR = CCU40_CC40_SRS_E2SR((curr >> 22u) & 0b11u);
        SPTR = CCU40_CC40_SRS_E2SR((curr >> 20u) & 0b11u);
        FPCV = (curr >> 16u) & 0b1111u;
        CAPV = (curr >> 0u) & 0b1111111111111111u;
    }
};

static_assert(sizeof(ccu40_cc40) == ccu40_cc40::size);

static volatile ccu40_cc40 *const CCU40_CC40 =
    reinterpret_cast<ccu40_cc40 *>(0x4000C100);

static volatile ccu40_cc40 *const CCU40_CC41 =
    reinterpret_cast<ccu40_cc40 *>(0x4000C200);

static volatile ccu40_cc40 *const CCU40_CC42 =
    reinterpret_cast<ccu40_cc40 *>(0x4000C300);

static volatile ccu40_cc40 *const CCU40_CC43 =
    reinterpret_cast<ccu40_cc40 *>(0x4000C400);

static volatile ccu40_cc40 *const CCU41_CC40 =
    reinterpret_cast<ccu40_cc40 *>(0x40010100);

static volatile ccu40_cc40 *const CCU41_CC41 =
    reinterpret_cast<ccu40_cc40 *>(0x40010200);

static volatile ccu40_cc40 *const CCU41_CC42 =
    reinterpret_cast<ccu40_cc40 *>(0x40010300);

static volatile ccu40_cc40 *const CCU41_CC43 =
    reinterpret_cast<ccu40_cc40 *>(0x40010400);

static volatile ccu40_cc40 *const CCU42_CC40 =
    reinterpret_cast<ccu40_cc40 *>(0x40014100);

static volatile ccu40_cc40 *const CCU42_CC41 =
    reinterpret_cast<ccu40_cc40 *>(0x40014200);

static volatile ccu40_cc40 *const CCU42_CC42 =
    reinterpret_cast<ccu40_cc40 *>(0x40014300);

static volatile ccu40_cc40 *const CCU42_CC43 =
    reinterpret_cast<ccu40_cc40 *>(0x40014400);

static volatile ccu40_cc40 *const CCU43_CC40 =
    reinterpret_cast<ccu40_cc40 *>(0x48004100);

static volatile ccu40_cc40 *const CCU43_CC41 =
    reinterpret_cast<ccu40_cc40 *>(0x48004200);

static volatile ccu40_cc40 *const CCU43_CC42 =
    reinterpret_cast<ccu40_cc40 *>(0x48004300);

static volatile ccu40_cc40 *const CCU43_CC43 =
    reinterpret_cast<ccu40_cc40 *>(0x48004400);

}; // namespace XMC4700
