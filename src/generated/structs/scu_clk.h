/**
 * \file
 * \brief Generated by ifgen (3.2.0).
 */
#pragma once

#include "../enums/SCU_CLK_EXTCLKCR_ECKSEL.h"
#include "../enums/SCU_CLK_MLINKCLKCR_WDTSEL.h"
#include "../enums/SCU_CLK_WDTCLKCR_WDTSEL.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * System Control Unit
 */
struct [[gnu::packed]] scu_clk
{
    /* Constant attributes. */
    static constexpr std::size_t size = 112; /*!< scu_clk's size in bytes. */

    /* Fields. */
    const uint32_t CLKSTAT = {}; /*!< (read-only) Clock Status Register */
    uint32_t CLKSET;             /*!< (write-only) CLK Set Register */
    uint32_t CLKCLR;             /*!< (write-only) CLK Clear Register */
    uint32_t SYSCLKCR; /*!< (read-write) System Clock Control Register */
    uint32_t CPUCLKCR; /*!< (read-write) CPU Clock Control Register */
    uint32_t
        PBCLKCR; /*!< (read-write) Peripheral Bus Clock Control Register */
    uint32_t USBCLKCR;   /*!< (read-write) USB Clock Control Register */
    uint32_t EBUCLKCR;   /*!< (read-write) EBU Clock Control Register */
    uint32_t CCUCLKCR;   /*!< (read-write) CCU Clock Control Register */
    uint32_t WDTCLKCR;   /*!< (read-write) WDT Clock Control Register */
    uint32_t EXTCLKCR;   /*!< (read-write) External Clock Control */
    uint32_t MLINKCLKCR; /*!< (read-write) Multi-Link Clock Control */
    uint32_t SLEEPCR;    /*!< (read-write) Sleep Control Register */
    uint32_t DSLEEPCR;   /*!< (read-write) Deep Sleep Control Register */
    static constexpr std::size_t reserved_padding0_length = 2;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    const uint32_t CGATSTAT0 =
        {};            /*!< (read-only) Peripheral 0 Clock Gating Status */
    uint32_t CGATSET0; /*!< (write-only) Peripheral 0 Clock Gating Set */
    uint32_t CGATCLR0; /*!< (write-only) Peripheral 0 Clock Gating Clear */
    const uint32_t CGATSTAT1 =
        {};            /*!< (read-only) Peripheral 1 Clock Gating Status */
    uint32_t CGATSET1; /*!< (write-only) Peripheral 1 Clock Gating Set */
    uint32_t CGATCLR1; /*!< (write-only) Peripheral 1 Clock Gating Clear */
    const uint32_t CGATSTAT2 =
        {};            /*!< (read-only) Peripheral 2 Clock Gating Status */
    uint32_t CGATSET2; /*!< (write-only) Peripheral 2 Clock Gating Set */
    uint32_t CGATCLR2; /*!< (write-only) Peripheral 2 Clock Gating Clear */
    const uint32_t CGATSTAT3 =
        {};            /*!< (read-only) Peripheral 3 Clock Gating Status */
    uint32_t CGATSET3; /*!< (write-only) Peripheral 3 Clock Gating Set */
    uint32_t CGATCLR3; /*!< (write-only) Peripheral 3 Clock Gating Clear */

    /* Methods. */

    /**
     * Get CLKSTAT's WDTCST bit.
     *
     * WDT Clock Status
     */
    inline bool get_CLKSTAT_WDTCST() volatile
    {
        return CLKSTAT & (1u << 5u);
    }

    /**
     * Get CLKSTAT's CCUCST bit.
     *
     * CCU Clock Status
     */
    inline bool get_CLKSTAT_CCUCST() volatile
    {
        return CLKSTAT & (1u << 4u);
    }

    /**
     * Get CLKSTAT's EBUCST bit.
     *
     * EBU Clock Status
     */
    inline bool get_CLKSTAT_EBUCST() volatile
    {
        return CLKSTAT & (1u << 3u);
    }

    /**
     * Get CLKSTAT's ETH0CST bit.
     *
     * Ethernet Clock Status
     */
    inline bool get_CLKSTAT_ETH0CST() volatile
    {
        return CLKSTAT & (1u << 2u);
    }

    /**
     * Get CLKSTAT's MMCCST bit.
     *
     * MMC Clock Status
     */
    inline bool get_CLKSTAT_MMCCST() volatile
    {
        return CLKSTAT & (1u << 1u);
    }

    /**
     * Get CLKSTAT's USBCST bit.
     *
     * USB Clock Status
     */
    inline bool get_CLKSTAT_USBCST() volatile
    {
        return CLKSTAT & (1u << 0u);
    }

    /**
     * Get all of CLKSTAT's bit fields.
     *
     * (read-only) Clock Status Register
     */
    inline void get_CLKSTAT(bool &WDTCST, bool &CCUCST, bool &EBUCST,
                            bool &ETH0CST, bool &MMCCST, bool &USBCST) volatile
    {
        uint32_t curr = CLKSTAT;

        WDTCST = curr & (1u << 5u);
        CCUCST = curr & (1u << 4u);
        EBUCST = curr & (1u << 3u);
        ETH0CST = curr & (1u << 2u);
        MMCCST = curr & (1u << 1u);
        USBCST = curr & (1u << 0u);
    }

    /**
     * Set CLKSET's WDTCEN bit.
     *
     * WDT Clock Enable
     */
    inline void set_CLKSET_WDTCEN() volatile
    {
        CLKSET |= 1u << 5u;
    }

    /**
     * Clear CLKSET's WDTCEN bit.
     *
     * WDT Clock Enable
     */
    inline void clear_CLKSET_WDTCEN() volatile
    {
        CLKSET &= ~(1u << 5u);
    }

    /**
     * Toggle CLKSET's WDTCEN bit.
     *
     * WDT Clock Enable
     */
    inline void toggle_CLKSET_WDTCEN() volatile
    {
        CLKSET ^= 1u << 5u;
    }

    /**
     * Set CLKSET's CCUCEN bit.
     *
     * CCU Clock Enable
     */
    inline void set_CLKSET_CCUCEN() volatile
    {
        CLKSET |= 1u << 4u;
    }

    /**
     * Clear CLKSET's CCUCEN bit.
     *
     * CCU Clock Enable
     */
    inline void clear_CLKSET_CCUCEN() volatile
    {
        CLKSET &= ~(1u << 4u);
    }

    /**
     * Toggle CLKSET's CCUCEN bit.
     *
     * CCU Clock Enable
     */
    inline void toggle_CLKSET_CCUCEN() volatile
    {
        CLKSET ^= 1u << 4u;
    }

    /**
     * Set CLKSET's EBUCEN bit.
     *
     * EBU Clock Enable
     */
    inline void set_CLKSET_EBUCEN() volatile
    {
        CLKSET |= 1u << 3u;
    }

    /**
     * Clear CLKSET's EBUCEN bit.
     *
     * EBU Clock Enable
     */
    inline void clear_CLKSET_EBUCEN() volatile
    {
        CLKSET &= ~(1u << 3u);
    }

    /**
     * Toggle CLKSET's EBUCEN bit.
     *
     * EBU Clock Enable
     */
    inline void toggle_CLKSET_EBUCEN() volatile
    {
        CLKSET ^= 1u << 3u;
    }

    /**
     * Set CLKSET's ETH0CEN bit.
     *
     * Ethernet Clock Enable
     */
    inline void set_CLKSET_ETH0CEN() volatile
    {
        CLKSET |= 1u << 2u;
    }

    /**
     * Clear CLKSET's ETH0CEN bit.
     *
     * Ethernet Clock Enable
     */
    inline void clear_CLKSET_ETH0CEN() volatile
    {
        CLKSET &= ~(1u << 2u);
    }

    /**
     * Toggle CLKSET's ETH0CEN bit.
     *
     * Ethernet Clock Enable
     */
    inline void toggle_CLKSET_ETH0CEN() volatile
    {
        CLKSET ^= 1u << 2u;
    }

    /**
     * Set CLKSET's MMCCEN bit.
     *
     * MMC Clock Enable
     */
    inline void set_CLKSET_MMCCEN() volatile
    {
        CLKSET |= 1u << 1u;
    }

    /**
     * Clear CLKSET's MMCCEN bit.
     *
     * MMC Clock Enable
     */
    inline void clear_CLKSET_MMCCEN() volatile
    {
        CLKSET &= ~(1u << 1u);
    }

    /**
     * Toggle CLKSET's MMCCEN bit.
     *
     * MMC Clock Enable
     */
    inline void toggle_CLKSET_MMCCEN() volatile
    {
        CLKSET ^= 1u << 1u;
    }

    /**
     * Set CLKSET's USBCEN bit.
     *
     * USB Clock Enable
     */
    inline void set_CLKSET_USBCEN() volatile
    {
        CLKSET |= 1u << 0u;
    }

    /**
     * Clear CLKSET's USBCEN bit.
     *
     * USB Clock Enable
     */
    inline void clear_CLKSET_USBCEN() volatile
    {
        CLKSET &= ~(1u << 0u);
    }

    /**
     * Toggle CLKSET's USBCEN bit.
     *
     * USB Clock Enable
     */
    inline void toggle_CLKSET_USBCEN() volatile
    {
        CLKSET ^= 1u << 0u;
    }

    /**
     * Set all of CLKSET's bit fields.
     *
     * (write-only) CLK Set Register
     */
    inline void set_CLKSET(bool WDTCEN, bool CCUCEN, bool EBUCEN, bool ETH0CEN,
                           bool MMCCEN, bool USBCEN) volatile
    {
        uint32_t curr = CLKSET;

        curr &= ~(0b1u << 5u);
        curr |= (WDTCEN & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (CCUCEN & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (EBUCEN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ETH0CEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (MMCCEN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (USBCEN & 0b1u) << 0u;

        CLKSET = curr;
    }

    /**
     * Set CLKCLR's WDTCDI bit.
     *
     * WDT Clock Disable
     */
    inline void set_CLKCLR_WDTCDI() volatile
    {
        CLKCLR |= 1u << 5u;
    }

    /**
     * Clear CLKCLR's WDTCDI bit.
     *
     * WDT Clock Disable
     */
    inline void clear_CLKCLR_WDTCDI() volatile
    {
        CLKCLR &= ~(1u << 5u);
    }

    /**
     * Toggle CLKCLR's WDTCDI bit.
     *
     * WDT Clock Disable
     */
    inline void toggle_CLKCLR_WDTCDI() volatile
    {
        CLKCLR ^= 1u << 5u;
    }

    /**
     * Set CLKCLR's CCUCDI bit.
     *
     * CCU Clock Disable
     */
    inline void set_CLKCLR_CCUCDI() volatile
    {
        CLKCLR |= 1u << 4u;
    }

    /**
     * Clear CLKCLR's CCUCDI bit.
     *
     * CCU Clock Disable
     */
    inline void clear_CLKCLR_CCUCDI() volatile
    {
        CLKCLR &= ~(1u << 4u);
    }

    /**
     * Toggle CLKCLR's CCUCDI bit.
     *
     * CCU Clock Disable
     */
    inline void toggle_CLKCLR_CCUCDI() volatile
    {
        CLKCLR ^= 1u << 4u;
    }

    /**
     * Set CLKCLR's EBUCDI bit.
     *
     * EBU Clock Disable
     */
    inline void set_CLKCLR_EBUCDI() volatile
    {
        CLKCLR |= 1u << 3u;
    }

    /**
     * Clear CLKCLR's EBUCDI bit.
     *
     * EBU Clock Disable
     */
    inline void clear_CLKCLR_EBUCDI() volatile
    {
        CLKCLR &= ~(1u << 3u);
    }

    /**
     * Toggle CLKCLR's EBUCDI bit.
     *
     * EBU Clock Disable
     */
    inline void toggle_CLKCLR_EBUCDI() volatile
    {
        CLKCLR ^= 1u << 3u;
    }

    /**
     * Set CLKCLR's ETH0CDI bit.
     *
     * Ethernet Clock Disable
     */
    inline void set_CLKCLR_ETH0CDI() volatile
    {
        CLKCLR |= 1u << 2u;
    }

    /**
     * Clear CLKCLR's ETH0CDI bit.
     *
     * Ethernet Clock Disable
     */
    inline void clear_CLKCLR_ETH0CDI() volatile
    {
        CLKCLR &= ~(1u << 2u);
    }

    /**
     * Toggle CLKCLR's ETH0CDI bit.
     *
     * Ethernet Clock Disable
     */
    inline void toggle_CLKCLR_ETH0CDI() volatile
    {
        CLKCLR ^= 1u << 2u;
    }

    /**
     * Set CLKCLR's MMCCDI bit.
     *
     * MMC Clock Disable
     */
    inline void set_CLKCLR_MMCCDI() volatile
    {
        CLKCLR |= 1u << 1u;
    }

    /**
     * Clear CLKCLR's MMCCDI bit.
     *
     * MMC Clock Disable
     */
    inline void clear_CLKCLR_MMCCDI() volatile
    {
        CLKCLR &= ~(1u << 1u);
    }

    /**
     * Toggle CLKCLR's MMCCDI bit.
     *
     * MMC Clock Disable
     */
    inline void toggle_CLKCLR_MMCCDI() volatile
    {
        CLKCLR ^= 1u << 1u;
    }

    /**
     * Set CLKCLR's USBCDI bit.
     *
     * USB Clock Disable
     */
    inline void set_CLKCLR_USBCDI() volatile
    {
        CLKCLR |= 1u << 0u;
    }

    /**
     * Clear CLKCLR's USBCDI bit.
     *
     * USB Clock Disable
     */
    inline void clear_CLKCLR_USBCDI() volatile
    {
        CLKCLR &= ~(1u << 0u);
    }

    /**
     * Toggle CLKCLR's USBCDI bit.
     *
     * USB Clock Disable
     */
    inline void toggle_CLKCLR_USBCDI() volatile
    {
        CLKCLR ^= 1u << 0u;
    }

    /**
     * Set all of CLKCLR's bit fields.
     *
     * (write-only) CLK Clear Register
     */
    inline void set_CLKCLR(bool WDTCDI, bool CCUCDI, bool EBUCDI, bool ETH0CDI,
                           bool MMCCDI, bool USBCDI) volatile
    {
        uint32_t curr = CLKCLR;

        curr &= ~(0b1u << 5u);
        curr |= (WDTCDI & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (CCUCDI & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (EBUCDI & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ETH0CDI & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (MMCCDI & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (USBCDI & 0b1u) << 0u;

        CLKCLR = curr;
    }

    /**
     * Get SYSCLKCR's SYSSEL bit.
     *
     * System Clock Selection Value
     */
    inline bool get_SYSCLKCR_SYSSEL() volatile
    {
        return SYSCLKCR & (1u << 16u);
    }

    /**
     * Set SYSCLKCR's SYSSEL bit.
     *
     * System Clock Selection Value
     */
    inline void set_SYSCLKCR_SYSSEL() volatile
    {
        SYSCLKCR |= 1u << 16u;
    }

    /**
     * Clear SYSCLKCR's SYSSEL bit.
     *
     * System Clock Selection Value
     */
    inline void clear_SYSCLKCR_SYSSEL() volatile
    {
        SYSCLKCR &= ~(1u << 16u);
    }

    /**
     * Toggle SYSCLKCR's SYSSEL bit.
     *
     * System Clock Selection Value
     */
    inline void toggle_SYSCLKCR_SYSSEL() volatile
    {
        SYSCLKCR ^= 1u << 16u;
    }

    /**
     * Get SYSCLKCR's SYSDIV field.
     *
     * System Clock Division Value
     */
    inline uint8_t get_SYSCLKCR_SYSDIV() volatile
    {
        return (SYSCLKCR >> 0u) & 0b11111111u;
    }

    /**
     * Set SYSCLKCR's SYSDIV field.
     *
     * System Clock Division Value
     */
    inline void set_SYSCLKCR_SYSDIV(uint8_t value) volatile
    {
        uint32_t curr = SYSCLKCR;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        SYSCLKCR = curr;
    }

    /**
     * Get all of SYSCLKCR's bit fields.
     *
     * (read-write) System Clock Control Register
     */
    inline void get_SYSCLKCR(bool &SYSSEL, uint8_t &SYSDIV) volatile
    {
        uint32_t curr = SYSCLKCR;

        SYSSEL = curr & (1u << 16u);
        SYSDIV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of SYSCLKCR's bit fields.
     *
     * (read-write) System Clock Control Register
     */
    inline void set_SYSCLKCR(bool SYSSEL, uint8_t SYSDIV) volatile
    {
        uint32_t curr = SYSCLKCR;

        curr &= ~(0b1u << 16u);
        curr |= (SYSSEL & 0b1u) << 16u;
        curr &= ~(0b11111111u << 0u);
        curr |= (SYSDIV & 0b11111111u) << 0u;

        SYSCLKCR = curr;
    }

    /**
     * Get CPUCLKCR's CPUDIV bit.
     *
     * CPU Clock Divider Enable
     */
    inline bool get_CPUCLKCR_CPUDIV() volatile
    {
        return CPUCLKCR & (1u << 0u);
    }

    /**
     * Set CPUCLKCR's CPUDIV bit.
     *
     * CPU Clock Divider Enable
     */
    inline void set_CPUCLKCR_CPUDIV() volatile
    {
        CPUCLKCR |= 1u << 0u;
    }

    /**
     * Clear CPUCLKCR's CPUDIV bit.
     *
     * CPU Clock Divider Enable
     */
    inline void clear_CPUCLKCR_CPUDIV() volatile
    {
        CPUCLKCR &= ~(1u << 0u);
    }

    /**
     * Toggle CPUCLKCR's CPUDIV bit.
     *
     * CPU Clock Divider Enable
     */
    inline void toggle_CPUCLKCR_CPUDIV() volatile
    {
        CPUCLKCR ^= 1u << 0u;
    }

    /**
     * Get PBCLKCR's PBDIV bit.
     *
     * PB Clock Divider Enable
     */
    inline bool get_PBCLKCR_PBDIV() volatile
    {
        return PBCLKCR & (1u << 0u);
    }

    /**
     * Set PBCLKCR's PBDIV bit.
     *
     * PB Clock Divider Enable
     */
    inline void set_PBCLKCR_PBDIV() volatile
    {
        PBCLKCR |= 1u << 0u;
    }

    /**
     * Clear PBCLKCR's PBDIV bit.
     *
     * PB Clock Divider Enable
     */
    inline void clear_PBCLKCR_PBDIV() volatile
    {
        PBCLKCR &= ~(1u << 0u);
    }

    /**
     * Toggle PBCLKCR's PBDIV bit.
     *
     * PB Clock Divider Enable
     */
    inline void toggle_PBCLKCR_PBDIV() volatile
    {
        PBCLKCR ^= 1u << 0u;
    }

    /**
     * Get USBCLKCR's USBSEL bit.
     *
     * USB Clock Selection Value
     */
    inline bool get_USBCLKCR_USBSEL() volatile
    {
        return USBCLKCR & (1u << 16u);
    }

    /**
     * Set USBCLKCR's USBSEL bit.
     *
     * USB Clock Selection Value
     */
    inline void set_USBCLKCR_USBSEL() volatile
    {
        USBCLKCR |= 1u << 16u;
    }

    /**
     * Clear USBCLKCR's USBSEL bit.
     *
     * USB Clock Selection Value
     */
    inline void clear_USBCLKCR_USBSEL() volatile
    {
        USBCLKCR &= ~(1u << 16u);
    }

    /**
     * Toggle USBCLKCR's USBSEL bit.
     *
     * USB Clock Selection Value
     */
    inline void toggle_USBCLKCR_USBSEL() volatile
    {
        USBCLKCR ^= 1u << 16u;
    }

    /**
     * Get USBCLKCR's USBDIV field.
     *
     * USB Clock Divider Value
     */
    inline uint8_t get_USBCLKCR_USBDIV() volatile
    {
        return (USBCLKCR >> 0u) & 0b111u;
    }

    /**
     * Set USBCLKCR's USBDIV field.
     *
     * USB Clock Divider Value
     */
    inline void set_USBCLKCR_USBDIV(uint8_t value) volatile
    {
        uint32_t curr = USBCLKCR;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        USBCLKCR = curr;
    }

    /**
     * Get all of USBCLKCR's bit fields.
     *
     * (read-write) USB Clock Control Register
     */
    inline void get_USBCLKCR(bool &USBSEL, uint8_t &USBDIV) volatile
    {
        uint32_t curr = USBCLKCR;

        USBSEL = curr & (1u << 16u);
        USBDIV = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of USBCLKCR's bit fields.
     *
     * (read-write) USB Clock Control Register
     */
    inline void set_USBCLKCR(bool USBSEL, uint8_t USBDIV) volatile
    {
        uint32_t curr = USBCLKCR;

        curr &= ~(0b1u << 16u);
        curr |= (USBSEL & 0b1u) << 16u;
        curr &= ~(0b111u << 0u);
        curr |= (USBDIV & 0b111u) << 0u;

        USBCLKCR = curr;
    }

    /**
     * Get EBUCLKCR's EBUDIV field.
     *
     * EBU Clock Divider Value
     */
    inline uint8_t get_EBUCLKCR_EBUDIV() volatile
    {
        return (EBUCLKCR >> 0u) & 0b111111u;
    }

    /**
     * Set EBUCLKCR's EBUDIV field.
     *
     * EBU Clock Divider Value
     */
    inline void set_EBUCLKCR_EBUDIV(uint8_t value) volatile
    {
        uint32_t curr = EBUCLKCR;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        EBUCLKCR = curr;
    }

    /**
     * Get CCUCLKCR's CCUDIV bit.
     *
     * CCU Clock Divider Enable
     */
    inline bool get_CCUCLKCR_CCUDIV() volatile
    {
        return CCUCLKCR & (1u << 0u);
    }

    /**
     * Set CCUCLKCR's CCUDIV bit.
     *
     * CCU Clock Divider Enable
     */
    inline void set_CCUCLKCR_CCUDIV() volatile
    {
        CCUCLKCR |= 1u << 0u;
    }

    /**
     * Clear CCUCLKCR's CCUDIV bit.
     *
     * CCU Clock Divider Enable
     */
    inline void clear_CCUCLKCR_CCUDIV() volatile
    {
        CCUCLKCR &= ~(1u << 0u);
    }

    /**
     * Toggle CCUCLKCR's CCUDIV bit.
     *
     * CCU Clock Divider Enable
     */
    inline void toggle_CCUCLKCR_CCUDIV() volatile
    {
        CCUCLKCR ^= 1u << 0u;
    }

    /**
     * Get WDTCLKCR's WDTSEL field.
     *
     * WDT Clock Selection Value
     */
    inline SCU_CLK_WDTCLKCR_WDTSEL get_WDTCLKCR_WDTSEL() volatile
    {
        return SCU_CLK_WDTCLKCR_WDTSEL((WDTCLKCR >> 16u) & 0b11u);
    }

    /**
     * Set WDTCLKCR's WDTSEL field.
     *
     * WDT Clock Selection Value
     */
    inline void set_WDTCLKCR_WDTSEL(SCU_CLK_WDTCLKCR_WDTSEL value) volatile
    {
        uint32_t curr = WDTCLKCR;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        WDTCLKCR = curr;
    }

    /**
     * Get WDTCLKCR's WDTDIV field.
     *
     * WDT Clock Divider Value
     */
    inline uint8_t get_WDTCLKCR_WDTDIV() volatile
    {
        return (WDTCLKCR >> 0u) & 0b11111111u;
    }

    /**
     * Set WDTCLKCR's WDTDIV field.
     *
     * WDT Clock Divider Value
     */
    inline void set_WDTCLKCR_WDTDIV(uint8_t value) volatile
    {
        uint32_t curr = WDTCLKCR;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        WDTCLKCR = curr;
    }

    /**
     * Get all of WDTCLKCR's bit fields.
     *
     * (read-write) WDT Clock Control Register
     */
    inline void get_WDTCLKCR(SCU_CLK_WDTCLKCR_WDTSEL &WDTSEL,
                             uint8_t &WDTDIV) volatile
    {
        uint32_t curr = WDTCLKCR;

        WDTSEL = SCU_CLK_WDTCLKCR_WDTSEL((curr >> 16u) & 0b11u);
        WDTDIV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of WDTCLKCR's bit fields.
     *
     * (read-write) WDT Clock Control Register
     */
    inline void set_WDTCLKCR(SCU_CLK_WDTCLKCR_WDTSEL WDTSEL,
                             uint8_t WDTDIV) volatile
    {
        uint32_t curr = WDTCLKCR;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(WDTSEL) & 0b11u) << 16u;
        curr &= ~(0b11111111u << 0u);
        curr |= (WDTDIV & 0b11111111u) << 0u;

        WDTCLKCR = curr;
    }

    /**
     * Get EXTCLKCR's ECKDIV field.
     *
     * External Clock Divider Value
     */
    inline uint16_t get_EXTCLKCR_ECKDIV() volatile
    {
        return (EXTCLKCR >> 16u) & 0b111111111u;
    }

    /**
     * Set EXTCLKCR's ECKDIV field.
     *
     * External Clock Divider Value
     */
    inline void set_EXTCLKCR_ECKDIV(uint16_t value) volatile
    {
        uint32_t curr = EXTCLKCR;

        curr &= ~(0b111111111u << 16u);
        curr |= (value & 0b111111111u) << 16u;

        EXTCLKCR = curr;
    }

    /**
     * Get EXTCLKCR's ECKSEL field.
     *
     * External Clock Selection Value
     */
    inline SCU_CLK_EXTCLKCR_ECKSEL get_EXTCLKCR_ECKSEL() volatile
    {
        return SCU_CLK_EXTCLKCR_ECKSEL((EXTCLKCR >> 0u) & 0b11u);
    }

    /**
     * Set EXTCLKCR's ECKSEL field.
     *
     * External Clock Selection Value
     */
    inline void set_EXTCLKCR_ECKSEL(SCU_CLK_EXTCLKCR_ECKSEL value) volatile
    {
        uint32_t curr = EXTCLKCR;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        EXTCLKCR = curr;
    }

    /**
     * Get all of EXTCLKCR's bit fields.
     *
     * (read-write) External Clock Control
     */
    inline void get_EXTCLKCR(uint16_t &ECKDIV,
                             SCU_CLK_EXTCLKCR_ECKSEL &ECKSEL) volatile
    {
        uint32_t curr = EXTCLKCR;

        ECKDIV = (curr >> 16u) & 0b111111111u;
        ECKSEL = SCU_CLK_EXTCLKCR_ECKSEL((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of EXTCLKCR's bit fields.
     *
     * (read-write) External Clock Control
     */
    inline void set_EXTCLKCR(uint16_t ECKDIV,
                             SCU_CLK_EXTCLKCR_ECKSEL ECKSEL) volatile
    {
        uint32_t curr = EXTCLKCR;

        curr &= ~(0b111111111u << 16u);
        curr |= (ECKDIV & 0b111111111u) << 16u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(ECKSEL) & 0b11u) << 0u;

        EXTCLKCR = curr;
    }

    /**
     * Get MLINKCLKCR's EBUDIV field.
     *
     * EBU Clock Divider Value
     */
    inline uint8_t get_MLINKCLKCR_EBUDIV() volatile
    {
        return (MLINKCLKCR >> 26u) & 0b111111u;
    }

    /**
     * Set MLINKCLKCR's EBUDIV field.
     *
     * EBU Clock Divider Value
     */
    inline void set_MLINKCLKCR_EBUDIV(uint8_t value) volatile
    {
        uint32_t curr = MLINKCLKCR;

        curr &= ~(0b111111u << 26u);
        curr |= (value & 0b111111u) << 26u;

        MLINKCLKCR = curr;
    }

    /**
     * Get MLINKCLKCR's WDTSEL field.
     *
     * WDT Clock Selection Value
     */
    inline SCU_CLK_MLINKCLKCR_WDTSEL get_MLINKCLKCR_WDTSEL() volatile
    {
        return SCU_CLK_MLINKCLKCR_WDTSEL((MLINKCLKCR >> 24u) & 0b11u);
    }

    /**
     * Set MLINKCLKCR's WDTSEL field.
     *
     * WDT Clock Selection Value
     */
    inline void set_MLINKCLKCR_WDTSEL(SCU_CLK_MLINKCLKCR_WDTSEL value) volatile
    {
        uint32_t curr = MLINKCLKCR;

        curr &= ~(0b11u << 24u);
        curr |= (std::to_underlying(value) & 0b11u) << 24u;

        MLINKCLKCR = curr;
    }

    /**
     * Get MLINKCLKCR's WDTDIV field.
     *
     * WDT Clock Divider Value
     */
    inline uint8_t get_MLINKCLKCR_WDTDIV() volatile
    {
        return (MLINKCLKCR >> 16u) & 0b11111111u;
    }

    /**
     * Set MLINKCLKCR's WDTDIV field.
     *
     * WDT Clock Divider Value
     */
    inline void set_MLINKCLKCR_WDTDIV(uint8_t value) volatile
    {
        uint32_t curr = MLINKCLKCR;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        MLINKCLKCR = curr;
    }

    /**
     * Get MLINKCLKCR's CCUDIV bit.
     *
     * CCU Clock Divider Enable
     */
    inline bool get_MLINKCLKCR_CCUDIV() volatile
    {
        return MLINKCLKCR & (1u << 14u);
    }

    /**
     * Set MLINKCLKCR's CCUDIV bit.
     *
     * CCU Clock Divider Enable
     */
    inline void set_MLINKCLKCR_CCUDIV() volatile
    {
        MLINKCLKCR |= 1u << 14u;
    }

    /**
     * Clear MLINKCLKCR's CCUDIV bit.
     *
     * CCU Clock Divider Enable
     */
    inline void clear_MLINKCLKCR_CCUDIV() volatile
    {
        MLINKCLKCR &= ~(1u << 14u);
    }

    /**
     * Toggle MLINKCLKCR's CCUDIV bit.
     *
     * CCU Clock Divider Enable
     */
    inline void toggle_MLINKCLKCR_CCUDIV() volatile
    {
        MLINKCLKCR ^= 1u << 14u;
    }

    /**
     * Get MLINKCLKCR's PBDIV bit.
     *
     * PB Clock Divider Enable
     */
    inline bool get_MLINKCLKCR_PBDIV() volatile
    {
        return MLINKCLKCR & (1u << 12u);
    }

    /**
     * Set MLINKCLKCR's PBDIV bit.
     *
     * PB Clock Divider Enable
     */
    inline void set_MLINKCLKCR_PBDIV() volatile
    {
        MLINKCLKCR |= 1u << 12u;
    }

    /**
     * Clear MLINKCLKCR's PBDIV bit.
     *
     * PB Clock Divider Enable
     */
    inline void clear_MLINKCLKCR_PBDIV() volatile
    {
        MLINKCLKCR &= ~(1u << 12u);
    }

    /**
     * Toggle MLINKCLKCR's PBDIV bit.
     *
     * PB Clock Divider Enable
     */
    inline void toggle_MLINKCLKCR_PBDIV() volatile
    {
        MLINKCLKCR ^= 1u << 12u;
    }

    /**
     * Get MLINKCLKCR's CPUDIV bit.
     *
     * CPU Clock Divider Enable
     */
    inline bool get_MLINKCLKCR_CPUDIV() volatile
    {
        return MLINKCLKCR & (1u << 10u);
    }

    /**
     * Set MLINKCLKCR's CPUDIV bit.
     *
     * CPU Clock Divider Enable
     */
    inline void set_MLINKCLKCR_CPUDIV() volatile
    {
        MLINKCLKCR |= 1u << 10u;
    }

    /**
     * Clear MLINKCLKCR's CPUDIV bit.
     *
     * CPU Clock Divider Enable
     */
    inline void clear_MLINKCLKCR_CPUDIV() volatile
    {
        MLINKCLKCR &= ~(1u << 10u);
    }

    /**
     * Toggle MLINKCLKCR's CPUDIV bit.
     *
     * CPU Clock Divider Enable
     */
    inline void toggle_MLINKCLKCR_CPUDIV() volatile
    {
        MLINKCLKCR ^= 1u << 10u;
    }

    /**
     * Get MLINKCLKCR's SYSSEL bit.
     *
     * System Clock Selection Value
     */
    inline bool get_MLINKCLKCR_SYSSEL() volatile
    {
        return MLINKCLKCR & (1u << 8u);
    }

    /**
     * Set MLINKCLKCR's SYSSEL bit.
     *
     * System Clock Selection Value
     */
    inline void set_MLINKCLKCR_SYSSEL() volatile
    {
        MLINKCLKCR |= 1u << 8u;
    }

    /**
     * Clear MLINKCLKCR's SYSSEL bit.
     *
     * System Clock Selection Value
     */
    inline void clear_MLINKCLKCR_SYSSEL() volatile
    {
        MLINKCLKCR &= ~(1u << 8u);
    }

    /**
     * Toggle MLINKCLKCR's SYSSEL bit.
     *
     * System Clock Selection Value
     */
    inline void toggle_MLINKCLKCR_SYSSEL() volatile
    {
        MLINKCLKCR ^= 1u << 8u;
    }

    /**
     * Get MLINKCLKCR's SYSDIV field.
     *
     * System Clock Division Value
     */
    inline uint8_t get_MLINKCLKCR_SYSDIV() volatile
    {
        return (MLINKCLKCR >> 0u) & 0b11111111u;
    }

    /**
     * Set MLINKCLKCR's SYSDIV field.
     *
     * System Clock Division Value
     */
    inline void set_MLINKCLKCR_SYSDIV(uint8_t value) volatile
    {
        uint32_t curr = MLINKCLKCR;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        MLINKCLKCR = curr;
    }

    /**
     * Get all of MLINKCLKCR's bit fields.
     *
     * (read-write) Multi-Link Clock Control
     */
    inline void get_MLINKCLKCR(uint8_t &EBUDIV,
                               SCU_CLK_MLINKCLKCR_WDTSEL &WDTSEL,
                               uint8_t &WDTDIV, bool &CCUDIV, bool &PBDIV,
                               bool &CPUDIV, bool &SYSSEL,
                               uint8_t &SYSDIV) volatile
    {
        uint32_t curr = MLINKCLKCR;

        EBUDIV = (curr >> 26u) & 0b111111u;
        WDTSEL = SCU_CLK_MLINKCLKCR_WDTSEL((curr >> 24u) & 0b11u);
        WDTDIV = (curr >> 16u) & 0b11111111u;
        CCUDIV = curr & (1u << 14u);
        PBDIV = curr & (1u << 12u);
        CPUDIV = curr & (1u << 10u);
        SYSSEL = curr & (1u << 8u);
        SYSDIV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of MLINKCLKCR's bit fields.
     *
     * (read-write) Multi-Link Clock Control
     */
    inline void set_MLINKCLKCR(uint8_t EBUDIV,
                               SCU_CLK_MLINKCLKCR_WDTSEL WDTSEL,
                               uint8_t WDTDIV, bool CCUDIV, bool PBDIV,
                               bool CPUDIV, bool SYSSEL,
                               uint8_t SYSDIV) volatile
    {
        uint32_t curr = MLINKCLKCR;

        curr &= ~(0b111111u << 26u);
        curr |= (EBUDIV & 0b111111u) << 26u;
        curr &= ~(0b11u << 24u);
        curr |= (std::to_underlying(WDTSEL) & 0b11u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (WDTDIV & 0b11111111u) << 16u;
        curr &= ~(0b1u << 14u);
        curr |= (CCUDIV & 0b1u) << 14u;
        curr &= ~(0b1u << 12u);
        curr |= (PBDIV & 0b1u) << 12u;
        curr &= ~(0b1u << 10u);
        curr |= (CPUDIV & 0b1u) << 10u;
        curr &= ~(0b1u << 8u);
        curr |= (SYSSEL & 0b1u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (SYSDIV & 0b11111111u) << 0u;

        MLINKCLKCR = curr;
    }

    /**
     * Get SLEEPCR's WDTCR bit.
     *
     * WDT Clock Control
     */
    inline bool get_SLEEPCR_WDTCR() volatile
    {
        return SLEEPCR & (1u << 21u);
    }

    /**
     * Set SLEEPCR's WDTCR bit.
     *
     * WDT Clock Control
     */
    inline void set_SLEEPCR_WDTCR() volatile
    {
        SLEEPCR |= 1u << 21u;
    }

    /**
     * Clear SLEEPCR's WDTCR bit.
     *
     * WDT Clock Control
     */
    inline void clear_SLEEPCR_WDTCR() volatile
    {
        SLEEPCR &= ~(1u << 21u);
    }

    /**
     * Toggle SLEEPCR's WDTCR bit.
     *
     * WDT Clock Control
     */
    inline void toggle_SLEEPCR_WDTCR() volatile
    {
        SLEEPCR ^= 1u << 21u;
    }

    /**
     * Get SLEEPCR's CCUCR bit.
     *
     * CCU Clock Control
     */
    inline bool get_SLEEPCR_CCUCR() volatile
    {
        return SLEEPCR & (1u << 20u);
    }

    /**
     * Set SLEEPCR's CCUCR bit.
     *
     * CCU Clock Control
     */
    inline void set_SLEEPCR_CCUCR() volatile
    {
        SLEEPCR |= 1u << 20u;
    }

    /**
     * Clear SLEEPCR's CCUCR bit.
     *
     * CCU Clock Control
     */
    inline void clear_SLEEPCR_CCUCR() volatile
    {
        SLEEPCR &= ~(1u << 20u);
    }

    /**
     * Toggle SLEEPCR's CCUCR bit.
     *
     * CCU Clock Control
     */
    inline void toggle_SLEEPCR_CCUCR() volatile
    {
        SLEEPCR ^= 1u << 20u;
    }

    /**
     * Get SLEEPCR's EBUCR bit.
     *
     * EBU Clock Control
     */
    inline bool get_SLEEPCR_EBUCR() volatile
    {
        return SLEEPCR & (1u << 19u);
    }

    /**
     * Set SLEEPCR's EBUCR bit.
     *
     * EBU Clock Control
     */
    inline void set_SLEEPCR_EBUCR() volatile
    {
        SLEEPCR |= 1u << 19u;
    }

    /**
     * Clear SLEEPCR's EBUCR bit.
     *
     * EBU Clock Control
     */
    inline void clear_SLEEPCR_EBUCR() volatile
    {
        SLEEPCR &= ~(1u << 19u);
    }

    /**
     * Toggle SLEEPCR's EBUCR bit.
     *
     * EBU Clock Control
     */
    inline void toggle_SLEEPCR_EBUCR() volatile
    {
        SLEEPCR ^= 1u << 19u;
    }

    /**
     * Get SLEEPCR's ETH0CR bit.
     *
     * Ethernet Clock Control
     */
    inline bool get_SLEEPCR_ETH0CR() volatile
    {
        return SLEEPCR & (1u << 18u);
    }

    /**
     * Set SLEEPCR's ETH0CR bit.
     *
     * Ethernet Clock Control
     */
    inline void set_SLEEPCR_ETH0CR() volatile
    {
        SLEEPCR |= 1u << 18u;
    }

    /**
     * Clear SLEEPCR's ETH0CR bit.
     *
     * Ethernet Clock Control
     */
    inline void clear_SLEEPCR_ETH0CR() volatile
    {
        SLEEPCR &= ~(1u << 18u);
    }

    /**
     * Toggle SLEEPCR's ETH0CR bit.
     *
     * Ethernet Clock Control
     */
    inline void toggle_SLEEPCR_ETH0CR() volatile
    {
        SLEEPCR ^= 1u << 18u;
    }

    /**
     * Get SLEEPCR's MMCCR bit.
     *
     * MMC Clock Control
     */
    inline bool get_SLEEPCR_MMCCR() volatile
    {
        return SLEEPCR & (1u << 17u);
    }

    /**
     * Set SLEEPCR's MMCCR bit.
     *
     * MMC Clock Control
     */
    inline void set_SLEEPCR_MMCCR() volatile
    {
        SLEEPCR |= 1u << 17u;
    }

    /**
     * Clear SLEEPCR's MMCCR bit.
     *
     * MMC Clock Control
     */
    inline void clear_SLEEPCR_MMCCR() volatile
    {
        SLEEPCR &= ~(1u << 17u);
    }

    /**
     * Toggle SLEEPCR's MMCCR bit.
     *
     * MMC Clock Control
     */
    inline void toggle_SLEEPCR_MMCCR() volatile
    {
        SLEEPCR ^= 1u << 17u;
    }

    /**
     * Get SLEEPCR's USBCR bit.
     *
     * USB Clock Control
     */
    inline bool get_SLEEPCR_USBCR() volatile
    {
        return SLEEPCR & (1u << 16u);
    }

    /**
     * Set SLEEPCR's USBCR bit.
     *
     * USB Clock Control
     */
    inline void set_SLEEPCR_USBCR() volatile
    {
        SLEEPCR |= 1u << 16u;
    }

    /**
     * Clear SLEEPCR's USBCR bit.
     *
     * USB Clock Control
     */
    inline void clear_SLEEPCR_USBCR() volatile
    {
        SLEEPCR &= ~(1u << 16u);
    }

    /**
     * Toggle SLEEPCR's USBCR bit.
     *
     * USB Clock Control
     */
    inline void toggle_SLEEPCR_USBCR() volatile
    {
        SLEEPCR ^= 1u << 16u;
    }

    /**
     * Get SLEEPCR's SYSSEL bit.
     *
     * System Clock Selection Value
     */
    inline bool get_SLEEPCR_SYSSEL() volatile
    {
        return SLEEPCR & (1u << 0u);
    }

    /**
     * Set SLEEPCR's SYSSEL bit.
     *
     * System Clock Selection Value
     */
    inline void set_SLEEPCR_SYSSEL() volatile
    {
        SLEEPCR |= 1u << 0u;
    }

    /**
     * Clear SLEEPCR's SYSSEL bit.
     *
     * System Clock Selection Value
     */
    inline void clear_SLEEPCR_SYSSEL() volatile
    {
        SLEEPCR &= ~(1u << 0u);
    }

    /**
     * Toggle SLEEPCR's SYSSEL bit.
     *
     * System Clock Selection Value
     */
    inline void toggle_SLEEPCR_SYSSEL() volatile
    {
        SLEEPCR ^= 1u << 0u;
    }

    /**
     * Get all of SLEEPCR's bit fields.
     *
     * (read-write) Sleep Control Register
     */
    inline void get_SLEEPCR(bool &WDTCR, bool &CCUCR, bool &EBUCR,
                            bool &ETH0CR, bool &MMCCR, bool &USBCR,
                            bool &SYSSEL) volatile
    {
        uint32_t curr = SLEEPCR;

        WDTCR = curr & (1u << 21u);
        CCUCR = curr & (1u << 20u);
        EBUCR = curr & (1u << 19u);
        ETH0CR = curr & (1u << 18u);
        MMCCR = curr & (1u << 17u);
        USBCR = curr & (1u << 16u);
        SYSSEL = curr & (1u << 0u);
    }

    /**
     * Set all of SLEEPCR's bit fields.
     *
     * (read-write) Sleep Control Register
     */
    inline void set_SLEEPCR(bool WDTCR, bool CCUCR, bool EBUCR, bool ETH0CR,
                            bool MMCCR, bool USBCR, bool SYSSEL) volatile
    {
        uint32_t curr = SLEEPCR;

        curr &= ~(0b1u << 21u);
        curr |= (WDTCR & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (CCUCR & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (EBUCR & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (ETH0CR & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (MMCCR & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (USBCR & 0b1u) << 16u;
        curr &= ~(0b1u << 0u);
        curr |= (SYSSEL & 0b1u) << 0u;

        SLEEPCR = curr;
    }

    /**
     * Get DSLEEPCR's WDTCR bit.
     *
     * WDT Clock Control
     */
    inline bool get_DSLEEPCR_WDTCR() volatile
    {
        return DSLEEPCR & (1u << 21u);
    }

    /**
     * Set DSLEEPCR's WDTCR bit.
     *
     * WDT Clock Control
     */
    inline void set_DSLEEPCR_WDTCR() volatile
    {
        DSLEEPCR |= 1u << 21u;
    }

    /**
     * Clear DSLEEPCR's WDTCR bit.
     *
     * WDT Clock Control
     */
    inline void clear_DSLEEPCR_WDTCR() volatile
    {
        DSLEEPCR &= ~(1u << 21u);
    }

    /**
     * Toggle DSLEEPCR's WDTCR bit.
     *
     * WDT Clock Control
     */
    inline void toggle_DSLEEPCR_WDTCR() volatile
    {
        DSLEEPCR ^= 1u << 21u;
    }

    /**
     * Get DSLEEPCR's CCUCR bit.
     *
     * CCU Clock Control
     */
    inline bool get_DSLEEPCR_CCUCR() volatile
    {
        return DSLEEPCR & (1u << 20u);
    }

    /**
     * Set DSLEEPCR's CCUCR bit.
     *
     * CCU Clock Control
     */
    inline void set_DSLEEPCR_CCUCR() volatile
    {
        DSLEEPCR |= 1u << 20u;
    }

    /**
     * Clear DSLEEPCR's CCUCR bit.
     *
     * CCU Clock Control
     */
    inline void clear_DSLEEPCR_CCUCR() volatile
    {
        DSLEEPCR &= ~(1u << 20u);
    }

    /**
     * Toggle DSLEEPCR's CCUCR bit.
     *
     * CCU Clock Control
     */
    inline void toggle_DSLEEPCR_CCUCR() volatile
    {
        DSLEEPCR ^= 1u << 20u;
    }

    /**
     * Get DSLEEPCR's EBUCR bit.
     *
     * EBU Clock Control
     */
    inline bool get_DSLEEPCR_EBUCR() volatile
    {
        return DSLEEPCR & (1u << 19u);
    }

    /**
     * Set DSLEEPCR's EBUCR bit.
     *
     * EBU Clock Control
     */
    inline void set_DSLEEPCR_EBUCR() volatile
    {
        DSLEEPCR |= 1u << 19u;
    }

    /**
     * Clear DSLEEPCR's EBUCR bit.
     *
     * EBU Clock Control
     */
    inline void clear_DSLEEPCR_EBUCR() volatile
    {
        DSLEEPCR &= ~(1u << 19u);
    }

    /**
     * Toggle DSLEEPCR's EBUCR bit.
     *
     * EBU Clock Control
     */
    inline void toggle_DSLEEPCR_EBUCR() volatile
    {
        DSLEEPCR ^= 1u << 19u;
    }

    /**
     * Get DSLEEPCR's ETH0CR bit.
     *
     * Ethernet Clock Control
     */
    inline bool get_DSLEEPCR_ETH0CR() volatile
    {
        return DSLEEPCR & (1u << 18u);
    }

    /**
     * Set DSLEEPCR's ETH0CR bit.
     *
     * Ethernet Clock Control
     */
    inline void set_DSLEEPCR_ETH0CR() volatile
    {
        DSLEEPCR |= 1u << 18u;
    }

    /**
     * Clear DSLEEPCR's ETH0CR bit.
     *
     * Ethernet Clock Control
     */
    inline void clear_DSLEEPCR_ETH0CR() volatile
    {
        DSLEEPCR &= ~(1u << 18u);
    }

    /**
     * Toggle DSLEEPCR's ETH0CR bit.
     *
     * Ethernet Clock Control
     */
    inline void toggle_DSLEEPCR_ETH0CR() volatile
    {
        DSLEEPCR ^= 1u << 18u;
    }

    /**
     * Get DSLEEPCR's MMCCR bit.
     *
     * MMC Clock Control
     */
    inline bool get_DSLEEPCR_MMCCR() volatile
    {
        return DSLEEPCR & (1u << 17u);
    }

    /**
     * Set DSLEEPCR's MMCCR bit.
     *
     * MMC Clock Control
     */
    inline void set_DSLEEPCR_MMCCR() volatile
    {
        DSLEEPCR |= 1u << 17u;
    }

    /**
     * Clear DSLEEPCR's MMCCR bit.
     *
     * MMC Clock Control
     */
    inline void clear_DSLEEPCR_MMCCR() volatile
    {
        DSLEEPCR &= ~(1u << 17u);
    }

    /**
     * Toggle DSLEEPCR's MMCCR bit.
     *
     * MMC Clock Control
     */
    inline void toggle_DSLEEPCR_MMCCR() volatile
    {
        DSLEEPCR ^= 1u << 17u;
    }

    /**
     * Get DSLEEPCR's USBCR bit.
     *
     * USB Clock Control
     */
    inline bool get_DSLEEPCR_USBCR() volatile
    {
        return DSLEEPCR & (1u << 16u);
    }

    /**
     * Set DSLEEPCR's USBCR bit.
     *
     * USB Clock Control
     */
    inline void set_DSLEEPCR_USBCR() volatile
    {
        DSLEEPCR |= 1u << 16u;
    }

    /**
     * Clear DSLEEPCR's USBCR bit.
     *
     * USB Clock Control
     */
    inline void clear_DSLEEPCR_USBCR() volatile
    {
        DSLEEPCR &= ~(1u << 16u);
    }

    /**
     * Toggle DSLEEPCR's USBCR bit.
     *
     * USB Clock Control
     */
    inline void toggle_DSLEEPCR_USBCR() volatile
    {
        DSLEEPCR ^= 1u << 16u;
    }

    /**
     * Get DSLEEPCR's VCOPDN bit.
     *
     * VCO Power Down
     */
    inline bool get_DSLEEPCR_VCOPDN() volatile
    {
        return DSLEEPCR & (1u << 13u);
    }

    /**
     * Set DSLEEPCR's VCOPDN bit.
     *
     * VCO Power Down
     */
    inline void set_DSLEEPCR_VCOPDN() volatile
    {
        DSLEEPCR |= 1u << 13u;
    }

    /**
     * Clear DSLEEPCR's VCOPDN bit.
     *
     * VCO Power Down
     */
    inline void clear_DSLEEPCR_VCOPDN() volatile
    {
        DSLEEPCR &= ~(1u << 13u);
    }

    /**
     * Toggle DSLEEPCR's VCOPDN bit.
     *
     * VCO Power Down
     */
    inline void toggle_DSLEEPCR_VCOPDN() volatile
    {
        DSLEEPCR ^= 1u << 13u;
    }

    /**
     * Get DSLEEPCR's PLLPDN bit.
     *
     * PLL Power Down
     */
    inline bool get_DSLEEPCR_PLLPDN() volatile
    {
        return DSLEEPCR & (1u << 12u);
    }

    /**
     * Set DSLEEPCR's PLLPDN bit.
     *
     * PLL Power Down
     */
    inline void set_DSLEEPCR_PLLPDN() volatile
    {
        DSLEEPCR |= 1u << 12u;
    }

    /**
     * Clear DSLEEPCR's PLLPDN bit.
     *
     * PLL Power Down
     */
    inline void clear_DSLEEPCR_PLLPDN() volatile
    {
        DSLEEPCR &= ~(1u << 12u);
    }

    /**
     * Toggle DSLEEPCR's PLLPDN bit.
     *
     * PLL Power Down
     */
    inline void toggle_DSLEEPCR_PLLPDN() volatile
    {
        DSLEEPCR ^= 1u << 12u;
    }

    /**
     * Get DSLEEPCR's FPDN bit.
     *
     * Flash Power Down
     */
    inline bool get_DSLEEPCR_FPDN() volatile
    {
        return DSLEEPCR & (1u << 11u);
    }

    /**
     * Set DSLEEPCR's FPDN bit.
     *
     * Flash Power Down
     */
    inline void set_DSLEEPCR_FPDN() volatile
    {
        DSLEEPCR |= 1u << 11u;
    }

    /**
     * Clear DSLEEPCR's FPDN bit.
     *
     * Flash Power Down
     */
    inline void clear_DSLEEPCR_FPDN() volatile
    {
        DSLEEPCR &= ~(1u << 11u);
    }

    /**
     * Toggle DSLEEPCR's FPDN bit.
     *
     * Flash Power Down
     */
    inline void toggle_DSLEEPCR_FPDN() volatile
    {
        DSLEEPCR ^= 1u << 11u;
    }

    /**
     * Get DSLEEPCR's SYSSEL bit.
     *
     * System Clock Selection Value
     */
    inline bool get_DSLEEPCR_SYSSEL() volatile
    {
        return DSLEEPCR & (1u << 0u);
    }

    /**
     * Set DSLEEPCR's SYSSEL bit.
     *
     * System Clock Selection Value
     */
    inline void set_DSLEEPCR_SYSSEL() volatile
    {
        DSLEEPCR |= 1u << 0u;
    }

    /**
     * Clear DSLEEPCR's SYSSEL bit.
     *
     * System Clock Selection Value
     */
    inline void clear_DSLEEPCR_SYSSEL() volatile
    {
        DSLEEPCR &= ~(1u << 0u);
    }

    /**
     * Toggle DSLEEPCR's SYSSEL bit.
     *
     * System Clock Selection Value
     */
    inline void toggle_DSLEEPCR_SYSSEL() volatile
    {
        DSLEEPCR ^= 1u << 0u;
    }

    /**
     * Get all of DSLEEPCR's bit fields.
     *
     * (read-write) Deep Sleep Control Register
     */
    inline void get_DSLEEPCR(bool &WDTCR, bool &CCUCR, bool &EBUCR,
                             bool &ETH0CR, bool &MMCCR, bool &USBCR,
                             bool &VCOPDN, bool &PLLPDN, bool &FPDN,
                             bool &SYSSEL) volatile
    {
        uint32_t curr = DSLEEPCR;

        WDTCR = curr & (1u << 21u);
        CCUCR = curr & (1u << 20u);
        EBUCR = curr & (1u << 19u);
        ETH0CR = curr & (1u << 18u);
        MMCCR = curr & (1u << 17u);
        USBCR = curr & (1u << 16u);
        VCOPDN = curr & (1u << 13u);
        PLLPDN = curr & (1u << 12u);
        FPDN = curr & (1u << 11u);
        SYSSEL = curr & (1u << 0u);
    }

    /**
     * Set all of DSLEEPCR's bit fields.
     *
     * (read-write) Deep Sleep Control Register
     */
    inline void set_DSLEEPCR(bool WDTCR, bool CCUCR, bool EBUCR, bool ETH0CR,
                             bool MMCCR, bool USBCR, bool VCOPDN, bool PLLPDN,
                             bool FPDN, bool SYSSEL) volatile
    {
        uint32_t curr = DSLEEPCR;

        curr &= ~(0b1u << 21u);
        curr |= (WDTCR & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (CCUCR & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (EBUCR & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (ETH0CR & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (MMCCR & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (USBCR & 0b1u) << 16u;
        curr &= ~(0b1u << 13u);
        curr |= (VCOPDN & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (PLLPDN & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (FPDN & 0b1u) << 11u;
        curr &= ~(0b1u << 0u);
        curr |= (SYSSEL & 0b1u) << 0u;

        DSLEEPCR = curr;
    }

    /**
     * Get CGATSTAT0's ERU1 bit.
     *
     * ERU1 Gating Status
     */
    inline bool get_CGATSTAT0_ERU1() volatile
    {
        return CGATSTAT0 & (1u << 16u);
    }

    /**
     * Get CGATSTAT0's USIC0 bit.
     *
     * USIC0 Gating Status
     */
    inline bool get_CGATSTAT0_USIC0() volatile
    {
        return CGATSTAT0 & (1u << 11u);
    }

    /**
     * Get CGATSTAT0's POSIF1 bit.
     *
     * POSIF1 Gating Status
     */
    inline bool get_CGATSTAT0_POSIF1() volatile
    {
        return CGATSTAT0 & (1u << 10u);
    }

    /**
     * Get CGATSTAT0's POSIF0 bit.
     *
     * POSIF0 Gating Status
     */
    inline bool get_CGATSTAT0_POSIF0() volatile
    {
        return CGATSTAT0 & (1u << 9u);
    }

    /**
     * Get CGATSTAT0's CCU81 bit.
     *
     * CCU81 Gating Status
     */
    inline bool get_CGATSTAT0_CCU81() volatile
    {
        return CGATSTAT0 & (1u << 8u);
    }

    /**
     * Get CGATSTAT0's CCU80 bit.
     *
     * CCU80 Gating Status
     */
    inline bool get_CGATSTAT0_CCU80() volatile
    {
        return CGATSTAT0 & (1u << 7u);
    }

    /**
     * Get CGATSTAT0's CCU42 bit.
     *
     * CCU42 Gating Status
     */
    inline bool get_CGATSTAT0_CCU42() volatile
    {
        return CGATSTAT0 & (1u << 4u);
    }

    /**
     * Get CGATSTAT0's CCU41 bit.
     *
     * CCU41 Gating Status
     */
    inline bool get_CGATSTAT0_CCU41() volatile
    {
        return CGATSTAT0 & (1u << 3u);
    }

    /**
     * Get CGATSTAT0's CCU40 bit.
     *
     * CCU40 Gating Status
     */
    inline bool get_CGATSTAT0_CCU40() volatile
    {
        return CGATSTAT0 & (1u << 2u);
    }

    /**
     * Get CGATSTAT0's DSD bit.
     *
     * DSD Gating Status
     */
    inline bool get_CGATSTAT0_DSD() volatile
    {
        return CGATSTAT0 & (1u << 1u);
    }

    /**
     * Get CGATSTAT0's VADC bit.
     *
     * VADC Gating Status
     */
    inline bool get_CGATSTAT0_VADC() volatile
    {
        return CGATSTAT0 & (1u << 0u);
    }

    /**
     * Get all of CGATSTAT0's bit fields.
     *
     * (read-only) Peripheral 0 Clock Gating Status
     */
    inline void get_CGATSTAT0(bool &ERU1, bool &USIC0, bool &POSIF1,
                              bool &POSIF0, bool &CCU81, bool &CCU80,
                              bool &CCU42, bool &CCU41, bool &CCU40, bool &DSD,
                              bool &VADC) volatile
    {
        uint32_t curr = CGATSTAT0;

        ERU1 = curr & (1u << 16u);
        USIC0 = curr & (1u << 11u);
        POSIF1 = curr & (1u << 10u);
        POSIF0 = curr & (1u << 9u);
        CCU81 = curr & (1u << 8u);
        CCU80 = curr & (1u << 7u);
        CCU42 = curr & (1u << 4u);
        CCU41 = curr & (1u << 3u);
        CCU40 = curr & (1u << 2u);
        DSD = curr & (1u << 1u);
        VADC = curr & (1u << 0u);
    }

    /**
     * Set CGATSET0's ERU1 bit.
     *
     * ERU1 Gating Set
     */
    inline void set_CGATSET0_ERU1() volatile
    {
        CGATSET0 |= 1u << 16u;
    }

    /**
     * Clear CGATSET0's ERU1 bit.
     *
     * ERU1 Gating Set
     */
    inline void clear_CGATSET0_ERU1() volatile
    {
        CGATSET0 &= ~(1u << 16u);
    }

    /**
     * Toggle CGATSET0's ERU1 bit.
     *
     * ERU1 Gating Set
     */
    inline void toggle_CGATSET0_ERU1() volatile
    {
        CGATSET0 ^= 1u << 16u;
    }

    /**
     * Set CGATSET0's USIC0 bit.
     *
     * USIC0 Gating Set
     */
    inline void set_CGATSET0_USIC0() volatile
    {
        CGATSET0 |= 1u << 11u;
    }

    /**
     * Clear CGATSET0's USIC0 bit.
     *
     * USIC0 Gating Set
     */
    inline void clear_CGATSET0_USIC0() volatile
    {
        CGATSET0 &= ~(1u << 11u);
    }

    /**
     * Toggle CGATSET0's USIC0 bit.
     *
     * USIC0 Gating Set
     */
    inline void toggle_CGATSET0_USIC0() volatile
    {
        CGATSET0 ^= 1u << 11u;
    }

    /**
     * Set CGATSET0's POSIF1 bit.
     *
     * POSIF1 Gating Set
     */
    inline void set_CGATSET0_POSIF1() volatile
    {
        CGATSET0 |= 1u << 10u;
    }

    /**
     * Clear CGATSET0's POSIF1 bit.
     *
     * POSIF1 Gating Set
     */
    inline void clear_CGATSET0_POSIF1() volatile
    {
        CGATSET0 &= ~(1u << 10u);
    }

    /**
     * Toggle CGATSET0's POSIF1 bit.
     *
     * POSIF1 Gating Set
     */
    inline void toggle_CGATSET0_POSIF1() volatile
    {
        CGATSET0 ^= 1u << 10u;
    }

    /**
     * Set CGATSET0's POSIF0 bit.
     *
     * POSIF0 Gating Set
     */
    inline void set_CGATSET0_POSIF0() volatile
    {
        CGATSET0 |= 1u << 9u;
    }

    /**
     * Clear CGATSET0's POSIF0 bit.
     *
     * POSIF0 Gating Set
     */
    inline void clear_CGATSET0_POSIF0() volatile
    {
        CGATSET0 &= ~(1u << 9u);
    }

    /**
     * Toggle CGATSET0's POSIF0 bit.
     *
     * POSIF0 Gating Set
     */
    inline void toggle_CGATSET0_POSIF0() volatile
    {
        CGATSET0 ^= 1u << 9u;
    }

    /**
     * Set CGATSET0's CCU81 bit.
     *
     * CCU81 Gating Set
     */
    inline void set_CGATSET0_CCU81() volatile
    {
        CGATSET0 |= 1u << 8u;
    }

    /**
     * Clear CGATSET0's CCU81 bit.
     *
     * CCU81 Gating Set
     */
    inline void clear_CGATSET0_CCU81() volatile
    {
        CGATSET0 &= ~(1u << 8u);
    }

    /**
     * Toggle CGATSET0's CCU81 bit.
     *
     * CCU81 Gating Set
     */
    inline void toggle_CGATSET0_CCU81() volatile
    {
        CGATSET0 ^= 1u << 8u;
    }

    /**
     * Set CGATSET0's CCU80 bit.
     *
     * CCU80 Gating Set
     */
    inline void set_CGATSET0_CCU80() volatile
    {
        CGATSET0 |= 1u << 7u;
    }

    /**
     * Clear CGATSET0's CCU80 bit.
     *
     * CCU80 Gating Set
     */
    inline void clear_CGATSET0_CCU80() volatile
    {
        CGATSET0 &= ~(1u << 7u);
    }

    /**
     * Toggle CGATSET0's CCU80 bit.
     *
     * CCU80 Gating Set
     */
    inline void toggle_CGATSET0_CCU80() volatile
    {
        CGATSET0 ^= 1u << 7u;
    }

    /**
     * Set CGATSET0's CCU42 bit.
     *
     * CCU42 Gating Set
     */
    inline void set_CGATSET0_CCU42() volatile
    {
        CGATSET0 |= 1u << 4u;
    }

    /**
     * Clear CGATSET0's CCU42 bit.
     *
     * CCU42 Gating Set
     */
    inline void clear_CGATSET0_CCU42() volatile
    {
        CGATSET0 &= ~(1u << 4u);
    }

    /**
     * Toggle CGATSET0's CCU42 bit.
     *
     * CCU42 Gating Set
     */
    inline void toggle_CGATSET0_CCU42() volatile
    {
        CGATSET0 ^= 1u << 4u;
    }

    /**
     * Set CGATSET0's CCU41 bit.
     *
     * CCU41 Gating Set
     */
    inline void set_CGATSET0_CCU41() volatile
    {
        CGATSET0 |= 1u << 3u;
    }

    /**
     * Clear CGATSET0's CCU41 bit.
     *
     * CCU41 Gating Set
     */
    inline void clear_CGATSET0_CCU41() volatile
    {
        CGATSET0 &= ~(1u << 3u);
    }

    /**
     * Toggle CGATSET0's CCU41 bit.
     *
     * CCU41 Gating Set
     */
    inline void toggle_CGATSET0_CCU41() volatile
    {
        CGATSET0 ^= 1u << 3u;
    }

    /**
     * Set CGATSET0's CCU40 bit.
     *
     * CCU40 Gating Set
     */
    inline void set_CGATSET0_CCU40() volatile
    {
        CGATSET0 |= 1u << 2u;
    }

    /**
     * Clear CGATSET0's CCU40 bit.
     *
     * CCU40 Gating Set
     */
    inline void clear_CGATSET0_CCU40() volatile
    {
        CGATSET0 &= ~(1u << 2u);
    }

    /**
     * Toggle CGATSET0's CCU40 bit.
     *
     * CCU40 Gating Set
     */
    inline void toggle_CGATSET0_CCU40() volatile
    {
        CGATSET0 ^= 1u << 2u;
    }

    /**
     * Set CGATSET0's DSD bit.
     *
     * DSD Gating Set
     */
    inline void set_CGATSET0_DSD() volatile
    {
        CGATSET0 |= 1u << 1u;
    }

    /**
     * Clear CGATSET0's DSD bit.
     *
     * DSD Gating Set
     */
    inline void clear_CGATSET0_DSD() volatile
    {
        CGATSET0 &= ~(1u << 1u);
    }

    /**
     * Toggle CGATSET0's DSD bit.
     *
     * DSD Gating Set
     */
    inline void toggle_CGATSET0_DSD() volatile
    {
        CGATSET0 ^= 1u << 1u;
    }

    /**
     * Set CGATSET0's VADC bit.
     *
     * VADC Gating Set
     */
    inline void set_CGATSET0_VADC() volatile
    {
        CGATSET0 |= 1u << 0u;
    }

    /**
     * Clear CGATSET0's VADC bit.
     *
     * VADC Gating Set
     */
    inline void clear_CGATSET0_VADC() volatile
    {
        CGATSET0 &= ~(1u << 0u);
    }

    /**
     * Toggle CGATSET0's VADC bit.
     *
     * VADC Gating Set
     */
    inline void toggle_CGATSET0_VADC() volatile
    {
        CGATSET0 ^= 1u << 0u;
    }

    /**
     * Set all of CGATSET0's bit fields.
     *
     * (write-only) Peripheral 0 Clock Gating Set
     */
    inline void set_CGATSET0(bool ERU1, bool USIC0, bool POSIF1, bool POSIF0,
                             bool CCU81, bool CCU80, bool CCU42, bool CCU41,
                             bool CCU40, bool DSD, bool VADC) volatile
    {
        uint32_t curr = CGATSET0;

        curr &= ~(0b1u << 16u);
        curr |= (ERU1 & 0b1u) << 16u;
        curr &= ~(0b1u << 11u);
        curr |= (USIC0 & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (POSIF1 & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (POSIF0 & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (CCU81 & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (CCU80 & 0b1u) << 7u;
        curr &= ~(0b1u << 4u);
        curr |= (CCU42 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (CCU41 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (CCU40 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSD & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (VADC & 0b1u) << 0u;

        CGATSET0 = curr;
    }

    /**
     * Set CGATCLR0's ERU1 bit.
     *
     * ERU1 Gating Clear
     */
    inline void set_CGATCLR0_ERU1() volatile
    {
        CGATCLR0 |= 1u << 16u;
    }

    /**
     * Clear CGATCLR0's ERU1 bit.
     *
     * ERU1 Gating Clear
     */
    inline void clear_CGATCLR0_ERU1() volatile
    {
        CGATCLR0 &= ~(1u << 16u);
    }

    /**
     * Toggle CGATCLR0's ERU1 bit.
     *
     * ERU1 Gating Clear
     */
    inline void toggle_CGATCLR0_ERU1() volatile
    {
        CGATCLR0 ^= 1u << 16u;
    }

    /**
     * Set CGATCLR0's USIC0 bit.
     *
     * USIC0 Gating Clear
     */
    inline void set_CGATCLR0_USIC0() volatile
    {
        CGATCLR0 |= 1u << 11u;
    }

    /**
     * Clear CGATCLR0's USIC0 bit.
     *
     * USIC0 Gating Clear
     */
    inline void clear_CGATCLR0_USIC0() volatile
    {
        CGATCLR0 &= ~(1u << 11u);
    }

    /**
     * Toggle CGATCLR0's USIC0 bit.
     *
     * USIC0 Gating Clear
     */
    inline void toggle_CGATCLR0_USIC0() volatile
    {
        CGATCLR0 ^= 1u << 11u;
    }

    /**
     * Set CGATCLR0's POSIF1 bit.
     *
     * POSIF1 Gating Clear
     */
    inline void set_CGATCLR0_POSIF1() volatile
    {
        CGATCLR0 |= 1u << 10u;
    }

    /**
     * Clear CGATCLR0's POSIF1 bit.
     *
     * POSIF1 Gating Clear
     */
    inline void clear_CGATCLR0_POSIF1() volatile
    {
        CGATCLR0 &= ~(1u << 10u);
    }

    /**
     * Toggle CGATCLR0's POSIF1 bit.
     *
     * POSIF1 Gating Clear
     */
    inline void toggle_CGATCLR0_POSIF1() volatile
    {
        CGATCLR0 ^= 1u << 10u;
    }

    /**
     * Set CGATCLR0's POSIF0 bit.
     *
     * POSIF0 Gating Clear
     */
    inline void set_CGATCLR0_POSIF0() volatile
    {
        CGATCLR0 |= 1u << 9u;
    }

    /**
     * Clear CGATCLR0's POSIF0 bit.
     *
     * POSIF0 Gating Clear
     */
    inline void clear_CGATCLR0_POSIF0() volatile
    {
        CGATCLR0 &= ~(1u << 9u);
    }

    /**
     * Toggle CGATCLR0's POSIF0 bit.
     *
     * POSIF0 Gating Clear
     */
    inline void toggle_CGATCLR0_POSIF0() volatile
    {
        CGATCLR0 ^= 1u << 9u;
    }

    /**
     * Set CGATCLR0's CCU81 bit.
     *
     * CCU81 Gating Clear
     */
    inline void set_CGATCLR0_CCU81() volatile
    {
        CGATCLR0 |= 1u << 8u;
    }

    /**
     * Clear CGATCLR0's CCU81 bit.
     *
     * CCU81 Gating Clear
     */
    inline void clear_CGATCLR0_CCU81() volatile
    {
        CGATCLR0 &= ~(1u << 8u);
    }

    /**
     * Toggle CGATCLR0's CCU81 bit.
     *
     * CCU81 Gating Clear
     */
    inline void toggle_CGATCLR0_CCU81() volatile
    {
        CGATCLR0 ^= 1u << 8u;
    }

    /**
     * Set CGATCLR0's CCU80 bit.
     *
     * CCU80 Gating Clear
     */
    inline void set_CGATCLR0_CCU80() volatile
    {
        CGATCLR0 |= 1u << 7u;
    }

    /**
     * Clear CGATCLR0's CCU80 bit.
     *
     * CCU80 Gating Clear
     */
    inline void clear_CGATCLR0_CCU80() volatile
    {
        CGATCLR0 &= ~(1u << 7u);
    }

    /**
     * Toggle CGATCLR0's CCU80 bit.
     *
     * CCU80 Gating Clear
     */
    inline void toggle_CGATCLR0_CCU80() volatile
    {
        CGATCLR0 ^= 1u << 7u;
    }

    /**
     * Set CGATCLR0's CCU42 bit.
     *
     * CCU42 Gating Clear
     */
    inline void set_CGATCLR0_CCU42() volatile
    {
        CGATCLR0 |= 1u << 4u;
    }

    /**
     * Clear CGATCLR0's CCU42 bit.
     *
     * CCU42 Gating Clear
     */
    inline void clear_CGATCLR0_CCU42() volatile
    {
        CGATCLR0 &= ~(1u << 4u);
    }

    /**
     * Toggle CGATCLR0's CCU42 bit.
     *
     * CCU42 Gating Clear
     */
    inline void toggle_CGATCLR0_CCU42() volatile
    {
        CGATCLR0 ^= 1u << 4u;
    }

    /**
     * Set CGATCLR0's CCU41 bit.
     *
     * CCU41 Gating Clear
     */
    inline void set_CGATCLR0_CCU41() volatile
    {
        CGATCLR0 |= 1u << 3u;
    }

    /**
     * Clear CGATCLR0's CCU41 bit.
     *
     * CCU41 Gating Clear
     */
    inline void clear_CGATCLR0_CCU41() volatile
    {
        CGATCLR0 &= ~(1u << 3u);
    }

    /**
     * Toggle CGATCLR0's CCU41 bit.
     *
     * CCU41 Gating Clear
     */
    inline void toggle_CGATCLR0_CCU41() volatile
    {
        CGATCLR0 ^= 1u << 3u;
    }

    /**
     * Set CGATCLR0's CCU40 bit.
     *
     * CCU40 Gating Clear
     */
    inline void set_CGATCLR0_CCU40() volatile
    {
        CGATCLR0 |= 1u << 2u;
    }

    /**
     * Clear CGATCLR0's CCU40 bit.
     *
     * CCU40 Gating Clear
     */
    inline void clear_CGATCLR0_CCU40() volatile
    {
        CGATCLR0 &= ~(1u << 2u);
    }

    /**
     * Toggle CGATCLR0's CCU40 bit.
     *
     * CCU40 Gating Clear
     */
    inline void toggle_CGATCLR0_CCU40() volatile
    {
        CGATCLR0 ^= 1u << 2u;
    }

    /**
     * Set CGATCLR0's DSD bit.
     *
     * DSD Gating Clear
     */
    inline void set_CGATCLR0_DSD() volatile
    {
        CGATCLR0 |= 1u << 1u;
    }

    /**
     * Clear CGATCLR0's DSD bit.
     *
     * DSD Gating Clear
     */
    inline void clear_CGATCLR0_DSD() volatile
    {
        CGATCLR0 &= ~(1u << 1u);
    }

    /**
     * Toggle CGATCLR0's DSD bit.
     *
     * DSD Gating Clear
     */
    inline void toggle_CGATCLR0_DSD() volatile
    {
        CGATCLR0 ^= 1u << 1u;
    }

    /**
     * Set CGATCLR0's VADC bit.
     *
     * VADC Gating Clear
     */
    inline void set_CGATCLR0_VADC() volatile
    {
        CGATCLR0 |= 1u << 0u;
    }

    /**
     * Clear CGATCLR0's VADC bit.
     *
     * VADC Gating Clear
     */
    inline void clear_CGATCLR0_VADC() volatile
    {
        CGATCLR0 &= ~(1u << 0u);
    }

    /**
     * Toggle CGATCLR0's VADC bit.
     *
     * VADC Gating Clear
     */
    inline void toggle_CGATCLR0_VADC() volatile
    {
        CGATCLR0 ^= 1u << 0u;
    }

    /**
     * Set all of CGATCLR0's bit fields.
     *
     * (write-only) Peripheral 0 Clock Gating Clear
     */
    inline void set_CGATCLR0(bool ERU1, bool USIC0, bool POSIF1, bool POSIF0,
                             bool CCU81, bool CCU80, bool CCU42, bool CCU41,
                             bool CCU40, bool DSD, bool VADC) volatile
    {
        uint32_t curr = CGATCLR0;

        curr &= ~(0b1u << 16u);
        curr |= (ERU1 & 0b1u) << 16u;
        curr &= ~(0b1u << 11u);
        curr |= (USIC0 & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (POSIF1 & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (POSIF0 & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (CCU81 & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (CCU80 & 0b1u) << 7u;
        curr &= ~(0b1u << 4u);
        curr |= (CCU42 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (CCU41 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (CCU40 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSD & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (VADC & 0b1u) << 0u;

        CGATCLR0 = curr;
    }

    /**
     * Get CGATSTAT1's PPORTS bit.
     *
     * PORTS Gating Status
     */
    inline bool get_CGATSTAT1_PPORTS() volatile
    {
        return CGATSTAT1 & (1u << 9u);
    }

    /**
     * Get CGATSTAT1's USIC2 bit.
     *
     * USIC2 Gating Status
     */
    inline bool get_CGATSTAT1_USIC2() volatile
    {
        return CGATSTAT1 & (1u << 8u);
    }

    /**
     * Get CGATSTAT1's USIC1 bit.
     *
     * USIC1 Gating Status
     */
    inline bool get_CGATSTAT1_USIC1() volatile
    {
        return CGATSTAT1 & (1u << 7u);
    }

    /**
     * Get CGATSTAT1's MMCI bit.
     *
     * MMC Interface Gating Status
     */
    inline bool get_CGATSTAT1_MMCI() volatile
    {
        return CGATSTAT1 & (1u << 6u);
    }

    /**
     * Get CGATSTAT1's DAC bit.
     *
     * DAC Gating Status
     */
    inline bool get_CGATSTAT1_DAC() volatile
    {
        return CGATSTAT1 & (1u << 5u);
    }

    /**
     * Get CGATSTAT1's MCAN0 bit.
     *
     * MultiCAN Gating Status
     */
    inline bool get_CGATSTAT1_MCAN0() volatile
    {
        return CGATSTAT1 & (1u << 4u);
    }

    /**
     * Get CGATSTAT1's LEDTSCU0 bit.
     *
     * LEDTS Gating Status
     */
    inline bool get_CGATSTAT1_LEDTSCU0() volatile
    {
        return CGATSTAT1 & (1u << 3u);
    }

    /**
     * Get CGATSTAT1's CCU43 bit.
     *
     * CCU43 Gating Status
     */
    inline bool get_CGATSTAT1_CCU43() volatile
    {
        return CGATSTAT1 & (1u << 0u);
    }

    /**
     * Get all of CGATSTAT1's bit fields.
     *
     * (read-only) Peripheral 1 Clock Gating Status
     */
    inline void get_CGATSTAT1(bool &PPORTS, bool &USIC2, bool &USIC1,
                              bool &MMCI, bool &DAC, bool &MCAN0,
                              bool &LEDTSCU0, bool &CCU43) volatile
    {
        uint32_t curr = CGATSTAT1;

        PPORTS = curr & (1u << 9u);
        USIC2 = curr & (1u << 8u);
        USIC1 = curr & (1u << 7u);
        MMCI = curr & (1u << 6u);
        DAC = curr & (1u << 5u);
        MCAN0 = curr & (1u << 4u);
        LEDTSCU0 = curr & (1u << 3u);
        CCU43 = curr & (1u << 0u);
    }

    /**
     * Set CGATSET1's PPORTS bit.
     *
     * PORTS Gating Set
     */
    inline void set_CGATSET1_PPORTS() volatile
    {
        CGATSET1 |= 1u << 9u;
    }

    /**
     * Clear CGATSET1's PPORTS bit.
     *
     * PORTS Gating Set
     */
    inline void clear_CGATSET1_PPORTS() volatile
    {
        CGATSET1 &= ~(1u << 9u);
    }

    /**
     * Toggle CGATSET1's PPORTS bit.
     *
     * PORTS Gating Set
     */
    inline void toggle_CGATSET1_PPORTS() volatile
    {
        CGATSET1 ^= 1u << 9u;
    }

    /**
     * Set CGATSET1's USIC2 bit.
     *
     * USIC2 Gating Set
     */
    inline void set_CGATSET1_USIC2() volatile
    {
        CGATSET1 |= 1u << 8u;
    }

    /**
     * Clear CGATSET1's USIC2 bit.
     *
     * USIC2 Gating Set
     */
    inline void clear_CGATSET1_USIC2() volatile
    {
        CGATSET1 &= ~(1u << 8u);
    }

    /**
     * Toggle CGATSET1's USIC2 bit.
     *
     * USIC2 Gating Set
     */
    inline void toggle_CGATSET1_USIC2() volatile
    {
        CGATSET1 ^= 1u << 8u;
    }

    /**
     * Set CGATSET1's USIC1 bit.
     *
     * USIC1 Gating Set
     */
    inline void set_CGATSET1_USIC1() volatile
    {
        CGATSET1 |= 1u << 7u;
    }

    /**
     * Clear CGATSET1's USIC1 bit.
     *
     * USIC1 Gating Set
     */
    inline void clear_CGATSET1_USIC1() volatile
    {
        CGATSET1 &= ~(1u << 7u);
    }

    /**
     * Toggle CGATSET1's USIC1 bit.
     *
     * USIC1 Gating Set
     */
    inline void toggle_CGATSET1_USIC1() volatile
    {
        CGATSET1 ^= 1u << 7u;
    }

    /**
     * Set CGATSET1's MMCI bit.
     *
     * MMC Interface Gating Set
     */
    inline void set_CGATSET1_MMCI() volatile
    {
        CGATSET1 |= 1u << 6u;
    }

    /**
     * Clear CGATSET1's MMCI bit.
     *
     * MMC Interface Gating Set
     */
    inline void clear_CGATSET1_MMCI() volatile
    {
        CGATSET1 &= ~(1u << 6u);
    }

    /**
     * Toggle CGATSET1's MMCI bit.
     *
     * MMC Interface Gating Set
     */
    inline void toggle_CGATSET1_MMCI() volatile
    {
        CGATSET1 ^= 1u << 6u;
    }

    /**
     * Set CGATSET1's DAC bit.
     *
     * DAC Gating Set
     */
    inline void set_CGATSET1_DAC() volatile
    {
        CGATSET1 |= 1u << 5u;
    }

    /**
     * Clear CGATSET1's DAC bit.
     *
     * DAC Gating Set
     */
    inline void clear_CGATSET1_DAC() volatile
    {
        CGATSET1 &= ~(1u << 5u);
    }

    /**
     * Toggle CGATSET1's DAC bit.
     *
     * DAC Gating Set
     */
    inline void toggle_CGATSET1_DAC() volatile
    {
        CGATSET1 ^= 1u << 5u;
    }

    /**
     * Set CGATSET1's MCAN0 bit.
     *
     * MultiCAN Gating Set
     */
    inline void set_CGATSET1_MCAN0() volatile
    {
        CGATSET1 |= 1u << 4u;
    }

    /**
     * Clear CGATSET1's MCAN0 bit.
     *
     * MultiCAN Gating Set
     */
    inline void clear_CGATSET1_MCAN0() volatile
    {
        CGATSET1 &= ~(1u << 4u);
    }

    /**
     * Toggle CGATSET1's MCAN0 bit.
     *
     * MultiCAN Gating Set
     */
    inline void toggle_CGATSET1_MCAN0() volatile
    {
        CGATSET1 ^= 1u << 4u;
    }

    /**
     * Set CGATSET1's LEDTSCU0 bit.
     *
     * LEDTS Gating Set
     */
    inline void set_CGATSET1_LEDTSCU0() volatile
    {
        CGATSET1 |= 1u << 3u;
    }

    /**
     * Clear CGATSET1's LEDTSCU0 bit.
     *
     * LEDTS Gating Set
     */
    inline void clear_CGATSET1_LEDTSCU0() volatile
    {
        CGATSET1 &= ~(1u << 3u);
    }

    /**
     * Toggle CGATSET1's LEDTSCU0 bit.
     *
     * LEDTS Gating Set
     */
    inline void toggle_CGATSET1_LEDTSCU0() volatile
    {
        CGATSET1 ^= 1u << 3u;
    }

    /**
     * Set CGATSET1's CCU43 bit.
     *
     * CCU43 Gating Set
     */
    inline void set_CGATSET1_CCU43() volatile
    {
        CGATSET1 |= 1u << 0u;
    }

    /**
     * Clear CGATSET1's CCU43 bit.
     *
     * CCU43 Gating Set
     */
    inline void clear_CGATSET1_CCU43() volatile
    {
        CGATSET1 &= ~(1u << 0u);
    }

    /**
     * Toggle CGATSET1's CCU43 bit.
     *
     * CCU43 Gating Set
     */
    inline void toggle_CGATSET1_CCU43() volatile
    {
        CGATSET1 ^= 1u << 0u;
    }

    /**
     * Set all of CGATSET1's bit fields.
     *
     * (write-only) Peripheral 1 Clock Gating Set
     */
    inline void set_CGATSET1(bool PPORTS, bool USIC2, bool USIC1, bool MMCI,
                             bool DAC, bool MCAN0, bool LEDTSCU0,
                             bool CCU43) volatile
    {
        uint32_t curr = CGATSET1;

        curr &= ~(0b1u << 9u);
        curr |= (PPORTS & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (USIC2 & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (USIC1 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (MMCI & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (DAC & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (MCAN0 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (LEDTSCU0 & 0b1u) << 3u;
        curr &= ~(0b1u << 0u);
        curr |= (CCU43 & 0b1u) << 0u;

        CGATSET1 = curr;
    }

    /**
     * Set CGATCLR1's PPORTS bit.
     *
     * PORTS Gating Clear
     */
    inline void set_CGATCLR1_PPORTS() volatile
    {
        CGATCLR1 |= 1u << 9u;
    }

    /**
     * Clear CGATCLR1's PPORTS bit.
     *
     * PORTS Gating Clear
     */
    inline void clear_CGATCLR1_PPORTS() volatile
    {
        CGATCLR1 &= ~(1u << 9u);
    }

    /**
     * Toggle CGATCLR1's PPORTS bit.
     *
     * PORTS Gating Clear
     */
    inline void toggle_CGATCLR1_PPORTS() volatile
    {
        CGATCLR1 ^= 1u << 9u;
    }

    /**
     * Set CGATCLR1's USIC2 bit.
     *
     * USIC2 Gating Clear
     */
    inline void set_CGATCLR1_USIC2() volatile
    {
        CGATCLR1 |= 1u << 8u;
    }

    /**
     * Clear CGATCLR1's USIC2 bit.
     *
     * USIC2 Gating Clear
     */
    inline void clear_CGATCLR1_USIC2() volatile
    {
        CGATCLR1 &= ~(1u << 8u);
    }

    /**
     * Toggle CGATCLR1's USIC2 bit.
     *
     * USIC2 Gating Clear
     */
    inline void toggle_CGATCLR1_USIC2() volatile
    {
        CGATCLR1 ^= 1u << 8u;
    }

    /**
     * Set CGATCLR1's USIC1 bit.
     *
     * USIC1 Gating Clear
     */
    inline void set_CGATCLR1_USIC1() volatile
    {
        CGATCLR1 |= 1u << 7u;
    }

    /**
     * Clear CGATCLR1's USIC1 bit.
     *
     * USIC1 Gating Clear
     */
    inline void clear_CGATCLR1_USIC1() volatile
    {
        CGATCLR1 &= ~(1u << 7u);
    }

    /**
     * Toggle CGATCLR1's USIC1 bit.
     *
     * USIC1 Gating Clear
     */
    inline void toggle_CGATCLR1_USIC1() volatile
    {
        CGATCLR1 ^= 1u << 7u;
    }

    /**
     * Set CGATCLR1's MMCI bit.
     *
     * MMC Interface Gating Clear
     */
    inline void set_CGATCLR1_MMCI() volatile
    {
        CGATCLR1 |= 1u << 6u;
    }

    /**
     * Clear CGATCLR1's MMCI bit.
     *
     * MMC Interface Gating Clear
     */
    inline void clear_CGATCLR1_MMCI() volatile
    {
        CGATCLR1 &= ~(1u << 6u);
    }

    /**
     * Toggle CGATCLR1's MMCI bit.
     *
     * MMC Interface Gating Clear
     */
    inline void toggle_CGATCLR1_MMCI() volatile
    {
        CGATCLR1 ^= 1u << 6u;
    }

    /**
     * Set CGATCLR1's DAC bit.
     *
     * DAC Gating Clear
     */
    inline void set_CGATCLR1_DAC() volatile
    {
        CGATCLR1 |= 1u << 5u;
    }

    /**
     * Clear CGATCLR1's DAC bit.
     *
     * DAC Gating Clear
     */
    inline void clear_CGATCLR1_DAC() volatile
    {
        CGATCLR1 &= ~(1u << 5u);
    }

    /**
     * Toggle CGATCLR1's DAC bit.
     *
     * DAC Gating Clear
     */
    inline void toggle_CGATCLR1_DAC() volatile
    {
        CGATCLR1 ^= 1u << 5u;
    }

    /**
     * Set CGATCLR1's MCAN0 bit.
     *
     * MultiCAN Gating Clear
     */
    inline void set_CGATCLR1_MCAN0() volatile
    {
        CGATCLR1 |= 1u << 4u;
    }

    /**
     * Clear CGATCLR1's MCAN0 bit.
     *
     * MultiCAN Gating Clear
     */
    inline void clear_CGATCLR1_MCAN0() volatile
    {
        CGATCLR1 &= ~(1u << 4u);
    }

    /**
     * Toggle CGATCLR1's MCAN0 bit.
     *
     * MultiCAN Gating Clear
     */
    inline void toggle_CGATCLR1_MCAN0() volatile
    {
        CGATCLR1 ^= 1u << 4u;
    }

    /**
     * Set CGATCLR1's LEDTSCU0 bit.
     *
     * LEDTS Gating Clear
     */
    inline void set_CGATCLR1_LEDTSCU0() volatile
    {
        CGATCLR1 |= 1u << 3u;
    }

    /**
     * Clear CGATCLR1's LEDTSCU0 bit.
     *
     * LEDTS Gating Clear
     */
    inline void clear_CGATCLR1_LEDTSCU0() volatile
    {
        CGATCLR1 &= ~(1u << 3u);
    }

    /**
     * Toggle CGATCLR1's LEDTSCU0 bit.
     *
     * LEDTS Gating Clear
     */
    inline void toggle_CGATCLR1_LEDTSCU0() volatile
    {
        CGATCLR1 ^= 1u << 3u;
    }

    /**
     * Set CGATCLR1's CCU43 bit.
     *
     * CCU43 Gating Clear
     */
    inline void set_CGATCLR1_CCU43() volatile
    {
        CGATCLR1 |= 1u << 0u;
    }

    /**
     * Clear CGATCLR1's CCU43 bit.
     *
     * CCU43 Gating Clear
     */
    inline void clear_CGATCLR1_CCU43() volatile
    {
        CGATCLR1 &= ~(1u << 0u);
    }

    /**
     * Toggle CGATCLR1's CCU43 bit.
     *
     * CCU43 Gating Clear
     */
    inline void toggle_CGATCLR1_CCU43() volatile
    {
        CGATCLR1 ^= 1u << 0u;
    }

    /**
     * Set all of CGATCLR1's bit fields.
     *
     * (write-only) Peripheral 1 Clock Gating Clear
     */
    inline void set_CGATCLR1(bool PPORTS, bool USIC2, bool USIC1, bool MMCI,
                             bool DAC, bool MCAN0, bool LEDTSCU0,
                             bool CCU43) volatile
    {
        uint32_t curr = CGATCLR1;

        curr &= ~(0b1u << 9u);
        curr |= (PPORTS & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (USIC2 & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (USIC1 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (MMCI & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (DAC & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (MCAN0 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (LEDTSCU0 & 0b1u) << 3u;
        curr &= ~(0b1u << 0u);
        curr |= (CCU43 & 0b1u) << 0u;

        CGATCLR1 = curr;
    }

    /**
     * Get CGATSTAT2's USB bit.
     *
     * USB Gating Status
     */
    inline bool get_CGATSTAT2_USB() volatile
    {
        return CGATSTAT2 & (1u << 7u);
    }

    /**
     * Get CGATSTAT2's FCE bit.
     *
     * FCE Gating Status
     */
    inline bool get_CGATSTAT2_FCE() volatile
    {
        return CGATSTAT2 & (1u << 6u);
    }

    /**
     * Get CGATSTAT2's DMA1 bit.
     *
     * DMA1 Gating Status
     */
    inline bool get_CGATSTAT2_DMA1() volatile
    {
        return CGATSTAT2 & (1u << 5u);
    }

    /**
     * Get CGATSTAT2's DMA0 bit.
     *
     * DMA0 Gating Status
     */
    inline bool get_CGATSTAT2_DMA0() volatile
    {
        return CGATSTAT2 & (1u << 4u);
    }

    /**
     * Get CGATSTAT2's ETH0 bit.
     *
     * ETH0 Gating Status
     */
    inline bool get_CGATSTAT2_ETH0() volatile
    {
        return CGATSTAT2 & (1u << 2u);
    }

    /**
     * Get CGATSTAT2's WDT bit.
     *
     * WDT Gating Status
     */
    inline bool get_CGATSTAT2_WDT() volatile
    {
        return CGATSTAT2 & (1u << 1u);
    }

    /**
     * Get all of CGATSTAT2's bit fields.
     *
     * (read-only) Peripheral 2 Clock Gating Status
     */
    inline void get_CGATSTAT2(bool &USB, bool &FCE, bool &DMA1, bool &DMA0,
                              bool &ETH0, bool &WDT) volatile
    {
        uint32_t curr = CGATSTAT2;

        USB = curr & (1u << 7u);
        FCE = curr & (1u << 6u);
        DMA1 = curr & (1u << 5u);
        DMA0 = curr & (1u << 4u);
        ETH0 = curr & (1u << 2u);
        WDT = curr & (1u << 1u);
    }

    /**
     * Set CGATSET2's USB bit.
     *
     * USB Gating Set
     */
    inline void set_CGATSET2_USB() volatile
    {
        CGATSET2 |= 1u << 7u;
    }

    /**
     * Clear CGATSET2's USB bit.
     *
     * USB Gating Set
     */
    inline void clear_CGATSET2_USB() volatile
    {
        CGATSET2 &= ~(1u << 7u);
    }

    /**
     * Toggle CGATSET2's USB bit.
     *
     * USB Gating Set
     */
    inline void toggle_CGATSET2_USB() volatile
    {
        CGATSET2 ^= 1u << 7u;
    }

    /**
     * Set CGATSET2's FCE bit.
     *
     * FCE Gating Set
     */
    inline void set_CGATSET2_FCE() volatile
    {
        CGATSET2 |= 1u << 6u;
    }

    /**
     * Clear CGATSET2's FCE bit.
     *
     * FCE Gating Set
     */
    inline void clear_CGATSET2_FCE() volatile
    {
        CGATSET2 &= ~(1u << 6u);
    }

    /**
     * Toggle CGATSET2's FCE bit.
     *
     * FCE Gating Set
     */
    inline void toggle_CGATSET2_FCE() volatile
    {
        CGATSET2 ^= 1u << 6u;
    }

    /**
     * Set CGATSET2's DMA1 bit.
     *
     * DMA1 Gating Set
     */
    inline void set_CGATSET2_DMA1() volatile
    {
        CGATSET2 |= 1u << 5u;
    }

    /**
     * Clear CGATSET2's DMA1 bit.
     *
     * DMA1 Gating Set
     */
    inline void clear_CGATSET2_DMA1() volatile
    {
        CGATSET2 &= ~(1u << 5u);
    }

    /**
     * Toggle CGATSET2's DMA1 bit.
     *
     * DMA1 Gating Set
     */
    inline void toggle_CGATSET2_DMA1() volatile
    {
        CGATSET2 ^= 1u << 5u;
    }

    /**
     * Set CGATSET2's DMA0 bit.
     *
     * DMA0 Gating Set
     */
    inline void set_CGATSET2_DMA0() volatile
    {
        CGATSET2 |= 1u << 4u;
    }

    /**
     * Clear CGATSET2's DMA0 bit.
     *
     * DMA0 Gating Set
     */
    inline void clear_CGATSET2_DMA0() volatile
    {
        CGATSET2 &= ~(1u << 4u);
    }

    /**
     * Toggle CGATSET2's DMA0 bit.
     *
     * DMA0 Gating Set
     */
    inline void toggle_CGATSET2_DMA0() volatile
    {
        CGATSET2 ^= 1u << 4u;
    }

    /**
     * Set CGATSET2's ETH0 bit.
     *
     * ETH0 Gating Set
     */
    inline void set_CGATSET2_ETH0() volatile
    {
        CGATSET2 |= 1u << 2u;
    }

    /**
     * Clear CGATSET2's ETH0 bit.
     *
     * ETH0 Gating Set
     */
    inline void clear_CGATSET2_ETH0() volatile
    {
        CGATSET2 &= ~(1u << 2u);
    }

    /**
     * Toggle CGATSET2's ETH0 bit.
     *
     * ETH0 Gating Set
     */
    inline void toggle_CGATSET2_ETH0() volatile
    {
        CGATSET2 ^= 1u << 2u;
    }

    /**
     * Set CGATSET2's WDT bit.
     *
     * WDT Gating Set
     */
    inline void set_CGATSET2_WDT() volatile
    {
        CGATSET2 |= 1u << 1u;
    }

    /**
     * Clear CGATSET2's WDT bit.
     *
     * WDT Gating Set
     */
    inline void clear_CGATSET2_WDT() volatile
    {
        CGATSET2 &= ~(1u << 1u);
    }

    /**
     * Toggle CGATSET2's WDT bit.
     *
     * WDT Gating Set
     */
    inline void toggle_CGATSET2_WDT() volatile
    {
        CGATSET2 ^= 1u << 1u;
    }

    /**
     * Set all of CGATSET2's bit fields.
     *
     * (write-only) Peripheral 2 Clock Gating Set
     */
    inline void set_CGATSET2(bool USB, bool FCE, bool DMA1, bool DMA0,
                             bool ETH0, bool WDT) volatile
    {
        uint32_t curr = CGATSET2;

        curr &= ~(0b1u << 7u);
        curr |= (USB & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (FCE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (DMA1 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (DMA0 & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (ETH0 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (WDT & 0b1u) << 1u;

        CGATSET2 = curr;
    }

    /**
     * Set CGATCLR2's USB bit.
     *
     * USB Gating Clear
     */
    inline void set_CGATCLR2_USB() volatile
    {
        CGATCLR2 |= 1u << 7u;
    }

    /**
     * Clear CGATCLR2's USB bit.
     *
     * USB Gating Clear
     */
    inline void clear_CGATCLR2_USB() volatile
    {
        CGATCLR2 &= ~(1u << 7u);
    }

    /**
     * Toggle CGATCLR2's USB bit.
     *
     * USB Gating Clear
     */
    inline void toggle_CGATCLR2_USB() volatile
    {
        CGATCLR2 ^= 1u << 7u;
    }

    /**
     * Set CGATCLR2's FCE bit.
     *
     * FCE Gating Clear
     */
    inline void set_CGATCLR2_FCE() volatile
    {
        CGATCLR2 |= 1u << 6u;
    }

    /**
     * Clear CGATCLR2's FCE bit.
     *
     * FCE Gating Clear
     */
    inline void clear_CGATCLR2_FCE() volatile
    {
        CGATCLR2 &= ~(1u << 6u);
    }

    /**
     * Toggle CGATCLR2's FCE bit.
     *
     * FCE Gating Clear
     */
    inline void toggle_CGATCLR2_FCE() volatile
    {
        CGATCLR2 ^= 1u << 6u;
    }

    /**
     * Set CGATCLR2's DMA1 bit.
     *
     * DMA1 Gating Clear
     */
    inline void set_CGATCLR2_DMA1() volatile
    {
        CGATCLR2 |= 1u << 5u;
    }

    /**
     * Clear CGATCLR2's DMA1 bit.
     *
     * DMA1 Gating Clear
     */
    inline void clear_CGATCLR2_DMA1() volatile
    {
        CGATCLR2 &= ~(1u << 5u);
    }

    /**
     * Toggle CGATCLR2's DMA1 bit.
     *
     * DMA1 Gating Clear
     */
    inline void toggle_CGATCLR2_DMA1() volatile
    {
        CGATCLR2 ^= 1u << 5u;
    }

    /**
     * Set CGATCLR2's DMA0 bit.
     *
     * DMA0 Gating Clear
     */
    inline void set_CGATCLR2_DMA0() volatile
    {
        CGATCLR2 |= 1u << 4u;
    }

    /**
     * Clear CGATCLR2's DMA0 bit.
     *
     * DMA0 Gating Clear
     */
    inline void clear_CGATCLR2_DMA0() volatile
    {
        CGATCLR2 &= ~(1u << 4u);
    }

    /**
     * Toggle CGATCLR2's DMA0 bit.
     *
     * DMA0 Gating Clear
     */
    inline void toggle_CGATCLR2_DMA0() volatile
    {
        CGATCLR2 ^= 1u << 4u;
    }

    /**
     * Set CGATCLR2's ETH0 bit.
     *
     * ETH0 Gating Clear
     */
    inline void set_CGATCLR2_ETH0() volatile
    {
        CGATCLR2 |= 1u << 2u;
    }

    /**
     * Clear CGATCLR2's ETH0 bit.
     *
     * ETH0 Gating Clear
     */
    inline void clear_CGATCLR2_ETH0() volatile
    {
        CGATCLR2 &= ~(1u << 2u);
    }

    /**
     * Toggle CGATCLR2's ETH0 bit.
     *
     * ETH0 Gating Clear
     */
    inline void toggle_CGATCLR2_ETH0() volatile
    {
        CGATCLR2 ^= 1u << 2u;
    }

    /**
     * Set CGATCLR2's WDT bit.
     *
     * WDT Gating Clear
     */
    inline void set_CGATCLR2_WDT() volatile
    {
        CGATCLR2 |= 1u << 1u;
    }

    /**
     * Clear CGATCLR2's WDT bit.
     *
     * WDT Gating Clear
     */
    inline void clear_CGATCLR2_WDT() volatile
    {
        CGATCLR2 &= ~(1u << 1u);
    }

    /**
     * Toggle CGATCLR2's WDT bit.
     *
     * WDT Gating Clear
     */
    inline void toggle_CGATCLR2_WDT() volatile
    {
        CGATCLR2 ^= 1u << 1u;
    }

    /**
     * Set all of CGATCLR2's bit fields.
     *
     * (write-only) Peripheral 2 Clock Gating Clear
     */
    inline void set_CGATCLR2(bool USB, bool FCE, bool DMA1, bool DMA0,
                             bool ETH0, bool WDT) volatile
    {
        uint32_t curr = CGATCLR2;

        curr &= ~(0b1u << 7u);
        curr |= (USB & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (FCE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (DMA1 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (DMA0 & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (ETH0 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (WDT & 0b1u) << 1u;

        CGATCLR2 = curr;
    }

    /**
     * Get CGATSTAT3's EBU bit.
     *
     * EBU Gating Status
     */
    inline bool get_CGATSTAT3_EBU() volatile
    {
        return CGATSTAT3 & (1u << 2u);
    }

    /**
     * Set CGATSET3's EBU bit.
     *
     * EBU Gating Set
     */
    inline void set_CGATSET3_EBU() volatile
    {
        CGATSET3 |= 1u << 2u;
    }

    /**
     * Clear CGATSET3's EBU bit.
     *
     * EBU Gating Set
     */
    inline void clear_CGATSET3_EBU() volatile
    {
        CGATSET3 &= ~(1u << 2u);
    }

    /**
     * Toggle CGATSET3's EBU bit.
     *
     * EBU Gating Set
     */
    inline void toggle_CGATSET3_EBU() volatile
    {
        CGATSET3 ^= 1u << 2u;
    }

    /**
     * Set CGATCLR3's EBU bit.
     *
     * EBU Gating Clear
     */
    inline void set_CGATCLR3_EBU() volatile
    {
        CGATCLR3 |= 1u << 2u;
    }

    /**
     * Clear CGATCLR3's EBU bit.
     *
     * EBU Gating Clear
     */
    inline void clear_CGATCLR3_EBU() volatile
    {
        CGATCLR3 &= ~(1u << 2u);
    }

    /**
     * Toggle CGATCLR3's EBU bit.
     *
     * EBU Gating Clear
     */
    inline void toggle_CGATCLR3_EBU() volatile
    {
        CGATCLR3 ^= 1u << 2u;
    }
};

static_assert(sizeof(scu_clk) == scu_clk::size);

static volatile scu_clk *const SCU_CLK =
    reinterpret_cast<scu_clk *>(0x50004600);

}; // namespace XMC4700
