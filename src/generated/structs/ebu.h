/**
 * \file
 * \brief Generated by ifgen (3.1.6).
 */
#pragma once

#include "../enums/EBU_ADDRSEL0_ALTENAB.h"
#include "../enums/EBU_ADDRSEL0_WPROT.h"
#include "../enums/EBU_BUSRAP0_ADDRC.h"
#include "../enums/EBU_BUSRAP0_AHOLDC.h"
#include "../enums/EBU_BUSRAP0_EXTCLOCK.h"
#include "../enums/EBU_BUSRAP0_EXTDATA.h"
#include "../enums/EBU_BUSRAP0_RDDTACS.h"
#include "../enums/EBU_BUSRAP0_RDRECOVC.h"
#include "../enums/EBU_BUSRAP0_WAITRDC.h"
#include "../enums/EBU_BUSRCON0_AAP.h"
#include "../enums/EBU_BUSRCON0_BCGEN.h"
#include "../enums/EBU_BUSRCON0_BFCMSEL.h"
#include "../enums/EBU_BUSRCON0_BFSSS.h"
#include "../enums/EBU_BUSRCON0_DBA.h"
#include "../enums/EBU_BUSRCON0_EBSE.h"
#include "../enums/EBU_BUSRCON0_FBBMSEL.h"
#include "../enums/EBU_BUSRCON0_FDBKEN.h"
#include "../enums/EBU_BUSRCON0_FETBLEN.h"
#include "../enums/EBU_BUSRCON0_WAITINV.h"
#include "../enums/EBU_BUSWCON0_LOCKCS.h"
#include "../enums/EBU_CLC_DISR.h"
#include "../enums/EBU_CLC_DISS.h"
#include "../enums/EBU_CLC_DIV2.h"
#include "../enums/EBU_CLC_DIV2ACK.h"
#include "../enums/EBU_CLC_EBUDIVACK.h"
#include "../enums/EBU_CLC_SYNC.h"
#include "../enums/EBU_CLC_SYNCACK.h"
#include "../enums/EBU_MODCON_ALE.h"
#include "../enums/EBU_MODCON_ARBMODE.h"
#include "../enums/EBU_MODCON_ARBSYNC.h"
#include "../enums/EBU_MODCON_EXTLOCK.h"
#include "../enums/EBU_MODCON_SDTRI.h"
#include "../enums/EBU_MODCON_TIMEOUTC.h"
#include "../enums/EBU_SDRMCON_AWIDTH.h"
#include "../enums/EBU_SDRMCON_BANKM.h"
#include "../enums/EBU_SDRMCON_CLKDIS.h"
#include "../enums/EBU_SDRMCON_PWR_MODE.h"
#include "../enums/EBU_SDRMCON_ROWM.h"
#include "../enums/EBU_SDRMCON_SDCMSEL.h"
#include "../enums/EBU_SDRMOD_BTYP.h"
#include "../enums/EBU_SDRMOD_BURSTL.h"
#include "../enums/EBU_SDRMOD_CASLAT.h"
#include "../enums/EBU_SDRMOD_OPMODE.h"
#include "../enums/EBU_SDRSTAT_REFERR.h"
#include "../enums/EBU_SDRSTAT_SDERR.h"
#include "../enums/EBU_SDRSTAT_SDRMBUSY.h"
#include "../enums/EBU_USERCON_ADDIO.h"
#include "../enums/EBU_USERCON_ADVIO.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * External Bus Unit
 */
struct [[gnu::packed]] ebu
{
    /* Constant attributes. */
    static constexpr std::size_t size = 120; /*!< ebu's size in bytes. */

    /* Fields. */
    uint32_t CLC;    /*!< (read-write) EBU Clock Control Register */
    uint32_t MODCON; /*!< (read-write) EBU Configuration Register */
    const uint32_t ID =
        {}; /*!< (read-only) EBU Module Identification Register */
    uint32_t
        USERCON; /*!< (read-write) EBU Test/Control Configuration Register */
    static constexpr std::size_t reserved_padding0_length = 2;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t ADDRSEL0; /*!< (read-write) EBU Address Select Register 0 */
    uint32_t ADDRSEL1; /*!< (read-write) EBU Address Select Register 1 */
    uint32_t ADDRSEL2; /*!< (read-write) EBU Address Select Register 2 */
    uint32_t ADDRSEL3; /*!< (read-write) EBU Address Select Register 3 */
    uint32_t BUSRCON0; /*!< (read-write) EBU Bus Configuration Register */
    uint32_t
        BUSRAP0; /*!< (read-write) EBU Bus Read Access Parameter Register */
    uint32_t
        BUSWCON0; /*!< (read-write) EBU Bus Write Configuration Register */
    uint32_t
        BUSWAP0; /*!< (read-write) EBU Bus Write Access Parameter Register */
    uint32_t BUSRCON1; /*!< (read-write) EBU Bus Configuration Register */
    uint32_t
        BUSRAP1; /*!< (read-write) EBU Bus Read Access Parameter Register */
    uint32_t
        BUSWCON1; /*!< (read-write) EBU Bus Write Configuration Register */
    uint32_t
        BUSWAP1; /*!< (read-write) EBU Bus Write Access Parameter Register */
    uint32_t BUSRCON2; /*!< (read-write) EBU Bus Configuration Register */
    uint32_t
        BUSRAP2; /*!< (read-write) EBU Bus Read Access Parameter Register */
    uint32_t
        BUSWCON2; /*!< (read-write) EBU Bus Write Configuration Register */
    uint32_t
        BUSWAP2; /*!< (read-write) EBU Bus Write Access Parameter Register */
    uint32_t BUSRCON3; /*!< (read-write) EBU Bus Configuration Register */
    uint32_t
        BUSRAP3; /*!< (read-write) EBU Bus Read Access Parameter Register */
    uint32_t
        BUSWCON3; /*!< (read-write) EBU Bus Write Configuration Register */
    uint32_t
        BUSWAP3; /*!< (read-write) EBU Bus Write Access Parameter Register */
    uint32_t SDRMCON; /*!< (read-write) EBU SDRAM Control Register */
    uint32_t SDRMOD;  /*!< (read-write) EBU SDRAM Mode Register */
    uint32_t SDRMREF; /*!< (read-write) EBU SDRAM Refresh Control Register */
    const uint32_t SDRSTAT = {}; /*!< (read-only) EBU SDRAM Status Register */

    /* Methods. */

    /**
     * Get CLC's EBUDIVACK field.
     */
    inline EBU_CLC_EBUDIVACK get_CLC_EBUDIVACK() volatile
    {
        return EBU_CLC_EBUDIVACK((CLC >> 22u) & 0b11u);
    }

    /**
     * Get CLC's DIV2ACK bit.
     */
    inline EBU_CLC_DIV2ACK get_CLC_DIV2ACK() volatile
    {
        return EBU_CLC_DIV2ACK(CLC & (1u << 21u));
    }

    /**
     * Get CLC's SYNCACK bit.
     */
    inline EBU_CLC_SYNCACK get_CLC_SYNCACK() volatile
    {
        return EBU_CLC_SYNCACK(CLC & (1u << 20u));
    }

    /**
     * Get CLC's EBUDIV field.
     */
    inline EBU_CLC_EBUDIVACK get_CLC_EBUDIV() volatile
    {
        return EBU_CLC_EBUDIVACK((CLC >> 18u) & 0b11u);
    }

    /**
     * Set CLC's EBUDIV field.
     *
     * EBU Clock Divide Ratio
     */
    inline void set_CLC_EBUDIV(EBU_CLC_EBUDIVACK value) volatile
    {
        uint32_t curr = CLC;

        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(value) & 0b11u) << 18u;

        CLC = curr;
    }

    /**
     * Get CLC's DIV2 bit.
     */
    inline EBU_CLC_DIV2 get_CLC_DIV2() volatile
    {
        return EBU_CLC_DIV2(CLC & (1u << 17u));
    }

    /**
     * Set CLC's DIV2 bit.
     *
     * DIV2 Clocking Mode
     */
    inline void set_CLC_DIV2() volatile
    {
        CLC |= 1u << 17u;
    }

    /**
     * Clear CLC's DIV2 bit.
     *
     * DIV2 Clocking Mode
     */
    inline void clear_CLC_DIV2() volatile
    {
        CLC &= ~(1u << 17u);
    }

    /**
     * Toggle CLC's DIV2 bit.
     *
     * DIV2 Clocking Mode
     */
    inline void toggle_CLC_DIV2() volatile
    {
        CLC ^= 1u << 17u;
    }

    /**
     * Get CLC's SYNC bit.
     */
    inline EBU_CLC_SYNC get_CLC_SYNC() volatile
    {
        return EBU_CLC_SYNC(CLC & (1u << 16u));
    }

    /**
     * Set CLC's SYNC bit.
     *
     * EBU Clocking Mode
     */
    inline void set_CLC_SYNC() volatile
    {
        CLC |= 1u << 16u;
    }

    /**
     * Clear CLC's SYNC bit.
     *
     * EBU Clocking Mode
     */
    inline void clear_CLC_SYNC() volatile
    {
        CLC &= ~(1u << 16u);
    }

    /**
     * Toggle CLC's SYNC bit.
     *
     * EBU Clocking Mode
     */
    inline void toggle_CLC_SYNC() volatile
    {
        CLC ^= 1u << 16u;
    }

    /**
     * Get CLC's DISS bit.
     */
    inline EBU_CLC_DISS get_CLC_DISS() volatile
    {
        return EBU_CLC_DISS(CLC & (1u << 1u));
    }

    /**
     * Get CLC's DISR bit.
     */
    inline EBU_CLC_DISR get_CLC_DISR() volatile
    {
        return EBU_CLC_DISR(CLC & (1u << 0u));
    }

    /**
     * Set CLC's DISR bit.
     *
     * EBU Disable Request Bit
     */
    inline void set_CLC_DISR() volatile
    {
        CLC |= 1u << 0u;
    }

    /**
     * Clear CLC's DISR bit.
     *
     * EBU Disable Request Bit
     */
    inline void clear_CLC_DISR() volatile
    {
        CLC &= ~(1u << 0u);
    }

    /**
     * Toggle CLC's DISR bit.
     *
     * EBU Disable Request Bit
     */
    inline void toggle_CLC_DISR() volatile
    {
        CLC ^= 1u << 0u;
    }

    /**
     * Get all of CLC's bit fields.
     */
    inline void get_CLC(EBU_CLC_EBUDIVACK &EBUDIVACK, EBU_CLC_DIV2ACK &DIV2ACK,
                        EBU_CLC_SYNCACK &SYNCACK, EBU_CLC_EBUDIVACK &EBUDIV,
                        EBU_CLC_DIV2 &DIV2, EBU_CLC_SYNC &SYNC,
                        EBU_CLC_DISS &DISS, EBU_CLC_DISR &DISR) volatile
    {
        uint32_t curr = CLC;

        EBUDIVACK = EBU_CLC_EBUDIVACK((curr >> 22u) & 0b11u);
        DIV2ACK = EBU_CLC_DIV2ACK(curr & (1u << 21u));
        SYNCACK = EBU_CLC_SYNCACK(curr & (1u << 20u));
        EBUDIV = EBU_CLC_EBUDIVACK((curr >> 18u) & 0b11u);
        DIV2 = EBU_CLC_DIV2(curr & (1u << 17u));
        SYNC = EBU_CLC_SYNC(curr & (1u << 16u));
        DISS = EBU_CLC_DISS(curr & (1u << 1u));
        DISR = EBU_CLC_DISR(curr & (1u << 0u));
    }

    /**
     * Set all of CLC's bit fields.
     *
     * (read-write) EBU Clock Control Register
     */
    inline void set_CLC(EBU_CLC_EBUDIVACK EBUDIV, EBU_CLC_DIV2 DIV2,
                        EBU_CLC_SYNC SYNC, EBU_CLC_DISR DISR) volatile
    {
        uint32_t curr = CLC;

        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(EBUDIV) & 0b11u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(DIV2) & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (std::to_underlying(SYNC) & 0b1u) << 16u;
        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(DISR) & 0b1u) << 0u;

        CLC = curr;
    }

    /**
     * Get MODCON's ALE bit.
     */
    inline EBU_MODCON_ALE get_MODCON_ALE() volatile
    {
        return EBU_MODCON_ALE(MODCON & (1u << 31u));
    }

    /**
     * Set MODCON's ALE bit.
     *
     * ALE Mode
     */
    inline void set_MODCON_ALE() volatile
    {
        MODCON |= 1u << 31u;
    }

    /**
     * Clear MODCON's ALE bit.
     *
     * ALE Mode
     */
    inline void clear_MODCON_ALE() volatile
    {
        MODCON &= ~(1u << 31u);
    }

    /**
     * Toggle MODCON's ALE bit.
     *
     * ALE Mode
     */
    inline void toggle_MODCON_ALE() volatile
    {
        MODCON ^= 1u << 31u;
    }

    /**
     * Get MODCON's ACCSINHACK bit.
     */
    inline bool get_MODCON_ACCSINHACK() volatile
    {
        return MODCON & (1u << 29u);
    }

    /**
     * Get MODCON's ACCSINH bit.
     */
    inline bool get_MODCON_ACCSINH() volatile
    {
        return MODCON & (1u << 28u);
    }

    /**
     * Set MODCON's ACCSINH bit.
     *
     * Access Inhibit request
     */
    inline void set_MODCON_ACCSINH() volatile
    {
        MODCON |= 1u << 28u;
    }

    /**
     * Clear MODCON's ACCSINH bit.
     *
     * Access Inhibit request
     */
    inline void clear_MODCON_ACCSINH() volatile
    {
        MODCON &= ~(1u << 28u);
    }

    /**
     * Toggle MODCON's ACCSINH bit.
     *
     * Access Inhibit request
     */
    inline void toggle_MODCON_ACCSINH() volatile
    {
        MODCON ^= 1u << 28u;
    }

    /**
     * Get MODCON's GLOBALCS field.
     */
    inline uint8_t get_MODCON_GLOBALCS() volatile
    {
        return (MODCON >> 24u) & 0b1111u;
    }

    /**
     * Set MODCON's GLOBALCS field.
     *
     * Global Chip Select Enable
     */
    inline void set_MODCON_GLOBALCS(uint8_t value) volatile
    {
        uint32_t curr = MODCON;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        MODCON = curr;
    }

    /**
     * Get MODCON's LOCKTIMEOUT field.
     */
    inline uint8_t get_MODCON_LOCKTIMEOUT() volatile
    {
        return (MODCON >> 16u) & 0b11111111u;
    }

    /**
     * Set MODCON's LOCKTIMEOUT field.
     *
     * Lock Timeout Counter Preload
     */
    inline void set_MODCON_LOCKTIMEOUT(uint8_t value) volatile
    {
        uint32_t curr = MODCON;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        MODCON = curr;
    }

    /**
     * Get MODCON's TIMEOUTC field.
     */
    inline EBU_MODCON_TIMEOUTC get_MODCON_TIMEOUTC() volatile
    {
        return EBU_MODCON_TIMEOUTC((MODCON >> 8u) & 0b11111111u);
    }

    /**
     * Set MODCON's TIMEOUTC field.
     *
     * Bus Time-out Control
     */
    inline void set_MODCON_TIMEOUTC(EBU_MODCON_TIMEOUTC value) volatile
    {
        uint32_t curr = MODCON;

        curr &= ~(0b11111111u << 8u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 8u;

        MODCON = curr;
    }

    /**
     * Get MODCON's ARBMODE field.
     */
    inline EBU_MODCON_ARBMODE get_MODCON_ARBMODE() volatile
    {
        return EBU_MODCON_ARBMODE((MODCON >> 6u) & 0b11u);
    }

    /**
     * Set MODCON's ARBMODE field.
     *
     * Arbitration Mode Selection
     */
    inline void set_MODCON_ARBMODE(EBU_MODCON_ARBMODE value) volatile
    {
        uint32_t curr = MODCON;

        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(value) & 0b11u) << 6u;

        MODCON = curr;
    }

    /**
     * Get MODCON's ARBSYNC bit.
     */
    inline EBU_MODCON_ARBSYNC get_MODCON_ARBSYNC() volatile
    {
        return EBU_MODCON_ARBSYNC(MODCON & (1u << 5u));
    }

    /**
     * Set MODCON's ARBSYNC bit.
     *
     * Arbitration Signal Synchronization Control
     */
    inline void set_MODCON_ARBSYNC() volatile
    {
        MODCON |= 1u << 5u;
    }

    /**
     * Clear MODCON's ARBSYNC bit.
     *
     * Arbitration Signal Synchronization Control
     */
    inline void clear_MODCON_ARBSYNC() volatile
    {
        MODCON &= ~(1u << 5u);
    }

    /**
     * Toggle MODCON's ARBSYNC bit.
     *
     * Arbitration Signal Synchronization Control
     */
    inline void toggle_MODCON_ARBSYNC() volatile
    {
        MODCON ^= 1u << 5u;
    }

    /**
     * Get MODCON's EXTLOCK bit.
     */
    inline EBU_MODCON_EXTLOCK get_MODCON_EXTLOCK() volatile
    {
        return EBU_MODCON_EXTLOCK(MODCON & (1u << 4u));
    }

    /**
     * Set MODCON's EXTLOCK bit.
     *
     * External Bus Lock Control
     */
    inline void set_MODCON_EXTLOCK() volatile
    {
        MODCON |= 1u << 4u;
    }

    /**
     * Clear MODCON's EXTLOCK bit.
     *
     * External Bus Lock Control
     */
    inline void clear_MODCON_EXTLOCK() volatile
    {
        MODCON &= ~(1u << 4u);
    }

    /**
     * Toggle MODCON's EXTLOCK bit.
     *
     * External Bus Lock Control
     */
    inline void toggle_MODCON_EXTLOCK() volatile
    {
        MODCON ^= 1u << 4u;
    }

    /**
     * Get MODCON's SDTRI bit.
     */
    inline EBU_MODCON_SDTRI get_MODCON_SDTRI() volatile
    {
        return EBU_MODCON_SDTRI(MODCON & (1u << 2u));
    }

    /**
     * Set MODCON's SDTRI bit.
     *
     * SDRAM Tristate
     */
    inline void set_MODCON_SDTRI() volatile
    {
        MODCON |= 1u << 2u;
    }

    /**
     * Clear MODCON's SDTRI bit.
     *
     * SDRAM Tristate
     */
    inline void clear_MODCON_SDTRI() volatile
    {
        MODCON &= ~(1u << 2u);
    }

    /**
     * Toggle MODCON's SDTRI bit.
     *
     * SDRAM Tristate
     */
    inline void toggle_MODCON_SDTRI() volatile
    {
        MODCON ^= 1u << 2u;
    }

    /**
     * Get MODCON's LCKABRT bit.
     */
    inline bool get_MODCON_LCKABRT() volatile
    {
        return MODCON & (1u << 1u);
    }

    /**
     * Get MODCON's STS bit.
     */
    inline bool get_MODCON_STS() volatile
    {
        return MODCON & (1u << 0u);
    }

    /**
     * Get all of MODCON's bit fields.
     */
    inline void get_MODCON(EBU_MODCON_ALE &ALE, bool &ACCSINHACK,
                           bool &ACCSINH, uint8_t &GLOBALCS,
                           uint8_t &LOCKTIMEOUT, EBU_MODCON_TIMEOUTC &TIMEOUTC,
                           EBU_MODCON_ARBMODE &ARBMODE,
                           EBU_MODCON_ARBSYNC &ARBSYNC,
                           EBU_MODCON_EXTLOCK &EXTLOCK,
                           EBU_MODCON_SDTRI &SDTRI, bool &LCKABRT,
                           bool &STS) volatile
    {
        uint32_t curr = MODCON;

        ALE = EBU_MODCON_ALE(curr & (1u << 31u));
        ACCSINHACK = curr & (1u << 29u);
        ACCSINH = curr & (1u << 28u);
        GLOBALCS = (curr >> 24u) & 0b1111u;
        LOCKTIMEOUT = (curr >> 16u) & 0b11111111u;
        TIMEOUTC = EBU_MODCON_TIMEOUTC((curr >> 8u) & 0b11111111u);
        ARBMODE = EBU_MODCON_ARBMODE((curr >> 6u) & 0b11u);
        ARBSYNC = EBU_MODCON_ARBSYNC(curr & (1u << 5u));
        EXTLOCK = EBU_MODCON_EXTLOCK(curr & (1u << 4u));
        SDTRI = EBU_MODCON_SDTRI(curr & (1u << 2u));
        LCKABRT = curr & (1u << 1u);
        STS = curr & (1u << 0u);
    }

    /**
     * Set all of MODCON's bit fields.
     *
     * (read-write) EBU Configuration Register
     */
    inline void set_MODCON(EBU_MODCON_ALE ALE, bool ACCSINH, uint8_t GLOBALCS,
                           uint8_t LOCKTIMEOUT, EBU_MODCON_TIMEOUTC TIMEOUTC,
                           EBU_MODCON_ARBMODE ARBMODE,
                           EBU_MODCON_ARBSYNC ARBSYNC,
                           EBU_MODCON_EXTLOCK EXTLOCK,
                           EBU_MODCON_SDTRI SDTRI) volatile
    {
        uint32_t curr = MODCON;

        curr &= ~(0b1u << 31u);
        curr |= (std::to_underlying(ALE) & 0b1u) << 31u;
        curr &= ~(0b1u << 28u);
        curr |= (ACCSINH & 0b1u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (GLOBALCS & 0b1111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (LOCKTIMEOUT & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (std::to_underlying(TIMEOUTC) & 0b11111111u) << 8u;
        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(ARBMODE) & 0b11u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (std::to_underlying(ARBSYNC) & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (std::to_underlying(EXTLOCK) & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (std::to_underlying(SDTRI) & 0b1u) << 2u;

        MODCON = curr;
    }

    /**
     * Get ID's MOD_NUMBER field.
     */
    inline uint16_t get_ID_MOD_NUMBER() volatile
    {
        return (ID >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get ID's MOD_TYPE field.
     */
    inline uint8_t get_ID_MOD_TYPE() volatile
    {
        return (ID >> 8u) & 0b11111111u;
    }

    /**
     * Get ID's MOD_REV field.
     */
    inline uint8_t get_ID_MOD_REV() volatile
    {
        return (ID >> 0u) & 0b11111111u;
    }

    /**
     * Get all of ID's bit fields.
     */
    inline void get_ID(uint16_t &MOD_NUMBER, uint8_t &MOD_TYPE,
                       uint8_t &MOD_REV) volatile
    {
        uint32_t curr = ID;

        MOD_NUMBER = (curr >> 16u) & 0b1111111111111111u;
        MOD_TYPE = (curr >> 8u) & 0b11111111u;
        MOD_REV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get USERCON's ADVIO bit.
     */
    inline EBU_USERCON_ADVIO get_USERCON_ADVIO() volatile
    {
        return EBU_USERCON_ADVIO(USERCON & (1u << 25u));
    }

    /**
     * Set USERCON's ADVIO bit.
     *
     * ADV Pin to GPIO Mode
     */
    inline void set_USERCON_ADVIO() volatile
    {
        USERCON |= 1u << 25u;
    }

    /**
     * Clear USERCON's ADVIO bit.
     *
     * ADV Pin to GPIO Mode
     */
    inline void clear_USERCON_ADVIO() volatile
    {
        USERCON &= ~(1u << 25u);
    }

    /**
     * Toggle USERCON's ADVIO bit.
     *
     * ADV Pin to GPIO Mode
     */
    inline void toggle_USERCON_ADVIO() volatile
    {
        USERCON ^= 1u << 25u;
    }

    /**
     * Get USERCON's ADDIO field.
     */
    inline EBU_USERCON_ADDIO get_USERCON_ADDIO() volatile
    {
        return EBU_USERCON_ADDIO((USERCON >> 16u) & 0b111111111u);
    }

    /**
     * Set USERCON's ADDIO field.
     *
     * Address Pins to GPIO Mode
     */
    inline void set_USERCON_ADDIO(EBU_USERCON_ADDIO value) volatile
    {
        uint32_t curr = USERCON;

        curr &= ~(0b111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b111111111u) << 16u;

        USERCON = curr;
    }

    /**
     * Get USERCON's DIP bit.
     */
    inline bool get_USERCON_DIP() volatile
    {
        return USERCON & (1u << 0u);
    }

    /**
     * Set USERCON's DIP bit.
     *
     * Disable Internal Pipelining
     */
    inline void set_USERCON_DIP() volatile
    {
        USERCON |= 1u << 0u;
    }

    /**
     * Clear USERCON's DIP bit.
     *
     * Disable Internal Pipelining
     */
    inline void clear_USERCON_DIP() volatile
    {
        USERCON &= ~(1u << 0u);
    }

    /**
     * Toggle USERCON's DIP bit.
     *
     * Disable Internal Pipelining
     */
    inline void toggle_USERCON_DIP() volatile
    {
        USERCON ^= 1u << 0u;
    }

    /**
     * Get all of USERCON's bit fields.
     */
    inline void get_USERCON(EBU_USERCON_ADVIO &ADVIO, EBU_USERCON_ADDIO &ADDIO,
                            bool &DIP) volatile
    {
        uint32_t curr = USERCON;

        ADVIO = EBU_USERCON_ADVIO(curr & (1u << 25u));
        ADDIO = EBU_USERCON_ADDIO((curr >> 16u) & 0b111111111u);
        DIP = curr & (1u << 0u);
    }

    /**
     * Set all of USERCON's bit fields.
     *
     * (read-write) EBU Test/Control Configuration Register
     */
    inline void set_USERCON(EBU_USERCON_ADVIO ADVIO, EBU_USERCON_ADDIO ADDIO,
                            bool DIP) volatile
    {
        uint32_t curr = USERCON;

        curr &= ~(0b1u << 25u);
        curr |= (std::to_underlying(ADVIO) & 0b1u) << 25u;
        curr &= ~(0b111111111u << 16u);
        curr |= (std::to_underlying(ADDIO) & 0b111111111u) << 16u;
        curr &= ~(0b1u << 0u);
        curr |= (DIP & 0b1u) << 0u;

        USERCON = curr;
    }

    /**
     * Get ADDRSEL0's WPROT bit.
     */
    inline EBU_ADDRSEL0_WPROT get_ADDRSEL0_WPROT() volatile
    {
        return EBU_ADDRSEL0_WPROT(ADDRSEL0 & (1u << 2u));
    }

    /**
     * Set ADDRSEL0's WPROT bit.
     *
     * Memory Region Write Protect
     */
    inline void set_ADDRSEL0_WPROT() volatile
    {
        ADDRSEL0 |= 1u << 2u;
    }

    /**
     * Clear ADDRSEL0's WPROT bit.
     *
     * Memory Region Write Protect
     */
    inline void clear_ADDRSEL0_WPROT() volatile
    {
        ADDRSEL0 &= ~(1u << 2u);
    }

    /**
     * Toggle ADDRSEL0's WPROT bit.
     *
     * Memory Region Write Protect
     */
    inline void toggle_ADDRSEL0_WPROT() volatile
    {
        ADDRSEL0 ^= 1u << 2u;
    }

    /**
     * Get ADDRSEL0's ALTENAB bit.
     */
    inline EBU_ADDRSEL0_ALTENAB get_ADDRSEL0_ALTENAB() volatile
    {
        return EBU_ADDRSEL0_ALTENAB(ADDRSEL0 & (1u << 1u));
    }

    /**
     * Set ADDRSEL0's ALTENAB bit.
     *
     * Alternate Region Enable
     */
    inline void set_ADDRSEL0_ALTENAB() volatile
    {
        ADDRSEL0 |= 1u << 1u;
    }

    /**
     * Clear ADDRSEL0's ALTENAB bit.
     *
     * Alternate Region Enable
     */
    inline void clear_ADDRSEL0_ALTENAB() volatile
    {
        ADDRSEL0 &= ~(1u << 1u);
    }

    /**
     * Toggle ADDRSEL0's ALTENAB bit.
     *
     * Alternate Region Enable
     */
    inline void toggle_ADDRSEL0_ALTENAB() volatile
    {
        ADDRSEL0 ^= 1u << 1u;
    }

    /**
     * Get ADDRSEL0's REGENAB bit.
     */
    inline EBU_ADDRSEL0_ALTENAB get_ADDRSEL0_REGENAB() volatile
    {
        return EBU_ADDRSEL0_ALTENAB(ADDRSEL0 & (1u << 0u));
    }

    /**
     * Set ADDRSEL0's REGENAB bit.
     *
     * Memory Region Enable
     */
    inline void set_ADDRSEL0_REGENAB() volatile
    {
        ADDRSEL0 |= 1u << 0u;
    }

    /**
     * Clear ADDRSEL0's REGENAB bit.
     *
     * Memory Region Enable
     */
    inline void clear_ADDRSEL0_REGENAB() volatile
    {
        ADDRSEL0 &= ~(1u << 0u);
    }

    /**
     * Toggle ADDRSEL0's REGENAB bit.
     *
     * Memory Region Enable
     */
    inline void toggle_ADDRSEL0_REGENAB() volatile
    {
        ADDRSEL0 ^= 1u << 0u;
    }

    /**
     * Get all of ADDRSEL0's bit fields.
     */
    inline void get_ADDRSEL0(EBU_ADDRSEL0_WPROT &WPROT,
                             EBU_ADDRSEL0_ALTENAB &ALTENAB,
                             EBU_ADDRSEL0_ALTENAB &REGENAB) volatile
    {
        uint32_t curr = ADDRSEL0;

        WPROT = EBU_ADDRSEL0_WPROT(curr & (1u << 2u));
        ALTENAB = EBU_ADDRSEL0_ALTENAB(curr & (1u << 1u));
        REGENAB = EBU_ADDRSEL0_ALTENAB(curr & (1u << 0u));
    }

    /**
     * Set all of ADDRSEL0's bit fields.
     *
     * (read-write) EBU Address Select Register 0
     */
    inline void set_ADDRSEL0(EBU_ADDRSEL0_WPROT WPROT,
                             EBU_ADDRSEL0_ALTENAB ALTENAB,
                             EBU_ADDRSEL0_ALTENAB REGENAB) volatile
    {
        uint32_t curr = ADDRSEL0;

        curr &= ~(0b1u << 2u);
        curr |= (std::to_underlying(WPROT) & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(ALTENAB) & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(REGENAB) & 0b1u) << 0u;

        ADDRSEL0 = curr;
    }

    /**
     * Get ADDRSEL1's WPROT bit.
     */
    inline EBU_ADDRSEL0_WPROT get_ADDRSEL1_WPROT() volatile
    {
        return EBU_ADDRSEL0_WPROT(ADDRSEL1 & (1u << 2u));
    }

    /**
     * Set ADDRSEL1's WPROT bit.
     *
     * Memory Region Write Protect
     */
    inline void set_ADDRSEL1_WPROT() volatile
    {
        ADDRSEL1 |= 1u << 2u;
    }

    /**
     * Clear ADDRSEL1's WPROT bit.
     *
     * Memory Region Write Protect
     */
    inline void clear_ADDRSEL1_WPROT() volatile
    {
        ADDRSEL1 &= ~(1u << 2u);
    }

    /**
     * Toggle ADDRSEL1's WPROT bit.
     *
     * Memory Region Write Protect
     */
    inline void toggle_ADDRSEL1_WPROT() volatile
    {
        ADDRSEL1 ^= 1u << 2u;
    }

    /**
     * Get ADDRSEL1's ALTENAB bit.
     */
    inline EBU_ADDRSEL0_ALTENAB get_ADDRSEL1_ALTENAB() volatile
    {
        return EBU_ADDRSEL0_ALTENAB(ADDRSEL1 & (1u << 1u));
    }

    /**
     * Set ADDRSEL1's ALTENAB bit.
     *
     * Alternate Region Enable
     */
    inline void set_ADDRSEL1_ALTENAB() volatile
    {
        ADDRSEL1 |= 1u << 1u;
    }

    /**
     * Clear ADDRSEL1's ALTENAB bit.
     *
     * Alternate Region Enable
     */
    inline void clear_ADDRSEL1_ALTENAB() volatile
    {
        ADDRSEL1 &= ~(1u << 1u);
    }

    /**
     * Toggle ADDRSEL1's ALTENAB bit.
     *
     * Alternate Region Enable
     */
    inline void toggle_ADDRSEL1_ALTENAB() volatile
    {
        ADDRSEL1 ^= 1u << 1u;
    }

    /**
     * Get ADDRSEL1's REGENAB bit.
     */
    inline EBU_ADDRSEL0_ALTENAB get_ADDRSEL1_REGENAB() volatile
    {
        return EBU_ADDRSEL0_ALTENAB(ADDRSEL1 & (1u << 0u));
    }

    /**
     * Set ADDRSEL1's REGENAB bit.
     *
     * Memory Region Enable
     */
    inline void set_ADDRSEL1_REGENAB() volatile
    {
        ADDRSEL1 |= 1u << 0u;
    }

    /**
     * Clear ADDRSEL1's REGENAB bit.
     *
     * Memory Region Enable
     */
    inline void clear_ADDRSEL1_REGENAB() volatile
    {
        ADDRSEL1 &= ~(1u << 0u);
    }

    /**
     * Toggle ADDRSEL1's REGENAB bit.
     *
     * Memory Region Enable
     */
    inline void toggle_ADDRSEL1_REGENAB() volatile
    {
        ADDRSEL1 ^= 1u << 0u;
    }

    /**
     * Get all of ADDRSEL1's bit fields.
     */
    inline void get_ADDRSEL1(EBU_ADDRSEL0_WPROT &WPROT,
                             EBU_ADDRSEL0_ALTENAB &ALTENAB,
                             EBU_ADDRSEL0_ALTENAB &REGENAB) volatile
    {
        uint32_t curr = ADDRSEL1;

        WPROT = EBU_ADDRSEL0_WPROT(curr & (1u << 2u));
        ALTENAB = EBU_ADDRSEL0_ALTENAB(curr & (1u << 1u));
        REGENAB = EBU_ADDRSEL0_ALTENAB(curr & (1u << 0u));
    }

    /**
     * Set all of ADDRSEL1's bit fields.
     *
     * (read-write) EBU Address Select Register 1
     */
    inline void set_ADDRSEL1(EBU_ADDRSEL0_WPROT WPROT,
                             EBU_ADDRSEL0_ALTENAB ALTENAB,
                             EBU_ADDRSEL0_ALTENAB REGENAB) volatile
    {
        uint32_t curr = ADDRSEL1;

        curr &= ~(0b1u << 2u);
        curr |= (std::to_underlying(WPROT) & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(ALTENAB) & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(REGENAB) & 0b1u) << 0u;

        ADDRSEL1 = curr;
    }

    /**
     * Get ADDRSEL2's WPROT bit.
     */
    inline EBU_ADDRSEL0_WPROT get_ADDRSEL2_WPROT() volatile
    {
        return EBU_ADDRSEL0_WPROT(ADDRSEL2 & (1u << 2u));
    }

    /**
     * Set ADDRSEL2's WPROT bit.
     *
     * Memory Region Write Protect
     */
    inline void set_ADDRSEL2_WPROT() volatile
    {
        ADDRSEL2 |= 1u << 2u;
    }

    /**
     * Clear ADDRSEL2's WPROT bit.
     *
     * Memory Region Write Protect
     */
    inline void clear_ADDRSEL2_WPROT() volatile
    {
        ADDRSEL2 &= ~(1u << 2u);
    }

    /**
     * Toggle ADDRSEL2's WPROT bit.
     *
     * Memory Region Write Protect
     */
    inline void toggle_ADDRSEL2_WPROT() volatile
    {
        ADDRSEL2 ^= 1u << 2u;
    }

    /**
     * Get ADDRSEL2's ALTENAB bit.
     */
    inline EBU_ADDRSEL0_ALTENAB get_ADDRSEL2_ALTENAB() volatile
    {
        return EBU_ADDRSEL0_ALTENAB(ADDRSEL2 & (1u << 1u));
    }

    /**
     * Set ADDRSEL2's ALTENAB bit.
     *
     * Alternate Region Enable
     */
    inline void set_ADDRSEL2_ALTENAB() volatile
    {
        ADDRSEL2 |= 1u << 1u;
    }

    /**
     * Clear ADDRSEL2's ALTENAB bit.
     *
     * Alternate Region Enable
     */
    inline void clear_ADDRSEL2_ALTENAB() volatile
    {
        ADDRSEL2 &= ~(1u << 1u);
    }

    /**
     * Toggle ADDRSEL2's ALTENAB bit.
     *
     * Alternate Region Enable
     */
    inline void toggle_ADDRSEL2_ALTENAB() volatile
    {
        ADDRSEL2 ^= 1u << 1u;
    }

    /**
     * Get ADDRSEL2's REGENAB bit.
     */
    inline EBU_ADDRSEL0_ALTENAB get_ADDRSEL2_REGENAB() volatile
    {
        return EBU_ADDRSEL0_ALTENAB(ADDRSEL2 & (1u << 0u));
    }

    /**
     * Set ADDRSEL2's REGENAB bit.
     *
     * Memory Region Enable
     */
    inline void set_ADDRSEL2_REGENAB() volatile
    {
        ADDRSEL2 |= 1u << 0u;
    }

    /**
     * Clear ADDRSEL2's REGENAB bit.
     *
     * Memory Region Enable
     */
    inline void clear_ADDRSEL2_REGENAB() volatile
    {
        ADDRSEL2 &= ~(1u << 0u);
    }

    /**
     * Toggle ADDRSEL2's REGENAB bit.
     *
     * Memory Region Enable
     */
    inline void toggle_ADDRSEL2_REGENAB() volatile
    {
        ADDRSEL2 ^= 1u << 0u;
    }

    /**
     * Get all of ADDRSEL2's bit fields.
     */
    inline void get_ADDRSEL2(EBU_ADDRSEL0_WPROT &WPROT,
                             EBU_ADDRSEL0_ALTENAB &ALTENAB,
                             EBU_ADDRSEL0_ALTENAB &REGENAB) volatile
    {
        uint32_t curr = ADDRSEL2;

        WPROT = EBU_ADDRSEL0_WPROT(curr & (1u << 2u));
        ALTENAB = EBU_ADDRSEL0_ALTENAB(curr & (1u << 1u));
        REGENAB = EBU_ADDRSEL0_ALTENAB(curr & (1u << 0u));
    }

    /**
     * Set all of ADDRSEL2's bit fields.
     *
     * (read-write) EBU Address Select Register 2
     */
    inline void set_ADDRSEL2(EBU_ADDRSEL0_WPROT WPROT,
                             EBU_ADDRSEL0_ALTENAB ALTENAB,
                             EBU_ADDRSEL0_ALTENAB REGENAB) volatile
    {
        uint32_t curr = ADDRSEL2;

        curr &= ~(0b1u << 2u);
        curr |= (std::to_underlying(WPROT) & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(ALTENAB) & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(REGENAB) & 0b1u) << 0u;

        ADDRSEL2 = curr;
    }

    /**
     * Get ADDRSEL3's WPROT bit.
     */
    inline EBU_ADDRSEL0_WPROT get_ADDRSEL3_WPROT() volatile
    {
        return EBU_ADDRSEL0_WPROT(ADDRSEL3 & (1u << 2u));
    }

    /**
     * Set ADDRSEL3's WPROT bit.
     *
     * Memory Region Write Protect
     */
    inline void set_ADDRSEL3_WPROT() volatile
    {
        ADDRSEL3 |= 1u << 2u;
    }

    /**
     * Clear ADDRSEL3's WPROT bit.
     *
     * Memory Region Write Protect
     */
    inline void clear_ADDRSEL3_WPROT() volatile
    {
        ADDRSEL3 &= ~(1u << 2u);
    }

    /**
     * Toggle ADDRSEL3's WPROT bit.
     *
     * Memory Region Write Protect
     */
    inline void toggle_ADDRSEL3_WPROT() volatile
    {
        ADDRSEL3 ^= 1u << 2u;
    }

    /**
     * Get ADDRSEL3's ALTENAB bit.
     */
    inline EBU_ADDRSEL0_ALTENAB get_ADDRSEL3_ALTENAB() volatile
    {
        return EBU_ADDRSEL0_ALTENAB(ADDRSEL3 & (1u << 1u));
    }

    /**
     * Set ADDRSEL3's ALTENAB bit.
     *
     * Alternate Region Enable
     */
    inline void set_ADDRSEL3_ALTENAB() volatile
    {
        ADDRSEL3 |= 1u << 1u;
    }

    /**
     * Clear ADDRSEL3's ALTENAB bit.
     *
     * Alternate Region Enable
     */
    inline void clear_ADDRSEL3_ALTENAB() volatile
    {
        ADDRSEL3 &= ~(1u << 1u);
    }

    /**
     * Toggle ADDRSEL3's ALTENAB bit.
     *
     * Alternate Region Enable
     */
    inline void toggle_ADDRSEL3_ALTENAB() volatile
    {
        ADDRSEL3 ^= 1u << 1u;
    }

    /**
     * Get ADDRSEL3's REGENAB bit.
     */
    inline EBU_ADDRSEL0_ALTENAB get_ADDRSEL3_REGENAB() volatile
    {
        return EBU_ADDRSEL0_ALTENAB(ADDRSEL3 & (1u << 0u));
    }

    /**
     * Set ADDRSEL3's REGENAB bit.
     *
     * Memory Region Enable
     */
    inline void set_ADDRSEL3_REGENAB() volatile
    {
        ADDRSEL3 |= 1u << 0u;
    }

    /**
     * Clear ADDRSEL3's REGENAB bit.
     *
     * Memory Region Enable
     */
    inline void clear_ADDRSEL3_REGENAB() volatile
    {
        ADDRSEL3 &= ~(1u << 0u);
    }

    /**
     * Toggle ADDRSEL3's REGENAB bit.
     *
     * Memory Region Enable
     */
    inline void toggle_ADDRSEL3_REGENAB() volatile
    {
        ADDRSEL3 ^= 1u << 0u;
    }

    /**
     * Get all of ADDRSEL3's bit fields.
     */
    inline void get_ADDRSEL3(EBU_ADDRSEL0_WPROT &WPROT,
                             EBU_ADDRSEL0_ALTENAB &ALTENAB,
                             EBU_ADDRSEL0_ALTENAB &REGENAB) volatile
    {
        uint32_t curr = ADDRSEL3;

        WPROT = EBU_ADDRSEL0_WPROT(curr & (1u << 2u));
        ALTENAB = EBU_ADDRSEL0_ALTENAB(curr & (1u << 1u));
        REGENAB = EBU_ADDRSEL0_ALTENAB(curr & (1u << 0u));
    }

    /**
     * Set all of ADDRSEL3's bit fields.
     *
     * (read-write) EBU Address Select Register 3
     */
    inline void set_ADDRSEL3(EBU_ADDRSEL0_WPROT WPROT,
                             EBU_ADDRSEL0_ALTENAB ALTENAB,
                             EBU_ADDRSEL0_ALTENAB REGENAB) volatile
    {
        uint32_t curr = ADDRSEL3;

        curr &= ~(0b1u << 2u);
        curr |= (std::to_underlying(WPROT) & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(ALTENAB) & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(REGENAB) & 0b1u) << 0u;

        ADDRSEL3 = curr;
    }

    /**
     * Get BUSRCON0's AGEN field.
     */
    inline uint8_t get_BUSRCON0_AGEN() volatile
    {
        return (BUSRCON0 >> 28u) & 0b1111u;
    }

    /**
     * Set BUSRCON0's AGEN field.
     *
     * Device Type for Region
     */
    inline void set_BUSRCON0_AGEN(uint8_t value) volatile
    {
        uint32_t curr = BUSRCON0;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        BUSRCON0 = curr;
    }

    /**
     * Get BUSRCON0's AAP bit.
     */
    inline EBU_BUSRCON0_AAP get_BUSRCON0_AAP() volatile
    {
        return EBU_BUSRCON0_AAP(BUSRCON0 & (1u << 26u));
    }

    /**
     * Set BUSRCON0's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void set_BUSRCON0_AAP() volatile
    {
        BUSRCON0 |= 1u << 26u;
    }

    /**
     * Clear BUSRCON0's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void clear_BUSRCON0_AAP() volatile
    {
        BUSRCON0 &= ~(1u << 26u);
    }

    /**
     * Toggle BUSRCON0's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void toggle_BUSRCON0_AAP() volatile
    {
        BUSRCON0 ^= 1u << 26u;
    }

    /**
     * Get BUSRCON0's WAIT field.
     */
    inline uint8_t get_BUSRCON0_WAIT() volatile
    {
        return (BUSRCON0 >> 24u) & 0b11u;
    }

    /**
     * Set BUSRCON0's WAIT field.
     *
     * External Wait Control: 0=OFF (default after reset)., 1=Asynchronous
     * input at WAIT., 2=Synchronous input at WAIT., 3=reserved., 0=OFF
     * (default after reset)., 1=Wait for page load (Early WAIT)., 2=Wait for
     * page load (WAIT with data)., 3=Abort and retry access.,
     */
    inline void set_BUSRCON0_WAIT(uint8_t value) volatile
    {
        uint32_t curr = BUSRCON0;

        curr &= ~(0b11u << 24u);
        curr |= (value & 0b11u) << 24u;

        BUSRCON0 = curr;
    }

    /**
     * Get BUSRCON0's PORTW field.
     */
    inline uint8_t get_BUSRCON0_PORTW() volatile
    {
        return (BUSRCON0 >> 22u) & 0b11u;
    }

    /**
     * Set BUSRCON0's PORTW field.
     *
     * Device Addressing Mode
     */
    inline void set_BUSRCON0_PORTW(uint8_t value) volatile
    {
        uint32_t curr = BUSRCON0;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        BUSRCON0 = curr;
    }

    /**
     * Get BUSRCON0's BCGEN field.
     */
    inline EBU_BUSRCON0_BCGEN get_BUSRCON0_BCGEN() volatile
    {
        return EBU_BUSRCON0_BCGEN((BUSRCON0 >> 20u) & 0b11u);
    }

    /**
     * Set BUSRCON0's BCGEN field.
     *
     * Byte Control Signal Control
     */
    inline void set_BUSRCON0_BCGEN(EBU_BUSRCON0_BCGEN value) volatile
    {
        uint32_t curr = BUSRCON0;

        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(value) & 0b11u) << 20u;

        BUSRCON0 = curr;
    }

    /**
     * Get BUSRCON0's WAITINV bit.
     */
    inline EBU_BUSRCON0_WAITINV get_BUSRCON0_WAITINV() volatile
    {
        return EBU_BUSRCON0_WAITINV(BUSRCON0 & (1u << 19u));
    }

    /**
     * Set BUSRCON0's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void set_BUSRCON0_WAITINV() volatile
    {
        BUSRCON0 |= 1u << 19u;
    }

    /**
     * Clear BUSRCON0's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void clear_BUSRCON0_WAITINV() volatile
    {
        BUSRCON0 &= ~(1u << 19u);
    }

    /**
     * Toggle BUSRCON0's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void toggle_BUSRCON0_WAITINV() volatile
    {
        BUSRCON0 ^= 1u << 19u;
    }

    /**
     * Get BUSRCON0's DBA bit.
     */
    inline EBU_BUSRCON0_DBA get_BUSRCON0_DBA() volatile
    {
        return EBU_BUSRCON0_DBA(BUSRCON0 & (1u << 18u));
    }

    /**
     * Set BUSRCON0's DBA bit.
     *
     * Disable Burst Address Wrapping
     */
    inline void set_BUSRCON0_DBA() volatile
    {
        BUSRCON0 |= 1u << 18u;
    }

    /**
     * Clear BUSRCON0's DBA bit.
     *
     * Disable Burst Address Wrapping
     */
    inline void clear_BUSRCON0_DBA() volatile
    {
        BUSRCON0 &= ~(1u << 18u);
    }

    /**
     * Toggle BUSRCON0's DBA bit.
     *
     * Disable Burst Address Wrapping
     */
    inline void toggle_BUSRCON0_DBA() volatile
    {
        BUSRCON0 ^= 1u << 18u;
    }

    /**
     * Get BUSRCON0's EBSE bit.
     */
    inline EBU_BUSRCON0_EBSE get_BUSRCON0_EBSE() volatile
    {
        return EBU_BUSRCON0_EBSE(BUSRCON0 & (1u << 17u));
    }

    /**
     * Set BUSRCON0's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void set_BUSRCON0_EBSE() volatile
    {
        BUSRCON0 |= 1u << 17u;
    }

    /**
     * Clear BUSRCON0's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void clear_BUSRCON0_EBSE() volatile
    {
        BUSRCON0 &= ~(1u << 17u);
    }

    /**
     * Toggle BUSRCON0's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void toggle_BUSRCON0_EBSE() volatile
    {
        BUSRCON0 ^= 1u << 17u;
    }

    /**
     * Get BUSRCON0's ECSE bit.
     */
    inline EBU_BUSRCON0_EBSE get_BUSRCON0_ECSE() volatile
    {
        return EBU_BUSRCON0_EBSE(BUSRCON0 & (1u << 16u));
    }

    /**
     * Set BUSRCON0's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void set_BUSRCON0_ECSE() volatile
    {
        BUSRCON0 |= 1u << 16u;
    }

    /**
     * Clear BUSRCON0's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void clear_BUSRCON0_ECSE() volatile
    {
        BUSRCON0 &= ~(1u << 16u);
    }

    /**
     * Toggle BUSRCON0's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void toggle_BUSRCON0_ECSE() volatile
    {
        BUSRCON0 ^= 1u << 16u;
    }

    /**
     * Get BUSRCON0's NAA bit.
     */
    inline bool get_BUSRCON0_NAA() volatile
    {
        return BUSRCON0 & (1u << 7u);
    }

    /**
     * Set BUSRCON0's NAA bit.
     *
     * Enable flash non-array access workaround
     */
    inline void set_BUSRCON0_NAA() volatile
    {
        BUSRCON0 |= 1u << 7u;
    }

    /**
     * Clear BUSRCON0's NAA bit.
     *
     * Enable flash non-array access workaround
     */
    inline void clear_BUSRCON0_NAA() volatile
    {
        BUSRCON0 &= ~(1u << 7u);
    }

    /**
     * Toggle BUSRCON0's NAA bit.
     *
     * Enable flash non-array access workaround
     */
    inline void toggle_BUSRCON0_NAA() volatile
    {
        BUSRCON0 ^= 1u << 7u;
    }

    /**
     * Get BUSRCON0's BFCMSEL bit.
     */
    inline EBU_BUSRCON0_BFCMSEL get_BUSRCON0_BFCMSEL() volatile
    {
        return EBU_BUSRCON0_BFCMSEL(BUSRCON0 & (1u << 6u));
    }

    /**
     * Set BUSRCON0's BFCMSEL bit.
     *
     * Burst Flash Clock Mode Select
     */
    inline void set_BUSRCON0_BFCMSEL() volatile
    {
        BUSRCON0 |= 1u << 6u;
    }

    /**
     * Clear BUSRCON0's BFCMSEL bit.
     *
     * Burst Flash Clock Mode Select
     */
    inline void clear_BUSRCON0_BFCMSEL() volatile
    {
        BUSRCON0 &= ~(1u << 6u);
    }

    /**
     * Toggle BUSRCON0's BFCMSEL bit.
     *
     * Burst Flash Clock Mode Select
     */
    inline void toggle_BUSRCON0_BFCMSEL() volatile
    {
        BUSRCON0 ^= 1u << 6u;
    }

    /**
     * Get BUSRCON0's FDBKEN bit.
     */
    inline EBU_BUSRCON0_FDBKEN get_BUSRCON0_FDBKEN() volatile
    {
        return EBU_BUSRCON0_FDBKEN(BUSRCON0 & (1u << 5u));
    }

    /**
     * Set BUSRCON0's FDBKEN bit.
     *
     * Burst FLASH Clock Feedback Enable
     */
    inline void set_BUSRCON0_FDBKEN() volatile
    {
        BUSRCON0 |= 1u << 5u;
    }

    /**
     * Clear BUSRCON0's FDBKEN bit.
     *
     * Burst FLASH Clock Feedback Enable
     */
    inline void clear_BUSRCON0_FDBKEN() volatile
    {
        BUSRCON0 &= ~(1u << 5u);
    }

    /**
     * Toggle BUSRCON0's FDBKEN bit.
     *
     * Burst FLASH Clock Feedback Enable
     */
    inline void toggle_BUSRCON0_FDBKEN() volatile
    {
        BUSRCON0 ^= 1u << 5u;
    }

    /**
     * Get BUSRCON0's BFSSS bit.
     */
    inline EBU_BUSRCON0_BFSSS get_BUSRCON0_BFSSS() volatile
    {
        return EBU_BUSRCON0_BFSSS(BUSRCON0 & (1u << 4u));
    }

    /**
     * Set BUSRCON0's BFSSS bit.
     *
     * Read Single Stage Synchronization:
     */
    inline void set_BUSRCON0_BFSSS() volatile
    {
        BUSRCON0 |= 1u << 4u;
    }

    /**
     * Clear BUSRCON0's BFSSS bit.
     *
     * Read Single Stage Synchronization:
     */
    inline void clear_BUSRCON0_BFSSS() volatile
    {
        BUSRCON0 &= ~(1u << 4u);
    }

    /**
     * Toggle BUSRCON0's BFSSS bit.
     *
     * Read Single Stage Synchronization:
     */
    inline void toggle_BUSRCON0_BFSSS() volatile
    {
        BUSRCON0 ^= 1u << 4u;
    }

    /**
     * Get BUSRCON0's FBBMSEL bit.
     */
    inline EBU_BUSRCON0_FBBMSEL get_BUSRCON0_FBBMSEL() volatile
    {
        return EBU_BUSRCON0_FBBMSEL(BUSRCON0 & (1u << 3u));
    }

    /**
     * Set BUSRCON0's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void set_BUSRCON0_FBBMSEL() volatile
    {
        BUSRCON0 |= 1u << 3u;
    }

    /**
     * Clear BUSRCON0's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void clear_BUSRCON0_FBBMSEL() volatile
    {
        BUSRCON0 &= ~(1u << 3u);
    }

    /**
     * Toggle BUSRCON0's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void toggle_BUSRCON0_FBBMSEL() volatile
    {
        BUSRCON0 ^= 1u << 3u;
    }

    /**
     * Get BUSRCON0's FETBLEN field.
     */
    inline EBU_BUSRCON0_FETBLEN get_BUSRCON0_FETBLEN() volatile
    {
        return EBU_BUSRCON0_FETBLEN((BUSRCON0 >> 0u) & 0b111u);
    }

    /**
     * Set BUSRCON0's FETBLEN field.
     *
     * Burst Length for Synchronous Burst
     */
    inline void set_BUSRCON0_FETBLEN(EBU_BUSRCON0_FETBLEN value) volatile
    {
        uint32_t curr = BUSRCON0;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        BUSRCON0 = curr;
    }

    /**
     * Get all of BUSRCON0's bit fields.
     */
    inline void get_BUSRCON0(
        uint8_t &AGEN, EBU_BUSRCON0_AAP &AAP, uint8_t &WAIT, uint8_t &PORTW,
        EBU_BUSRCON0_BCGEN &BCGEN, EBU_BUSRCON0_WAITINV &WAITINV,
        EBU_BUSRCON0_DBA &DBA, EBU_BUSRCON0_EBSE &EBSE,
        EBU_BUSRCON0_EBSE &ECSE, bool &NAA, EBU_BUSRCON0_BFCMSEL &BFCMSEL,
        EBU_BUSRCON0_FDBKEN &FDBKEN, EBU_BUSRCON0_BFSSS &BFSSS,
        EBU_BUSRCON0_FBBMSEL &FBBMSEL, EBU_BUSRCON0_FETBLEN &FETBLEN) volatile
    {
        uint32_t curr = BUSRCON0;

        AGEN = (curr >> 28u) & 0b1111u;
        AAP = EBU_BUSRCON0_AAP(curr & (1u << 26u));
        WAIT = (curr >> 24u) & 0b11u;
        PORTW = (curr >> 22u) & 0b11u;
        BCGEN = EBU_BUSRCON0_BCGEN((curr >> 20u) & 0b11u);
        WAITINV = EBU_BUSRCON0_WAITINV(curr & (1u << 19u));
        DBA = EBU_BUSRCON0_DBA(curr & (1u << 18u));
        EBSE = EBU_BUSRCON0_EBSE(curr & (1u << 17u));
        ECSE = EBU_BUSRCON0_EBSE(curr & (1u << 16u));
        NAA = curr & (1u << 7u);
        BFCMSEL = EBU_BUSRCON0_BFCMSEL(curr & (1u << 6u));
        FDBKEN = EBU_BUSRCON0_FDBKEN(curr & (1u << 5u));
        BFSSS = EBU_BUSRCON0_BFSSS(curr & (1u << 4u));
        FBBMSEL = EBU_BUSRCON0_FBBMSEL(curr & (1u << 3u));
        FETBLEN = EBU_BUSRCON0_FETBLEN((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of BUSRCON0's bit fields.
     *
     * (read-write) EBU Bus Configuration Register
     */
    inline void set_BUSRCON0(
        uint8_t AGEN, EBU_BUSRCON0_AAP AAP, uint8_t WAIT, uint8_t PORTW,
        EBU_BUSRCON0_BCGEN BCGEN, EBU_BUSRCON0_WAITINV WAITINV,
        EBU_BUSRCON0_DBA DBA, EBU_BUSRCON0_EBSE EBSE, EBU_BUSRCON0_EBSE ECSE,
        bool NAA, EBU_BUSRCON0_BFCMSEL BFCMSEL, EBU_BUSRCON0_FDBKEN FDBKEN,
        EBU_BUSRCON0_BFSSS BFSSS, EBU_BUSRCON0_FBBMSEL FBBMSEL,
        EBU_BUSRCON0_FETBLEN FETBLEN) volatile
    {
        uint32_t curr = BUSRCON0;

        curr &= ~(0b1111u << 28u);
        curr |= (AGEN & 0b1111u) << 28u;
        curr &= ~(0b1u << 26u);
        curr |= (std::to_underlying(AAP) & 0b1u) << 26u;
        curr &= ~(0b11u << 24u);
        curr |= (WAIT & 0b11u) << 24u;
        curr &= ~(0b11u << 22u);
        curr |= (PORTW & 0b11u) << 22u;
        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(BCGEN) & 0b11u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (std::to_underlying(WAITINV) & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (std::to_underlying(DBA) & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(EBSE) & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (std::to_underlying(ECSE) & 0b1u) << 16u;
        curr &= ~(0b1u << 7u);
        curr |= (NAA & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (std::to_underlying(BFCMSEL) & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (std::to_underlying(FDBKEN) & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (std::to_underlying(BFSSS) & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(FBBMSEL) & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(FETBLEN) & 0b111u) << 0u;

        BUSRCON0 = curr;
    }

    /**
     * Get BUSRAP0's ADDRC field.
     */
    inline EBU_BUSRAP0_ADDRC get_BUSRAP0_ADDRC() volatile
    {
        return EBU_BUSRAP0_ADDRC((BUSRAP0 >> 28u) & 0b1111u);
    }

    /**
     * Set BUSRAP0's ADDRC field.
     *
     * Address Cycles
     */
    inline void set_BUSRAP0_ADDRC(EBU_BUSRAP0_ADDRC value) volatile
    {
        uint32_t curr = BUSRAP0;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(value) & 0b1111u) << 28u;

        BUSRAP0 = curr;
    }

    /**
     * Get BUSRAP0's AHOLDC field.
     */
    inline EBU_BUSRAP0_AHOLDC get_BUSRAP0_AHOLDC() volatile
    {
        return EBU_BUSRAP0_AHOLDC((BUSRAP0 >> 24u) & 0b1111u);
    }

    /**
     * Set BUSRAP0's AHOLDC field.
     *
     * Address Hold Cycles
     */
    inline void set_BUSRAP0_AHOLDC(EBU_BUSRAP0_AHOLDC value) volatile
    {
        uint32_t curr = BUSRAP0;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        BUSRAP0 = curr;
    }

    /**
     * Get BUSRAP0's CMDDELAY field.
     */
    inline EBU_BUSRAP0_AHOLDC get_BUSRAP0_CMDDELAY() volatile
    {
        return EBU_BUSRAP0_AHOLDC((BUSRAP0 >> 20u) & 0b1111u);
    }

    /**
     * Set BUSRAP0's CMDDELAY field.
     *
     * Command Delay Cycles
     */
    inline void set_BUSRAP0_CMDDELAY(EBU_BUSRAP0_AHOLDC value) volatile
    {
        uint32_t curr = BUSRAP0;

        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(value) & 0b1111u) << 20u;

        BUSRAP0 = curr;
    }

    /**
     * Get BUSRAP0's EXTDATA field.
     */
    inline EBU_BUSRAP0_EXTDATA get_BUSRAP0_EXTDATA() volatile
    {
        return EBU_BUSRAP0_EXTDATA((BUSRAP0 >> 18u) & 0b11u);
    }

    /**
     * Set BUSRAP0's EXTDATA field.
     *
     * Extended data
     */
    inline void set_BUSRAP0_EXTDATA(EBU_BUSRAP0_EXTDATA value) volatile
    {
        uint32_t curr = BUSRAP0;

        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(value) & 0b11u) << 18u;

        BUSRAP0 = curr;
    }

    /**
     * Get BUSRAP0's EXTCLOCK field.
     */
    inline EBU_BUSRAP0_EXTCLOCK get_BUSRAP0_EXTCLOCK() volatile
    {
        return EBU_BUSRAP0_EXTCLOCK((BUSRAP0 >> 16u) & 0b11u);
    }

    /**
     * Set BUSRAP0's EXTCLOCK field.
     *
     * Frequency of external clock at pin BFCLKO
     */
    inline void set_BUSRAP0_EXTCLOCK(EBU_BUSRAP0_EXTCLOCK value) volatile
    {
        uint32_t curr = BUSRAP0;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        BUSRAP0 = curr;
    }

    /**
     * Get BUSRAP0's DATAC field.
     */
    inline uint8_t get_BUSRAP0_DATAC() volatile
    {
        return (BUSRAP0 >> 12u) & 0b1111u;
    }

    /**
     * Set BUSRAP0's DATAC field.
     *
     * Data Hold Cycles for Read Accesses
     */
    inline void set_BUSRAP0_DATAC(uint8_t value) volatile
    {
        uint32_t curr = BUSRAP0;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        BUSRAP0 = curr;
    }

    /**
     * Get BUSRAP0's WAITRDC field.
     */
    inline EBU_BUSRAP0_WAITRDC get_BUSRAP0_WAITRDC() volatile
    {
        return EBU_BUSRAP0_WAITRDC((BUSRAP0 >> 7u) & 0b11111u);
    }

    /**
     * Set BUSRAP0's WAITRDC field.
     *
     * Programmed Wait States for read accesses
     */
    inline void set_BUSRAP0_WAITRDC(EBU_BUSRAP0_WAITRDC value) volatile
    {
        uint32_t curr = BUSRAP0;

        curr &= ~(0b11111u << 7u);
        curr |= (std::to_underlying(value) & 0b11111u) << 7u;

        BUSRAP0 = curr;
    }

    /**
     * Get BUSRAP0's RDRECOVC field.
     */
    inline EBU_BUSRAP0_RDRECOVC get_BUSRAP0_RDRECOVC() volatile
    {
        return EBU_BUSRAP0_RDRECOVC((BUSRAP0 >> 4u) & 0b111u);
    }

    /**
     * Set BUSRAP0's RDRECOVC field.
     *
     * Recovery Cycles after Read Accesses
     */
    inline void set_BUSRAP0_RDRECOVC(EBU_BUSRAP0_RDRECOVC value) volatile
    {
        uint32_t curr = BUSRAP0;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        BUSRAP0 = curr;
    }

    /**
     * Get BUSRAP0's RDDTACS field.
     */
    inline EBU_BUSRAP0_RDDTACS get_BUSRAP0_RDDTACS() volatile
    {
        return EBU_BUSRAP0_RDDTACS((BUSRAP0 >> 0u) & 0b1111u);
    }

    /**
     * Set BUSRAP0's RDDTACS field.
     *
     * Recovery Cycles between Different Regions
     */
    inline void set_BUSRAP0_RDDTACS(EBU_BUSRAP0_RDDTACS value) volatile
    {
        uint32_t curr = BUSRAP0;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        BUSRAP0 = curr;
    }

    /**
     * Get all of BUSRAP0's bit fields.
     */
    inline void get_BUSRAP0(EBU_BUSRAP0_ADDRC &ADDRC,
                            EBU_BUSRAP0_AHOLDC &AHOLDC,
                            EBU_BUSRAP0_AHOLDC &CMDDELAY,
                            EBU_BUSRAP0_EXTDATA &EXTDATA,
                            EBU_BUSRAP0_EXTCLOCK &EXTCLOCK, uint8_t &DATAC,
                            EBU_BUSRAP0_WAITRDC &WAITRDC,
                            EBU_BUSRAP0_RDRECOVC &RDRECOVC,
                            EBU_BUSRAP0_RDDTACS &RDDTACS) volatile
    {
        uint32_t curr = BUSRAP0;

        ADDRC = EBU_BUSRAP0_ADDRC((curr >> 28u) & 0b1111u);
        AHOLDC = EBU_BUSRAP0_AHOLDC((curr >> 24u) & 0b1111u);
        CMDDELAY = EBU_BUSRAP0_AHOLDC((curr >> 20u) & 0b1111u);
        EXTDATA = EBU_BUSRAP0_EXTDATA((curr >> 18u) & 0b11u);
        EXTCLOCK = EBU_BUSRAP0_EXTCLOCK((curr >> 16u) & 0b11u);
        DATAC = (curr >> 12u) & 0b1111u;
        WAITRDC = EBU_BUSRAP0_WAITRDC((curr >> 7u) & 0b11111u);
        RDRECOVC = EBU_BUSRAP0_RDRECOVC((curr >> 4u) & 0b111u);
        RDDTACS = EBU_BUSRAP0_RDDTACS((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of BUSRAP0's bit fields.
     *
     * (read-write) EBU Bus Read Access Parameter Register
     */
    inline void set_BUSRAP0(EBU_BUSRAP0_ADDRC ADDRC, EBU_BUSRAP0_AHOLDC AHOLDC,
                            EBU_BUSRAP0_AHOLDC CMDDELAY,
                            EBU_BUSRAP0_EXTDATA EXTDATA,
                            EBU_BUSRAP0_EXTCLOCK EXTCLOCK, uint8_t DATAC,
                            EBU_BUSRAP0_WAITRDC WAITRDC,
                            EBU_BUSRAP0_RDRECOVC RDRECOVC,
                            EBU_BUSRAP0_RDDTACS RDDTACS) volatile
    {
        uint32_t curr = BUSRAP0;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(ADDRC) & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(AHOLDC) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(CMDDELAY) & 0b1111u) << 20u;
        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(EXTDATA) & 0b11u) << 18u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(EXTCLOCK) & 0b11u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (DATAC & 0b1111u) << 12u;
        curr &= ~(0b11111u << 7u);
        curr |= (std::to_underlying(WAITRDC) & 0b11111u) << 7u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(RDRECOVC) & 0b111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(RDDTACS) & 0b1111u) << 0u;

        BUSRAP0 = curr;
    }

    /**
     * Get BUSWCON0's AGEN field.
     */
    inline uint8_t get_BUSWCON0_AGEN() volatile
    {
        return (BUSWCON0 >> 28u) & 0b1111u;
    }

    /**
     * Set BUSWCON0's AGEN field.
     *
     * Device Type for Region
     */
    inline void set_BUSWCON0_AGEN(uint8_t value) volatile
    {
        uint32_t curr = BUSWCON0;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        BUSWCON0 = curr;
    }

    /**
     * Get BUSWCON0's LOCKCS bit.
     */
    inline EBU_BUSWCON0_LOCKCS get_BUSWCON0_LOCKCS() volatile
    {
        return EBU_BUSWCON0_LOCKCS(BUSWCON0 & (1u << 27u));
    }

    /**
     * Set BUSWCON0's LOCKCS bit.
     *
     * Lock Chip Select
     */
    inline void set_BUSWCON0_LOCKCS() volatile
    {
        BUSWCON0 |= 1u << 27u;
    }

    /**
     * Clear BUSWCON0's LOCKCS bit.
     *
     * Lock Chip Select
     */
    inline void clear_BUSWCON0_LOCKCS() volatile
    {
        BUSWCON0 &= ~(1u << 27u);
    }

    /**
     * Toggle BUSWCON0's LOCKCS bit.
     *
     * Lock Chip Select
     */
    inline void toggle_BUSWCON0_LOCKCS() volatile
    {
        BUSWCON0 ^= 1u << 27u;
    }

    /**
     * Get BUSWCON0's AAP bit.
     */
    inline EBU_BUSRCON0_AAP get_BUSWCON0_AAP() volatile
    {
        return EBU_BUSRCON0_AAP(BUSWCON0 & (1u << 26u));
    }

    /**
     * Set BUSWCON0's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void set_BUSWCON0_AAP() volatile
    {
        BUSWCON0 |= 1u << 26u;
    }

    /**
     * Clear BUSWCON0's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void clear_BUSWCON0_AAP() volatile
    {
        BUSWCON0 &= ~(1u << 26u);
    }

    /**
     * Toggle BUSWCON0's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void toggle_BUSWCON0_AAP() volatile
    {
        BUSWCON0 ^= 1u << 26u;
    }

    /**
     * Get BUSWCON0's WAIT field.
     */
    inline uint8_t get_BUSWCON0_WAIT() volatile
    {
        return (BUSWCON0 >> 24u) & 0b11u;
    }

    /**
     * Set BUSWCON0's WAIT field.
     *
     * External Wait Control: 0=OFF (default after reset)., 1=Asynchronous
     * input at WAIT., 2=Synchronous input at WAIT., 3=reserved., 0=OFF
     * (default after reset)., 1=Wait for page load (Early WAIT)., 2=Wait for
     * page load (WAIT with data)., 3=Abort and retry access.,
     */
    inline void set_BUSWCON0_WAIT(uint8_t value) volatile
    {
        uint32_t curr = BUSWCON0;

        curr &= ~(0b11u << 24u);
        curr |= (value & 0b11u) << 24u;

        BUSWCON0 = curr;
    }

    /**
     * Get BUSWCON0's PORTW field.
     */
    inline uint8_t get_BUSWCON0_PORTW() volatile
    {
        return (BUSWCON0 >> 22u) & 0b11u;
    }

    /**
     * Get BUSWCON0's BCGEN field.
     */
    inline EBU_BUSRCON0_BCGEN get_BUSWCON0_BCGEN() volatile
    {
        return EBU_BUSRCON0_BCGEN((BUSWCON0 >> 20u) & 0b11u);
    }

    /**
     * Set BUSWCON0's BCGEN field.
     *
     * Byte Control Signal Control
     */
    inline void set_BUSWCON0_BCGEN(EBU_BUSRCON0_BCGEN value) volatile
    {
        uint32_t curr = BUSWCON0;

        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(value) & 0b11u) << 20u;

        BUSWCON0 = curr;
    }

    /**
     * Get BUSWCON0's WAITINV bit.
     */
    inline EBU_BUSRCON0_WAITINV get_BUSWCON0_WAITINV() volatile
    {
        return EBU_BUSRCON0_WAITINV(BUSWCON0 & (1u << 19u));
    }

    /**
     * Set BUSWCON0's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void set_BUSWCON0_WAITINV() volatile
    {
        BUSWCON0 |= 1u << 19u;
    }

    /**
     * Clear BUSWCON0's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void clear_BUSWCON0_WAITINV() volatile
    {
        BUSWCON0 &= ~(1u << 19u);
    }

    /**
     * Toggle BUSWCON0's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void toggle_BUSWCON0_WAITINV() volatile
    {
        BUSWCON0 ^= 1u << 19u;
    }

    /**
     * Get BUSWCON0's EBSE bit.
     */
    inline EBU_BUSRCON0_EBSE get_BUSWCON0_EBSE() volatile
    {
        return EBU_BUSRCON0_EBSE(BUSWCON0 & (1u << 17u));
    }

    /**
     * Set BUSWCON0's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void set_BUSWCON0_EBSE() volatile
    {
        BUSWCON0 |= 1u << 17u;
    }

    /**
     * Clear BUSWCON0's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void clear_BUSWCON0_EBSE() volatile
    {
        BUSWCON0 &= ~(1u << 17u);
    }

    /**
     * Toggle BUSWCON0's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void toggle_BUSWCON0_EBSE() volatile
    {
        BUSWCON0 ^= 1u << 17u;
    }

    /**
     * Get BUSWCON0's ECSE bit.
     */
    inline EBU_BUSRCON0_EBSE get_BUSWCON0_ECSE() volatile
    {
        return EBU_BUSRCON0_EBSE(BUSWCON0 & (1u << 16u));
    }

    /**
     * Set BUSWCON0's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void set_BUSWCON0_ECSE() volatile
    {
        BUSWCON0 |= 1u << 16u;
    }

    /**
     * Clear BUSWCON0's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void clear_BUSWCON0_ECSE() volatile
    {
        BUSWCON0 &= ~(1u << 16u);
    }

    /**
     * Toggle BUSWCON0's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void toggle_BUSWCON0_ECSE() volatile
    {
        BUSWCON0 ^= 1u << 16u;
    }

    /**
     * Get BUSWCON0's NAA bit.
     */
    inline bool get_BUSWCON0_NAA() volatile
    {
        return BUSWCON0 & (1u << 7u);
    }

    /**
     * Get BUSWCON0's FBBMSEL bit.
     */
    inline EBU_BUSRCON0_FBBMSEL get_BUSWCON0_FBBMSEL() volatile
    {
        return EBU_BUSRCON0_FBBMSEL(BUSWCON0 & (1u << 3u));
    }

    /**
     * Set BUSWCON0's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void set_BUSWCON0_FBBMSEL() volatile
    {
        BUSWCON0 |= 1u << 3u;
    }

    /**
     * Clear BUSWCON0's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void clear_BUSWCON0_FBBMSEL() volatile
    {
        BUSWCON0 &= ~(1u << 3u);
    }

    /**
     * Toggle BUSWCON0's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void toggle_BUSWCON0_FBBMSEL() volatile
    {
        BUSWCON0 ^= 1u << 3u;
    }

    /**
     * Get BUSWCON0's FETBLEN field.
     */
    inline EBU_BUSRCON0_FETBLEN get_BUSWCON0_FETBLEN() volatile
    {
        return EBU_BUSRCON0_FETBLEN((BUSWCON0 >> 0u) & 0b111u);
    }

    /**
     * Set BUSWCON0's FETBLEN field.
     *
     * Burst Length for Synchronous Burst
     */
    inline void set_BUSWCON0_FETBLEN(EBU_BUSRCON0_FETBLEN value) volatile
    {
        uint32_t curr = BUSWCON0;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        BUSWCON0 = curr;
    }

    /**
     * Get all of BUSWCON0's bit fields.
     */
    inline void get_BUSWCON0(uint8_t &AGEN, EBU_BUSWCON0_LOCKCS &LOCKCS,
                             EBU_BUSRCON0_AAP &AAP, uint8_t &WAIT,
                             uint8_t &PORTW, EBU_BUSRCON0_BCGEN &BCGEN,
                             EBU_BUSRCON0_WAITINV &WAITINV,
                             EBU_BUSRCON0_EBSE &EBSE, EBU_BUSRCON0_EBSE &ECSE,
                             bool &NAA, EBU_BUSRCON0_FBBMSEL &FBBMSEL,
                             EBU_BUSRCON0_FETBLEN &FETBLEN) volatile
    {
        uint32_t curr = BUSWCON0;

        AGEN = (curr >> 28u) & 0b1111u;
        LOCKCS = EBU_BUSWCON0_LOCKCS(curr & (1u << 27u));
        AAP = EBU_BUSRCON0_AAP(curr & (1u << 26u));
        WAIT = (curr >> 24u) & 0b11u;
        PORTW = (curr >> 22u) & 0b11u;
        BCGEN = EBU_BUSRCON0_BCGEN((curr >> 20u) & 0b11u);
        WAITINV = EBU_BUSRCON0_WAITINV(curr & (1u << 19u));
        EBSE = EBU_BUSRCON0_EBSE(curr & (1u << 17u));
        ECSE = EBU_BUSRCON0_EBSE(curr & (1u << 16u));
        NAA = curr & (1u << 7u);
        FBBMSEL = EBU_BUSRCON0_FBBMSEL(curr & (1u << 3u));
        FETBLEN = EBU_BUSRCON0_FETBLEN((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of BUSWCON0's bit fields.
     *
     * (read-write) EBU Bus Write Configuration Register
     */
    inline void set_BUSWCON0(uint8_t AGEN, EBU_BUSWCON0_LOCKCS LOCKCS,
                             EBU_BUSRCON0_AAP AAP, uint8_t WAIT,
                             EBU_BUSRCON0_BCGEN BCGEN,
                             EBU_BUSRCON0_WAITINV WAITINV,
                             EBU_BUSRCON0_EBSE EBSE, EBU_BUSRCON0_EBSE ECSE,
                             EBU_BUSRCON0_FBBMSEL FBBMSEL,
                             EBU_BUSRCON0_FETBLEN FETBLEN) volatile
    {
        uint32_t curr = BUSWCON0;

        curr &= ~(0b1111u << 28u);
        curr |= (AGEN & 0b1111u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (std::to_underlying(LOCKCS) & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (std::to_underlying(AAP) & 0b1u) << 26u;
        curr &= ~(0b11u << 24u);
        curr |= (WAIT & 0b11u) << 24u;
        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(BCGEN) & 0b11u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (std::to_underlying(WAITINV) & 0b1u) << 19u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(EBSE) & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (std::to_underlying(ECSE) & 0b1u) << 16u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(FBBMSEL) & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(FETBLEN) & 0b111u) << 0u;

        BUSWCON0 = curr;
    }

    /**
     * Get BUSWAP0's ADDRC field.
     */
    inline EBU_BUSRAP0_ADDRC get_BUSWAP0_ADDRC() volatile
    {
        return EBU_BUSRAP0_ADDRC((BUSWAP0 >> 28u) & 0b1111u);
    }

    /**
     * Set BUSWAP0's ADDRC field.
     *
     * Address Cycles
     */
    inline void set_BUSWAP0_ADDRC(EBU_BUSRAP0_ADDRC value) volatile
    {
        uint32_t curr = BUSWAP0;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(value) & 0b1111u) << 28u;

        BUSWAP0 = curr;
    }

    /**
     * Get BUSWAP0's AHOLDC field.
     */
    inline EBU_BUSRAP0_AHOLDC get_BUSWAP0_AHOLDC() volatile
    {
        return EBU_BUSRAP0_AHOLDC((BUSWAP0 >> 24u) & 0b1111u);
    }

    /**
     * Set BUSWAP0's AHOLDC field.
     *
     * Address Hold Cycles
     */
    inline void set_BUSWAP0_AHOLDC(EBU_BUSRAP0_AHOLDC value) volatile
    {
        uint32_t curr = BUSWAP0;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        BUSWAP0 = curr;
    }

    /**
     * Get BUSWAP0's CMDDELAY field.
     */
    inline EBU_BUSRAP0_AHOLDC get_BUSWAP0_CMDDELAY() volatile
    {
        return EBU_BUSRAP0_AHOLDC((BUSWAP0 >> 20u) & 0b1111u);
    }

    /**
     * Set BUSWAP0's CMDDELAY field.
     *
     * Command Delay Cycles
     */
    inline void set_BUSWAP0_CMDDELAY(EBU_BUSRAP0_AHOLDC value) volatile
    {
        uint32_t curr = BUSWAP0;

        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(value) & 0b1111u) << 20u;

        BUSWAP0 = curr;
    }

    /**
     * Get BUSWAP0's EXTDATA field.
     */
    inline EBU_BUSRAP0_EXTDATA get_BUSWAP0_EXTDATA() volatile
    {
        return EBU_BUSRAP0_EXTDATA((BUSWAP0 >> 18u) & 0b11u);
    }

    /**
     * Set BUSWAP0's EXTDATA field.
     *
     * Extended data
     */
    inline void set_BUSWAP0_EXTDATA(EBU_BUSRAP0_EXTDATA value) volatile
    {
        uint32_t curr = BUSWAP0;

        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(value) & 0b11u) << 18u;

        BUSWAP0 = curr;
    }

    /**
     * Get BUSWAP0's EXTCLOCK field.
     */
    inline EBU_BUSRAP0_EXTCLOCK get_BUSWAP0_EXTCLOCK() volatile
    {
        return EBU_BUSRAP0_EXTCLOCK((BUSWAP0 >> 16u) & 0b11u);
    }

    /**
     * Set BUSWAP0's EXTCLOCK field.
     *
     * Frequency of external clock at pin BFCLKO
     */
    inline void set_BUSWAP0_EXTCLOCK(EBU_BUSRAP0_EXTCLOCK value) volatile
    {
        uint32_t curr = BUSWAP0;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        BUSWAP0 = curr;
    }

    /**
     * Get BUSWAP0's DATAC field.
     */
    inline EBU_BUSRAP0_RDDTACS get_BUSWAP0_DATAC() volatile
    {
        return EBU_BUSRAP0_RDDTACS((BUSWAP0 >> 12u) & 0b1111u);
    }

    /**
     * Set BUSWAP0's DATAC field.
     *
     * Data Hold Cycles for Write Accesses
     */
    inline void set_BUSWAP0_DATAC(EBU_BUSRAP0_RDDTACS value) volatile
    {
        uint32_t curr = BUSWAP0;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(value) & 0b1111u) << 12u;

        BUSWAP0 = curr;
    }

    /**
     * Get BUSWAP0's WAITWRC field.
     */
    inline EBU_BUSRAP0_WAITRDC get_BUSWAP0_WAITWRC() volatile
    {
        return EBU_BUSRAP0_WAITRDC((BUSWAP0 >> 7u) & 0b11111u);
    }

    /**
     * Set BUSWAP0's WAITWRC field.
     *
     * Programmed Wait States for write accesses
     */
    inline void set_BUSWAP0_WAITWRC(EBU_BUSRAP0_WAITRDC value) volatile
    {
        uint32_t curr = BUSWAP0;

        curr &= ~(0b11111u << 7u);
        curr |= (std::to_underlying(value) & 0b11111u) << 7u;

        BUSWAP0 = curr;
    }

    /**
     * Get BUSWAP0's WRRECOVC field.
     */
    inline EBU_BUSRAP0_RDRECOVC get_BUSWAP0_WRRECOVC() volatile
    {
        return EBU_BUSRAP0_RDRECOVC((BUSWAP0 >> 4u) & 0b111u);
    }

    /**
     * Set BUSWAP0's WRRECOVC field.
     *
     * Recovery Cycles after Write Accesses
     */
    inline void set_BUSWAP0_WRRECOVC(EBU_BUSRAP0_RDRECOVC value) volatile
    {
        uint32_t curr = BUSWAP0;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        BUSWAP0 = curr;
    }

    /**
     * Get BUSWAP0's WRDTACS field.
     */
    inline EBU_BUSRAP0_RDDTACS get_BUSWAP0_WRDTACS() volatile
    {
        return EBU_BUSRAP0_RDDTACS((BUSWAP0 >> 0u) & 0b1111u);
    }

    /**
     * Set BUSWAP0's WRDTACS field.
     *
     * Recovery Cycles between Different Regions
     */
    inline void set_BUSWAP0_WRDTACS(EBU_BUSRAP0_RDDTACS value) volatile
    {
        uint32_t curr = BUSWAP0;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        BUSWAP0 = curr;
    }

    /**
     * Get all of BUSWAP0's bit fields.
     */
    inline void get_BUSWAP0(
        EBU_BUSRAP0_ADDRC &ADDRC, EBU_BUSRAP0_AHOLDC &AHOLDC,
        EBU_BUSRAP0_AHOLDC &CMDDELAY, EBU_BUSRAP0_EXTDATA &EXTDATA,
        EBU_BUSRAP0_EXTCLOCK &EXTCLOCK, EBU_BUSRAP0_RDDTACS &DATAC,
        EBU_BUSRAP0_WAITRDC &WAITWRC, EBU_BUSRAP0_RDRECOVC &WRRECOVC,
        EBU_BUSRAP0_RDDTACS &WRDTACS) volatile
    {
        uint32_t curr = BUSWAP0;

        ADDRC = EBU_BUSRAP0_ADDRC((curr >> 28u) & 0b1111u);
        AHOLDC = EBU_BUSRAP0_AHOLDC((curr >> 24u) & 0b1111u);
        CMDDELAY = EBU_BUSRAP0_AHOLDC((curr >> 20u) & 0b1111u);
        EXTDATA = EBU_BUSRAP0_EXTDATA((curr >> 18u) & 0b11u);
        EXTCLOCK = EBU_BUSRAP0_EXTCLOCK((curr >> 16u) & 0b11u);
        DATAC = EBU_BUSRAP0_RDDTACS((curr >> 12u) & 0b1111u);
        WAITWRC = EBU_BUSRAP0_WAITRDC((curr >> 7u) & 0b11111u);
        WRRECOVC = EBU_BUSRAP0_RDRECOVC((curr >> 4u) & 0b111u);
        WRDTACS = EBU_BUSRAP0_RDDTACS((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of BUSWAP0's bit fields.
     *
     * (read-write) EBU Bus Write Access Parameter Register
     */
    inline void set_BUSWAP0(EBU_BUSRAP0_ADDRC ADDRC, EBU_BUSRAP0_AHOLDC AHOLDC,
                            EBU_BUSRAP0_AHOLDC CMDDELAY,
                            EBU_BUSRAP0_EXTDATA EXTDATA,
                            EBU_BUSRAP0_EXTCLOCK EXTCLOCK,
                            EBU_BUSRAP0_RDDTACS DATAC,
                            EBU_BUSRAP0_WAITRDC WAITWRC,
                            EBU_BUSRAP0_RDRECOVC WRRECOVC,
                            EBU_BUSRAP0_RDDTACS WRDTACS) volatile
    {
        uint32_t curr = BUSWAP0;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(ADDRC) & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(AHOLDC) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(CMDDELAY) & 0b1111u) << 20u;
        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(EXTDATA) & 0b11u) << 18u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(EXTCLOCK) & 0b11u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(DATAC) & 0b1111u) << 12u;
        curr &= ~(0b11111u << 7u);
        curr |= (std::to_underlying(WAITWRC) & 0b11111u) << 7u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(WRRECOVC) & 0b111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(WRDTACS) & 0b1111u) << 0u;

        BUSWAP0 = curr;
    }

    /**
     * Get BUSRCON1's AGEN field.
     */
    inline uint8_t get_BUSRCON1_AGEN() volatile
    {
        return (BUSRCON1 >> 28u) & 0b1111u;
    }

    /**
     * Set BUSRCON1's AGEN field.
     *
     * Device Type for Region
     */
    inline void set_BUSRCON1_AGEN(uint8_t value) volatile
    {
        uint32_t curr = BUSRCON1;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        BUSRCON1 = curr;
    }

    /**
     * Get BUSRCON1's AAP bit.
     */
    inline EBU_BUSRCON0_AAP get_BUSRCON1_AAP() volatile
    {
        return EBU_BUSRCON0_AAP(BUSRCON1 & (1u << 26u));
    }

    /**
     * Set BUSRCON1's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void set_BUSRCON1_AAP() volatile
    {
        BUSRCON1 |= 1u << 26u;
    }

    /**
     * Clear BUSRCON1's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void clear_BUSRCON1_AAP() volatile
    {
        BUSRCON1 &= ~(1u << 26u);
    }

    /**
     * Toggle BUSRCON1's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void toggle_BUSRCON1_AAP() volatile
    {
        BUSRCON1 ^= 1u << 26u;
    }

    /**
     * Get BUSRCON1's WAIT field.
     */
    inline uint8_t get_BUSRCON1_WAIT() volatile
    {
        return (BUSRCON1 >> 24u) & 0b11u;
    }

    /**
     * Set BUSRCON1's WAIT field.
     *
     * External Wait Control: 0=OFF (default after reset)., 1=Asynchronous
     * input at WAIT., 2=Synchronous input at WAIT., 3=reserved., 0=OFF
     * (default after reset)., 1=Wait for page load (Early WAIT)., 2=Wait for
     * page load (WAIT with data)., 3=Abort and retry access.,
     */
    inline void set_BUSRCON1_WAIT(uint8_t value) volatile
    {
        uint32_t curr = BUSRCON1;

        curr &= ~(0b11u << 24u);
        curr |= (value & 0b11u) << 24u;

        BUSRCON1 = curr;
    }

    /**
     * Get BUSRCON1's PORTW field.
     */
    inline uint8_t get_BUSRCON1_PORTW() volatile
    {
        return (BUSRCON1 >> 22u) & 0b11u;
    }

    /**
     * Set BUSRCON1's PORTW field.
     *
     * Device Addressing Mode
     */
    inline void set_BUSRCON1_PORTW(uint8_t value) volatile
    {
        uint32_t curr = BUSRCON1;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        BUSRCON1 = curr;
    }

    /**
     * Get BUSRCON1's BCGEN field.
     */
    inline EBU_BUSRCON0_BCGEN get_BUSRCON1_BCGEN() volatile
    {
        return EBU_BUSRCON0_BCGEN((BUSRCON1 >> 20u) & 0b11u);
    }

    /**
     * Set BUSRCON1's BCGEN field.
     *
     * Byte Control Signal Control
     */
    inline void set_BUSRCON1_BCGEN(EBU_BUSRCON0_BCGEN value) volatile
    {
        uint32_t curr = BUSRCON1;

        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(value) & 0b11u) << 20u;

        BUSRCON1 = curr;
    }

    /**
     * Get BUSRCON1's WAITINV bit.
     */
    inline EBU_BUSRCON0_WAITINV get_BUSRCON1_WAITINV() volatile
    {
        return EBU_BUSRCON0_WAITINV(BUSRCON1 & (1u << 19u));
    }

    /**
     * Set BUSRCON1's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void set_BUSRCON1_WAITINV() volatile
    {
        BUSRCON1 |= 1u << 19u;
    }

    /**
     * Clear BUSRCON1's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void clear_BUSRCON1_WAITINV() volatile
    {
        BUSRCON1 &= ~(1u << 19u);
    }

    /**
     * Toggle BUSRCON1's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void toggle_BUSRCON1_WAITINV() volatile
    {
        BUSRCON1 ^= 1u << 19u;
    }

    /**
     * Get BUSRCON1's DBA bit.
     */
    inline EBU_BUSRCON0_DBA get_BUSRCON1_DBA() volatile
    {
        return EBU_BUSRCON0_DBA(BUSRCON1 & (1u << 18u));
    }

    /**
     * Set BUSRCON1's DBA bit.
     *
     * Disable Burst Address Wrapping
     */
    inline void set_BUSRCON1_DBA() volatile
    {
        BUSRCON1 |= 1u << 18u;
    }

    /**
     * Clear BUSRCON1's DBA bit.
     *
     * Disable Burst Address Wrapping
     */
    inline void clear_BUSRCON1_DBA() volatile
    {
        BUSRCON1 &= ~(1u << 18u);
    }

    /**
     * Toggle BUSRCON1's DBA bit.
     *
     * Disable Burst Address Wrapping
     */
    inline void toggle_BUSRCON1_DBA() volatile
    {
        BUSRCON1 ^= 1u << 18u;
    }

    /**
     * Get BUSRCON1's EBSE bit.
     */
    inline EBU_BUSRCON0_EBSE get_BUSRCON1_EBSE() volatile
    {
        return EBU_BUSRCON0_EBSE(BUSRCON1 & (1u << 17u));
    }

    /**
     * Set BUSRCON1's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void set_BUSRCON1_EBSE() volatile
    {
        BUSRCON1 |= 1u << 17u;
    }

    /**
     * Clear BUSRCON1's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void clear_BUSRCON1_EBSE() volatile
    {
        BUSRCON1 &= ~(1u << 17u);
    }

    /**
     * Toggle BUSRCON1's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void toggle_BUSRCON1_EBSE() volatile
    {
        BUSRCON1 ^= 1u << 17u;
    }

    /**
     * Get BUSRCON1's ECSE bit.
     */
    inline EBU_BUSRCON0_EBSE get_BUSRCON1_ECSE() volatile
    {
        return EBU_BUSRCON0_EBSE(BUSRCON1 & (1u << 16u));
    }

    /**
     * Set BUSRCON1's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void set_BUSRCON1_ECSE() volatile
    {
        BUSRCON1 |= 1u << 16u;
    }

    /**
     * Clear BUSRCON1's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void clear_BUSRCON1_ECSE() volatile
    {
        BUSRCON1 &= ~(1u << 16u);
    }

    /**
     * Toggle BUSRCON1's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void toggle_BUSRCON1_ECSE() volatile
    {
        BUSRCON1 ^= 1u << 16u;
    }

    /**
     * Get BUSRCON1's NAA bit.
     */
    inline bool get_BUSRCON1_NAA() volatile
    {
        return BUSRCON1 & (1u << 7u);
    }

    /**
     * Set BUSRCON1's NAA bit.
     *
     * Enable flash non-array access workaround
     */
    inline void set_BUSRCON1_NAA() volatile
    {
        BUSRCON1 |= 1u << 7u;
    }

    /**
     * Clear BUSRCON1's NAA bit.
     *
     * Enable flash non-array access workaround
     */
    inline void clear_BUSRCON1_NAA() volatile
    {
        BUSRCON1 &= ~(1u << 7u);
    }

    /**
     * Toggle BUSRCON1's NAA bit.
     *
     * Enable flash non-array access workaround
     */
    inline void toggle_BUSRCON1_NAA() volatile
    {
        BUSRCON1 ^= 1u << 7u;
    }

    /**
     * Get BUSRCON1's BFCMSEL bit.
     */
    inline EBU_BUSRCON0_BFCMSEL get_BUSRCON1_BFCMSEL() volatile
    {
        return EBU_BUSRCON0_BFCMSEL(BUSRCON1 & (1u << 6u));
    }

    /**
     * Set BUSRCON1's BFCMSEL bit.
     *
     * Burst Flash Clock Mode Select
     */
    inline void set_BUSRCON1_BFCMSEL() volatile
    {
        BUSRCON1 |= 1u << 6u;
    }

    /**
     * Clear BUSRCON1's BFCMSEL bit.
     *
     * Burst Flash Clock Mode Select
     */
    inline void clear_BUSRCON1_BFCMSEL() volatile
    {
        BUSRCON1 &= ~(1u << 6u);
    }

    /**
     * Toggle BUSRCON1's BFCMSEL bit.
     *
     * Burst Flash Clock Mode Select
     */
    inline void toggle_BUSRCON1_BFCMSEL() volatile
    {
        BUSRCON1 ^= 1u << 6u;
    }

    /**
     * Get BUSRCON1's FDBKEN bit.
     */
    inline EBU_BUSRCON0_FDBKEN get_BUSRCON1_FDBKEN() volatile
    {
        return EBU_BUSRCON0_FDBKEN(BUSRCON1 & (1u << 5u));
    }

    /**
     * Set BUSRCON1's FDBKEN bit.
     *
     * Burst FLASH Clock Feedback Enable
     */
    inline void set_BUSRCON1_FDBKEN() volatile
    {
        BUSRCON1 |= 1u << 5u;
    }

    /**
     * Clear BUSRCON1's FDBKEN bit.
     *
     * Burst FLASH Clock Feedback Enable
     */
    inline void clear_BUSRCON1_FDBKEN() volatile
    {
        BUSRCON1 &= ~(1u << 5u);
    }

    /**
     * Toggle BUSRCON1's FDBKEN bit.
     *
     * Burst FLASH Clock Feedback Enable
     */
    inline void toggle_BUSRCON1_FDBKEN() volatile
    {
        BUSRCON1 ^= 1u << 5u;
    }

    /**
     * Get BUSRCON1's BFSSS bit.
     */
    inline EBU_BUSRCON0_BFSSS get_BUSRCON1_BFSSS() volatile
    {
        return EBU_BUSRCON0_BFSSS(BUSRCON1 & (1u << 4u));
    }

    /**
     * Set BUSRCON1's BFSSS bit.
     *
     * Read Single Stage Synchronization:
     */
    inline void set_BUSRCON1_BFSSS() volatile
    {
        BUSRCON1 |= 1u << 4u;
    }

    /**
     * Clear BUSRCON1's BFSSS bit.
     *
     * Read Single Stage Synchronization:
     */
    inline void clear_BUSRCON1_BFSSS() volatile
    {
        BUSRCON1 &= ~(1u << 4u);
    }

    /**
     * Toggle BUSRCON1's BFSSS bit.
     *
     * Read Single Stage Synchronization:
     */
    inline void toggle_BUSRCON1_BFSSS() volatile
    {
        BUSRCON1 ^= 1u << 4u;
    }

    /**
     * Get BUSRCON1's FBBMSEL bit.
     */
    inline EBU_BUSRCON0_FBBMSEL get_BUSRCON1_FBBMSEL() volatile
    {
        return EBU_BUSRCON0_FBBMSEL(BUSRCON1 & (1u << 3u));
    }

    /**
     * Set BUSRCON1's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void set_BUSRCON1_FBBMSEL() volatile
    {
        BUSRCON1 |= 1u << 3u;
    }

    /**
     * Clear BUSRCON1's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void clear_BUSRCON1_FBBMSEL() volatile
    {
        BUSRCON1 &= ~(1u << 3u);
    }

    /**
     * Toggle BUSRCON1's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void toggle_BUSRCON1_FBBMSEL() volatile
    {
        BUSRCON1 ^= 1u << 3u;
    }

    /**
     * Get BUSRCON1's FETBLEN field.
     */
    inline EBU_BUSRCON0_FETBLEN get_BUSRCON1_FETBLEN() volatile
    {
        return EBU_BUSRCON0_FETBLEN((BUSRCON1 >> 0u) & 0b111u);
    }

    /**
     * Set BUSRCON1's FETBLEN field.
     *
     * Burst Length for Synchronous Burst
     */
    inline void set_BUSRCON1_FETBLEN(EBU_BUSRCON0_FETBLEN value) volatile
    {
        uint32_t curr = BUSRCON1;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        BUSRCON1 = curr;
    }

    /**
     * Get all of BUSRCON1's bit fields.
     */
    inline void get_BUSRCON1(
        uint8_t &AGEN, EBU_BUSRCON0_AAP &AAP, uint8_t &WAIT, uint8_t &PORTW,
        EBU_BUSRCON0_BCGEN &BCGEN, EBU_BUSRCON0_WAITINV &WAITINV,
        EBU_BUSRCON0_DBA &DBA, EBU_BUSRCON0_EBSE &EBSE,
        EBU_BUSRCON0_EBSE &ECSE, bool &NAA, EBU_BUSRCON0_BFCMSEL &BFCMSEL,
        EBU_BUSRCON0_FDBKEN &FDBKEN, EBU_BUSRCON0_BFSSS &BFSSS,
        EBU_BUSRCON0_FBBMSEL &FBBMSEL, EBU_BUSRCON0_FETBLEN &FETBLEN) volatile
    {
        uint32_t curr = BUSRCON1;

        AGEN = (curr >> 28u) & 0b1111u;
        AAP = EBU_BUSRCON0_AAP(curr & (1u << 26u));
        WAIT = (curr >> 24u) & 0b11u;
        PORTW = (curr >> 22u) & 0b11u;
        BCGEN = EBU_BUSRCON0_BCGEN((curr >> 20u) & 0b11u);
        WAITINV = EBU_BUSRCON0_WAITINV(curr & (1u << 19u));
        DBA = EBU_BUSRCON0_DBA(curr & (1u << 18u));
        EBSE = EBU_BUSRCON0_EBSE(curr & (1u << 17u));
        ECSE = EBU_BUSRCON0_EBSE(curr & (1u << 16u));
        NAA = curr & (1u << 7u);
        BFCMSEL = EBU_BUSRCON0_BFCMSEL(curr & (1u << 6u));
        FDBKEN = EBU_BUSRCON0_FDBKEN(curr & (1u << 5u));
        BFSSS = EBU_BUSRCON0_BFSSS(curr & (1u << 4u));
        FBBMSEL = EBU_BUSRCON0_FBBMSEL(curr & (1u << 3u));
        FETBLEN = EBU_BUSRCON0_FETBLEN((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of BUSRCON1's bit fields.
     *
     * (read-write) EBU Bus Configuration Register
     */
    inline void set_BUSRCON1(
        uint8_t AGEN, EBU_BUSRCON0_AAP AAP, uint8_t WAIT, uint8_t PORTW,
        EBU_BUSRCON0_BCGEN BCGEN, EBU_BUSRCON0_WAITINV WAITINV,
        EBU_BUSRCON0_DBA DBA, EBU_BUSRCON0_EBSE EBSE, EBU_BUSRCON0_EBSE ECSE,
        bool NAA, EBU_BUSRCON0_BFCMSEL BFCMSEL, EBU_BUSRCON0_FDBKEN FDBKEN,
        EBU_BUSRCON0_BFSSS BFSSS, EBU_BUSRCON0_FBBMSEL FBBMSEL,
        EBU_BUSRCON0_FETBLEN FETBLEN) volatile
    {
        uint32_t curr = BUSRCON1;

        curr &= ~(0b1111u << 28u);
        curr |= (AGEN & 0b1111u) << 28u;
        curr &= ~(0b1u << 26u);
        curr |= (std::to_underlying(AAP) & 0b1u) << 26u;
        curr &= ~(0b11u << 24u);
        curr |= (WAIT & 0b11u) << 24u;
        curr &= ~(0b11u << 22u);
        curr |= (PORTW & 0b11u) << 22u;
        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(BCGEN) & 0b11u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (std::to_underlying(WAITINV) & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (std::to_underlying(DBA) & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(EBSE) & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (std::to_underlying(ECSE) & 0b1u) << 16u;
        curr &= ~(0b1u << 7u);
        curr |= (NAA & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (std::to_underlying(BFCMSEL) & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (std::to_underlying(FDBKEN) & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (std::to_underlying(BFSSS) & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(FBBMSEL) & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(FETBLEN) & 0b111u) << 0u;

        BUSRCON1 = curr;
    }

    /**
     * Get BUSRAP1's ADDRC field.
     */
    inline EBU_BUSRAP0_ADDRC get_BUSRAP1_ADDRC() volatile
    {
        return EBU_BUSRAP0_ADDRC((BUSRAP1 >> 28u) & 0b1111u);
    }

    /**
     * Set BUSRAP1's ADDRC field.
     *
     * Address Cycles
     */
    inline void set_BUSRAP1_ADDRC(EBU_BUSRAP0_ADDRC value) volatile
    {
        uint32_t curr = BUSRAP1;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(value) & 0b1111u) << 28u;

        BUSRAP1 = curr;
    }

    /**
     * Get BUSRAP1's AHOLDC field.
     */
    inline EBU_BUSRAP0_AHOLDC get_BUSRAP1_AHOLDC() volatile
    {
        return EBU_BUSRAP0_AHOLDC((BUSRAP1 >> 24u) & 0b1111u);
    }

    /**
     * Set BUSRAP1's AHOLDC field.
     *
     * Address Hold Cycles
     */
    inline void set_BUSRAP1_AHOLDC(EBU_BUSRAP0_AHOLDC value) volatile
    {
        uint32_t curr = BUSRAP1;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        BUSRAP1 = curr;
    }

    /**
     * Get BUSRAP1's CMDDELAY field.
     */
    inline EBU_BUSRAP0_AHOLDC get_BUSRAP1_CMDDELAY() volatile
    {
        return EBU_BUSRAP0_AHOLDC((BUSRAP1 >> 20u) & 0b1111u);
    }

    /**
     * Set BUSRAP1's CMDDELAY field.
     *
     * Command Delay Cycles
     */
    inline void set_BUSRAP1_CMDDELAY(EBU_BUSRAP0_AHOLDC value) volatile
    {
        uint32_t curr = BUSRAP1;

        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(value) & 0b1111u) << 20u;

        BUSRAP1 = curr;
    }

    /**
     * Get BUSRAP1's EXTDATA field.
     */
    inline EBU_BUSRAP0_EXTDATA get_BUSRAP1_EXTDATA() volatile
    {
        return EBU_BUSRAP0_EXTDATA((BUSRAP1 >> 18u) & 0b11u);
    }

    /**
     * Set BUSRAP1's EXTDATA field.
     *
     * Extended data
     */
    inline void set_BUSRAP1_EXTDATA(EBU_BUSRAP0_EXTDATA value) volatile
    {
        uint32_t curr = BUSRAP1;

        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(value) & 0b11u) << 18u;

        BUSRAP1 = curr;
    }

    /**
     * Get BUSRAP1's EXTCLOCK field.
     */
    inline EBU_BUSRAP0_EXTCLOCK get_BUSRAP1_EXTCLOCK() volatile
    {
        return EBU_BUSRAP0_EXTCLOCK((BUSRAP1 >> 16u) & 0b11u);
    }

    /**
     * Set BUSRAP1's EXTCLOCK field.
     *
     * Frequency of external clock at pin BFCLKO
     */
    inline void set_BUSRAP1_EXTCLOCK(EBU_BUSRAP0_EXTCLOCK value) volatile
    {
        uint32_t curr = BUSRAP1;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        BUSRAP1 = curr;
    }

    /**
     * Get BUSRAP1's DATAC field.
     */
    inline uint8_t get_BUSRAP1_DATAC() volatile
    {
        return (BUSRAP1 >> 12u) & 0b1111u;
    }

    /**
     * Set BUSRAP1's DATAC field.
     *
     * Data Hold Cycles for Read Accesses
     */
    inline void set_BUSRAP1_DATAC(uint8_t value) volatile
    {
        uint32_t curr = BUSRAP1;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        BUSRAP1 = curr;
    }

    /**
     * Get BUSRAP1's WAITRDC field.
     */
    inline EBU_BUSRAP0_WAITRDC get_BUSRAP1_WAITRDC() volatile
    {
        return EBU_BUSRAP0_WAITRDC((BUSRAP1 >> 7u) & 0b11111u);
    }

    /**
     * Set BUSRAP1's WAITRDC field.
     *
     * Programmed Wait States for read accesses
     */
    inline void set_BUSRAP1_WAITRDC(EBU_BUSRAP0_WAITRDC value) volatile
    {
        uint32_t curr = BUSRAP1;

        curr &= ~(0b11111u << 7u);
        curr |= (std::to_underlying(value) & 0b11111u) << 7u;

        BUSRAP1 = curr;
    }

    /**
     * Get BUSRAP1's RDRECOVC field.
     */
    inline EBU_BUSRAP0_RDRECOVC get_BUSRAP1_RDRECOVC() volatile
    {
        return EBU_BUSRAP0_RDRECOVC((BUSRAP1 >> 4u) & 0b111u);
    }

    /**
     * Set BUSRAP1's RDRECOVC field.
     *
     * Recovery Cycles after Read Accesses
     */
    inline void set_BUSRAP1_RDRECOVC(EBU_BUSRAP0_RDRECOVC value) volatile
    {
        uint32_t curr = BUSRAP1;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        BUSRAP1 = curr;
    }

    /**
     * Get BUSRAP1's RDDTACS field.
     */
    inline EBU_BUSRAP0_RDDTACS get_BUSRAP1_RDDTACS() volatile
    {
        return EBU_BUSRAP0_RDDTACS((BUSRAP1 >> 0u) & 0b1111u);
    }

    /**
     * Set BUSRAP1's RDDTACS field.
     *
     * Recovery Cycles between Different Regions
     */
    inline void set_BUSRAP1_RDDTACS(EBU_BUSRAP0_RDDTACS value) volatile
    {
        uint32_t curr = BUSRAP1;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        BUSRAP1 = curr;
    }

    /**
     * Get all of BUSRAP1's bit fields.
     */
    inline void get_BUSRAP1(EBU_BUSRAP0_ADDRC &ADDRC,
                            EBU_BUSRAP0_AHOLDC &AHOLDC,
                            EBU_BUSRAP0_AHOLDC &CMDDELAY,
                            EBU_BUSRAP0_EXTDATA &EXTDATA,
                            EBU_BUSRAP0_EXTCLOCK &EXTCLOCK, uint8_t &DATAC,
                            EBU_BUSRAP0_WAITRDC &WAITRDC,
                            EBU_BUSRAP0_RDRECOVC &RDRECOVC,
                            EBU_BUSRAP0_RDDTACS &RDDTACS) volatile
    {
        uint32_t curr = BUSRAP1;

        ADDRC = EBU_BUSRAP0_ADDRC((curr >> 28u) & 0b1111u);
        AHOLDC = EBU_BUSRAP0_AHOLDC((curr >> 24u) & 0b1111u);
        CMDDELAY = EBU_BUSRAP0_AHOLDC((curr >> 20u) & 0b1111u);
        EXTDATA = EBU_BUSRAP0_EXTDATA((curr >> 18u) & 0b11u);
        EXTCLOCK = EBU_BUSRAP0_EXTCLOCK((curr >> 16u) & 0b11u);
        DATAC = (curr >> 12u) & 0b1111u;
        WAITRDC = EBU_BUSRAP0_WAITRDC((curr >> 7u) & 0b11111u);
        RDRECOVC = EBU_BUSRAP0_RDRECOVC((curr >> 4u) & 0b111u);
        RDDTACS = EBU_BUSRAP0_RDDTACS((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of BUSRAP1's bit fields.
     *
     * (read-write) EBU Bus Read Access Parameter Register
     */
    inline void set_BUSRAP1(EBU_BUSRAP0_ADDRC ADDRC, EBU_BUSRAP0_AHOLDC AHOLDC,
                            EBU_BUSRAP0_AHOLDC CMDDELAY,
                            EBU_BUSRAP0_EXTDATA EXTDATA,
                            EBU_BUSRAP0_EXTCLOCK EXTCLOCK, uint8_t DATAC,
                            EBU_BUSRAP0_WAITRDC WAITRDC,
                            EBU_BUSRAP0_RDRECOVC RDRECOVC,
                            EBU_BUSRAP0_RDDTACS RDDTACS) volatile
    {
        uint32_t curr = BUSRAP1;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(ADDRC) & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(AHOLDC) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(CMDDELAY) & 0b1111u) << 20u;
        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(EXTDATA) & 0b11u) << 18u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(EXTCLOCK) & 0b11u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (DATAC & 0b1111u) << 12u;
        curr &= ~(0b11111u << 7u);
        curr |= (std::to_underlying(WAITRDC) & 0b11111u) << 7u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(RDRECOVC) & 0b111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(RDDTACS) & 0b1111u) << 0u;

        BUSRAP1 = curr;
    }

    /**
     * Get BUSWCON1's AGEN field.
     */
    inline uint8_t get_BUSWCON1_AGEN() volatile
    {
        return (BUSWCON1 >> 28u) & 0b1111u;
    }

    /**
     * Set BUSWCON1's AGEN field.
     *
     * Device Type for Region
     */
    inline void set_BUSWCON1_AGEN(uint8_t value) volatile
    {
        uint32_t curr = BUSWCON1;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        BUSWCON1 = curr;
    }

    /**
     * Get BUSWCON1's LOCKCS bit.
     */
    inline EBU_BUSWCON0_LOCKCS get_BUSWCON1_LOCKCS() volatile
    {
        return EBU_BUSWCON0_LOCKCS(BUSWCON1 & (1u << 27u));
    }

    /**
     * Set BUSWCON1's LOCKCS bit.
     *
     * Lock Chip Select
     */
    inline void set_BUSWCON1_LOCKCS() volatile
    {
        BUSWCON1 |= 1u << 27u;
    }

    /**
     * Clear BUSWCON1's LOCKCS bit.
     *
     * Lock Chip Select
     */
    inline void clear_BUSWCON1_LOCKCS() volatile
    {
        BUSWCON1 &= ~(1u << 27u);
    }

    /**
     * Toggle BUSWCON1's LOCKCS bit.
     *
     * Lock Chip Select
     */
    inline void toggle_BUSWCON1_LOCKCS() volatile
    {
        BUSWCON1 ^= 1u << 27u;
    }

    /**
     * Get BUSWCON1's AAP bit.
     */
    inline EBU_BUSRCON0_AAP get_BUSWCON1_AAP() volatile
    {
        return EBU_BUSRCON0_AAP(BUSWCON1 & (1u << 26u));
    }

    /**
     * Set BUSWCON1's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void set_BUSWCON1_AAP() volatile
    {
        BUSWCON1 |= 1u << 26u;
    }

    /**
     * Clear BUSWCON1's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void clear_BUSWCON1_AAP() volatile
    {
        BUSWCON1 &= ~(1u << 26u);
    }

    /**
     * Toggle BUSWCON1's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void toggle_BUSWCON1_AAP() volatile
    {
        BUSWCON1 ^= 1u << 26u;
    }

    /**
     * Get BUSWCON1's WAIT field.
     */
    inline uint8_t get_BUSWCON1_WAIT() volatile
    {
        return (BUSWCON1 >> 24u) & 0b11u;
    }

    /**
     * Set BUSWCON1's WAIT field.
     *
     * External Wait Control: 0=OFF (default after reset)., 1=Asynchronous
     * input at WAIT., 2=Synchronous input at WAIT., 3=reserved., 0=OFF
     * (default after reset)., 1=Wait for page load (Early WAIT)., 2=Wait for
     * page load (WAIT with data)., 3=Abort and retry access.,
     */
    inline void set_BUSWCON1_WAIT(uint8_t value) volatile
    {
        uint32_t curr = BUSWCON1;

        curr &= ~(0b11u << 24u);
        curr |= (value & 0b11u) << 24u;

        BUSWCON1 = curr;
    }

    /**
     * Get BUSWCON1's PORTW field.
     */
    inline uint8_t get_BUSWCON1_PORTW() volatile
    {
        return (BUSWCON1 >> 22u) & 0b11u;
    }

    /**
     * Get BUSWCON1's BCGEN field.
     */
    inline EBU_BUSRCON0_BCGEN get_BUSWCON1_BCGEN() volatile
    {
        return EBU_BUSRCON0_BCGEN((BUSWCON1 >> 20u) & 0b11u);
    }

    /**
     * Set BUSWCON1's BCGEN field.
     *
     * Byte Control Signal Control
     */
    inline void set_BUSWCON1_BCGEN(EBU_BUSRCON0_BCGEN value) volatile
    {
        uint32_t curr = BUSWCON1;

        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(value) & 0b11u) << 20u;

        BUSWCON1 = curr;
    }

    /**
     * Get BUSWCON1's WAITINV bit.
     */
    inline EBU_BUSRCON0_WAITINV get_BUSWCON1_WAITINV() volatile
    {
        return EBU_BUSRCON0_WAITINV(BUSWCON1 & (1u << 19u));
    }

    /**
     * Set BUSWCON1's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void set_BUSWCON1_WAITINV() volatile
    {
        BUSWCON1 |= 1u << 19u;
    }

    /**
     * Clear BUSWCON1's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void clear_BUSWCON1_WAITINV() volatile
    {
        BUSWCON1 &= ~(1u << 19u);
    }

    /**
     * Toggle BUSWCON1's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void toggle_BUSWCON1_WAITINV() volatile
    {
        BUSWCON1 ^= 1u << 19u;
    }

    /**
     * Get BUSWCON1's EBSE bit.
     */
    inline EBU_BUSRCON0_EBSE get_BUSWCON1_EBSE() volatile
    {
        return EBU_BUSRCON0_EBSE(BUSWCON1 & (1u << 17u));
    }

    /**
     * Set BUSWCON1's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void set_BUSWCON1_EBSE() volatile
    {
        BUSWCON1 |= 1u << 17u;
    }

    /**
     * Clear BUSWCON1's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void clear_BUSWCON1_EBSE() volatile
    {
        BUSWCON1 &= ~(1u << 17u);
    }

    /**
     * Toggle BUSWCON1's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void toggle_BUSWCON1_EBSE() volatile
    {
        BUSWCON1 ^= 1u << 17u;
    }

    /**
     * Get BUSWCON1's ECSE bit.
     */
    inline EBU_BUSRCON0_EBSE get_BUSWCON1_ECSE() volatile
    {
        return EBU_BUSRCON0_EBSE(BUSWCON1 & (1u << 16u));
    }

    /**
     * Set BUSWCON1's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void set_BUSWCON1_ECSE() volatile
    {
        BUSWCON1 |= 1u << 16u;
    }

    /**
     * Clear BUSWCON1's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void clear_BUSWCON1_ECSE() volatile
    {
        BUSWCON1 &= ~(1u << 16u);
    }

    /**
     * Toggle BUSWCON1's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void toggle_BUSWCON1_ECSE() volatile
    {
        BUSWCON1 ^= 1u << 16u;
    }

    /**
     * Get BUSWCON1's NAA bit.
     */
    inline bool get_BUSWCON1_NAA() volatile
    {
        return BUSWCON1 & (1u << 7u);
    }

    /**
     * Get BUSWCON1's FBBMSEL bit.
     */
    inline EBU_BUSRCON0_FBBMSEL get_BUSWCON1_FBBMSEL() volatile
    {
        return EBU_BUSRCON0_FBBMSEL(BUSWCON1 & (1u << 3u));
    }

    /**
     * Set BUSWCON1's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void set_BUSWCON1_FBBMSEL() volatile
    {
        BUSWCON1 |= 1u << 3u;
    }

    /**
     * Clear BUSWCON1's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void clear_BUSWCON1_FBBMSEL() volatile
    {
        BUSWCON1 &= ~(1u << 3u);
    }

    /**
     * Toggle BUSWCON1's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void toggle_BUSWCON1_FBBMSEL() volatile
    {
        BUSWCON1 ^= 1u << 3u;
    }

    /**
     * Get BUSWCON1's FETBLEN field.
     */
    inline EBU_BUSRCON0_FETBLEN get_BUSWCON1_FETBLEN() volatile
    {
        return EBU_BUSRCON0_FETBLEN((BUSWCON1 >> 0u) & 0b111u);
    }

    /**
     * Set BUSWCON1's FETBLEN field.
     *
     * Burst Length for Synchronous Burst
     */
    inline void set_BUSWCON1_FETBLEN(EBU_BUSRCON0_FETBLEN value) volatile
    {
        uint32_t curr = BUSWCON1;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        BUSWCON1 = curr;
    }

    /**
     * Get all of BUSWCON1's bit fields.
     */
    inline void get_BUSWCON1(uint8_t &AGEN, EBU_BUSWCON0_LOCKCS &LOCKCS,
                             EBU_BUSRCON0_AAP &AAP, uint8_t &WAIT,
                             uint8_t &PORTW, EBU_BUSRCON0_BCGEN &BCGEN,
                             EBU_BUSRCON0_WAITINV &WAITINV,
                             EBU_BUSRCON0_EBSE &EBSE, EBU_BUSRCON0_EBSE &ECSE,
                             bool &NAA, EBU_BUSRCON0_FBBMSEL &FBBMSEL,
                             EBU_BUSRCON0_FETBLEN &FETBLEN) volatile
    {
        uint32_t curr = BUSWCON1;

        AGEN = (curr >> 28u) & 0b1111u;
        LOCKCS = EBU_BUSWCON0_LOCKCS(curr & (1u << 27u));
        AAP = EBU_BUSRCON0_AAP(curr & (1u << 26u));
        WAIT = (curr >> 24u) & 0b11u;
        PORTW = (curr >> 22u) & 0b11u;
        BCGEN = EBU_BUSRCON0_BCGEN((curr >> 20u) & 0b11u);
        WAITINV = EBU_BUSRCON0_WAITINV(curr & (1u << 19u));
        EBSE = EBU_BUSRCON0_EBSE(curr & (1u << 17u));
        ECSE = EBU_BUSRCON0_EBSE(curr & (1u << 16u));
        NAA = curr & (1u << 7u);
        FBBMSEL = EBU_BUSRCON0_FBBMSEL(curr & (1u << 3u));
        FETBLEN = EBU_BUSRCON0_FETBLEN((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of BUSWCON1's bit fields.
     *
     * (read-write) EBU Bus Write Configuration Register
     */
    inline void set_BUSWCON1(uint8_t AGEN, EBU_BUSWCON0_LOCKCS LOCKCS,
                             EBU_BUSRCON0_AAP AAP, uint8_t WAIT,
                             EBU_BUSRCON0_BCGEN BCGEN,
                             EBU_BUSRCON0_WAITINV WAITINV,
                             EBU_BUSRCON0_EBSE EBSE, EBU_BUSRCON0_EBSE ECSE,
                             EBU_BUSRCON0_FBBMSEL FBBMSEL,
                             EBU_BUSRCON0_FETBLEN FETBLEN) volatile
    {
        uint32_t curr = BUSWCON1;

        curr &= ~(0b1111u << 28u);
        curr |= (AGEN & 0b1111u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (std::to_underlying(LOCKCS) & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (std::to_underlying(AAP) & 0b1u) << 26u;
        curr &= ~(0b11u << 24u);
        curr |= (WAIT & 0b11u) << 24u;
        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(BCGEN) & 0b11u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (std::to_underlying(WAITINV) & 0b1u) << 19u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(EBSE) & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (std::to_underlying(ECSE) & 0b1u) << 16u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(FBBMSEL) & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(FETBLEN) & 0b111u) << 0u;

        BUSWCON1 = curr;
    }

    /**
     * Get BUSWAP1's ADDRC field.
     */
    inline EBU_BUSRAP0_ADDRC get_BUSWAP1_ADDRC() volatile
    {
        return EBU_BUSRAP0_ADDRC((BUSWAP1 >> 28u) & 0b1111u);
    }

    /**
     * Set BUSWAP1's ADDRC field.
     *
     * Address Cycles
     */
    inline void set_BUSWAP1_ADDRC(EBU_BUSRAP0_ADDRC value) volatile
    {
        uint32_t curr = BUSWAP1;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(value) & 0b1111u) << 28u;

        BUSWAP1 = curr;
    }

    /**
     * Get BUSWAP1's AHOLDC field.
     */
    inline EBU_BUSRAP0_AHOLDC get_BUSWAP1_AHOLDC() volatile
    {
        return EBU_BUSRAP0_AHOLDC((BUSWAP1 >> 24u) & 0b1111u);
    }

    /**
     * Set BUSWAP1's AHOLDC field.
     *
     * Address Hold Cycles
     */
    inline void set_BUSWAP1_AHOLDC(EBU_BUSRAP0_AHOLDC value) volatile
    {
        uint32_t curr = BUSWAP1;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        BUSWAP1 = curr;
    }

    /**
     * Get BUSWAP1's CMDDELAY field.
     */
    inline EBU_BUSRAP0_AHOLDC get_BUSWAP1_CMDDELAY() volatile
    {
        return EBU_BUSRAP0_AHOLDC((BUSWAP1 >> 20u) & 0b1111u);
    }

    /**
     * Set BUSWAP1's CMDDELAY field.
     *
     * Command Delay Cycles
     */
    inline void set_BUSWAP1_CMDDELAY(EBU_BUSRAP0_AHOLDC value) volatile
    {
        uint32_t curr = BUSWAP1;

        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(value) & 0b1111u) << 20u;

        BUSWAP1 = curr;
    }

    /**
     * Get BUSWAP1's EXTDATA field.
     */
    inline EBU_BUSRAP0_EXTDATA get_BUSWAP1_EXTDATA() volatile
    {
        return EBU_BUSRAP0_EXTDATA((BUSWAP1 >> 18u) & 0b11u);
    }

    /**
     * Set BUSWAP1's EXTDATA field.
     *
     * Extended data
     */
    inline void set_BUSWAP1_EXTDATA(EBU_BUSRAP0_EXTDATA value) volatile
    {
        uint32_t curr = BUSWAP1;

        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(value) & 0b11u) << 18u;

        BUSWAP1 = curr;
    }

    /**
     * Get BUSWAP1's EXTCLOCK field.
     */
    inline EBU_BUSRAP0_EXTCLOCK get_BUSWAP1_EXTCLOCK() volatile
    {
        return EBU_BUSRAP0_EXTCLOCK((BUSWAP1 >> 16u) & 0b11u);
    }

    /**
     * Set BUSWAP1's EXTCLOCK field.
     *
     * Frequency of external clock at pin BFCLKO
     */
    inline void set_BUSWAP1_EXTCLOCK(EBU_BUSRAP0_EXTCLOCK value) volatile
    {
        uint32_t curr = BUSWAP1;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        BUSWAP1 = curr;
    }

    /**
     * Get BUSWAP1's DATAC field.
     */
    inline EBU_BUSRAP0_RDDTACS get_BUSWAP1_DATAC() volatile
    {
        return EBU_BUSRAP0_RDDTACS((BUSWAP1 >> 12u) & 0b1111u);
    }

    /**
     * Set BUSWAP1's DATAC field.
     *
     * Data Hold Cycles for Write Accesses
     */
    inline void set_BUSWAP1_DATAC(EBU_BUSRAP0_RDDTACS value) volatile
    {
        uint32_t curr = BUSWAP1;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(value) & 0b1111u) << 12u;

        BUSWAP1 = curr;
    }

    /**
     * Get BUSWAP1's WAITWRC field.
     */
    inline EBU_BUSRAP0_WAITRDC get_BUSWAP1_WAITWRC() volatile
    {
        return EBU_BUSRAP0_WAITRDC((BUSWAP1 >> 7u) & 0b11111u);
    }

    /**
     * Set BUSWAP1's WAITWRC field.
     *
     * Programmed Wait States for write accesses
     */
    inline void set_BUSWAP1_WAITWRC(EBU_BUSRAP0_WAITRDC value) volatile
    {
        uint32_t curr = BUSWAP1;

        curr &= ~(0b11111u << 7u);
        curr |= (std::to_underlying(value) & 0b11111u) << 7u;

        BUSWAP1 = curr;
    }

    /**
     * Get BUSWAP1's WRRECOVC field.
     */
    inline EBU_BUSRAP0_RDRECOVC get_BUSWAP1_WRRECOVC() volatile
    {
        return EBU_BUSRAP0_RDRECOVC((BUSWAP1 >> 4u) & 0b111u);
    }

    /**
     * Set BUSWAP1's WRRECOVC field.
     *
     * Recovery Cycles after Write Accesses
     */
    inline void set_BUSWAP1_WRRECOVC(EBU_BUSRAP0_RDRECOVC value) volatile
    {
        uint32_t curr = BUSWAP1;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        BUSWAP1 = curr;
    }

    /**
     * Get BUSWAP1's WRDTACS field.
     */
    inline EBU_BUSRAP0_RDDTACS get_BUSWAP1_WRDTACS() volatile
    {
        return EBU_BUSRAP0_RDDTACS((BUSWAP1 >> 0u) & 0b1111u);
    }

    /**
     * Set BUSWAP1's WRDTACS field.
     *
     * Recovery Cycles between Different Regions
     */
    inline void set_BUSWAP1_WRDTACS(EBU_BUSRAP0_RDDTACS value) volatile
    {
        uint32_t curr = BUSWAP1;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        BUSWAP1 = curr;
    }

    /**
     * Get all of BUSWAP1's bit fields.
     */
    inline void get_BUSWAP1(
        EBU_BUSRAP0_ADDRC &ADDRC, EBU_BUSRAP0_AHOLDC &AHOLDC,
        EBU_BUSRAP0_AHOLDC &CMDDELAY, EBU_BUSRAP0_EXTDATA &EXTDATA,
        EBU_BUSRAP0_EXTCLOCK &EXTCLOCK, EBU_BUSRAP0_RDDTACS &DATAC,
        EBU_BUSRAP0_WAITRDC &WAITWRC, EBU_BUSRAP0_RDRECOVC &WRRECOVC,
        EBU_BUSRAP0_RDDTACS &WRDTACS) volatile
    {
        uint32_t curr = BUSWAP1;

        ADDRC = EBU_BUSRAP0_ADDRC((curr >> 28u) & 0b1111u);
        AHOLDC = EBU_BUSRAP0_AHOLDC((curr >> 24u) & 0b1111u);
        CMDDELAY = EBU_BUSRAP0_AHOLDC((curr >> 20u) & 0b1111u);
        EXTDATA = EBU_BUSRAP0_EXTDATA((curr >> 18u) & 0b11u);
        EXTCLOCK = EBU_BUSRAP0_EXTCLOCK((curr >> 16u) & 0b11u);
        DATAC = EBU_BUSRAP0_RDDTACS((curr >> 12u) & 0b1111u);
        WAITWRC = EBU_BUSRAP0_WAITRDC((curr >> 7u) & 0b11111u);
        WRRECOVC = EBU_BUSRAP0_RDRECOVC((curr >> 4u) & 0b111u);
        WRDTACS = EBU_BUSRAP0_RDDTACS((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of BUSWAP1's bit fields.
     *
     * (read-write) EBU Bus Write Access Parameter Register
     */
    inline void set_BUSWAP1(EBU_BUSRAP0_ADDRC ADDRC, EBU_BUSRAP0_AHOLDC AHOLDC,
                            EBU_BUSRAP0_AHOLDC CMDDELAY,
                            EBU_BUSRAP0_EXTDATA EXTDATA,
                            EBU_BUSRAP0_EXTCLOCK EXTCLOCK,
                            EBU_BUSRAP0_RDDTACS DATAC,
                            EBU_BUSRAP0_WAITRDC WAITWRC,
                            EBU_BUSRAP0_RDRECOVC WRRECOVC,
                            EBU_BUSRAP0_RDDTACS WRDTACS) volatile
    {
        uint32_t curr = BUSWAP1;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(ADDRC) & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(AHOLDC) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(CMDDELAY) & 0b1111u) << 20u;
        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(EXTDATA) & 0b11u) << 18u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(EXTCLOCK) & 0b11u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(DATAC) & 0b1111u) << 12u;
        curr &= ~(0b11111u << 7u);
        curr |= (std::to_underlying(WAITWRC) & 0b11111u) << 7u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(WRRECOVC) & 0b111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(WRDTACS) & 0b1111u) << 0u;

        BUSWAP1 = curr;
    }

    /**
     * Get BUSRCON2's AGEN field.
     */
    inline uint8_t get_BUSRCON2_AGEN() volatile
    {
        return (BUSRCON2 >> 28u) & 0b1111u;
    }

    /**
     * Set BUSRCON2's AGEN field.
     *
     * Device Type for Region
     */
    inline void set_BUSRCON2_AGEN(uint8_t value) volatile
    {
        uint32_t curr = BUSRCON2;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        BUSRCON2 = curr;
    }

    /**
     * Get BUSRCON2's AAP bit.
     */
    inline EBU_BUSRCON0_AAP get_BUSRCON2_AAP() volatile
    {
        return EBU_BUSRCON0_AAP(BUSRCON2 & (1u << 26u));
    }

    /**
     * Set BUSRCON2's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void set_BUSRCON2_AAP() volatile
    {
        BUSRCON2 |= 1u << 26u;
    }

    /**
     * Clear BUSRCON2's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void clear_BUSRCON2_AAP() volatile
    {
        BUSRCON2 &= ~(1u << 26u);
    }

    /**
     * Toggle BUSRCON2's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void toggle_BUSRCON2_AAP() volatile
    {
        BUSRCON2 ^= 1u << 26u;
    }

    /**
     * Get BUSRCON2's WAIT field.
     */
    inline uint8_t get_BUSRCON2_WAIT() volatile
    {
        return (BUSRCON2 >> 24u) & 0b11u;
    }

    /**
     * Set BUSRCON2's WAIT field.
     *
     * External Wait Control: 0=OFF (default after reset)., 1=Asynchronous
     * input at WAIT., 2=Synchronous input at WAIT., 3=reserved., 0=OFF
     * (default after reset)., 1=Wait for page load (Early WAIT)., 2=Wait for
     * page load (WAIT with data)., 3=Abort and retry access.,
     */
    inline void set_BUSRCON2_WAIT(uint8_t value) volatile
    {
        uint32_t curr = BUSRCON2;

        curr &= ~(0b11u << 24u);
        curr |= (value & 0b11u) << 24u;

        BUSRCON2 = curr;
    }

    /**
     * Get BUSRCON2's PORTW field.
     */
    inline uint8_t get_BUSRCON2_PORTW() volatile
    {
        return (BUSRCON2 >> 22u) & 0b11u;
    }

    /**
     * Set BUSRCON2's PORTW field.
     *
     * Device Addressing Mode
     */
    inline void set_BUSRCON2_PORTW(uint8_t value) volatile
    {
        uint32_t curr = BUSRCON2;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        BUSRCON2 = curr;
    }

    /**
     * Get BUSRCON2's BCGEN field.
     */
    inline EBU_BUSRCON0_BCGEN get_BUSRCON2_BCGEN() volatile
    {
        return EBU_BUSRCON0_BCGEN((BUSRCON2 >> 20u) & 0b11u);
    }

    /**
     * Set BUSRCON2's BCGEN field.
     *
     * Byte Control Signal Control
     */
    inline void set_BUSRCON2_BCGEN(EBU_BUSRCON0_BCGEN value) volatile
    {
        uint32_t curr = BUSRCON2;

        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(value) & 0b11u) << 20u;

        BUSRCON2 = curr;
    }

    /**
     * Get BUSRCON2's WAITINV bit.
     */
    inline EBU_BUSRCON0_WAITINV get_BUSRCON2_WAITINV() volatile
    {
        return EBU_BUSRCON0_WAITINV(BUSRCON2 & (1u << 19u));
    }

    /**
     * Set BUSRCON2's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void set_BUSRCON2_WAITINV() volatile
    {
        BUSRCON2 |= 1u << 19u;
    }

    /**
     * Clear BUSRCON2's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void clear_BUSRCON2_WAITINV() volatile
    {
        BUSRCON2 &= ~(1u << 19u);
    }

    /**
     * Toggle BUSRCON2's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void toggle_BUSRCON2_WAITINV() volatile
    {
        BUSRCON2 ^= 1u << 19u;
    }

    /**
     * Get BUSRCON2's DBA bit.
     */
    inline EBU_BUSRCON0_DBA get_BUSRCON2_DBA() volatile
    {
        return EBU_BUSRCON0_DBA(BUSRCON2 & (1u << 18u));
    }

    /**
     * Set BUSRCON2's DBA bit.
     *
     * Disable Burst Address Wrapping
     */
    inline void set_BUSRCON2_DBA() volatile
    {
        BUSRCON2 |= 1u << 18u;
    }

    /**
     * Clear BUSRCON2's DBA bit.
     *
     * Disable Burst Address Wrapping
     */
    inline void clear_BUSRCON2_DBA() volatile
    {
        BUSRCON2 &= ~(1u << 18u);
    }

    /**
     * Toggle BUSRCON2's DBA bit.
     *
     * Disable Burst Address Wrapping
     */
    inline void toggle_BUSRCON2_DBA() volatile
    {
        BUSRCON2 ^= 1u << 18u;
    }

    /**
     * Get BUSRCON2's EBSE bit.
     */
    inline EBU_BUSRCON0_EBSE get_BUSRCON2_EBSE() volatile
    {
        return EBU_BUSRCON0_EBSE(BUSRCON2 & (1u << 17u));
    }

    /**
     * Set BUSRCON2's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void set_BUSRCON2_EBSE() volatile
    {
        BUSRCON2 |= 1u << 17u;
    }

    /**
     * Clear BUSRCON2's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void clear_BUSRCON2_EBSE() volatile
    {
        BUSRCON2 &= ~(1u << 17u);
    }

    /**
     * Toggle BUSRCON2's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void toggle_BUSRCON2_EBSE() volatile
    {
        BUSRCON2 ^= 1u << 17u;
    }

    /**
     * Get BUSRCON2's ECSE bit.
     */
    inline EBU_BUSRCON0_EBSE get_BUSRCON2_ECSE() volatile
    {
        return EBU_BUSRCON0_EBSE(BUSRCON2 & (1u << 16u));
    }

    /**
     * Set BUSRCON2's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void set_BUSRCON2_ECSE() volatile
    {
        BUSRCON2 |= 1u << 16u;
    }

    /**
     * Clear BUSRCON2's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void clear_BUSRCON2_ECSE() volatile
    {
        BUSRCON2 &= ~(1u << 16u);
    }

    /**
     * Toggle BUSRCON2's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void toggle_BUSRCON2_ECSE() volatile
    {
        BUSRCON2 ^= 1u << 16u;
    }

    /**
     * Get BUSRCON2's NAA bit.
     */
    inline bool get_BUSRCON2_NAA() volatile
    {
        return BUSRCON2 & (1u << 7u);
    }

    /**
     * Set BUSRCON2's NAA bit.
     *
     * Enable flash non-array access workaround
     */
    inline void set_BUSRCON2_NAA() volatile
    {
        BUSRCON2 |= 1u << 7u;
    }

    /**
     * Clear BUSRCON2's NAA bit.
     *
     * Enable flash non-array access workaround
     */
    inline void clear_BUSRCON2_NAA() volatile
    {
        BUSRCON2 &= ~(1u << 7u);
    }

    /**
     * Toggle BUSRCON2's NAA bit.
     *
     * Enable flash non-array access workaround
     */
    inline void toggle_BUSRCON2_NAA() volatile
    {
        BUSRCON2 ^= 1u << 7u;
    }

    /**
     * Get BUSRCON2's BFCMSEL bit.
     */
    inline EBU_BUSRCON0_BFCMSEL get_BUSRCON2_BFCMSEL() volatile
    {
        return EBU_BUSRCON0_BFCMSEL(BUSRCON2 & (1u << 6u));
    }

    /**
     * Set BUSRCON2's BFCMSEL bit.
     *
     * Burst Flash Clock Mode Select
     */
    inline void set_BUSRCON2_BFCMSEL() volatile
    {
        BUSRCON2 |= 1u << 6u;
    }

    /**
     * Clear BUSRCON2's BFCMSEL bit.
     *
     * Burst Flash Clock Mode Select
     */
    inline void clear_BUSRCON2_BFCMSEL() volatile
    {
        BUSRCON2 &= ~(1u << 6u);
    }

    /**
     * Toggle BUSRCON2's BFCMSEL bit.
     *
     * Burst Flash Clock Mode Select
     */
    inline void toggle_BUSRCON2_BFCMSEL() volatile
    {
        BUSRCON2 ^= 1u << 6u;
    }

    /**
     * Get BUSRCON2's FDBKEN bit.
     */
    inline EBU_BUSRCON0_FDBKEN get_BUSRCON2_FDBKEN() volatile
    {
        return EBU_BUSRCON0_FDBKEN(BUSRCON2 & (1u << 5u));
    }

    /**
     * Set BUSRCON2's FDBKEN bit.
     *
     * Burst FLASH Clock Feedback Enable
     */
    inline void set_BUSRCON2_FDBKEN() volatile
    {
        BUSRCON2 |= 1u << 5u;
    }

    /**
     * Clear BUSRCON2's FDBKEN bit.
     *
     * Burst FLASH Clock Feedback Enable
     */
    inline void clear_BUSRCON2_FDBKEN() volatile
    {
        BUSRCON2 &= ~(1u << 5u);
    }

    /**
     * Toggle BUSRCON2's FDBKEN bit.
     *
     * Burst FLASH Clock Feedback Enable
     */
    inline void toggle_BUSRCON2_FDBKEN() volatile
    {
        BUSRCON2 ^= 1u << 5u;
    }

    /**
     * Get BUSRCON2's BFSSS bit.
     */
    inline EBU_BUSRCON0_BFSSS get_BUSRCON2_BFSSS() volatile
    {
        return EBU_BUSRCON0_BFSSS(BUSRCON2 & (1u << 4u));
    }

    /**
     * Set BUSRCON2's BFSSS bit.
     *
     * Read Single Stage Synchronization:
     */
    inline void set_BUSRCON2_BFSSS() volatile
    {
        BUSRCON2 |= 1u << 4u;
    }

    /**
     * Clear BUSRCON2's BFSSS bit.
     *
     * Read Single Stage Synchronization:
     */
    inline void clear_BUSRCON2_BFSSS() volatile
    {
        BUSRCON2 &= ~(1u << 4u);
    }

    /**
     * Toggle BUSRCON2's BFSSS bit.
     *
     * Read Single Stage Synchronization:
     */
    inline void toggle_BUSRCON2_BFSSS() volatile
    {
        BUSRCON2 ^= 1u << 4u;
    }

    /**
     * Get BUSRCON2's FBBMSEL bit.
     */
    inline EBU_BUSRCON0_FBBMSEL get_BUSRCON2_FBBMSEL() volatile
    {
        return EBU_BUSRCON0_FBBMSEL(BUSRCON2 & (1u << 3u));
    }

    /**
     * Set BUSRCON2's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void set_BUSRCON2_FBBMSEL() volatile
    {
        BUSRCON2 |= 1u << 3u;
    }

    /**
     * Clear BUSRCON2's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void clear_BUSRCON2_FBBMSEL() volatile
    {
        BUSRCON2 &= ~(1u << 3u);
    }

    /**
     * Toggle BUSRCON2's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void toggle_BUSRCON2_FBBMSEL() volatile
    {
        BUSRCON2 ^= 1u << 3u;
    }

    /**
     * Get BUSRCON2's FETBLEN field.
     */
    inline EBU_BUSRCON0_FETBLEN get_BUSRCON2_FETBLEN() volatile
    {
        return EBU_BUSRCON0_FETBLEN((BUSRCON2 >> 0u) & 0b111u);
    }

    /**
     * Set BUSRCON2's FETBLEN field.
     *
     * Burst Length for Synchronous Burst
     */
    inline void set_BUSRCON2_FETBLEN(EBU_BUSRCON0_FETBLEN value) volatile
    {
        uint32_t curr = BUSRCON2;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        BUSRCON2 = curr;
    }

    /**
     * Get all of BUSRCON2's bit fields.
     */
    inline void get_BUSRCON2(
        uint8_t &AGEN, EBU_BUSRCON0_AAP &AAP, uint8_t &WAIT, uint8_t &PORTW,
        EBU_BUSRCON0_BCGEN &BCGEN, EBU_BUSRCON0_WAITINV &WAITINV,
        EBU_BUSRCON0_DBA &DBA, EBU_BUSRCON0_EBSE &EBSE,
        EBU_BUSRCON0_EBSE &ECSE, bool &NAA, EBU_BUSRCON0_BFCMSEL &BFCMSEL,
        EBU_BUSRCON0_FDBKEN &FDBKEN, EBU_BUSRCON0_BFSSS &BFSSS,
        EBU_BUSRCON0_FBBMSEL &FBBMSEL, EBU_BUSRCON0_FETBLEN &FETBLEN) volatile
    {
        uint32_t curr = BUSRCON2;

        AGEN = (curr >> 28u) & 0b1111u;
        AAP = EBU_BUSRCON0_AAP(curr & (1u << 26u));
        WAIT = (curr >> 24u) & 0b11u;
        PORTW = (curr >> 22u) & 0b11u;
        BCGEN = EBU_BUSRCON0_BCGEN((curr >> 20u) & 0b11u);
        WAITINV = EBU_BUSRCON0_WAITINV(curr & (1u << 19u));
        DBA = EBU_BUSRCON0_DBA(curr & (1u << 18u));
        EBSE = EBU_BUSRCON0_EBSE(curr & (1u << 17u));
        ECSE = EBU_BUSRCON0_EBSE(curr & (1u << 16u));
        NAA = curr & (1u << 7u);
        BFCMSEL = EBU_BUSRCON0_BFCMSEL(curr & (1u << 6u));
        FDBKEN = EBU_BUSRCON0_FDBKEN(curr & (1u << 5u));
        BFSSS = EBU_BUSRCON0_BFSSS(curr & (1u << 4u));
        FBBMSEL = EBU_BUSRCON0_FBBMSEL(curr & (1u << 3u));
        FETBLEN = EBU_BUSRCON0_FETBLEN((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of BUSRCON2's bit fields.
     *
     * (read-write) EBU Bus Configuration Register
     */
    inline void set_BUSRCON2(
        uint8_t AGEN, EBU_BUSRCON0_AAP AAP, uint8_t WAIT, uint8_t PORTW,
        EBU_BUSRCON0_BCGEN BCGEN, EBU_BUSRCON0_WAITINV WAITINV,
        EBU_BUSRCON0_DBA DBA, EBU_BUSRCON0_EBSE EBSE, EBU_BUSRCON0_EBSE ECSE,
        bool NAA, EBU_BUSRCON0_BFCMSEL BFCMSEL, EBU_BUSRCON0_FDBKEN FDBKEN,
        EBU_BUSRCON0_BFSSS BFSSS, EBU_BUSRCON0_FBBMSEL FBBMSEL,
        EBU_BUSRCON0_FETBLEN FETBLEN) volatile
    {
        uint32_t curr = BUSRCON2;

        curr &= ~(0b1111u << 28u);
        curr |= (AGEN & 0b1111u) << 28u;
        curr &= ~(0b1u << 26u);
        curr |= (std::to_underlying(AAP) & 0b1u) << 26u;
        curr &= ~(0b11u << 24u);
        curr |= (WAIT & 0b11u) << 24u;
        curr &= ~(0b11u << 22u);
        curr |= (PORTW & 0b11u) << 22u;
        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(BCGEN) & 0b11u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (std::to_underlying(WAITINV) & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (std::to_underlying(DBA) & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(EBSE) & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (std::to_underlying(ECSE) & 0b1u) << 16u;
        curr &= ~(0b1u << 7u);
        curr |= (NAA & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (std::to_underlying(BFCMSEL) & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (std::to_underlying(FDBKEN) & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (std::to_underlying(BFSSS) & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(FBBMSEL) & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(FETBLEN) & 0b111u) << 0u;

        BUSRCON2 = curr;
    }

    /**
     * Get BUSRAP2's ADDRC field.
     */
    inline EBU_BUSRAP0_ADDRC get_BUSRAP2_ADDRC() volatile
    {
        return EBU_BUSRAP0_ADDRC((BUSRAP2 >> 28u) & 0b1111u);
    }

    /**
     * Set BUSRAP2's ADDRC field.
     *
     * Address Cycles
     */
    inline void set_BUSRAP2_ADDRC(EBU_BUSRAP0_ADDRC value) volatile
    {
        uint32_t curr = BUSRAP2;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(value) & 0b1111u) << 28u;

        BUSRAP2 = curr;
    }

    /**
     * Get BUSRAP2's AHOLDC field.
     */
    inline EBU_BUSRAP0_AHOLDC get_BUSRAP2_AHOLDC() volatile
    {
        return EBU_BUSRAP0_AHOLDC((BUSRAP2 >> 24u) & 0b1111u);
    }

    /**
     * Set BUSRAP2's AHOLDC field.
     *
     * Address Hold Cycles
     */
    inline void set_BUSRAP2_AHOLDC(EBU_BUSRAP0_AHOLDC value) volatile
    {
        uint32_t curr = BUSRAP2;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        BUSRAP2 = curr;
    }

    /**
     * Get BUSRAP2's CMDDELAY field.
     */
    inline EBU_BUSRAP0_AHOLDC get_BUSRAP2_CMDDELAY() volatile
    {
        return EBU_BUSRAP0_AHOLDC((BUSRAP2 >> 20u) & 0b1111u);
    }

    /**
     * Set BUSRAP2's CMDDELAY field.
     *
     * Command Delay Cycles
     */
    inline void set_BUSRAP2_CMDDELAY(EBU_BUSRAP0_AHOLDC value) volatile
    {
        uint32_t curr = BUSRAP2;

        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(value) & 0b1111u) << 20u;

        BUSRAP2 = curr;
    }

    /**
     * Get BUSRAP2's EXTDATA field.
     */
    inline EBU_BUSRAP0_EXTDATA get_BUSRAP2_EXTDATA() volatile
    {
        return EBU_BUSRAP0_EXTDATA((BUSRAP2 >> 18u) & 0b11u);
    }

    /**
     * Set BUSRAP2's EXTDATA field.
     *
     * Extended data
     */
    inline void set_BUSRAP2_EXTDATA(EBU_BUSRAP0_EXTDATA value) volatile
    {
        uint32_t curr = BUSRAP2;

        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(value) & 0b11u) << 18u;

        BUSRAP2 = curr;
    }

    /**
     * Get BUSRAP2's EXTCLOCK field.
     */
    inline EBU_BUSRAP0_EXTCLOCK get_BUSRAP2_EXTCLOCK() volatile
    {
        return EBU_BUSRAP0_EXTCLOCK((BUSRAP2 >> 16u) & 0b11u);
    }

    /**
     * Set BUSRAP2's EXTCLOCK field.
     *
     * Frequency of external clock at pin BFCLKO
     */
    inline void set_BUSRAP2_EXTCLOCK(EBU_BUSRAP0_EXTCLOCK value) volatile
    {
        uint32_t curr = BUSRAP2;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        BUSRAP2 = curr;
    }

    /**
     * Get BUSRAP2's DATAC field.
     */
    inline uint8_t get_BUSRAP2_DATAC() volatile
    {
        return (BUSRAP2 >> 12u) & 0b1111u;
    }

    /**
     * Set BUSRAP2's DATAC field.
     *
     * Data Hold Cycles for Read Accesses
     */
    inline void set_BUSRAP2_DATAC(uint8_t value) volatile
    {
        uint32_t curr = BUSRAP2;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        BUSRAP2 = curr;
    }

    /**
     * Get BUSRAP2's WAITRDC field.
     */
    inline EBU_BUSRAP0_WAITRDC get_BUSRAP2_WAITRDC() volatile
    {
        return EBU_BUSRAP0_WAITRDC((BUSRAP2 >> 7u) & 0b11111u);
    }

    /**
     * Set BUSRAP2's WAITRDC field.
     *
     * Programmed Wait States for read accesses
     */
    inline void set_BUSRAP2_WAITRDC(EBU_BUSRAP0_WAITRDC value) volatile
    {
        uint32_t curr = BUSRAP2;

        curr &= ~(0b11111u << 7u);
        curr |= (std::to_underlying(value) & 0b11111u) << 7u;

        BUSRAP2 = curr;
    }

    /**
     * Get BUSRAP2's RDRECOVC field.
     */
    inline EBU_BUSRAP0_RDRECOVC get_BUSRAP2_RDRECOVC() volatile
    {
        return EBU_BUSRAP0_RDRECOVC((BUSRAP2 >> 4u) & 0b111u);
    }

    /**
     * Set BUSRAP2's RDRECOVC field.
     *
     * Recovery Cycles after Read Accesses
     */
    inline void set_BUSRAP2_RDRECOVC(EBU_BUSRAP0_RDRECOVC value) volatile
    {
        uint32_t curr = BUSRAP2;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        BUSRAP2 = curr;
    }

    /**
     * Get BUSRAP2's RDDTACS field.
     */
    inline EBU_BUSRAP0_RDDTACS get_BUSRAP2_RDDTACS() volatile
    {
        return EBU_BUSRAP0_RDDTACS((BUSRAP2 >> 0u) & 0b1111u);
    }

    /**
     * Set BUSRAP2's RDDTACS field.
     *
     * Recovery Cycles between Different Regions
     */
    inline void set_BUSRAP2_RDDTACS(EBU_BUSRAP0_RDDTACS value) volatile
    {
        uint32_t curr = BUSRAP2;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        BUSRAP2 = curr;
    }

    /**
     * Get all of BUSRAP2's bit fields.
     */
    inline void get_BUSRAP2(EBU_BUSRAP0_ADDRC &ADDRC,
                            EBU_BUSRAP0_AHOLDC &AHOLDC,
                            EBU_BUSRAP0_AHOLDC &CMDDELAY,
                            EBU_BUSRAP0_EXTDATA &EXTDATA,
                            EBU_BUSRAP0_EXTCLOCK &EXTCLOCK, uint8_t &DATAC,
                            EBU_BUSRAP0_WAITRDC &WAITRDC,
                            EBU_BUSRAP0_RDRECOVC &RDRECOVC,
                            EBU_BUSRAP0_RDDTACS &RDDTACS) volatile
    {
        uint32_t curr = BUSRAP2;

        ADDRC = EBU_BUSRAP0_ADDRC((curr >> 28u) & 0b1111u);
        AHOLDC = EBU_BUSRAP0_AHOLDC((curr >> 24u) & 0b1111u);
        CMDDELAY = EBU_BUSRAP0_AHOLDC((curr >> 20u) & 0b1111u);
        EXTDATA = EBU_BUSRAP0_EXTDATA((curr >> 18u) & 0b11u);
        EXTCLOCK = EBU_BUSRAP0_EXTCLOCK((curr >> 16u) & 0b11u);
        DATAC = (curr >> 12u) & 0b1111u;
        WAITRDC = EBU_BUSRAP0_WAITRDC((curr >> 7u) & 0b11111u);
        RDRECOVC = EBU_BUSRAP0_RDRECOVC((curr >> 4u) & 0b111u);
        RDDTACS = EBU_BUSRAP0_RDDTACS((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of BUSRAP2's bit fields.
     *
     * (read-write) EBU Bus Read Access Parameter Register
     */
    inline void set_BUSRAP2(EBU_BUSRAP0_ADDRC ADDRC, EBU_BUSRAP0_AHOLDC AHOLDC,
                            EBU_BUSRAP0_AHOLDC CMDDELAY,
                            EBU_BUSRAP0_EXTDATA EXTDATA,
                            EBU_BUSRAP0_EXTCLOCK EXTCLOCK, uint8_t DATAC,
                            EBU_BUSRAP0_WAITRDC WAITRDC,
                            EBU_BUSRAP0_RDRECOVC RDRECOVC,
                            EBU_BUSRAP0_RDDTACS RDDTACS) volatile
    {
        uint32_t curr = BUSRAP2;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(ADDRC) & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(AHOLDC) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(CMDDELAY) & 0b1111u) << 20u;
        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(EXTDATA) & 0b11u) << 18u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(EXTCLOCK) & 0b11u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (DATAC & 0b1111u) << 12u;
        curr &= ~(0b11111u << 7u);
        curr |= (std::to_underlying(WAITRDC) & 0b11111u) << 7u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(RDRECOVC) & 0b111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(RDDTACS) & 0b1111u) << 0u;

        BUSRAP2 = curr;
    }

    /**
     * Get BUSWCON2's AGEN field.
     */
    inline uint8_t get_BUSWCON2_AGEN() volatile
    {
        return (BUSWCON2 >> 28u) & 0b1111u;
    }

    /**
     * Set BUSWCON2's AGEN field.
     *
     * Device Type for Region
     */
    inline void set_BUSWCON2_AGEN(uint8_t value) volatile
    {
        uint32_t curr = BUSWCON2;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        BUSWCON2 = curr;
    }

    /**
     * Get BUSWCON2's LOCKCS bit.
     */
    inline EBU_BUSWCON0_LOCKCS get_BUSWCON2_LOCKCS() volatile
    {
        return EBU_BUSWCON0_LOCKCS(BUSWCON2 & (1u << 27u));
    }

    /**
     * Set BUSWCON2's LOCKCS bit.
     *
     * Lock Chip Select
     */
    inline void set_BUSWCON2_LOCKCS() volatile
    {
        BUSWCON2 |= 1u << 27u;
    }

    /**
     * Clear BUSWCON2's LOCKCS bit.
     *
     * Lock Chip Select
     */
    inline void clear_BUSWCON2_LOCKCS() volatile
    {
        BUSWCON2 &= ~(1u << 27u);
    }

    /**
     * Toggle BUSWCON2's LOCKCS bit.
     *
     * Lock Chip Select
     */
    inline void toggle_BUSWCON2_LOCKCS() volatile
    {
        BUSWCON2 ^= 1u << 27u;
    }

    /**
     * Get BUSWCON2's AAP bit.
     */
    inline EBU_BUSRCON0_AAP get_BUSWCON2_AAP() volatile
    {
        return EBU_BUSRCON0_AAP(BUSWCON2 & (1u << 26u));
    }

    /**
     * Set BUSWCON2's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void set_BUSWCON2_AAP() volatile
    {
        BUSWCON2 |= 1u << 26u;
    }

    /**
     * Clear BUSWCON2's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void clear_BUSWCON2_AAP() volatile
    {
        BUSWCON2 &= ~(1u << 26u);
    }

    /**
     * Toggle BUSWCON2's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void toggle_BUSWCON2_AAP() volatile
    {
        BUSWCON2 ^= 1u << 26u;
    }

    /**
     * Get BUSWCON2's WAIT field.
     */
    inline uint8_t get_BUSWCON2_WAIT() volatile
    {
        return (BUSWCON2 >> 24u) & 0b11u;
    }

    /**
     * Set BUSWCON2's WAIT field.
     *
     * External Wait Control: 0=OFF (default after reset)., 1=Asynchronous
     * input at WAIT., 2=Synchronous input at WAIT., 3=reserved., 0=OFF
     * (default after reset)., 1=Wait for page load (Early WAIT)., 2=Wait for
     * page load (WAIT with data)., 3=Abort and retry access.,
     */
    inline void set_BUSWCON2_WAIT(uint8_t value) volatile
    {
        uint32_t curr = BUSWCON2;

        curr &= ~(0b11u << 24u);
        curr |= (value & 0b11u) << 24u;

        BUSWCON2 = curr;
    }

    /**
     * Get BUSWCON2's PORTW field.
     */
    inline uint8_t get_BUSWCON2_PORTW() volatile
    {
        return (BUSWCON2 >> 22u) & 0b11u;
    }

    /**
     * Get BUSWCON2's BCGEN field.
     */
    inline EBU_BUSRCON0_BCGEN get_BUSWCON2_BCGEN() volatile
    {
        return EBU_BUSRCON0_BCGEN((BUSWCON2 >> 20u) & 0b11u);
    }

    /**
     * Set BUSWCON2's BCGEN field.
     *
     * Byte Control Signal Control
     */
    inline void set_BUSWCON2_BCGEN(EBU_BUSRCON0_BCGEN value) volatile
    {
        uint32_t curr = BUSWCON2;

        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(value) & 0b11u) << 20u;

        BUSWCON2 = curr;
    }

    /**
     * Get BUSWCON2's WAITINV bit.
     */
    inline EBU_BUSRCON0_WAITINV get_BUSWCON2_WAITINV() volatile
    {
        return EBU_BUSRCON0_WAITINV(BUSWCON2 & (1u << 19u));
    }

    /**
     * Set BUSWCON2's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void set_BUSWCON2_WAITINV() volatile
    {
        BUSWCON2 |= 1u << 19u;
    }

    /**
     * Clear BUSWCON2's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void clear_BUSWCON2_WAITINV() volatile
    {
        BUSWCON2 &= ~(1u << 19u);
    }

    /**
     * Toggle BUSWCON2's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void toggle_BUSWCON2_WAITINV() volatile
    {
        BUSWCON2 ^= 1u << 19u;
    }

    /**
     * Get BUSWCON2's EBSE bit.
     */
    inline EBU_BUSRCON0_EBSE get_BUSWCON2_EBSE() volatile
    {
        return EBU_BUSRCON0_EBSE(BUSWCON2 & (1u << 17u));
    }

    /**
     * Set BUSWCON2's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void set_BUSWCON2_EBSE() volatile
    {
        BUSWCON2 |= 1u << 17u;
    }

    /**
     * Clear BUSWCON2's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void clear_BUSWCON2_EBSE() volatile
    {
        BUSWCON2 &= ~(1u << 17u);
    }

    /**
     * Toggle BUSWCON2's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void toggle_BUSWCON2_EBSE() volatile
    {
        BUSWCON2 ^= 1u << 17u;
    }

    /**
     * Get BUSWCON2's ECSE bit.
     */
    inline EBU_BUSRCON0_EBSE get_BUSWCON2_ECSE() volatile
    {
        return EBU_BUSRCON0_EBSE(BUSWCON2 & (1u << 16u));
    }

    /**
     * Set BUSWCON2's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void set_BUSWCON2_ECSE() volatile
    {
        BUSWCON2 |= 1u << 16u;
    }

    /**
     * Clear BUSWCON2's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void clear_BUSWCON2_ECSE() volatile
    {
        BUSWCON2 &= ~(1u << 16u);
    }

    /**
     * Toggle BUSWCON2's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void toggle_BUSWCON2_ECSE() volatile
    {
        BUSWCON2 ^= 1u << 16u;
    }

    /**
     * Get BUSWCON2's NAA bit.
     */
    inline bool get_BUSWCON2_NAA() volatile
    {
        return BUSWCON2 & (1u << 7u);
    }

    /**
     * Get BUSWCON2's FBBMSEL bit.
     */
    inline EBU_BUSRCON0_FBBMSEL get_BUSWCON2_FBBMSEL() volatile
    {
        return EBU_BUSRCON0_FBBMSEL(BUSWCON2 & (1u << 3u));
    }

    /**
     * Set BUSWCON2's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void set_BUSWCON2_FBBMSEL() volatile
    {
        BUSWCON2 |= 1u << 3u;
    }

    /**
     * Clear BUSWCON2's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void clear_BUSWCON2_FBBMSEL() volatile
    {
        BUSWCON2 &= ~(1u << 3u);
    }

    /**
     * Toggle BUSWCON2's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void toggle_BUSWCON2_FBBMSEL() volatile
    {
        BUSWCON2 ^= 1u << 3u;
    }

    /**
     * Get BUSWCON2's FETBLEN field.
     */
    inline EBU_BUSRCON0_FETBLEN get_BUSWCON2_FETBLEN() volatile
    {
        return EBU_BUSRCON0_FETBLEN((BUSWCON2 >> 0u) & 0b111u);
    }

    /**
     * Set BUSWCON2's FETBLEN field.
     *
     * Burst Length for Synchronous Burst
     */
    inline void set_BUSWCON2_FETBLEN(EBU_BUSRCON0_FETBLEN value) volatile
    {
        uint32_t curr = BUSWCON2;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        BUSWCON2 = curr;
    }

    /**
     * Get all of BUSWCON2's bit fields.
     */
    inline void get_BUSWCON2(uint8_t &AGEN, EBU_BUSWCON0_LOCKCS &LOCKCS,
                             EBU_BUSRCON0_AAP &AAP, uint8_t &WAIT,
                             uint8_t &PORTW, EBU_BUSRCON0_BCGEN &BCGEN,
                             EBU_BUSRCON0_WAITINV &WAITINV,
                             EBU_BUSRCON0_EBSE &EBSE, EBU_BUSRCON0_EBSE &ECSE,
                             bool &NAA, EBU_BUSRCON0_FBBMSEL &FBBMSEL,
                             EBU_BUSRCON0_FETBLEN &FETBLEN) volatile
    {
        uint32_t curr = BUSWCON2;

        AGEN = (curr >> 28u) & 0b1111u;
        LOCKCS = EBU_BUSWCON0_LOCKCS(curr & (1u << 27u));
        AAP = EBU_BUSRCON0_AAP(curr & (1u << 26u));
        WAIT = (curr >> 24u) & 0b11u;
        PORTW = (curr >> 22u) & 0b11u;
        BCGEN = EBU_BUSRCON0_BCGEN((curr >> 20u) & 0b11u);
        WAITINV = EBU_BUSRCON0_WAITINV(curr & (1u << 19u));
        EBSE = EBU_BUSRCON0_EBSE(curr & (1u << 17u));
        ECSE = EBU_BUSRCON0_EBSE(curr & (1u << 16u));
        NAA = curr & (1u << 7u);
        FBBMSEL = EBU_BUSRCON0_FBBMSEL(curr & (1u << 3u));
        FETBLEN = EBU_BUSRCON0_FETBLEN((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of BUSWCON2's bit fields.
     *
     * (read-write) EBU Bus Write Configuration Register
     */
    inline void set_BUSWCON2(uint8_t AGEN, EBU_BUSWCON0_LOCKCS LOCKCS,
                             EBU_BUSRCON0_AAP AAP, uint8_t WAIT,
                             EBU_BUSRCON0_BCGEN BCGEN,
                             EBU_BUSRCON0_WAITINV WAITINV,
                             EBU_BUSRCON0_EBSE EBSE, EBU_BUSRCON0_EBSE ECSE,
                             EBU_BUSRCON0_FBBMSEL FBBMSEL,
                             EBU_BUSRCON0_FETBLEN FETBLEN) volatile
    {
        uint32_t curr = BUSWCON2;

        curr &= ~(0b1111u << 28u);
        curr |= (AGEN & 0b1111u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (std::to_underlying(LOCKCS) & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (std::to_underlying(AAP) & 0b1u) << 26u;
        curr &= ~(0b11u << 24u);
        curr |= (WAIT & 0b11u) << 24u;
        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(BCGEN) & 0b11u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (std::to_underlying(WAITINV) & 0b1u) << 19u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(EBSE) & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (std::to_underlying(ECSE) & 0b1u) << 16u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(FBBMSEL) & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(FETBLEN) & 0b111u) << 0u;

        BUSWCON2 = curr;
    }

    /**
     * Get BUSWAP2's ADDRC field.
     */
    inline EBU_BUSRAP0_ADDRC get_BUSWAP2_ADDRC() volatile
    {
        return EBU_BUSRAP0_ADDRC((BUSWAP2 >> 28u) & 0b1111u);
    }

    /**
     * Set BUSWAP2's ADDRC field.
     *
     * Address Cycles
     */
    inline void set_BUSWAP2_ADDRC(EBU_BUSRAP0_ADDRC value) volatile
    {
        uint32_t curr = BUSWAP2;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(value) & 0b1111u) << 28u;

        BUSWAP2 = curr;
    }

    /**
     * Get BUSWAP2's AHOLDC field.
     */
    inline EBU_BUSRAP0_AHOLDC get_BUSWAP2_AHOLDC() volatile
    {
        return EBU_BUSRAP0_AHOLDC((BUSWAP2 >> 24u) & 0b1111u);
    }

    /**
     * Set BUSWAP2's AHOLDC field.
     *
     * Address Hold Cycles
     */
    inline void set_BUSWAP2_AHOLDC(EBU_BUSRAP0_AHOLDC value) volatile
    {
        uint32_t curr = BUSWAP2;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        BUSWAP2 = curr;
    }

    /**
     * Get BUSWAP2's CMDDELAY field.
     */
    inline EBU_BUSRAP0_AHOLDC get_BUSWAP2_CMDDELAY() volatile
    {
        return EBU_BUSRAP0_AHOLDC((BUSWAP2 >> 20u) & 0b1111u);
    }

    /**
     * Set BUSWAP2's CMDDELAY field.
     *
     * Command Delay Cycles
     */
    inline void set_BUSWAP2_CMDDELAY(EBU_BUSRAP0_AHOLDC value) volatile
    {
        uint32_t curr = BUSWAP2;

        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(value) & 0b1111u) << 20u;

        BUSWAP2 = curr;
    }

    /**
     * Get BUSWAP2's EXTDATA field.
     */
    inline EBU_BUSRAP0_EXTDATA get_BUSWAP2_EXTDATA() volatile
    {
        return EBU_BUSRAP0_EXTDATA((BUSWAP2 >> 18u) & 0b11u);
    }

    /**
     * Set BUSWAP2's EXTDATA field.
     *
     * Extended data
     */
    inline void set_BUSWAP2_EXTDATA(EBU_BUSRAP0_EXTDATA value) volatile
    {
        uint32_t curr = BUSWAP2;

        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(value) & 0b11u) << 18u;

        BUSWAP2 = curr;
    }

    /**
     * Get BUSWAP2's EXTCLOCK field.
     */
    inline EBU_BUSRAP0_EXTCLOCK get_BUSWAP2_EXTCLOCK() volatile
    {
        return EBU_BUSRAP0_EXTCLOCK((BUSWAP2 >> 16u) & 0b11u);
    }

    /**
     * Set BUSWAP2's EXTCLOCK field.
     *
     * Frequency of external clock at pin BFCLKO
     */
    inline void set_BUSWAP2_EXTCLOCK(EBU_BUSRAP0_EXTCLOCK value) volatile
    {
        uint32_t curr = BUSWAP2;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        BUSWAP2 = curr;
    }

    /**
     * Get BUSWAP2's DATAC field.
     */
    inline EBU_BUSRAP0_RDDTACS get_BUSWAP2_DATAC() volatile
    {
        return EBU_BUSRAP0_RDDTACS((BUSWAP2 >> 12u) & 0b1111u);
    }

    /**
     * Set BUSWAP2's DATAC field.
     *
     * Data Hold Cycles for Write Accesses
     */
    inline void set_BUSWAP2_DATAC(EBU_BUSRAP0_RDDTACS value) volatile
    {
        uint32_t curr = BUSWAP2;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(value) & 0b1111u) << 12u;

        BUSWAP2 = curr;
    }

    /**
     * Get BUSWAP2's WAITWRC field.
     */
    inline EBU_BUSRAP0_WAITRDC get_BUSWAP2_WAITWRC() volatile
    {
        return EBU_BUSRAP0_WAITRDC((BUSWAP2 >> 7u) & 0b11111u);
    }

    /**
     * Set BUSWAP2's WAITWRC field.
     *
     * Programmed Wait States for write accesses
     */
    inline void set_BUSWAP2_WAITWRC(EBU_BUSRAP0_WAITRDC value) volatile
    {
        uint32_t curr = BUSWAP2;

        curr &= ~(0b11111u << 7u);
        curr |= (std::to_underlying(value) & 0b11111u) << 7u;

        BUSWAP2 = curr;
    }

    /**
     * Get BUSWAP2's WRRECOVC field.
     */
    inline EBU_BUSRAP0_RDRECOVC get_BUSWAP2_WRRECOVC() volatile
    {
        return EBU_BUSRAP0_RDRECOVC((BUSWAP2 >> 4u) & 0b111u);
    }

    /**
     * Set BUSWAP2's WRRECOVC field.
     *
     * Recovery Cycles after Write Accesses
     */
    inline void set_BUSWAP2_WRRECOVC(EBU_BUSRAP0_RDRECOVC value) volatile
    {
        uint32_t curr = BUSWAP2;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        BUSWAP2 = curr;
    }

    /**
     * Get BUSWAP2's WRDTACS field.
     */
    inline EBU_BUSRAP0_RDDTACS get_BUSWAP2_WRDTACS() volatile
    {
        return EBU_BUSRAP0_RDDTACS((BUSWAP2 >> 0u) & 0b1111u);
    }

    /**
     * Set BUSWAP2's WRDTACS field.
     *
     * Recovery Cycles between Different Regions
     */
    inline void set_BUSWAP2_WRDTACS(EBU_BUSRAP0_RDDTACS value) volatile
    {
        uint32_t curr = BUSWAP2;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        BUSWAP2 = curr;
    }

    /**
     * Get all of BUSWAP2's bit fields.
     */
    inline void get_BUSWAP2(
        EBU_BUSRAP0_ADDRC &ADDRC, EBU_BUSRAP0_AHOLDC &AHOLDC,
        EBU_BUSRAP0_AHOLDC &CMDDELAY, EBU_BUSRAP0_EXTDATA &EXTDATA,
        EBU_BUSRAP0_EXTCLOCK &EXTCLOCK, EBU_BUSRAP0_RDDTACS &DATAC,
        EBU_BUSRAP0_WAITRDC &WAITWRC, EBU_BUSRAP0_RDRECOVC &WRRECOVC,
        EBU_BUSRAP0_RDDTACS &WRDTACS) volatile
    {
        uint32_t curr = BUSWAP2;

        ADDRC = EBU_BUSRAP0_ADDRC((curr >> 28u) & 0b1111u);
        AHOLDC = EBU_BUSRAP0_AHOLDC((curr >> 24u) & 0b1111u);
        CMDDELAY = EBU_BUSRAP0_AHOLDC((curr >> 20u) & 0b1111u);
        EXTDATA = EBU_BUSRAP0_EXTDATA((curr >> 18u) & 0b11u);
        EXTCLOCK = EBU_BUSRAP0_EXTCLOCK((curr >> 16u) & 0b11u);
        DATAC = EBU_BUSRAP0_RDDTACS((curr >> 12u) & 0b1111u);
        WAITWRC = EBU_BUSRAP0_WAITRDC((curr >> 7u) & 0b11111u);
        WRRECOVC = EBU_BUSRAP0_RDRECOVC((curr >> 4u) & 0b111u);
        WRDTACS = EBU_BUSRAP0_RDDTACS((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of BUSWAP2's bit fields.
     *
     * (read-write) EBU Bus Write Access Parameter Register
     */
    inline void set_BUSWAP2(EBU_BUSRAP0_ADDRC ADDRC, EBU_BUSRAP0_AHOLDC AHOLDC,
                            EBU_BUSRAP0_AHOLDC CMDDELAY,
                            EBU_BUSRAP0_EXTDATA EXTDATA,
                            EBU_BUSRAP0_EXTCLOCK EXTCLOCK,
                            EBU_BUSRAP0_RDDTACS DATAC,
                            EBU_BUSRAP0_WAITRDC WAITWRC,
                            EBU_BUSRAP0_RDRECOVC WRRECOVC,
                            EBU_BUSRAP0_RDDTACS WRDTACS) volatile
    {
        uint32_t curr = BUSWAP2;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(ADDRC) & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(AHOLDC) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(CMDDELAY) & 0b1111u) << 20u;
        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(EXTDATA) & 0b11u) << 18u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(EXTCLOCK) & 0b11u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(DATAC) & 0b1111u) << 12u;
        curr &= ~(0b11111u << 7u);
        curr |= (std::to_underlying(WAITWRC) & 0b11111u) << 7u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(WRRECOVC) & 0b111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(WRDTACS) & 0b1111u) << 0u;

        BUSWAP2 = curr;
    }

    /**
     * Get BUSRCON3's AGEN field.
     */
    inline uint8_t get_BUSRCON3_AGEN() volatile
    {
        return (BUSRCON3 >> 28u) & 0b1111u;
    }

    /**
     * Set BUSRCON3's AGEN field.
     *
     * Device Type for Region
     */
    inline void set_BUSRCON3_AGEN(uint8_t value) volatile
    {
        uint32_t curr = BUSRCON3;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        BUSRCON3 = curr;
    }

    /**
     * Get BUSRCON3's AAP bit.
     */
    inline EBU_BUSRCON0_AAP get_BUSRCON3_AAP() volatile
    {
        return EBU_BUSRCON0_AAP(BUSRCON3 & (1u << 26u));
    }

    /**
     * Set BUSRCON3's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void set_BUSRCON3_AAP() volatile
    {
        BUSRCON3 |= 1u << 26u;
    }

    /**
     * Clear BUSRCON3's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void clear_BUSRCON3_AAP() volatile
    {
        BUSRCON3 &= ~(1u << 26u);
    }

    /**
     * Toggle BUSRCON3's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void toggle_BUSRCON3_AAP() volatile
    {
        BUSRCON3 ^= 1u << 26u;
    }

    /**
     * Get BUSRCON3's WAIT field.
     */
    inline uint8_t get_BUSRCON3_WAIT() volatile
    {
        return (BUSRCON3 >> 24u) & 0b11u;
    }

    /**
     * Set BUSRCON3's WAIT field.
     *
     * External Wait Control: 0=OFF (default after reset)., 1=Asynchronous
     * input at WAIT., 2=Synchronous input at WAIT., 3=reserved., 0=OFF
     * (default after reset)., 1=Wait for page load (Early WAIT)., 2=Wait for
     * page load (WAIT with data)., 3=Abort and retry access.,
     */
    inline void set_BUSRCON3_WAIT(uint8_t value) volatile
    {
        uint32_t curr = BUSRCON3;

        curr &= ~(0b11u << 24u);
        curr |= (value & 0b11u) << 24u;

        BUSRCON3 = curr;
    }

    /**
     * Get BUSRCON3's PORTW field.
     */
    inline uint8_t get_BUSRCON3_PORTW() volatile
    {
        return (BUSRCON3 >> 22u) & 0b11u;
    }

    /**
     * Set BUSRCON3's PORTW field.
     *
     * Device Addressing Mode
     */
    inline void set_BUSRCON3_PORTW(uint8_t value) volatile
    {
        uint32_t curr = BUSRCON3;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        BUSRCON3 = curr;
    }

    /**
     * Get BUSRCON3's BCGEN field.
     */
    inline EBU_BUSRCON0_BCGEN get_BUSRCON3_BCGEN() volatile
    {
        return EBU_BUSRCON0_BCGEN((BUSRCON3 >> 20u) & 0b11u);
    }

    /**
     * Set BUSRCON3's BCGEN field.
     *
     * Byte Control Signal Control
     */
    inline void set_BUSRCON3_BCGEN(EBU_BUSRCON0_BCGEN value) volatile
    {
        uint32_t curr = BUSRCON3;

        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(value) & 0b11u) << 20u;

        BUSRCON3 = curr;
    }

    /**
     * Get BUSRCON3's WAITINV bit.
     */
    inline EBU_BUSRCON0_WAITINV get_BUSRCON3_WAITINV() volatile
    {
        return EBU_BUSRCON0_WAITINV(BUSRCON3 & (1u << 19u));
    }

    /**
     * Set BUSRCON3's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void set_BUSRCON3_WAITINV() volatile
    {
        BUSRCON3 |= 1u << 19u;
    }

    /**
     * Clear BUSRCON3's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void clear_BUSRCON3_WAITINV() volatile
    {
        BUSRCON3 &= ~(1u << 19u);
    }

    /**
     * Toggle BUSRCON3's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void toggle_BUSRCON3_WAITINV() volatile
    {
        BUSRCON3 ^= 1u << 19u;
    }

    /**
     * Get BUSRCON3's DBA bit.
     */
    inline EBU_BUSRCON0_DBA get_BUSRCON3_DBA() volatile
    {
        return EBU_BUSRCON0_DBA(BUSRCON3 & (1u << 18u));
    }

    /**
     * Set BUSRCON3's DBA bit.
     *
     * Disable Burst Address Wrapping
     */
    inline void set_BUSRCON3_DBA() volatile
    {
        BUSRCON3 |= 1u << 18u;
    }

    /**
     * Clear BUSRCON3's DBA bit.
     *
     * Disable Burst Address Wrapping
     */
    inline void clear_BUSRCON3_DBA() volatile
    {
        BUSRCON3 &= ~(1u << 18u);
    }

    /**
     * Toggle BUSRCON3's DBA bit.
     *
     * Disable Burst Address Wrapping
     */
    inline void toggle_BUSRCON3_DBA() volatile
    {
        BUSRCON3 ^= 1u << 18u;
    }

    /**
     * Get BUSRCON3's EBSE bit.
     */
    inline EBU_BUSRCON0_EBSE get_BUSRCON3_EBSE() volatile
    {
        return EBU_BUSRCON0_EBSE(BUSRCON3 & (1u << 17u));
    }

    /**
     * Set BUSRCON3's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void set_BUSRCON3_EBSE() volatile
    {
        BUSRCON3 |= 1u << 17u;
    }

    /**
     * Clear BUSRCON3's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void clear_BUSRCON3_EBSE() volatile
    {
        BUSRCON3 &= ~(1u << 17u);
    }

    /**
     * Toggle BUSRCON3's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void toggle_BUSRCON3_EBSE() volatile
    {
        BUSRCON3 ^= 1u << 17u;
    }

    /**
     * Get BUSRCON3's ECSE bit.
     */
    inline EBU_BUSRCON0_EBSE get_BUSRCON3_ECSE() volatile
    {
        return EBU_BUSRCON0_EBSE(BUSRCON3 & (1u << 16u));
    }

    /**
     * Set BUSRCON3's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void set_BUSRCON3_ECSE() volatile
    {
        BUSRCON3 |= 1u << 16u;
    }

    /**
     * Clear BUSRCON3's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void clear_BUSRCON3_ECSE() volatile
    {
        BUSRCON3 &= ~(1u << 16u);
    }

    /**
     * Toggle BUSRCON3's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void toggle_BUSRCON3_ECSE() volatile
    {
        BUSRCON3 ^= 1u << 16u;
    }

    /**
     * Get BUSRCON3's NAA bit.
     */
    inline bool get_BUSRCON3_NAA() volatile
    {
        return BUSRCON3 & (1u << 7u);
    }

    /**
     * Set BUSRCON3's NAA bit.
     *
     * Enable flash non-array access workaround
     */
    inline void set_BUSRCON3_NAA() volatile
    {
        BUSRCON3 |= 1u << 7u;
    }

    /**
     * Clear BUSRCON3's NAA bit.
     *
     * Enable flash non-array access workaround
     */
    inline void clear_BUSRCON3_NAA() volatile
    {
        BUSRCON3 &= ~(1u << 7u);
    }

    /**
     * Toggle BUSRCON3's NAA bit.
     *
     * Enable flash non-array access workaround
     */
    inline void toggle_BUSRCON3_NAA() volatile
    {
        BUSRCON3 ^= 1u << 7u;
    }

    /**
     * Get BUSRCON3's BFCMSEL bit.
     */
    inline EBU_BUSRCON0_BFCMSEL get_BUSRCON3_BFCMSEL() volatile
    {
        return EBU_BUSRCON0_BFCMSEL(BUSRCON3 & (1u << 6u));
    }

    /**
     * Set BUSRCON3's BFCMSEL bit.
     *
     * Burst Flash Clock Mode Select
     */
    inline void set_BUSRCON3_BFCMSEL() volatile
    {
        BUSRCON3 |= 1u << 6u;
    }

    /**
     * Clear BUSRCON3's BFCMSEL bit.
     *
     * Burst Flash Clock Mode Select
     */
    inline void clear_BUSRCON3_BFCMSEL() volatile
    {
        BUSRCON3 &= ~(1u << 6u);
    }

    /**
     * Toggle BUSRCON3's BFCMSEL bit.
     *
     * Burst Flash Clock Mode Select
     */
    inline void toggle_BUSRCON3_BFCMSEL() volatile
    {
        BUSRCON3 ^= 1u << 6u;
    }

    /**
     * Get BUSRCON3's FDBKEN bit.
     */
    inline EBU_BUSRCON0_FDBKEN get_BUSRCON3_FDBKEN() volatile
    {
        return EBU_BUSRCON0_FDBKEN(BUSRCON3 & (1u << 5u));
    }

    /**
     * Set BUSRCON3's FDBKEN bit.
     *
     * Burst FLASH Clock Feedback Enable
     */
    inline void set_BUSRCON3_FDBKEN() volatile
    {
        BUSRCON3 |= 1u << 5u;
    }

    /**
     * Clear BUSRCON3's FDBKEN bit.
     *
     * Burst FLASH Clock Feedback Enable
     */
    inline void clear_BUSRCON3_FDBKEN() volatile
    {
        BUSRCON3 &= ~(1u << 5u);
    }

    /**
     * Toggle BUSRCON3's FDBKEN bit.
     *
     * Burst FLASH Clock Feedback Enable
     */
    inline void toggle_BUSRCON3_FDBKEN() volatile
    {
        BUSRCON3 ^= 1u << 5u;
    }

    /**
     * Get BUSRCON3's BFSSS bit.
     */
    inline EBU_BUSRCON0_BFSSS get_BUSRCON3_BFSSS() volatile
    {
        return EBU_BUSRCON0_BFSSS(BUSRCON3 & (1u << 4u));
    }

    /**
     * Set BUSRCON3's BFSSS bit.
     *
     * Read Single Stage Synchronization:
     */
    inline void set_BUSRCON3_BFSSS() volatile
    {
        BUSRCON3 |= 1u << 4u;
    }

    /**
     * Clear BUSRCON3's BFSSS bit.
     *
     * Read Single Stage Synchronization:
     */
    inline void clear_BUSRCON3_BFSSS() volatile
    {
        BUSRCON3 &= ~(1u << 4u);
    }

    /**
     * Toggle BUSRCON3's BFSSS bit.
     *
     * Read Single Stage Synchronization:
     */
    inline void toggle_BUSRCON3_BFSSS() volatile
    {
        BUSRCON3 ^= 1u << 4u;
    }

    /**
     * Get BUSRCON3's FBBMSEL bit.
     */
    inline EBU_BUSRCON0_FBBMSEL get_BUSRCON3_FBBMSEL() volatile
    {
        return EBU_BUSRCON0_FBBMSEL(BUSRCON3 & (1u << 3u));
    }

    /**
     * Set BUSRCON3's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void set_BUSRCON3_FBBMSEL() volatile
    {
        BUSRCON3 |= 1u << 3u;
    }

    /**
     * Clear BUSRCON3's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void clear_BUSRCON3_FBBMSEL() volatile
    {
        BUSRCON3 &= ~(1u << 3u);
    }

    /**
     * Toggle BUSRCON3's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void toggle_BUSRCON3_FBBMSEL() volatile
    {
        BUSRCON3 ^= 1u << 3u;
    }

    /**
     * Get BUSRCON3's FETBLEN field.
     */
    inline EBU_BUSRCON0_FETBLEN get_BUSRCON3_FETBLEN() volatile
    {
        return EBU_BUSRCON0_FETBLEN((BUSRCON3 >> 0u) & 0b111u);
    }

    /**
     * Set BUSRCON3's FETBLEN field.
     *
     * Burst Length for Synchronous Burst
     */
    inline void set_BUSRCON3_FETBLEN(EBU_BUSRCON0_FETBLEN value) volatile
    {
        uint32_t curr = BUSRCON3;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        BUSRCON3 = curr;
    }

    /**
     * Get all of BUSRCON3's bit fields.
     */
    inline void get_BUSRCON3(
        uint8_t &AGEN, EBU_BUSRCON0_AAP &AAP, uint8_t &WAIT, uint8_t &PORTW,
        EBU_BUSRCON0_BCGEN &BCGEN, EBU_BUSRCON0_WAITINV &WAITINV,
        EBU_BUSRCON0_DBA &DBA, EBU_BUSRCON0_EBSE &EBSE,
        EBU_BUSRCON0_EBSE &ECSE, bool &NAA, EBU_BUSRCON0_BFCMSEL &BFCMSEL,
        EBU_BUSRCON0_FDBKEN &FDBKEN, EBU_BUSRCON0_BFSSS &BFSSS,
        EBU_BUSRCON0_FBBMSEL &FBBMSEL, EBU_BUSRCON0_FETBLEN &FETBLEN) volatile
    {
        uint32_t curr = BUSRCON3;

        AGEN = (curr >> 28u) & 0b1111u;
        AAP = EBU_BUSRCON0_AAP(curr & (1u << 26u));
        WAIT = (curr >> 24u) & 0b11u;
        PORTW = (curr >> 22u) & 0b11u;
        BCGEN = EBU_BUSRCON0_BCGEN((curr >> 20u) & 0b11u);
        WAITINV = EBU_BUSRCON0_WAITINV(curr & (1u << 19u));
        DBA = EBU_BUSRCON0_DBA(curr & (1u << 18u));
        EBSE = EBU_BUSRCON0_EBSE(curr & (1u << 17u));
        ECSE = EBU_BUSRCON0_EBSE(curr & (1u << 16u));
        NAA = curr & (1u << 7u);
        BFCMSEL = EBU_BUSRCON0_BFCMSEL(curr & (1u << 6u));
        FDBKEN = EBU_BUSRCON0_FDBKEN(curr & (1u << 5u));
        BFSSS = EBU_BUSRCON0_BFSSS(curr & (1u << 4u));
        FBBMSEL = EBU_BUSRCON0_FBBMSEL(curr & (1u << 3u));
        FETBLEN = EBU_BUSRCON0_FETBLEN((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of BUSRCON3's bit fields.
     *
     * (read-write) EBU Bus Configuration Register
     */
    inline void set_BUSRCON3(
        uint8_t AGEN, EBU_BUSRCON0_AAP AAP, uint8_t WAIT, uint8_t PORTW,
        EBU_BUSRCON0_BCGEN BCGEN, EBU_BUSRCON0_WAITINV WAITINV,
        EBU_BUSRCON0_DBA DBA, EBU_BUSRCON0_EBSE EBSE, EBU_BUSRCON0_EBSE ECSE,
        bool NAA, EBU_BUSRCON0_BFCMSEL BFCMSEL, EBU_BUSRCON0_FDBKEN FDBKEN,
        EBU_BUSRCON0_BFSSS BFSSS, EBU_BUSRCON0_FBBMSEL FBBMSEL,
        EBU_BUSRCON0_FETBLEN FETBLEN) volatile
    {
        uint32_t curr = BUSRCON3;

        curr &= ~(0b1111u << 28u);
        curr |= (AGEN & 0b1111u) << 28u;
        curr &= ~(0b1u << 26u);
        curr |= (std::to_underlying(AAP) & 0b1u) << 26u;
        curr &= ~(0b11u << 24u);
        curr |= (WAIT & 0b11u) << 24u;
        curr &= ~(0b11u << 22u);
        curr |= (PORTW & 0b11u) << 22u;
        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(BCGEN) & 0b11u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (std::to_underlying(WAITINV) & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (std::to_underlying(DBA) & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(EBSE) & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (std::to_underlying(ECSE) & 0b1u) << 16u;
        curr &= ~(0b1u << 7u);
        curr |= (NAA & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (std::to_underlying(BFCMSEL) & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (std::to_underlying(FDBKEN) & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (std::to_underlying(BFSSS) & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(FBBMSEL) & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(FETBLEN) & 0b111u) << 0u;

        BUSRCON3 = curr;
    }

    /**
     * Get BUSRAP3's ADDRC field.
     */
    inline EBU_BUSRAP0_ADDRC get_BUSRAP3_ADDRC() volatile
    {
        return EBU_BUSRAP0_ADDRC((BUSRAP3 >> 28u) & 0b1111u);
    }

    /**
     * Set BUSRAP3's ADDRC field.
     *
     * Address Cycles
     */
    inline void set_BUSRAP3_ADDRC(EBU_BUSRAP0_ADDRC value) volatile
    {
        uint32_t curr = BUSRAP3;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(value) & 0b1111u) << 28u;

        BUSRAP3 = curr;
    }

    /**
     * Get BUSRAP3's AHOLDC field.
     */
    inline EBU_BUSRAP0_AHOLDC get_BUSRAP3_AHOLDC() volatile
    {
        return EBU_BUSRAP0_AHOLDC((BUSRAP3 >> 24u) & 0b1111u);
    }

    /**
     * Set BUSRAP3's AHOLDC field.
     *
     * Address Hold Cycles
     */
    inline void set_BUSRAP3_AHOLDC(EBU_BUSRAP0_AHOLDC value) volatile
    {
        uint32_t curr = BUSRAP3;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        BUSRAP3 = curr;
    }

    /**
     * Get BUSRAP3's CMDDELAY field.
     */
    inline EBU_BUSRAP0_AHOLDC get_BUSRAP3_CMDDELAY() volatile
    {
        return EBU_BUSRAP0_AHOLDC((BUSRAP3 >> 20u) & 0b1111u);
    }

    /**
     * Set BUSRAP3's CMDDELAY field.
     *
     * Command Delay Cycles
     */
    inline void set_BUSRAP3_CMDDELAY(EBU_BUSRAP0_AHOLDC value) volatile
    {
        uint32_t curr = BUSRAP3;

        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(value) & 0b1111u) << 20u;

        BUSRAP3 = curr;
    }

    /**
     * Get BUSRAP3's EXTDATA field.
     */
    inline EBU_BUSRAP0_EXTDATA get_BUSRAP3_EXTDATA() volatile
    {
        return EBU_BUSRAP0_EXTDATA((BUSRAP3 >> 18u) & 0b11u);
    }

    /**
     * Set BUSRAP3's EXTDATA field.
     *
     * Extended data
     */
    inline void set_BUSRAP3_EXTDATA(EBU_BUSRAP0_EXTDATA value) volatile
    {
        uint32_t curr = BUSRAP3;

        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(value) & 0b11u) << 18u;

        BUSRAP3 = curr;
    }

    /**
     * Get BUSRAP3's EXTCLOCK field.
     */
    inline EBU_BUSRAP0_EXTCLOCK get_BUSRAP3_EXTCLOCK() volatile
    {
        return EBU_BUSRAP0_EXTCLOCK((BUSRAP3 >> 16u) & 0b11u);
    }

    /**
     * Set BUSRAP3's EXTCLOCK field.
     *
     * Frequency of external clock at pin BFCLKO
     */
    inline void set_BUSRAP3_EXTCLOCK(EBU_BUSRAP0_EXTCLOCK value) volatile
    {
        uint32_t curr = BUSRAP3;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        BUSRAP3 = curr;
    }

    /**
     * Get BUSRAP3's DATAC field.
     */
    inline uint8_t get_BUSRAP3_DATAC() volatile
    {
        return (BUSRAP3 >> 12u) & 0b1111u;
    }

    /**
     * Set BUSRAP3's DATAC field.
     *
     * Data Hold Cycles for Read Accesses
     */
    inline void set_BUSRAP3_DATAC(uint8_t value) volatile
    {
        uint32_t curr = BUSRAP3;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        BUSRAP3 = curr;
    }

    /**
     * Get BUSRAP3's WAITRDC field.
     */
    inline EBU_BUSRAP0_WAITRDC get_BUSRAP3_WAITRDC() volatile
    {
        return EBU_BUSRAP0_WAITRDC((BUSRAP3 >> 7u) & 0b11111u);
    }

    /**
     * Set BUSRAP3's WAITRDC field.
     *
     * Programmed Wait States for read accesses
     */
    inline void set_BUSRAP3_WAITRDC(EBU_BUSRAP0_WAITRDC value) volatile
    {
        uint32_t curr = BUSRAP3;

        curr &= ~(0b11111u << 7u);
        curr |= (std::to_underlying(value) & 0b11111u) << 7u;

        BUSRAP3 = curr;
    }

    /**
     * Get BUSRAP3's RDRECOVC field.
     */
    inline EBU_BUSRAP0_RDRECOVC get_BUSRAP3_RDRECOVC() volatile
    {
        return EBU_BUSRAP0_RDRECOVC((BUSRAP3 >> 4u) & 0b111u);
    }

    /**
     * Set BUSRAP3's RDRECOVC field.
     *
     * Recovery Cycles after Read Accesses
     */
    inline void set_BUSRAP3_RDRECOVC(EBU_BUSRAP0_RDRECOVC value) volatile
    {
        uint32_t curr = BUSRAP3;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        BUSRAP3 = curr;
    }

    /**
     * Get BUSRAP3's RDDTACS field.
     */
    inline EBU_BUSRAP0_RDDTACS get_BUSRAP3_RDDTACS() volatile
    {
        return EBU_BUSRAP0_RDDTACS((BUSRAP3 >> 0u) & 0b1111u);
    }

    /**
     * Set BUSRAP3's RDDTACS field.
     *
     * Recovery Cycles between Different Regions
     */
    inline void set_BUSRAP3_RDDTACS(EBU_BUSRAP0_RDDTACS value) volatile
    {
        uint32_t curr = BUSRAP3;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        BUSRAP3 = curr;
    }

    /**
     * Get all of BUSRAP3's bit fields.
     */
    inline void get_BUSRAP3(EBU_BUSRAP0_ADDRC &ADDRC,
                            EBU_BUSRAP0_AHOLDC &AHOLDC,
                            EBU_BUSRAP0_AHOLDC &CMDDELAY,
                            EBU_BUSRAP0_EXTDATA &EXTDATA,
                            EBU_BUSRAP0_EXTCLOCK &EXTCLOCK, uint8_t &DATAC,
                            EBU_BUSRAP0_WAITRDC &WAITRDC,
                            EBU_BUSRAP0_RDRECOVC &RDRECOVC,
                            EBU_BUSRAP0_RDDTACS &RDDTACS) volatile
    {
        uint32_t curr = BUSRAP3;

        ADDRC = EBU_BUSRAP0_ADDRC((curr >> 28u) & 0b1111u);
        AHOLDC = EBU_BUSRAP0_AHOLDC((curr >> 24u) & 0b1111u);
        CMDDELAY = EBU_BUSRAP0_AHOLDC((curr >> 20u) & 0b1111u);
        EXTDATA = EBU_BUSRAP0_EXTDATA((curr >> 18u) & 0b11u);
        EXTCLOCK = EBU_BUSRAP0_EXTCLOCK((curr >> 16u) & 0b11u);
        DATAC = (curr >> 12u) & 0b1111u;
        WAITRDC = EBU_BUSRAP0_WAITRDC((curr >> 7u) & 0b11111u);
        RDRECOVC = EBU_BUSRAP0_RDRECOVC((curr >> 4u) & 0b111u);
        RDDTACS = EBU_BUSRAP0_RDDTACS((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of BUSRAP3's bit fields.
     *
     * (read-write) EBU Bus Read Access Parameter Register
     */
    inline void set_BUSRAP3(EBU_BUSRAP0_ADDRC ADDRC, EBU_BUSRAP0_AHOLDC AHOLDC,
                            EBU_BUSRAP0_AHOLDC CMDDELAY,
                            EBU_BUSRAP0_EXTDATA EXTDATA,
                            EBU_BUSRAP0_EXTCLOCK EXTCLOCK, uint8_t DATAC,
                            EBU_BUSRAP0_WAITRDC WAITRDC,
                            EBU_BUSRAP0_RDRECOVC RDRECOVC,
                            EBU_BUSRAP0_RDDTACS RDDTACS) volatile
    {
        uint32_t curr = BUSRAP3;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(ADDRC) & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(AHOLDC) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(CMDDELAY) & 0b1111u) << 20u;
        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(EXTDATA) & 0b11u) << 18u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(EXTCLOCK) & 0b11u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (DATAC & 0b1111u) << 12u;
        curr &= ~(0b11111u << 7u);
        curr |= (std::to_underlying(WAITRDC) & 0b11111u) << 7u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(RDRECOVC) & 0b111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(RDDTACS) & 0b1111u) << 0u;

        BUSRAP3 = curr;
    }

    /**
     * Get BUSWCON3's AGEN field.
     */
    inline uint8_t get_BUSWCON3_AGEN() volatile
    {
        return (BUSWCON3 >> 28u) & 0b1111u;
    }

    /**
     * Set BUSWCON3's AGEN field.
     *
     * Device Type for Region
     */
    inline void set_BUSWCON3_AGEN(uint8_t value) volatile
    {
        uint32_t curr = BUSWCON3;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        BUSWCON3 = curr;
    }

    /**
     * Get BUSWCON3's LOCKCS bit.
     */
    inline EBU_BUSWCON0_LOCKCS get_BUSWCON3_LOCKCS() volatile
    {
        return EBU_BUSWCON0_LOCKCS(BUSWCON3 & (1u << 27u));
    }

    /**
     * Set BUSWCON3's LOCKCS bit.
     *
     * Lock Chip Select
     */
    inline void set_BUSWCON3_LOCKCS() volatile
    {
        BUSWCON3 |= 1u << 27u;
    }

    /**
     * Clear BUSWCON3's LOCKCS bit.
     *
     * Lock Chip Select
     */
    inline void clear_BUSWCON3_LOCKCS() volatile
    {
        BUSWCON3 &= ~(1u << 27u);
    }

    /**
     * Toggle BUSWCON3's LOCKCS bit.
     *
     * Lock Chip Select
     */
    inline void toggle_BUSWCON3_LOCKCS() volatile
    {
        BUSWCON3 ^= 1u << 27u;
    }

    /**
     * Get BUSWCON3's AAP bit.
     */
    inline EBU_BUSRCON0_AAP get_BUSWCON3_AAP() volatile
    {
        return EBU_BUSRCON0_AAP(BUSWCON3 & (1u << 26u));
    }

    /**
     * Set BUSWCON3's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void set_BUSWCON3_AAP() volatile
    {
        BUSWCON3 |= 1u << 26u;
    }

    /**
     * Clear BUSWCON3's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void clear_BUSWCON3_AAP() volatile
    {
        BUSWCON3 &= ~(1u << 26u);
    }

    /**
     * Toggle BUSWCON3's AAP bit.
     *
     * Asynchronous Address phase:
     */
    inline void toggle_BUSWCON3_AAP() volatile
    {
        BUSWCON3 ^= 1u << 26u;
    }

    /**
     * Get BUSWCON3's WAIT field.
     */
    inline uint8_t get_BUSWCON3_WAIT() volatile
    {
        return (BUSWCON3 >> 24u) & 0b11u;
    }

    /**
     * Set BUSWCON3's WAIT field.
     *
     * External Wait Control: 0=OFF (default after reset)., 1=Asynchronous
     * input at WAIT., 2=Synchronous input at WAIT., 3=reserved., 0=OFF
     * (default after reset)., 1=Wait for page load (Early WAIT)., 2=Wait for
     * page load (WAIT with data)., 3=Abort and retry access.,
     */
    inline void set_BUSWCON3_WAIT(uint8_t value) volatile
    {
        uint32_t curr = BUSWCON3;

        curr &= ~(0b11u << 24u);
        curr |= (value & 0b11u) << 24u;

        BUSWCON3 = curr;
    }

    /**
     * Get BUSWCON3's PORTW field.
     */
    inline uint8_t get_BUSWCON3_PORTW() volatile
    {
        return (BUSWCON3 >> 22u) & 0b11u;
    }

    /**
     * Get BUSWCON3's BCGEN field.
     */
    inline EBU_BUSRCON0_BCGEN get_BUSWCON3_BCGEN() volatile
    {
        return EBU_BUSRCON0_BCGEN((BUSWCON3 >> 20u) & 0b11u);
    }

    /**
     * Set BUSWCON3's BCGEN field.
     *
     * Byte Control Signal Control
     */
    inline void set_BUSWCON3_BCGEN(EBU_BUSRCON0_BCGEN value) volatile
    {
        uint32_t curr = BUSWCON3;

        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(value) & 0b11u) << 20u;

        BUSWCON3 = curr;
    }

    /**
     * Get BUSWCON3's WAITINV bit.
     */
    inline EBU_BUSRCON0_WAITINV get_BUSWCON3_WAITINV() volatile
    {
        return EBU_BUSRCON0_WAITINV(BUSWCON3 & (1u << 19u));
    }

    /**
     * Set BUSWCON3's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void set_BUSWCON3_WAITINV() volatile
    {
        BUSWCON3 |= 1u << 19u;
    }

    /**
     * Clear BUSWCON3's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void clear_BUSWCON3_WAITINV() volatile
    {
        BUSWCON3 &= ~(1u << 19u);
    }

    /**
     * Toggle BUSWCON3's WAITINV bit.
     *
     * Reversed polarity at WAIT
     */
    inline void toggle_BUSWCON3_WAITINV() volatile
    {
        BUSWCON3 ^= 1u << 19u;
    }

    /**
     * Get BUSWCON3's EBSE bit.
     */
    inline EBU_BUSRCON0_EBSE get_BUSWCON3_EBSE() volatile
    {
        return EBU_BUSRCON0_EBSE(BUSWCON3 & (1u << 17u));
    }

    /**
     * Set BUSWCON3's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void set_BUSWCON3_EBSE() volatile
    {
        BUSWCON3 |= 1u << 17u;
    }

    /**
     * Clear BUSWCON3's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void clear_BUSWCON3_EBSE() volatile
    {
        BUSWCON3 &= ~(1u << 17u);
    }

    /**
     * Toggle BUSWCON3's EBSE bit.
     *
     * Early Burst Signal Enable for Synchronous Burst
     */
    inline void toggle_BUSWCON3_EBSE() volatile
    {
        BUSWCON3 ^= 1u << 17u;
    }

    /**
     * Get BUSWCON3's ECSE bit.
     */
    inline EBU_BUSRCON0_EBSE get_BUSWCON3_ECSE() volatile
    {
        return EBU_BUSRCON0_EBSE(BUSWCON3 & (1u << 16u));
    }

    /**
     * Set BUSWCON3's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void set_BUSWCON3_ECSE() volatile
    {
        BUSWCON3 |= 1u << 16u;
    }

    /**
     * Clear BUSWCON3's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void clear_BUSWCON3_ECSE() volatile
    {
        BUSWCON3 &= ~(1u << 16u);
    }

    /**
     * Toggle BUSWCON3's ECSE bit.
     *
     * Early Chip Select for Synchronous Burst
     */
    inline void toggle_BUSWCON3_ECSE() volatile
    {
        BUSWCON3 ^= 1u << 16u;
    }

    /**
     * Get BUSWCON3's NAA bit.
     */
    inline bool get_BUSWCON3_NAA() volatile
    {
        return BUSWCON3 & (1u << 7u);
    }

    /**
     * Get BUSWCON3's FBBMSEL bit.
     */
    inline EBU_BUSRCON0_FBBMSEL get_BUSWCON3_FBBMSEL() volatile
    {
        return EBU_BUSRCON0_FBBMSEL(BUSWCON3 & (1u << 3u));
    }

    /**
     * Set BUSWCON3's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void set_BUSWCON3_FBBMSEL() volatile
    {
        BUSWCON3 |= 1u << 3u;
    }

    /**
     * Clear BUSWCON3's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void clear_BUSWCON3_FBBMSEL() volatile
    {
        BUSWCON3 &= ~(1u << 3u);
    }

    /**
     * Toggle BUSWCON3's FBBMSEL bit.
     *
     * Synchronous burst buffer mode select
     */
    inline void toggle_BUSWCON3_FBBMSEL() volatile
    {
        BUSWCON3 ^= 1u << 3u;
    }

    /**
     * Get BUSWCON3's FETBLEN field.
     */
    inline EBU_BUSRCON0_FETBLEN get_BUSWCON3_FETBLEN() volatile
    {
        return EBU_BUSRCON0_FETBLEN((BUSWCON3 >> 0u) & 0b111u);
    }

    /**
     * Set BUSWCON3's FETBLEN field.
     *
     * Burst Length for Synchronous Burst
     */
    inline void set_BUSWCON3_FETBLEN(EBU_BUSRCON0_FETBLEN value) volatile
    {
        uint32_t curr = BUSWCON3;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        BUSWCON3 = curr;
    }

    /**
     * Get all of BUSWCON3's bit fields.
     */
    inline void get_BUSWCON3(uint8_t &AGEN, EBU_BUSWCON0_LOCKCS &LOCKCS,
                             EBU_BUSRCON0_AAP &AAP, uint8_t &WAIT,
                             uint8_t &PORTW, EBU_BUSRCON0_BCGEN &BCGEN,
                             EBU_BUSRCON0_WAITINV &WAITINV,
                             EBU_BUSRCON0_EBSE &EBSE, EBU_BUSRCON0_EBSE &ECSE,
                             bool &NAA, EBU_BUSRCON0_FBBMSEL &FBBMSEL,
                             EBU_BUSRCON0_FETBLEN &FETBLEN) volatile
    {
        uint32_t curr = BUSWCON3;

        AGEN = (curr >> 28u) & 0b1111u;
        LOCKCS = EBU_BUSWCON0_LOCKCS(curr & (1u << 27u));
        AAP = EBU_BUSRCON0_AAP(curr & (1u << 26u));
        WAIT = (curr >> 24u) & 0b11u;
        PORTW = (curr >> 22u) & 0b11u;
        BCGEN = EBU_BUSRCON0_BCGEN((curr >> 20u) & 0b11u);
        WAITINV = EBU_BUSRCON0_WAITINV(curr & (1u << 19u));
        EBSE = EBU_BUSRCON0_EBSE(curr & (1u << 17u));
        ECSE = EBU_BUSRCON0_EBSE(curr & (1u << 16u));
        NAA = curr & (1u << 7u);
        FBBMSEL = EBU_BUSRCON0_FBBMSEL(curr & (1u << 3u));
        FETBLEN = EBU_BUSRCON0_FETBLEN((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of BUSWCON3's bit fields.
     *
     * (read-write) EBU Bus Write Configuration Register
     */
    inline void set_BUSWCON3(uint8_t AGEN, EBU_BUSWCON0_LOCKCS LOCKCS,
                             EBU_BUSRCON0_AAP AAP, uint8_t WAIT,
                             EBU_BUSRCON0_BCGEN BCGEN,
                             EBU_BUSRCON0_WAITINV WAITINV,
                             EBU_BUSRCON0_EBSE EBSE, EBU_BUSRCON0_EBSE ECSE,
                             EBU_BUSRCON0_FBBMSEL FBBMSEL,
                             EBU_BUSRCON0_FETBLEN FETBLEN) volatile
    {
        uint32_t curr = BUSWCON3;

        curr &= ~(0b1111u << 28u);
        curr |= (AGEN & 0b1111u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (std::to_underlying(LOCKCS) & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (std::to_underlying(AAP) & 0b1u) << 26u;
        curr &= ~(0b11u << 24u);
        curr |= (WAIT & 0b11u) << 24u;
        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(BCGEN) & 0b11u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (std::to_underlying(WAITINV) & 0b1u) << 19u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(EBSE) & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (std::to_underlying(ECSE) & 0b1u) << 16u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(FBBMSEL) & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(FETBLEN) & 0b111u) << 0u;

        BUSWCON3 = curr;
    }

    /**
     * Get BUSWAP3's ADDRC field.
     */
    inline EBU_BUSRAP0_ADDRC get_BUSWAP3_ADDRC() volatile
    {
        return EBU_BUSRAP0_ADDRC((BUSWAP3 >> 28u) & 0b1111u);
    }

    /**
     * Set BUSWAP3's ADDRC field.
     *
     * Address Cycles
     */
    inline void set_BUSWAP3_ADDRC(EBU_BUSRAP0_ADDRC value) volatile
    {
        uint32_t curr = BUSWAP3;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(value) & 0b1111u) << 28u;

        BUSWAP3 = curr;
    }

    /**
     * Get BUSWAP3's AHOLDC field.
     */
    inline EBU_BUSRAP0_AHOLDC get_BUSWAP3_AHOLDC() volatile
    {
        return EBU_BUSRAP0_AHOLDC((BUSWAP3 >> 24u) & 0b1111u);
    }

    /**
     * Set BUSWAP3's AHOLDC field.
     *
     * Address Hold Cycles
     */
    inline void set_BUSWAP3_AHOLDC(EBU_BUSRAP0_AHOLDC value) volatile
    {
        uint32_t curr = BUSWAP3;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        BUSWAP3 = curr;
    }

    /**
     * Get BUSWAP3's CMDDELAY field.
     */
    inline EBU_BUSRAP0_AHOLDC get_BUSWAP3_CMDDELAY() volatile
    {
        return EBU_BUSRAP0_AHOLDC((BUSWAP3 >> 20u) & 0b1111u);
    }

    /**
     * Set BUSWAP3's CMDDELAY field.
     *
     * Command Delay Cycles
     */
    inline void set_BUSWAP3_CMDDELAY(EBU_BUSRAP0_AHOLDC value) volatile
    {
        uint32_t curr = BUSWAP3;

        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(value) & 0b1111u) << 20u;

        BUSWAP3 = curr;
    }

    /**
     * Get BUSWAP3's EXTDATA field.
     */
    inline EBU_BUSRAP0_EXTDATA get_BUSWAP3_EXTDATA() volatile
    {
        return EBU_BUSRAP0_EXTDATA((BUSWAP3 >> 18u) & 0b11u);
    }

    /**
     * Set BUSWAP3's EXTDATA field.
     *
     * Extended data
     */
    inline void set_BUSWAP3_EXTDATA(EBU_BUSRAP0_EXTDATA value) volatile
    {
        uint32_t curr = BUSWAP3;

        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(value) & 0b11u) << 18u;

        BUSWAP3 = curr;
    }

    /**
     * Get BUSWAP3's EXTCLOCK field.
     */
    inline EBU_BUSRAP0_EXTCLOCK get_BUSWAP3_EXTCLOCK() volatile
    {
        return EBU_BUSRAP0_EXTCLOCK((BUSWAP3 >> 16u) & 0b11u);
    }

    /**
     * Set BUSWAP3's EXTCLOCK field.
     *
     * Frequency of external clock at pin BFCLKO
     */
    inline void set_BUSWAP3_EXTCLOCK(EBU_BUSRAP0_EXTCLOCK value) volatile
    {
        uint32_t curr = BUSWAP3;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        BUSWAP3 = curr;
    }

    /**
     * Get BUSWAP3's DATAC field.
     */
    inline EBU_BUSRAP0_RDDTACS get_BUSWAP3_DATAC() volatile
    {
        return EBU_BUSRAP0_RDDTACS((BUSWAP3 >> 12u) & 0b1111u);
    }

    /**
     * Set BUSWAP3's DATAC field.
     *
     * Data Hold Cycles for Write Accesses
     */
    inline void set_BUSWAP3_DATAC(EBU_BUSRAP0_RDDTACS value) volatile
    {
        uint32_t curr = BUSWAP3;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(value) & 0b1111u) << 12u;

        BUSWAP3 = curr;
    }

    /**
     * Get BUSWAP3's WAITWRC field.
     */
    inline EBU_BUSRAP0_WAITRDC get_BUSWAP3_WAITWRC() volatile
    {
        return EBU_BUSRAP0_WAITRDC((BUSWAP3 >> 7u) & 0b11111u);
    }

    /**
     * Set BUSWAP3's WAITWRC field.
     *
     * Programmed Wait States for write accesses
     */
    inline void set_BUSWAP3_WAITWRC(EBU_BUSRAP0_WAITRDC value) volatile
    {
        uint32_t curr = BUSWAP3;

        curr &= ~(0b11111u << 7u);
        curr |= (std::to_underlying(value) & 0b11111u) << 7u;

        BUSWAP3 = curr;
    }

    /**
     * Get BUSWAP3's WRRECOVC field.
     */
    inline EBU_BUSRAP0_RDRECOVC get_BUSWAP3_WRRECOVC() volatile
    {
        return EBU_BUSRAP0_RDRECOVC((BUSWAP3 >> 4u) & 0b111u);
    }

    /**
     * Set BUSWAP3's WRRECOVC field.
     *
     * Recovery Cycles after Write Accesses
     */
    inline void set_BUSWAP3_WRRECOVC(EBU_BUSRAP0_RDRECOVC value) volatile
    {
        uint32_t curr = BUSWAP3;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        BUSWAP3 = curr;
    }

    /**
     * Get BUSWAP3's WRDTACS field.
     */
    inline EBU_BUSRAP0_RDDTACS get_BUSWAP3_WRDTACS() volatile
    {
        return EBU_BUSRAP0_RDDTACS((BUSWAP3 >> 0u) & 0b1111u);
    }

    /**
     * Set BUSWAP3's WRDTACS field.
     *
     * Recovery Cycles between Different Regions
     */
    inline void set_BUSWAP3_WRDTACS(EBU_BUSRAP0_RDDTACS value) volatile
    {
        uint32_t curr = BUSWAP3;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        BUSWAP3 = curr;
    }

    /**
     * Get all of BUSWAP3's bit fields.
     */
    inline void get_BUSWAP3(
        EBU_BUSRAP0_ADDRC &ADDRC, EBU_BUSRAP0_AHOLDC &AHOLDC,
        EBU_BUSRAP0_AHOLDC &CMDDELAY, EBU_BUSRAP0_EXTDATA &EXTDATA,
        EBU_BUSRAP0_EXTCLOCK &EXTCLOCK, EBU_BUSRAP0_RDDTACS &DATAC,
        EBU_BUSRAP0_WAITRDC &WAITWRC, EBU_BUSRAP0_RDRECOVC &WRRECOVC,
        EBU_BUSRAP0_RDDTACS &WRDTACS) volatile
    {
        uint32_t curr = BUSWAP3;

        ADDRC = EBU_BUSRAP0_ADDRC((curr >> 28u) & 0b1111u);
        AHOLDC = EBU_BUSRAP0_AHOLDC((curr >> 24u) & 0b1111u);
        CMDDELAY = EBU_BUSRAP0_AHOLDC((curr >> 20u) & 0b1111u);
        EXTDATA = EBU_BUSRAP0_EXTDATA((curr >> 18u) & 0b11u);
        EXTCLOCK = EBU_BUSRAP0_EXTCLOCK((curr >> 16u) & 0b11u);
        DATAC = EBU_BUSRAP0_RDDTACS((curr >> 12u) & 0b1111u);
        WAITWRC = EBU_BUSRAP0_WAITRDC((curr >> 7u) & 0b11111u);
        WRRECOVC = EBU_BUSRAP0_RDRECOVC((curr >> 4u) & 0b111u);
        WRDTACS = EBU_BUSRAP0_RDDTACS((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of BUSWAP3's bit fields.
     *
     * (read-write) EBU Bus Write Access Parameter Register
     */
    inline void set_BUSWAP3(EBU_BUSRAP0_ADDRC ADDRC, EBU_BUSRAP0_AHOLDC AHOLDC,
                            EBU_BUSRAP0_AHOLDC CMDDELAY,
                            EBU_BUSRAP0_EXTDATA EXTDATA,
                            EBU_BUSRAP0_EXTCLOCK EXTCLOCK,
                            EBU_BUSRAP0_RDDTACS DATAC,
                            EBU_BUSRAP0_WAITRDC WAITWRC,
                            EBU_BUSRAP0_RDRECOVC WRRECOVC,
                            EBU_BUSRAP0_RDDTACS WRDTACS) volatile
    {
        uint32_t curr = BUSWAP3;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(ADDRC) & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(AHOLDC) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(CMDDELAY) & 0b1111u) << 20u;
        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(EXTDATA) & 0b11u) << 18u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(EXTCLOCK) & 0b11u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(DATAC) & 0b1111u) << 12u;
        curr &= ~(0b11111u << 7u);
        curr |= (std::to_underlying(WAITWRC) & 0b11111u) << 7u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(WRRECOVC) & 0b111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(WRDTACS) & 0b1111u) << 0u;

        BUSWAP3 = curr;
    }

    /**
     * Get SDRMCON's CRAS field.
     */
    inline uint8_t get_SDRMCON_CRAS() volatile
    {
        return (SDRMCON >> 0u) & 0b1111u;
    }

    /**
     * Set SDRMCON's CRAS field.
     *
     * Row to precharge delay counter
     */
    inline void set_SDRMCON_CRAS(uint8_t value) volatile
    {
        uint32_t curr = SDRMCON;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        SDRMCON = curr;
    }

    /**
     * Get SDRMCON's CRFSH field.
     */
    inline uint8_t get_SDRMCON_CRFSH() volatile
    {
        return (SDRMCON >> 4u) & 0b1111u;
    }

    /**
     * Set SDRMCON's CRFSH field.
     *
     * Initialization refresh commands counter
     */
    inline void set_SDRMCON_CRFSH(uint8_t value) volatile
    {
        uint32_t curr = SDRMCON;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        SDRMCON = curr;
    }

    /**
     * Get SDRMCON's CRSC field.
     */
    inline uint8_t get_SDRMCON_CRSC() volatile
    {
        return (SDRMCON >> 8u) & 0b11u;
    }

    /**
     * Set SDRMCON's CRSC field.
     *
     * Mode register set-up time
     */
    inline void set_SDRMCON_CRSC(uint8_t value) volatile
    {
        uint32_t curr = SDRMCON;

        curr &= ~(0b11u << 8u);
        curr |= (value & 0b11u) << 8u;

        SDRMCON = curr;
    }

    /**
     * Get SDRMCON's CRP field.
     */
    inline uint8_t get_SDRMCON_CRP() volatile
    {
        return (SDRMCON >> 10u) & 0b11u;
    }

    /**
     * Set SDRMCON's CRP field.
     *
     * Row precharge time counter
     */
    inline void set_SDRMCON_CRP(uint8_t value) volatile
    {
        uint32_t curr = SDRMCON;

        curr &= ~(0b11u << 10u);
        curr |= (value & 0b11u) << 10u;

        SDRMCON = curr;
    }

    /**
     * Get SDRMCON's AWIDTH field.
     */
    inline EBU_SDRMCON_AWIDTH get_SDRMCON_AWIDTH() volatile
    {
        return EBU_SDRMCON_AWIDTH((SDRMCON >> 12u) & 0b11u);
    }

    /**
     * Set SDRMCON's AWIDTH field.
     *
     * Width of column address
     */
    inline void set_SDRMCON_AWIDTH(EBU_SDRMCON_AWIDTH value) volatile
    {
        uint32_t curr = SDRMCON;

        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(value) & 0b11u) << 12u;

        SDRMCON = curr;
    }

    /**
     * Get SDRMCON's CRCD field.
     */
    inline uint8_t get_SDRMCON_CRCD() volatile
    {
        return (SDRMCON >> 14u) & 0b11u;
    }

    /**
     * Set SDRMCON's CRCD field.
     *
     * Row to column delay counter
     */
    inline void set_SDRMCON_CRCD(uint8_t value) volatile
    {
        uint32_t curr = SDRMCON;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        SDRMCON = curr;
    }

    /**
     * Get SDRMCON's CRC field.
     */
    inline uint8_t get_SDRMCON_CRC() volatile
    {
        return (SDRMCON >> 16u) & 0b111u;
    }

    /**
     * Set SDRMCON's CRC field.
     *
     * Row cycle time counter
     */
    inline void set_SDRMCON_CRC(uint8_t value) volatile
    {
        uint32_t curr = SDRMCON;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        SDRMCON = curr;
    }

    /**
     * Get SDRMCON's ROWM field.
     */
    inline EBU_SDRMCON_ROWM get_SDRMCON_ROWM() volatile
    {
        return EBU_SDRMCON_ROWM((SDRMCON >> 19u) & 0b111u);
    }

    /**
     * Set SDRMCON's ROWM field.
     *
     * Mask for row tag
     */
    inline void set_SDRMCON_ROWM(EBU_SDRMCON_ROWM value) volatile
    {
        uint32_t curr = SDRMCON;

        curr &= ~(0b111u << 19u);
        curr |= (std::to_underlying(value) & 0b111u) << 19u;

        SDRMCON = curr;
    }

    /**
     * Get SDRMCON's BANKM field.
     */
    inline EBU_SDRMCON_BANKM get_SDRMCON_BANKM() volatile
    {
        return EBU_SDRMCON_BANKM((SDRMCON >> 22u) & 0b111u);
    }

    /**
     * Set SDRMCON's BANKM field.
     *
     * Mask for bank tag
     */
    inline void set_SDRMCON_BANKM(EBU_SDRMCON_BANKM value) volatile
    {
        uint32_t curr = SDRMCON;

        curr &= ~(0b111u << 22u);
        curr |= (std::to_underlying(value) & 0b111u) << 22u;

        SDRMCON = curr;
    }

    /**
     * Get SDRMCON's CRCE field.
     */
    inline uint8_t get_SDRMCON_CRCE() volatile
    {
        return (SDRMCON >> 25u) & 0b111u;
    }

    /**
     * Set SDRMCON's CRCE field.
     *
     * Row cycle time counter extension
     */
    inline void set_SDRMCON_CRCE(uint8_t value) volatile
    {
        uint32_t curr = SDRMCON;

        curr &= ~(0b111u << 25u);
        curr |= (value & 0b111u) << 25u;

        SDRMCON = curr;
    }

    /**
     * Get SDRMCON's CLKDIS bit.
     */
    inline EBU_SDRMCON_CLKDIS get_SDRMCON_CLKDIS() volatile
    {
        return EBU_SDRMCON_CLKDIS(SDRMCON & (1u << 28u));
    }

    /**
     * Set SDRMCON's CLKDIS bit.
     *
     * Disable SDRAM clock output
     */
    inline void set_SDRMCON_CLKDIS() volatile
    {
        SDRMCON |= 1u << 28u;
    }

    /**
     * Clear SDRMCON's CLKDIS bit.
     *
     * Disable SDRAM clock output
     */
    inline void clear_SDRMCON_CLKDIS() volatile
    {
        SDRMCON &= ~(1u << 28u);
    }

    /**
     * Toggle SDRMCON's CLKDIS bit.
     *
     * Disable SDRAM clock output
     */
    inline void toggle_SDRMCON_CLKDIS() volatile
    {
        SDRMCON ^= 1u << 28u;
    }

    /**
     * Get SDRMCON's PWR_MODE field.
     */
    inline EBU_SDRMCON_PWR_MODE get_SDRMCON_PWR_MODE() volatile
    {
        return EBU_SDRMCON_PWR_MODE((SDRMCON >> 29u) & 0b11u);
    }

    /**
     * Set SDRMCON's PWR_MODE field.
     *
     * Power Save Mode used for gated clock mode
     */
    inline void set_SDRMCON_PWR_MODE(EBU_SDRMCON_PWR_MODE value) volatile
    {
        uint32_t curr = SDRMCON;

        curr &= ~(0b11u << 29u);
        curr |= (std::to_underlying(value) & 0b11u) << 29u;

        SDRMCON = curr;
    }

    /**
     * Get SDRMCON's SDCMSEL bit.
     */
    inline EBU_SDRMCON_SDCMSEL get_SDRMCON_SDCMSEL() volatile
    {
        return EBU_SDRMCON_SDCMSEL(SDRMCON & (1u << 31u));
    }

    /**
     * Set SDRMCON's SDCMSEL bit.
     *
     * SDRAM clock mode select
     */
    inline void set_SDRMCON_SDCMSEL() volatile
    {
        SDRMCON |= 1u << 31u;
    }

    /**
     * Clear SDRMCON's SDCMSEL bit.
     *
     * SDRAM clock mode select
     */
    inline void clear_SDRMCON_SDCMSEL() volatile
    {
        SDRMCON &= ~(1u << 31u);
    }

    /**
     * Toggle SDRMCON's SDCMSEL bit.
     *
     * SDRAM clock mode select
     */
    inline void toggle_SDRMCON_SDCMSEL() volatile
    {
        SDRMCON ^= 1u << 31u;
    }

    /**
     * Get all of SDRMCON's bit fields.
     */
    inline void get_SDRMCON(uint8_t &CRAS, uint8_t &CRFSH, uint8_t &CRSC,
                            uint8_t &CRP, EBU_SDRMCON_AWIDTH &AWIDTH,
                            uint8_t &CRCD, uint8_t &CRC,
                            EBU_SDRMCON_ROWM &ROWM, EBU_SDRMCON_BANKM &BANKM,
                            uint8_t &CRCE, EBU_SDRMCON_CLKDIS &CLKDIS,
                            EBU_SDRMCON_PWR_MODE &PWR_MODE,
                            EBU_SDRMCON_SDCMSEL &SDCMSEL) volatile
    {
        uint32_t curr = SDRMCON;

        CRAS = (curr >> 0u) & 0b1111u;
        CRFSH = (curr >> 4u) & 0b1111u;
        CRSC = (curr >> 8u) & 0b11u;
        CRP = (curr >> 10u) & 0b11u;
        AWIDTH = EBU_SDRMCON_AWIDTH((curr >> 12u) & 0b11u);
        CRCD = (curr >> 14u) & 0b11u;
        CRC = (curr >> 16u) & 0b111u;
        ROWM = EBU_SDRMCON_ROWM((curr >> 19u) & 0b111u);
        BANKM = EBU_SDRMCON_BANKM((curr >> 22u) & 0b111u);
        CRCE = (curr >> 25u) & 0b111u;
        CLKDIS = EBU_SDRMCON_CLKDIS(curr & (1u << 28u));
        PWR_MODE = EBU_SDRMCON_PWR_MODE((curr >> 29u) & 0b11u);
        SDCMSEL = EBU_SDRMCON_SDCMSEL(curr & (1u << 31u));
    }

    /**
     * Set all of SDRMCON's bit fields.
     *
     * (read-write) EBU SDRAM Control Register
     */
    inline void set_SDRMCON(uint8_t CRAS, uint8_t CRFSH, uint8_t CRSC,
                            uint8_t CRP, EBU_SDRMCON_AWIDTH AWIDTH,
                            uint8_t CRCD, uint8_t CRC, EBU_SDRMCON_ROWM ROWM,
                            EBU_SDRMCON_BANKM BANKM, uint8_t CRCE,
                            EBU_SDRMCON_CLKDIS CLKDIS,
                            EBU_SDRMCON_PWR_MODE PWR_MODE,
                            EBU_SDRMCON_SDCMSEL SDCMSEL) volatile
    {
        uint32_t curr = SDRMCON;

        curr &= ~(0b1111u << 0u);
        curr |= (CRAS & 0b1111u) << 0u;
        curr &= ~(0b1111u << 4u);
        curr |= (CRFSH & 0b1111u) << 4u;
        curr &= ~(0b11u << 8u);
        curr |= (CRSC & 0b11u) << 8u;
        curr &= ~(0b11u << 10u);
        curr |= (CRP & 0b11u) << 10u;
        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(AWIDTH) & 0b11u) << 12u;
        curr &= ~(0b11u << 14u);
        curr |= (CRCD & 0b11u) << 14u;
        curr &= ~(0b111u << 16u);
        curr |= (CRC & 0b111u) << 16u;
        curr &= ~(0b111u << 19u);
        curr |= (std::to_underlying(ROWM) & 0b111u) << 19u;
        curr &= ~(0b111u << 22u);
        curr |= (std::to_underlying(BANKM) & 0b111u) << 22u;
        curr &= ~(0b111u << 25u);
        curr |= (CRCE & 0b111u) << 25u;
        curr &= ~(0b1u << 28u);
        curr |= (std::to_underlying(CLKDIS) & 0b1u) << 28u;
        curr &= ~(0b11u << 29u);
        curr |= (std::to_underlying(PWR_MODE) & 0b11u) << 29u;
        curr &= ~(0b1u << 31u);
        curr |= (std::to_underlying(SDCMSEL) & 0b1u) << 31u;

        SDRMCON = curr;
    }

    /**
     * Get SDRMOD's BURSTL field.
     */
    inline EBU_SDRMOD_BURSTL get_SDRMOD_BURSTL() volatile
    {
        return EBU_SDRMOD_BURSTL((SDRMOD >> 0u) & 0b111u);
    }

    /**
     * Set SDRMOD's BURSTL field.
     *
     * Burst length
     */
    inline void set_SDRMOD_BURSTL(EBU_SDRMOD_BURSTL value) volatile
    {
        uint32_t curr = SDRMOD;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        SDRMOD = curr;
    }

    /**
     * Get SDRMOD's BTYP bit.
     */
    inline EBU_SDRMOD_BTYP get_SDRMOD_BTYP() volatile
    {
        return EBU_SDRMOD_BTYP(SDRMOD & (1u << 3u));
    }

    /**
     * Set SDRMOD's BTYP bit.
     *
     * Burst type
     */
    inline void set_SDRMOD_BTYP() volatile
    {
        SDRMOD |= 1u << 3u;
    }

    /**
     * Clear SDRMOD's BTYP bit.
     *
     * Burst type
     */
    inline void clear_SDRMOD_BTYP() volatile
    {
        SDRMOD &= ~(1u << 3u);
    }

    /**
     * Toggle SDRMOD's BTYP bit.
     *
     * Burst type
     */
    inline void toggle_SDRMOD_BTYP() volatile
    {
        SDRMOD ^= 1u << 3u;
    }

    /**
     * Get SDRMOD's CASLAT field.
     */
    inline EBU_SDRMOD_CASLAT get_SDRMOD_CASLAT() volatile
    {
        return EBU_SDRMOD_CASLAT((SDRMOD >> 4u) & 0b111u);
    }

    /**
     * Set SDRMOD's CASLAT field.
     *
     * CAS latency
     */
    inline void set_SDRMOD_CASLAT(EBU_SDRMOD_CASLAT value) volatile
    {
        uint32_t curr = SDRMOD;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        SDRMOD = curr;
    }

    /**
     * Get SDRMOD's OPMODE field.
     */
    inline EBU_SDRMOD_OPMODE get_SDRMOD_OPMODE() volatile
    {
        return EBU_SDRMOD_OPMODE((SDRMOD >> 7u) & 0b1111111u);
    }

    /**
     * Set SDRMOD's OPMODE field.
     *
     * Operation Mode
     */
    inline void set_SDRMOD_OPMODE(EBU_SDRMOD_OPMODE value) volatile
    {
        uint32_t curr = SDRMOD;

        curr &= ~(0b1111111u << 7u);
        curr |= (std::to_underlying(value) & 0b1111111u) << 7u;

        SDRMOD = curr;
    }

    /**
     * Set SDRMOD's COLDSTART bit.
     *
     * SDRAM coldstart
     */
    inline void set_SDRMOD_COLDSTART() volatile
    {
        SDRMOD |= 1u << 15u;
    }

    /**
     * Clear SDRMOD's COLDSTART bit.
     *
     * SDRAM coldstart
     */
    inline void clear_SDRMOD_COLDSTART() volatile
    {
        SDRMOD &= ~(1u << 15u);
    }

    /**
     * Toggle SDRMOD's COLDSTART bit.
     *
     * SDRAM coldstart
     */
    inline void toggle_SDRMOD_COLDSTART() volatile
    {
        SDRMOD ^= 1u << 15u;
    }

    /**
     * Get SDRMOD's XOPM field.
     */
    inline uint16_t get_SDRMOD_XOPM() volatile
    {
        return (SDRMOD >> 16u) & 0b111111111111u;
    }

    /**
     * Set SDRMOD's XOPM field.
     *
     * Extended Operation Mode
     */
    inline void set_SDRMOD_XOPM(uint16_t value) volatile
    {
        uint32_t curr = SDRMOD;

        curr &= ~(0b111111111111u << 16u);
        curr |= (value & 0b111111111111u) << 16u;

        SDRMOD = curr;
    }

    /**
     * Get SDRMOD's XBA field.
     */
    inline uint8_t get_SDRMOD_XBA() volatile
    {
        return (SDRMOD >> 28u) & 0b1111u;
    }

    /**
     * Set SDRMOD's XBA field.
     *
     * Extended Operation Bank Select
     */
    inline void set_SDRMOD_XBA(uint8_t value) volatile
    {
        uint32_t curr = SDRMOD;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        SDRMOD = curr;
    }

    /**
     * Get all of SDRMOD's bit fields.
     */
    inline void get_SDRMOD(EBU_SDRMOD_BURSTL &BURSTL, EBU_SDRMOD_BTYP &BTYP,
                           EBU_SDRMOD_CASLAT &CASLAT,
                           EBU_SDRMOD_OPMODE &OPMODE, uint16_t &XOPM,
                           uint8_t &XBA) volatile
    {
        uint32_t curr = SDRMOD;

        BURSTL = EBU_SDRMOD_BURSTL((curr >> 0u) & 0b111u);
        BTYP = EBU_SDRMOD_BTYP(curr & (1u << 3u));
        CASLAT = EBU_SDRMOD_CASLAT((curr >> 4u) & 0b111u);
        OPMODE = EBU_SDRMOD_OPMODE((curr >> 7u) & 0b1111111u);
        XOPM = (curr >> 16u) & 0b111111111111u;
        XBA = (curr >> 28u) & 0b1111u;
    }

    /**
     * Set all of SDRMOD's bit fields.
     *
     * (read-write) EBU SDRAM Mode Register
     */
    inline void set_SDRMOD(EBU_SDRMOD_BURSTL BURSTL, EBU_SDRMOD_BTYP BTYP,
                           EBU_SDRMOD_CASLAT CASLAT, EBU_SDRMOD_OPMODE OPMODE,
                           bool COLDSTART, uint16_t XOPM, uint8_t XBA) volatile
    {
        uint32_t curr = SDRMOD;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(BURSTL) & 0b111u) << 0u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(BTYP) & 0b1u) << 3u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(CASLAT) & 0b111u) << 4u;
        curr &= ~(0b1111111u << 7u);
        curr |= (std::to_underlying(OPMODE) & 0b1111111u) << 7u;
        curr &= ~(0b1u << 15u);
        curr |= (COLDSTART & 0b1u) << 15u;
        curr &= ~(0b111111111111u << 16u);
        curr |= (XOPM & 0b111111111111u) << 16u;
        curr &= ~(0b1111u << 28u);
        curr |= (XBA & 0b1111u) << 28u;

        SDRMOD = curr;
    }

    /**
     * Get SDRMREF's REFRESHC field.
     */
    inline uint8_t get_SDRMREF_REFRESHC() volatile
    {
        return (SDRMREF >> 0u) & 0b111111u;
    }

    /**
     * Set SDRMREF's REFRESHC field.
     *
     * Refresh counter period
     */
    inline void set_SDRMREF_REFRESHC(uint8_t value) volatile
    {
        uint32_t curr = SDRMREF;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        SDRMREF = curr;
    }

    /**
     * Get SDRMREF's REFRESHR field.
     */
    inline uint8_t get_SDRMREF_REFRESHR() volatile
    {
        return (SDRMREF >> 6u) & 0b111u;
    }

    /**
     * Set SDRMREF's REFRESHR field.
     *
     * Number of refresh commands
     */
    inline void set_SDRMREF_REFRESHR(uint8_t value) volatile
    {
        uint32_t curr = SDRMREF;

        curr &= ~(0b111u << 6u);
        curr |= (value & 0b111u) << 6u;

        SDRMREF = curr;
    }

    /**
     * Get SDRMREF's SELFREXST bit.
     */
    inline bool get_SDRMREF_SELFREXST() volatile
    {
        return SDRMREF & (1u << 9u);
    }

    /**
     * Get SDRMREF's SELFREX bit.
     */
    inline bool get_SDRMREF_SELFREX() volatile
    {
        return SDRMREF & (1u << 10u);
    }

    /**
     * Set SDRMREF's SELFREX bit.
     *
     * Self Refresh Exit (Power Up).
     */
    inline void set_SDRMREF_SELFREX() volatile
    {
        SDRMREF |= 1u << 10u;
    }

    /**
     * Clear SDRMREF's SELFREX bit.
     *
     * Self Refresh Exit (Power Up).
     */
    inline void clear_SDRMREF_SELFREX() volatile
    {
        SDRMREF &= ~(1u << 10u);
    }

    /**
     * Toggle SDRMREF's SELFREX bit.
     *
     * Self Refresh Exit (Power Up).
     */
    inline void toggle_SDRMREF_SELFREX() volatile
    {
        SDRMREF ^= 1u << 10u;
    }

    /**
     * Get SDRMREF's SELFRENST bit.
     */
    inline bool get_SDRMREF_SELFRENST() volatile
    {
        return SDRMREF & (1u << 11u);
    }

    /**
     * Get SDRMREF's SELFREN bit.
     */
    inline bool get_SDRMREF_SELFREN() volatile
    {
        return SDRMREF & (1u << 12u);
    }

    /**
     * Set SDRMREF's SELFREN bit.
     *
     * Self Refresh Entry
     */
    inline void set_SDRMREF_SELFREN() volatile
    {
        SDRMREF |= 1u << 12u;
    }

    /**
     * Clear SDRMREF's SELFREN bit.
     *
     * Self Refresh Entry
     */
    inline void clear_SDRMREF_SELFREN() volatile
    {
        SDRMREF &= ~(1u << 12u);
    }

    /**
     * Toggle SDRMREF's SELFREN bit.
     *
     * Self Refresh Entry
     */
    inline void toggle_SDRMREF_SELFREN() volatile
    {
        SDRMREF ^= 1u << 12u;
    }

    /**
     * Get SDRMREF's AUTOSELFR bit.
     */
    inline bool get_SDRMREF_AUTOSELFR() volatile
    {
        return SDRMREF & (1u << 13u);
    }

    /**
     * Set SDRMREF's AUTOSELFR bit.
     *
     * Automatic Self Refresh
     */
    inline void set_SDRMREF_AUTOSELFR() volatile
    {
        SDRMREF |= 1u << 13u;
    }

    /**
     * Clear SDRMREF's AUTOSELFR bit.
     *
     * Automatic Self Refresh
     */
    inline void clear_SDRMREF_AUTOSELFR() volatile
    {
        SDRMREF &= ~(1u << 13u);
    }

    /**
     * Toggle SDRMREF's AUTOSELFR bit.
     *
     * Automatic Self Refresh
     */
    inline void toggle_SDRMREF_AUTOSELFR() volatile
    {
        SDRMREF ^= 1u << 13u;
    }

    /**
     * Get SDRMREF's ERFSHC field.
     */
    inline uint8_t get_SDRMREF_ERFSHC() volatile
    {
        return (SDRMREF >> 14u) & 0b11u;
    }

    /**
     * Set SDRMREF's ERFSHC field.
     *
     * Extended Refresh Counter Period
     */
    inline void set_SDRMREF_ERFSHC(uint8_t value) volatile
    {
        uint32_t curr = SDRMREF;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        SDRMREF = curr;
    }

    /**
     * Get SDRMREF's SELFREX_DLY field.
     */
    inline uint8_t get_SDRMREF_SELFREX_DLY() volatile
    {
        return (SDRMREF >> 16u) & 0b11111111u;
    }

    /**
     * Set SDRMREF's SELFREX_DLY field.
     *
     * Self Refresh Exit Delay
     */
    inline void set_SDRMREF_SELFREX_DLY(uint8_t value) volatile
    {
        uint32_t curr = SDRMREF;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        SDRMREF = curr;
    }

    /**
     * Get SDRMREF's ARFSH bit.
     */
    inline bool get_SDRMREF_ARFSH() volatile
    {
        return SDRMREF & (1u << 24u);
    }

    /**
     * Set SDRMREF's ARFSH bit.
     *
     * Auto Refresh on Self refresh Exit
     */
    inline void set_SDRMREF_ARFSH() volatile
    {
        SDRMREF |= 1u << 24u;
    }

    /**
     * Clear SDRMREF's ARFSH bit.
     *
     * Auto Refresh on Self refresh Exit
     */
    inline void clear_SDRMREF_ARFSH() volatile
    {
        SDRMREF &= ~(1u << 24u);
    }

    /**
     * Toggle SDRMREF's ARFSH bit.
     *
     * Auto Refresh on Self refresh Exit
     */
    inline void toggle_SDRMREF_ARFSH() volatile
    {
        SDRMREF ^= 1u << 24u;
    }

    /**
     * Get SDRMREF's RES_DLY field.
     */
    inline uint8_t get_SDRMREF_RES_DLY() volatile
    {
        return (SDRMREF >> 25u) & 0b111u;
    }

    /**
     * Set SDRMREF's RES_DLY field.
     *
     * Delay on Power Down Exit
     */
    inline void set_SDRMREF_RES_DLY(uint8_t value) volatile
    {
        uint32_t curr = SDRMREF;

        curr &= ~(0b111u << 25u);
        curr |= (value & 0b111u) << 25u;

        SDRMREF = curr;
    }

    /**
     * Get all of SDRMREF's bit fields.
     */
    inline void get_SDRMREF(uint8_t &REFRESHC, uint8_t &REFRESHR,
                            bool &SELFREXST, bool &SELFREX, bool &SELFRENST,
                            bool &SELFREN, bool &AUTOSELFR, uint8_t &ERFSHC,
                            uint8_t &SELFREX_DLY, bool &ARFSH,
                            uint8_t &RES_DLY) volatile
    {
        uint32_t curr = SDRMREF;

        REFRESHC = (curr >> 0u) & 0b111111u;
        REFRESHR = (curr >> 6u) & 0b111u;
        SELFREXST = curr & (1u << 9u);
        SELFREX = curr & (1u << 10u);
        SELFRENST = curr & (1u << 11u);
        SELFREN = curr & (1u << 12u);
        AUTOSELFR = curr & (1u << 13u);
        ERFSHC = (curr >> 14u) & 0b11u;
        SELFREX_DLY = (curr >> 16u) & 0b11111111u;
        ARFSH = curr & (1u << 24u);
        RES_DLY = (curr >> 25u) & 0b111u;
    }

    /**
     * Set all of SDRMREF's bit fields.
     *
     * (read-write) EBU SDRAM Refresh Control Register
     */
    inline void set_SDRMREF(uint8_t REFRESHC, uint8_t REFRESHR, bool SELFREX,
                            bool SELFREN, bool AUTOSELFR, uint8_t ERFSHC,
                            uint8_t SELFREX_DLY, bool ARFSH,
                            uint8_t RES_DLY) volatile
    {
        uint32_t curr = SDRMREF;

        curr &= ~(0b111111u << 0u);
        curr |= (REFRESHC & 0b111111u) << 0u;
        curr &= ~(0b111u << 6u);
        curr |= (REFRESHR & 0b111u) << 6u;
        curr &= ~(0b1u << 10u);
        curr |= (SELFREX & 0b1u) << 10u;
        curr &= ~(0b1u << 12u);
        curr |= (SELFREN & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (AUTOSELFR & 0b1u) << 13u;
        curr &= ~(0b11u << 14u);
        curr |= (ERFSHC & 0b11u) << 14u;
        curr &= ~(0b11111111u << 16u);
        curr |= (SELFREX_DLY & 0b11111111u) << 16u;
        curr &= ~(0b1u << 24u);
        curr |= (ARFSH & 0b1u) << 24u;
        curr &= ~(0b111u << 25u);
        curr |= (RES_DLY & 0b111u) << 25u;

        SDRMREF = curr;
    }

    /**
     * Get SDRSTAT's REFERR bit.
     */
    inline EBU_SDRSTAT_REFERR get_SDRSTAT_REFERR() volatile
    {
        return EBU_SDRSTAT_REFERR(SDRSTAT & (1u << 0u));
    }

    /**
     * Get SDRSTAT's SDRMBUSY bit.
     */
    inline EBU_SDRSTAT_SDRMBUSY get_SDRSTAT_SDRMBUSY() volatile
    {
        return EBU_SDRSTAT_SDRMBUSY(SDRSTAT & (1u << 1u));
    }

    /**
     * Get SDRSTAT's SDERR bit.
     */
    inline EBU_SDRSTAT_SDERR get_SDRSTAT_SDERR() volatile
    {
        return EBU_SDRSTAT_SDERR(SDRSTAT & (1u << 2u));
    }

    /**
     * Get all of SDRSTAT's bit fields.
     */
    inline void get_SDRSTAT(EBU_SDRSTAT_REFERR &REFERR,
                            EBU_SDRSTAT_SDRMBUSY &SDRMBUSY,
                            EBU_SDRSTAT_SDERR &SDERR) volatile
    {
        uint32_t curr = SDRSTAT;

        REFERR = EBU_SDRSTAT_REFERR(curr & (1u << 0u));
        SDRMBUSY = EBU_SDRSTAT_SDRMBUSY(curr & (1u << 1u));
        SDERR = EBU_SDRSTAT_SDERR(curr & (1u << 2u));
    }
};

static_assert(sizeof(ebu) == ebu::size);

static volatile ebu *const EBU = reinterpret_cast<ebu *>(0x58008000);

}; // namespace XMC4700
