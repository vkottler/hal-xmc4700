/**
 * \file
 * \brief Generated by ifgen (3.2.0).
 */
#pragma once

#include "../enums/VADC_G0_ARBCFG_ANONS.h"
#include "../enums/VADC_G0_ARBCFG_ARBRND.h"
#include "../enums/VADC_G0_ARBPR_PRIO2.h"
#include "../enums/VADC_G0_ASMR_ENGT.h"
#include "../enums/VADC_G0_BFLC_BFM3.h"
#include "../enums/VADC_G0_BFLNP_BFL3NP.h"
#include "../enums/VADC_G0_CEVNP0_CEV7NP.h"
#include "../enums/VADC_G0_CHCTR_BNDSELU.h"
#include "../enums/VADC_G0_CHCTR_BWDCH.h"
#include "../enums/VADC_G0_CHCTR_CHEVMODE.h"
#include "../enums/VADC_G0_CHCTR_ICLSEL.h"
#include "../enums/VADC_G0_CHCTR_RESREG.h"
#include "../enums/VADC_G0_EMUXCTR_EMUXMODE.h"
#include "../enums/VADC_G0_ICLASS_CME.h"
#include "../enums/VADC_G0_QCTRL0_SRCRESREG.h"
#include "../enums/VADC_G0_QCTRL0_XTMODE.h"
#include "../enums/VADC_G0_QMR0_ENGT.h"
#include "../enums/VADC_G0_QSR0_FILL.h"
#include "../enums/VADC_G0_RCR_DMM.h"
#include "../enums/VADC_G0_RCR_FEN.h"
#include "../enums/VADC_G0_RES_CRS.h"
#include "../enums/VADC_G0_SYNCTR_STSEL.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * Analog to Digital Converter
 */
struct [[gnu::packed]] vadc_g0
{
    /* Constant attributes. */
    static constexpr std::size_t size = 960; /*!< vadc_g0's size in bytes. */

    /* Fields. */
    union {
        uint32_t QINR0;            /* (write-only) Queue 0 Input Register */
        const uint32_t QBUR0 = {}; /* (read-only) Queue 0 Backup Register */
    };
    static constexpr std::size_t reserved_padding0_length = 32;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t ARBCFG; /*!< (read-write) Arbitration Configuration Register */
    uint32_t ARBPR;  /*!< (read-write) Arbitration Priority Register */
    uint32_t CHASS;  /*!< (read-write) Channel Assignment Register */
    static constexpr std::size_t reserved_padding1_length = 5;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    static constexpr std::size_t ICLASS_length = 2;
    uint32_t ICLASS[ICLASS_length]; /*!< (read-write) Input Class Register */
    static constexpr std::size_t reserved_padding2_length = 2;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t ALIAS; /*!< (read-write) Alias Register */
    const uint32_t reserved_padding3 = {};
    uint32_t BOUND; /*!< (read-write) Boundary Select Register */
    const uint32_t reserved_padding4 = {};
    uint32_t SYNCTR; /*!< (read-write) Synchronization Control Register */
    const uint32_t reserved_padding5 = {};
    uint32_t BFL;   /*!< (read-write) Boundary Flag Register */
    uint32_t BFLS;  /*!< (write-only) Boundary Flag Software Register */
    uint32_t BFLC;  /*!< (read-write) Boundary Flag Control Register */
    uint32_t BFLNP; /*!< (read-write) Boundary Flag Node Pointer Register */
    static constexpr std::size_t reserved_padding6_length = 10;
    const uint32_t reserved_padding6[reserved_padding6_length] = {};
    uint32_t QCTRL0; /*!< (read-write) Queue 0 Source Control Register */
    uint32_t QMR0;   /*!< (read-write) Queue 0 Mode Register */
    const uint32_t QSR0 = {}; /*!< (read-only) Queue 0 Status Register */
    const uint32_t Q0R0 = {}; /*!< (read-only) Queue 0 Register 0 */
    static constexpr std::size_t reserved_padding7_length = 3;
    const uint32_t reserved_padding7[reserved_padding7_length] = {};
    uint32_t ASCTRL; /*!< (read-write) Autoscan Source Control Register */
    uint32_t ASMR;   /*!< (read-write) Autoscan Source Mode Register */
    uint32_t
        ASSEL; /*!< (read-write) Autoscan Source Channel Select Register */
    uint32_t ASPND; /*!< (read-write) Autoscan Source Pending Register */
    static constexpr std::size_t reserved_padding8_length = 20;
    const uint32_t reserved_padding8[reserved_padding8_length] = {};
    uint32_t CEFLAG; /*!< (read-write) Channel Event Flag Register */
    uint32_t REFLAG; /*!< (read-write) Result Event Flag Register */
    uint32_t SEFLAG; /*!< (read-write) Source Event Flag Register */
    const uint32_t reserved_padding9 = {};
    uint32_t CEFCLR; /*!< (write-only) Channel Event Flag Clear Register */
    uint32_t REFCLR; /*!< (write-only) Result Event Flag Clear Register */
    uint32_t SEFCLR; /*!< (write-only) Source Event Flag Clear Register */
    const uint32_t reserved_padding10 = {};
    uint32_t CEVNP0; /*!< (read-write) Channel Event Node Pointer Register 0 */
    static constexpr std::size_t reserved_padding11_length = 3;
    const uint32_t reserved_padding11[reserved_padding11_length] = {};
    uint32_t REVNP0; /*!< (read-write) Result Event Node Pointer Register 0 */
    uint32_t REVNP1; /*!< (read-write) Result Event Node Pointer Register 1 */
    static constexpr std::size_t reserved_padding12_length = 2;
    const uint32_t reserved_padding12[reserved_padding12_length] = {};
    uint32_t SEVNP; /*!< (read-write) Source Event Node Pointer Register */
    const uint32_t reserved_padding13 = {};
    uint32_t
        SRACT; /*!< (write-only) Service Request Software Activation Trigger */
    static constexpr std::size_t reserved_padding14_length = 9;
    const uint32_t reserved_padding14[reserved_padding14_length] = {};
    uint32_t
        EMUXCTR; /*!< (read-write) E0ternal Multiplexer Control Register */
    const uint32_t reserved_padding15 = {};
    uint32_t VFR; /*!< (read-write) Valid Flag Register */
    const uint32_t reserved_padding16 = {};
    static constexpr std::size_t CHCTR_length = 8;
    uint32_t CHCTR[CHCTR_length]; /*!< (read-write) Channel Ctrl. Reg. */
    static constexpr std::size_t reserved_padding17_length = 24;
    const uint32_t reserved_padding17[reserved_padding17_length] = {};
    static constexpr std::size_t RCR_length = 16;
    uint32_t RCR[RCR_length]; /*!< (read-write) Result Control Register */
    static constexpr std::size_t reserved_padding18_length = 16;
    const uint32_t reserved_padding18[reserved_padding18_length] = {};
    static constexpr std::size_t RES_length = 16;
    uint32_t RES[RES_length]; /*!< (read-write) Result Register */
    static constexpr std::size_t reserved_padding19_length = 16;
    const uint32_t reserved_padding19[reserved_padding19_length] = {};
    static constexpr std::size_t RESD_length = 16;
    const uint32_t RESD[RESD_length] =
        {}; /*!< (read-only) Result Register, Debug */

    /* Methods. */

    /**
     * Get ARBCFG's SAMPLE bit.
     *
     * Sample Phase Flag
     */
    inline bool get_ARBCFG_SAMPLE() volatile
    {
        return ARBCFG & (1u << 31u);
    }

    /**
     * Get ARBCFG's BUSY bit.
     *
     * Converter Busy Flag
     */
    inline bool get_ARBCFG_BUSY() volatile
    {
        return ARBCFG & (1u << 30u);
    }

    /**
     * Get ARBCFG's CAL bit.
     *
     * Start-Up Calibration Active Indication
     */
    inline bool get_ARBCFG_CAL() volatile
    {
        return ARBCFG & (1u << 28u);
    }

    /**
     * Get ARBCFG's ANONS field.
     *
     * Analog Converter Control Status
     */
    inline VADC_G0_ARBCFG_ANONS get_ARBCFG_ANONS() volatile
    {
        return VADC_G0_ARBCFG_ANONS((ARBCFG >> 16u) & 0b11u);
    }

    /**
     * Get ARBCFG's ARBM bit.
     *
     * Arbitration Mode
     */
    inline bool get_ARBCFG_ARBM() volatile
    {
        return ARBCFG & (1u << 7u);
    }

    /**
     * Set ARBCFG's ARBM bit.
     *
     * Arbitration Mode
     */
    inline void set_ARBCFG_ARBM() volatile
    {
        ARBCFG |= 1u << 7u;
    }

    /**
     * Clear ARBCFG's ARBM bit.
     *
     * Arbitration Mode
     */
    inline void clear_ARBCFG_ARBM() volatile
    {
        ARBCFG &= ~(1u << 7u);
    }

    /**
     * Toggle ARBCFG's ARBM bit.
     *
     * Arbitration Mode
     */
    inline void toggle_ARBCFG_ARBM() volatile
    {
        ARBCFG ^= 1u << 7u;
    }

    /**
     * Get ARBCFG's ARBRND field.
     *
     * Arbitration Round Length
     */
    inline VADC_G0_ARBCFG_ARBRND get_ARBCFG_ARBRND() volatile
    {
        return VADC_G0_ARBCFG_ARBRND((ARBCFG >> 4u) & 0b11u);
    }

    /**
     * Set ARBCFG's ARBRND field.
     *
     * Arbitration Round Length
     */
    inline void set_ARBCFG_ARBRND(VADC_G0_ARBCFG_ARBRND value) volatile
    {
        uint32_t curr = ARBCFG;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        ARBCFG = curr;
    }

    /**
     * Get ARBCFG's ANONC field.
     *
     * Analog Converter Control
     */
    inline uint8_t get_ARBCFG_ANONC() volatile
    {
        return (ARBCFG >> 0u) & 0b11u;
    }

    /**
     * Set ARBCFG's ANONC field.
     *
     * Analog Converter Control
     */
    inline void set_ARBCFG_ANONC(uint8_t value) volatile
    {
        uint32_t curr = ARBCFG;

        curr &= ~(0b11u << 0u);
        curr |= (value & 0b11u) << 0u;

        ARBCFG = curr;
    }

    /**
     * Get all of ARBCFG's bit fields.
     *
     * (read-write) Arbitration Configuration Register
     */
    inline void get_ARBCFG(bool &SAMPLE, bool &BUSY, bool &CAL,
                           VADC_G0_ARBCFG_ANONS &ANONS, bool &ARBM,
                           VADC_G0_ARBCFG_ARBRND &ARBRND,
                           uint8_t &ANONC) volatile
    {
        uint32_t curr = ARBCFG;

        SAMPLE = curr & (1u << 31u);
        BUSY = curr & (1u << 30u);
        CAL = curr & (1u << 28u);
        ANONS = VADC_G0_ARBCFG_ANONS((curr >> 16u) & 0b11u);
        ARBM = curr & (1u << 7u);
        ARBRND = VADC_G0_ARBCFG_ARBRND((curr >> 4u) & 0b11u);
        ANONC = (curr >> 0u) & 0b11u;
    }

    /**
     * Set all of ARBCFG's bit fields.
     *
     * (read-write) Arbitration Configuration Register
     */
    inline void set_ARBCFG(bool ARBM, VADC_G0_ARBCFG_ARBRND ARBRND,
                           uint8_t ANONC) volatile
    {
        uint32_t curr = ARBCFG;

        curr &= ~(0b1u << 7u);
        curr |= (ARBM & 0b1u) << 7u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(ARBRND) & 0b11u) << 4u;
        curr &= ~(0b11u << 0u);
        curr |= (ANONC & 0b11u) << 0u;

        ARBCFG = curr;
    }

    /**
     * Get ARBPR's ASEN2 bit.
     *
     * Arbitration Slot 2 Enable
     */
    inline bool get_ARBPR_ASEN2() volatile
    {
        return ARBPR & (1u << 26u);
    }

    /**
     * Set ARBPR's ASEN2 bit.
     *
     * Arbitration Slot 2 Enable
     */
    inline void set_ARBPR_ASEN2() volatile
    {
        ARBPR |= 1u << 26u;
    }

    /**
     * Clear ARBPR's ASEN2 bit.
     *
     * Arbitration Slot 2 Enable
     */
    inline void clear_ARBPR_ASEN2() volatile
    {
        ARBPR &= ~(1u << 26u);
    }

    /**
     * Toggle ARBPR's ASEN2 bit.
     *
     * Arbitration Slot 2 Enable
     */
    inline void toggle_ARBPR_ASEN2() volatile
    {
        ARBPR ^= 1u << 26u;
    }

    /**
     * Get ARBPR's ASEN1 bit.
     *
     * Arbitration Slot 1 Enable
     */
    inline bool get_ARBPR_ASEN1() volatile
    {
        return ARBPR & (1u << 25u);
    }

    /**
     * Set ARBPR's ASEN1 bit.
     *
     * Arbitration Slot 1 Enable
     */
    inline void set_ARBPR_ASEN1() volatile
    {
        ARBPR |= 1u << 25u;
    }

    /**
     * Clear ARBPR's ASEN1 bit.
     *
     * Arbitration Slot 1 Enable
     */
    inline void clear_ARBPR_ASEN1() volatile
    {
        ARBPR &= ~(1u << 25u);
    }

    /**
     * Toggle ARBPR's ASEN1 bit.
     *
     * Arbitration Slot 1 Enable
     */
    inline void toggle_ARBPR_ASEN1() volatile
    {
        ARBPR ^= 1u << 25u;
    }

    /**
     * Get ARBPR's ASEN0 bit.
     *
     * Arbitration Slot 0 Enable
     */
    inline bool get_ARBPR_ASEN0() volatile
    {
        return ARBPR & (1u << 24u);
    }

    /**
     * Set ARBPR's ASEN0 bit.
     *
     * Arbitration Slot 0 Enable
     */
    inline void set_ARBPR_ASEN0() volatile
    {
        ARBPR |= 1u << 24u;
    }

    /**
     * Clear ARBPR's ASEN0 bit.
     *
     * Arbitration Slot 0 Enable
     */
    inline void clear_ARBPR_ASEN0() volatile
    {
        ARBPR &= ~(1u << 24u);
    }

    /**
     * Toggle ARBPR's ASEN0 bit.
     *
     * Arbitration Slot 0 Enable
     */
    inline void toggle_ARBPR_ASEN0() volatile
    {
        ARBPR ^= 1u << 24u;
    }

    /**
     * Get ARBPR's CSM2 bit.
     *
     * Conversion Start Mode of Request Source x
     */
    inline bool get_ARBPR_CSM2() volatile
    {
        return ARBPR & (1u << 11u);
    }

    /**
     * Set ARBPR's CSM2 bit.
     *
     * Conversion Start Mode of Request Source x
     */
    inline void set_ARBPR_CSM2() volatile
    {
        ARBPR |= 1u << 11u;
    }

    /**
     * Clear ARBPR's CSM2 bit.
     *
     * Conversion Start Mode of Request Source x
     */
    inline void clear_ARBPR_CSM2() volatile
    {
        ARBPR &= ~(1u << 11u);
    }

    /**
     * Toggle ARBPR's CSM2 bit.
     *
     * Conversion Start Mode of Request Source x
     */
    inline void toggle_ARBPR_CSM2() volatile
    {
        ARBPR ^= 1u << 11u;
    }

    /**
     * Get ARBPR's CSM1 bit.
     *
     * Conversion Start Mode of Request Source x
     */
    inline bool get_ARBPR_CSM1() volatile
    {
        return ARBPR & (1u << 7u);
    }

    /**
     * Set ARBPR's CSM1 bit.
     *
     * Conversion Start Mode of Request Source x
     */
    inline void set_ARBPR_CSM1() volatile
    {
        ARBPR |= 1u << 7u;
    }

    /**
     * Clear ARBPR's CSM1 bit.
     *
     * Conversion Start Mode of Request Source x
     */
    inline void clear_ARBPR_CSM1() volatile
    {
        ARBPR &= ~(1u << 7u);
    }

    /**
     * Toggle ARBPR's CSM1 bit.
     *
     * Conversion Start Mode of Request Source x
     */
    inline void toggle_ARBPR_CSM1() volatile
    {
        ARBPR ^= 1u << 7u;
    }

    /**
     * Get ARBPR's CSM0 bit.
     *
     * Conversion Start Mode of Request Source x
     */
    inline bool get_ARBPR_CSM0() volatile
    {
        return ARBPR & (1u << 3u);
    }

    /**
     * Set ARBPR's CSM0 bit.
     *
     * Conversion Start Mode of Request Source x
     */
    inline void set_ARBPR_CSM0() volatile
    {
        ARBPR |= 1u << 3u;
    }

    /**
     * Clear ARBPR's CSM0 bit.
     *
     * Conversion Start Mode of Request Source x
     */
    inline void clear_ARBPR_CSM0() volatile
    {
        ARBPR &= ~(1u << 3u);
    }

    /**
     * Toggle ARBPR's CSM0 bit.
     *
     * Conversion Start Mode of Request Source x
     */
    inline void toggle_ARBPR_CSM0() volatile
    {
        ARBPR ^= 1u << 3u;
    }

    /**
     * Get ARBPR's PRIO2 field.
     *
     * Priority of Request Source x
     */
    inline VADC_G0_ARBPR_PRIO2 get_ARBPR_PRIO2() volatile
    {
        return VADC_G0_ARBPR_PRIO2((ARBPR >> 8u) & 0b11u);
    }

    /**
     * Set ARBPR's PRIO2 field.
     *
     * Priority of Request Source x
     */
    inline void set_ARBPR_PRIO2(VADC_G0_ARBPR_PRIO2 value) volatile
    {
        uint32_t curr = ARBPR;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        ARBPR = curr;
    }

    /**
     * Get ARBPR's PRIO1 field.
     *
     * Priority of Request Source x
     */
    inline VADC_G0_ARBPR_PRIO2 get_ARBPR_PRIO1() volatile
    {
        return VADC_G0_ARBPR_PRIO2((ARBPR >> 4u) & 0b11u);
    }

    /**
     * Set ARBPR's PRIO1 field.
     *
     * Priority of Request Source x
     */
    inline void set_ARBPR_PRIO1(VADC_G0_ARBPR_PRIO2 value) volatile
    {
        uint32_t curr = ARBPR;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        ARBPR = curr;
    }

    /**
     * Get ARBPR's PRIO0 field.
     *
     * Priority of Request Source x
     */
    inline VADC_G0_ARBPR_PRIO2 get_ARBPR_PRIO0() volatile
    {
        return VADC_G0_ARBPR_PRIO2((ARBPR >> 0u) & 0b11u);
    }

    /**
     * Set ARBPR's PRIO0 field.
     *
     * Priority of Request Source x
     */
    inline void set_ARBPR_PRIO0(VADC_G0_ARBPR_PRIO2 value) volatile
    {
        uint32_t curr = ARBPR;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        ARBPR = curr;
    }

    /**
     * Get all of ARBPR's bit fields.
     *
     * (read-write) Arbitration Priority Register
     */
    inline void get_ARBPR(bool &ASEN2, bool &ASEN1, bool &ASEN0, bool &CSM2,
                          bool &CSM1, bool &CSM0, VADC_G0_ARBPR_PRIO2 &PRIO2,
                          VADC_G0_ARBPR_PRIO2 &PRIO1,
                          VADC_G0_ARBPR_PRIO2 &PRIO0) volatile
    {
        uint32_t curr = ARBPR;

        ASEN2 = curr & (1u << 26u);
        ASEN1 = curr & (1u << 25u);
        ASEN0 = curr & (1u << 24u);
        CSM2 = curr & (1u << 11u);
        CSM1 = curr & (1u << 7u);
        CSM0 = curr & (1u << 3u);
        PRIO2 = VADC_G0_ARBPR_PRIO2((curr >> 8u) & 0b11u);
        PRIO1 = VADC_G0_ARBPR_PRIO2((curr >> 4u) & 0b11u);
        PRIO0 = VADC_G0_ARBPR_PRIO2((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of ARBPR's bit fields.
     *
     * (read-write) Arbitration Priority Register
     */
    inline void set_ARBPR(bool ASEN2, bool ASEN1, bool ASEN0, bool CSM2,
                          bool CSM1, bool CSM0, VADC_G0_ARBPR_PRIO2 PRIO2,
                          VADC_G0_ARBPR_PRIO2 PRIO1,
                          VADC_G0_ARBPR_PRIO2 PRIO0) volatile
    {
        uint32_t curr = ARBPR;

        curr &= ~(0b1u << 26u);
        curr |= (ASEN2 & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (ASEN1 & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (ASEN0 & 0b1u) << 24u;
        curr &= ~(0b1u << 11u);
        curr |= (CSM2 & 0b1u) << 11u;
        curr &= ~(0b1u << 7u);
        curr |= (CSM1 & 0b1u) << 7u;
        curr &= ~(0b1u << 3u);
        curr |= (CSM0 & 0b1u) << 3u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(PRIO2) & 0b11u) << 8u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(PRIO1) & 0b11u) << 4u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(PRIO0) & 0b11u) << 0u;

        ARBPR = curr;
    }

    /**
     * Get CHASS's ASSCH7 bit.
     *
     * Assignment for Channel 7
     */
    inline bool get_CHASS_ASSCH7() volatile
    {
        return CHASS & (1u << 7u);
    }

    /**
     * Set CHASS's ASSCH7 bit.
     *
     * Assignment for Channel 7
     */
    inline void set_CHASS_ASSCH7() volatile
    {
        CHASS |= 1u << 7u;
    }

    /**
     * Clear CHASS's ASSCH7 bit.
     *
     * Assignment for Channel 7
     */
    inline void clear_CHASS_ASSCH7() volatile
    {
        CHASS &= ~(1u << 7u);
    }

    /**
     * Toggle CHASS's ASSCH7 bit.
     *
     * Assignment for Channel 7
     */
    inline void toggle_CHASS_ASSCH7() volatile
    {
        CHASS ^= 1u << 7u;
    }

    /**
     * Get CHASS's ASSCH6 bit.
     *
     * Assignment for Channel 6
     */
    inline bool get_CHASS_ASSCH6() volatile
    {
        return CHASS & (1u << 6u);
    }

    /**
     * Set CHASS's ASSCH6 bit.
     *
     * Assignment for Channel 6
     */
    inline void set_CHASS_ASSCH6() volatile
    {
        CHASS |= 1u << 6u;
    }

    /**
     * Clear CHASS's ASSCH6 bit.
     *
     * Assignment for Channel 6
     */
    inline void clear_CHASS_ASSCH6() volatile
    {
        CHASS &= ~(1u << 6u);
    }

    /**
     * Toggle CHASS's ASSCH6 bit.
     *
     * Assignment for Channel 6
     */
    inline void toggle_CHASS_ASSCH6() volatile
    {
        CHASS ^= 1u << 6u;
    }

    /**
     * Get CHASS's ASSCH5 bit.
     *
     * Assignment for Channel 5
     */
    inline bool get_CHASS_ASSCH5() volatile
    {
        return CHASS & (1u << 5u);
    }

    /**
     * Set CHASS's ASSCH5 bit.
     *
     * Assignment for Channel 5
     */
    inline void set_CHASS_ASSCH5() volatile
    {
        CHASS |= 1u << 5u;
    }

    /**
     * Clear CHASS's ASSCH5 bit.
     *
     * Assignment for Channel 5
     */
    inline void clear_CHASS_ASSCH5() volatile
    {
        CHASS &= ~(1u << 5u);
    }

    /**
     * Toggle CHASS's ASSCH5 bit.
     *
     * Assignment for Channel 5
     */
    inline void toggle_CHASS_ASSCH5() volatile
    {
        CHASS ^= 1u << 5u;
    }

    /**
     * Get CHASS's ASSCH4 bit.
     *
     * Assignment for Channel 4
     */
    inline bool get_CHASS_ASSCH4() volatile
    {
        return CHASS & (1u << 4u);
    }

    /**
     * Set CHASS's ASSCH4 bit.
     *
     * Assignment for Channel 4
     */
    inline void set_CHASS_ASSCH4() volatile
    {
        CHASS |= 1u << 4u;
    }

    /**
     * Clear CHASS's ASSCH4 bit.
     *
     * Assignment for Channel 4
     */
    inline void clear_CHASS_ASSCH4() volatile
    {
        CHASS &= ~(1u << 4u);
    }

    /**
     * Toggle CHASS's ASSCH4 bit.
     *
     * Assignment for Channel 4
     */
    inline void toggle_CHASS_ASSCH4() volatile
    {
        CHASS ^= 1u << 4u;
    }

    /**
     * Get CHASS's ASSCH3 bit.
     *
     * Assignment for Channel 3
     */
    inline bool get_CHASS_ASSCH3() volatile
    {
        return CHASS & (1u << 3u);
    }

    /**
     * Set CHASS's ASSCH3 bit.
     *
     * Assignment for Channel 3
     */
    inline void set_CHASS_ASSCH3() volatile
    {
        CHASS |= 1u << 3u;
    }

    /**
     * Clear CHASS's ASSCH3 bit.
     *
     * Assignment for Channel 3
     */
    inline void clear_CHASS_ASSCH3() volatile
    {
        CHASS &= ~(1u << 3u);
    }

    /**
     * Toggle CHASS's ASSCH3 bit.
     *
     * Assignment for Channel 3
     */
    inline void toggle_CHASS_ASSCH3() volatile
    {
        CHASS ^= 1u << 3u;
    }

    /**
     * Get CHASS's ASSCH2 bit.
     *
     * Assignment for Channel 2
     */
    inline bool get_CHASS_ASSCH2() volatile
    {
        return CHASS & (1u << 2u);
    }

    /**
     * Set CHASS's ASSCH2 bit.
     *
     * Assignment for Channel 2
     */
    inline void set_CHASS_ASSCH2() volatile
    {
        CHASS |= 1u << 2u;
    }

    /**
     * Clear CHASS's ASSCH2 bit.
     *
     * Assignment for Channel 2
     */
    inline void clear_CHASS_ASSCH2() volatile
    {
        CHASS &= ~(1u << 2u);
    }

    /**
     * Toggle CHASS's ASSCH2 bit.
     *
     * Assignment for Channel 2
     */
    inline void toggle_CHASS_ASSCH2() volatile
    {
        CHASS ^= 1u << 2u;
    }

    /**
     * Get CHASS's ASSCH1 bit.
     *
     * Assignment for Channel 1
     */
    inline bool get_CHASS_ASSCH1() volatile
    {
        return CHASS & (1u << 1u);
    }

    /**
     * Set CHASS's ASSCH1 bit.
     *
     * Assignment for Channel 1
     */
    inline void set_CHASS_ASSCH1() volatile
    {
        CHASS |= 1u << 1u;
    }

    /**
     * Clear CHASS's ASSCH1 bit.
     *
     * Assignment for Channel 1
     */
    inline void clear_CHASS_ASSCH1() volatile
    {
        CHASS &= ~(1u << 1u);
    }

    /**
     * Toggle CHASS's ASSCH1 bit.
     *
     * Assignment for Channel 1
     */
    inline void toggle_CHASS_ASSCH1() volatile
    {
        CHASS ^= 1u << 1u;
    }

    /**
     * Get CHASS's ASSCH0 bit.
     *
     * Assignment for Channel 0
     */
    inline bool get_CHASS_ASSCH0() volatile
    {
        return CHASS & (1u << 0u);
    }

    /**
     * Set CHASS's ASSCH0 bit.
     *
     * Assignment for Channel 0
     */
    inline void set_CHASS_ASSCH0() volatile
    {
        CHASS |= 1u << 0u;
    }

    /**
     * Clear CHASS's ASSCH0 bit.
     *
     * Assignment for Channel 0
     */
    inline void clear_CHASS_ASSCH0() volatile
    {
        CHASS &= ~(1u << 0u);
    }

    /**
     * Toggle CHASS's ASSCH0 bit.
     *
     * Assignment for Channel 0
     */
    inline void toggle_CHASS_ASSCH0() volatile
    {
        CHASS ^= 1u << 0u;
    }

    /**
     * Get all of CHASS's bit fields.
     *
     * (read-write) Channel Assignment Register
     */
    inline void get_CHASS(bool &ASSCH7, bool &ASSCH6, bool &ASSCH5,
                          bool &ASSCH4, bool &ASSCH3, bool &ASSCH2,
                          bool &ASSCH1, bool &ASSCH0) volatile
    {
        uint32_t curr = CHASS;

        ASSCH7 = curr & (1u << 7u);
        ASSCH6 = curr & (1u << 6u);
        ASSCH5 = curr & (1u << 5u);
        ASSCH4 = curr & (1u << 4u);
        ASSCH3 = curr & (1u << 3u);
        ASSCH2 = curr & (1u << 2u);
        ASSCH1 = curr & (1u << 1u);
        ASSCH0 = curr & (1u << 0u);
    }

    /**
     * Set all of CHASS's bit fields.
     *
     * (read-write) Channel Assignment Register
     */
    inline void set_CHASS(bool ASSCH7, bool ASSCH6, bool ASSCH5, bool ASSCH4,
                          bool ASSCH3, bool ASSCH2, bool ASSCH1,
                          bool ASSCH0) volatile
    {
        uint32_t curr = CHASS;

        curr &= ~(0b1u << 7u);
        curr |= (ASSCH7 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (ASSCH6 & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ASSCH5 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (ASSCH4 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (ASSCH3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ASSCH2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ASSCH1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ASSCH0 & 0b1u) << 0u;

        CHASS = curr;
    }

    /**
     * Get ICLASS's CME field.
     *
     * Conversion Mode for EMUX Conversions
     */
    inline VADC_G0_ICLASS_CME get_ICLASS_CME(std::size_t index) volatile
    {
        return VADC_G0_ICLASS_CME((ICLASS[index] >> 24u) & 0b111u);
    }

    /**
     * Set ICLASS's CME field.
     *
     * Conversion Mode for EMUX Conversions
     */
    inline void set_ICLASS_CME(std::size_t index,
                               VADC_G0_ICLASS_CME value) volatile
    {
        uint32_t curr = ICLASS[index];

        curr &= ~(0b111u << 24u);
        curr |= (std::to_underlying(value) & 0b111u) << 24u;

        ICLASS[index] = curr;
    }

    /**
     * Get ICLASS's STCE field.
     *
     * Sample Time Control for EMUX Conversions
     */
    inline uint8_t get_ICLASS_STCE(std::size_t index) volatile
    {
        return (ICLASS[index] >> 16u) & 0b11111u;
    }

    /**
     * Set ICLASS's STCE field.
     *
     * Sample Time Control for EMUX Conversions
     */
    inline void set_ICLASS_STCE(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = ICLASS[index];

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        ICLASS[index] = curr;
    }

    /**
     * Get ICLASS's CMS field.
     *
     * Conversion Mode for Standard Conversions
     */
    inline VADC_G0_ICLASS_CME get_ICLASS_CMS(std::size_t index) volatile
    {
        return VADC_G0_ICLASS_CME((ICLASS[index] >> 8u) & 0b111u);
    }

    /**
     * Set ICLASS's CMS field.
     *
     * Conversion Mode for Standard Conversions
     */
    inline void set_ICLASS_CMS(std::size_t index,
                               VADC_G0_ICLASS_CME value) volatile
    {
        uint32_t curr = ICLASS[index];

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        ICLASS[index] = curr;
    }

    /**
     * Get ICLASS's STCS field.
     *
     * Sample Time Control for Standard Conversions
     */
    inline uint8_t get_ICLASS_STCS(std::size_t index) volatile
    {
        return (ICLASS[index] >> 0u) & 0b11111u;
    }

    /**
     * Set ICLASS's STCS field.
     *
     * Sample Time Control for Standard Conversions
     */
    inline void set_ICLASS_STCS(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = ICLASS[index];

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        ICLASS[index] = curr;
    }

    /**
     * Get all of ICLASS's bit fields.
     *
     * (read-write) Input Class Register
     */
    inline void get_ICLASS(std::size_t index, VADC_G0_ICLASS_CME &CME,
                           uint8_t &STCE, VADC_G0_ICLASS_CME &CMS,
                           uint8_t &STCS) volatile
    {
        uint32_t curr = ICLASS[index];

        CME = VADC_G0_ICLASS_CME((curr >> 24u) & 0b111u);
        STCE = (curr >> 16u) & 0b11111u;
        CMS = VADC_G0_ICLASS_CME((curr >> 8u) & 0b111u);
        STCS = (curr >> 0u) & 0b11111u;
    }

    /**
     * Set all of ICLASS's bit fields.
     *
     * (read-write) Input Class Register
     */
    inline void set_ICLASS(std::size_t index, VADC_G0_ICLASS_CME CME,
                           uint8_t STCE, VADC_G0_ICLASS_CME CMS,
                           uint8_t STCS) volatile
    {
        uint32_t curr = ICLASS[index];

        curr &= ~(0b111u << 24u);
        curr |= (std::to_underlying(CME) & 0b111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (STCE & 0b11111u) << 16u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(CMS) & 0b111u) << 8u;
        curr &= ~(0b11111u << 0u);
        curr |= (STCS & 0b11111u) << 0u;

        ICLASS[index] = curr;
    }

    /**
     * Get ALIAS's ALIAS1 field.
     *
     * Alias Value for CH1 Conversion Requests
     */
    inline uint8_t get_ALIAS_ALIAS1() volatile
    {
        return (ALIAS >> 8u) & 0b11111u;
    }

    /**
     * Set ALIAS's ALIAS1 field.
     *
     * Alias Value for CH1 Conversion Requests
     */
    inline void set_ALIAS_ALIAS1(uint8_t value) volatile
    {
        uint32_t curr = ALIAS;

        curr &= ~(0b11111u << 8u);
        curr |= (value & 0b11111u) << 8u;

        ALIAS = curr;
    }

    /**
     * Get ALIAS's ALIAS0 field.
     *
     * Alias Value for CH0 Conversion Requests
     */
    inline uint8_t get_ALIAS_ALIAS0() volatile
    {
        return (ALIAS >> 0u) & 0b11111u;
    }

    /**
     * Set ALIAS's ALIAS0 field.
     *
     * Alias Value for CH0 Conversion Requests
     */
    inline void set_ALIAS_ALIAS0(uint8_t value) volatile
    {
        uint32_t curr = ALIAS;

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        ALIAS = curr;
    }

    /**
     * Get all of ALIAS's bit fields.
     *
     * (read-write) Alias Register
     */
    inline void get_ALIAS(uint8_t &ALIAS1, uint8_t &ALIAS0) volatile
    {
        uint32_t curr = ALIAS;

        ALIAS1 = (curr >> 8u) & 0b11111u;
        ALIAS0 = (curr >> 0u) & 0b11111u;
    }

    /**
     * Set all of ALIAS's bit fields.
     *
     * (read-write) Alias Register
     */
    inline void set_ALIAS(uint8_t ALIAS1, uint8_t ALIAS0) volatile
    {
        uint32_t curr = ALIAS;

        curr &= ~(0b11111u << 8u);
        curr |= (ALIAS1 & 0b11111u) << 8u;
        curr &= ~(0b11111u << 0u);
        curr |= (ALIAS0 & 0b11111u) << 0u;

        ALIAS = curr;
    }

    /**
     * Get BOUND's BOUNDARY1 field.
     *
     * Boundary Value 1 for Limit Checking
     */
    inline uint16_t get_BOUND_BOUNDARY1() volatile
    {
        return (BOUND >> 16u) & 0b111111111111u;
    }

    /**
     * Set BOUND's BOUNDARY1 field.
     *
     * Boundary Value 1 for Limit Checking
     */
    inline void set_BOUND_BOUNDARY1(uint16_t value) volatile
    {
        uint32_t curr = BOUND;

        curr &= ~(0b111111111111u << 16u);
        curr |= (value & 0b111111111111u) << 16u;

        BOUND = curr;
    }

    /**
     * Get BOUND's BOUNDARY0 field.
     *
     * Boundary Value 0 for Limit Checking
     */
    inline uint16_t get_BOUND_BOUNDARY0() volatile
    {
        return (BOUND >> 0u) & 0b111111111111u;
    }

    /**
     * Set BOUND's BOUNDARY0 field.
     *
     * Boundary Value 0 for Limit Checking
     */
    inline void set_BOUND_BOUNDARY0(uint16_t value) volatile
    {
        uint32_t curr = BOUND;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        BOUND = curr;
    }

    /**
     * Get all of BOUND's bit fields.
     *
     * (read-write) Boundary Select Register
     */
    inline void get_BOUND(uint16_t &BOUNDARY1, uint16_t &BOUNDARY0) volatile
    {
        uint32_t curr = BOUND;

        BOUNDARY1 = (curr >> 16u) & 0b111111111111u;
        BOUNDARY0 = (curr >> 0u) & 0b111111111111u;
    }

    /**
     * Set all of BOUND's bit fields.
     *
     * (read-write) Boundary Select Register
     */
    inline void set_BOUND(uint16_t BOUNDARY1, uint16_t BOUNDARY0) volatile
    {
        uint32_t curr = BOUND;

        curr &= ~(0b111111111111u << 16u);
        curr |= (BOUNDARY1 & 0b111111111111u) << 16u;
        curr &= ~(0b111111111111u << 0u);
        curr |= (BOUNDARY0 & 0b111111111111u) << 0u;

        BOUND = curr;
    }

    /**
     * Get SYNCTR's EVALR3 bit.
     *
     * Evaluate Ready Input Rx
     */
    inline bool get_SYNCTR_EVALR3() volatile
    {
        return SYNCTR & (1u << 6u);
    }

    /**
     * Set SYNCTR's EVALR3 bit.
     *
     * Evaluate Ready Input Rx
     */
    inline void set_SYNCTR_EVALR3() volatile
    {
        SYNCTR |= 1u << 6u;
    }

    /**
     * Clear SYNCTR's EVALR3 bit.
     *
     * Evaluate Ready Input Rx
     */
    inline void clear_SYNCTR_EVALR3() volatile
    {
        SYNCTR &= ~(1u << 6u);
    }

    /**
     * Toggle SYNCTR's EVALR3 bit.
     *
     * Evaluate Ready Input Rx
     */
    inline void toggle_SYNCTR_EVALR3() volatile
    {
        SYNCTR ^= 1u << 6u;
    }

    /**
     * Get SYNCTR's EVALR2 bit.
     *
     * Evaluate Ready Input Rx
     */
    inline bool get_SYNCTR_EVALR2() volatile
    {
        return SYNCTR & (1u << 5u);
    }

    /**
     * Set SYNCTR's EVALR2 bit.
     *
     * Evaluate Ready Input Rx
     */
    inline void set_SYNCTR_EVALR2() volatile
    {
        SYNCTR |= 1u << 5u;
    }

    /**
     * Clear SYNCTR's EVALR2 bit.
     *
     * Evaluate Ready Input Rx
     */
    inline void clear_SYNCTR_EVALR2() volatile
    {
        SYNCTR &= ~(1u << 5u);
    }

    /**
     * Toggle SYNCTR's EVALR2 bit.
     *
     * Evaluate Ready Input Rx
     */
    inline void toggle_SYNCTR_EVALR2() volatile
    {
        SYNCTR ^= 1u << 5u;
    }

    /**
     * Get SYNCTR's EVALR1 bit.
     *
     * Evaluate Ready Input Rx
     */
    inline bool get_SYNCTR_EVALR1() volatile
    {
        return SYNCTR & (1u << 4u);
    }

    /**
     * Set SYNCTR's EVALR1 bit.
     *
     * Evaluate Ready Input Rx
     */
    inline void set_SYNCTR_EVALR1() volatile
    {
        SYNCTR |= 1u << 4u;
    }

    /**
     * Clear SYNCTR's EVALR1 bit.
     *
     * Evaluate Ready Input Rx
     */
    inline void clear_SYNCTR_EVALR1() volatile
    {
        SYNCTR &= ~(1u << 4u);
    }

    /**
     * Toggle SYNCTR's EVALR1 bit.
     *
     * Evaluate Ready Input Rx
     */
    inline void toggle_SYNCTR_EVALR1() volatile
    {
        SYNCTR ^= 1u << 4u;
    }

    /**
     * Get SYNCTR's STSEL field.
     *
     * Start Selection
     */
    inline VADC_G0_SYNCTR_STSEL get_SYNCTR_STSEL() volatile
    {
        return VADC_G0_SYNCTR_STSEL((SYNCTR >> 0u) & 0b11u);
    }

    /**
     * Set SYNCTR's STSEL field.
     *
     * Start Selection
     */
    inline void set_SYNCTR_STSEL(VADC_G0_SYNCTR_STSEL value) volatile
    {
        uint32_t curr = SYNCTR;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        SYNCTR = curr;
    }

    /**
     * Get all of SYNCTR's bit fields.
     *
     * (read-write) Synchronization Control Register
     */
    inline void get_SYNCTR(bool &EVALR3, bool &EVALR2, bool &EVALR1,
                           VADC_G0_SYNCTR_STSEL &STSEL) volatile
    {
        uint32_t curr = SYNCTR;

        EVALR3 = curr & (1u << 6u);
        EVALR2 = curr & (1u << 5u);
        EVALR1 = curr & (1u << 4u);
        STSEL = VADC_G0_SYNCTR_STSEL((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of SYNCTR's bit fields.
     *
     * (read-write) Synchronization Control Register
     */
    inline void set_SYNCTR(bool EVALR3, bool EVALR2, bool EVALR1,
                           VADC_G0_SYNCTR_STSEL STSEL) volatile
    {
        uint32_t curr = SYNCTR;

        curr &= ~(0b1u << 6u);
        curr |= (EVALR3 & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (EVALR2 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (EVALR1 & 0b1u) << 4u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(STSEL) & 0b11u) << 0u;

        SYNCTR = curr;
    }

    /**
     * Get BFL's BFI3 bit.
     *
     * Boundary Flag 3 Inversion Control
     */
    inline bool get_BFL_BFI3() volatile
    {
        return BFL & (1u << 19u);
    }

    /**
     * Set BFL's BFI3 bit.
     *
     * Boundary Flag 3 Inversion Control
     */
    inline void set_BFL_BFI3() volatile
    {
        BFL |= 1u << 19u;
    }

    /**
     * Clear BFL's BFI3 bit.
     *
     * Boundary Flag 3 Inversion Control
     */
    inline void clear_BFL_BFI3() volatile
    {
        BFL &= ~(1u << 19u);
    }

    /**
     * Toggle BFL's BFI3 bit.
     *
     * Boundary Flag 3 Inversion Control
     */
    inline void toggle_BFL_BFI3() volatile
    {
        BFL ^= 1u << 19u;
    }

    /**
     * Get BFL's BFI2 bit.
     *
     * Boundary Flag 2 Inversion Control
     */
    inline bool get_BFL_BFI2() volatile
    {
        return BFL & (1u << 18u);
    }

    /**
     * Set BFL's BFI2 bit.
     *
     * Boundary Flag 2 Inversion Control
     */
    inline void set_BFL_BFI2() volatile
    {
        BFL |= 1u << 18u;
    }

    /**
     * Clear BFL's BFI2 bit.
     *
     * Boundary Flag 2 Inversion Control
     */
    inline void clear_BFL_BFI2() volatile
    {
        BFL &= ~(1u << 18u);
    }

    /**
     * Toggle BFL's BFI2 bit.
     *
     * Boundary Flag 2 Inversion Control
     */
    inline void toggle_BFL_BFI2() volatile
    {
        BFL ^= 1u << 18u;
    }

    /**
     * Get BFL's BFI1 bit.
     *
     * Boundary Flag 1 Inversion Control
     */
    inline bool get_BFL_BFI1() volatile
    {
        return BFL & (1u << 17u);
    }

    /**
     * Set BFL's BFI1 bit.
     *
     * Boundary Flag 1 Inversion Control
     */
    inline void set_BFL_BFI1() volatile
    {
        BFL |= 1u << 17u;
    }

    /**
     * Clear BFL's BFI1 bit.
     *
     * Boundary Flag 1 Inversion Control
     */
    inline void clear_BFL_BFI1() volatile
    {
        BFL &= ~(1u << 17u);
    }

    /**
     * Toggle BFL's BFI1 bit.
     *
     * Boundary Flag 1 Inversion Control
     */
    inline void toggle_BFL_BFI1() volatile
    {
        BFL ^= 1u << 17u;
    }

    /**
     * Get BFL's BFI0 bit.
     *
     * Boundary Flag 0 Inversion Control
     */
    inline bool get_BFL_BFI0() volatile
    {
        return BFL & (1u << 16u);
    }

    /**
     * Set BFL's BFI0 bit.
     *
     * Boundary Flag 0 Inversion Control
     */
    inline void set_BFL_BFI0() volatile
    {
        BFL |= 1u << 16u;
    }

    /**
     * Clear BFL's BFI0 bit.
     *
     * Boundary Flag 0 Inversion Control
     */
    inline void clear_BFL_BFI0() volatile
    {
        BFL &= ~(1u << 16u);
    }

    /**
     * Toggle BFL's BFI0 bit.
     *
     * Boundary Flag 0 Inversion Control
     */
    inline void toggle_BFL_BFI0() volatile
    {
        BFL ^= 1u << 16u;
    }

    /**
     * Get BFL's BFA3 bit.
     *
     * Boundary Flag 3 Activation Select
     */
    inline bool get_BFL_BFA3() volatile
    {
        return BFL & (1u << 11u);
    }

    /**
     * Set BFL's BFA3 bit.
     *
     * Boundary Flag 3 Activation Select
     */
    inline void set_BFL_BFA3() volatile
    {
        BFL |= 1u << 11u;
    }

    /**
     * Clear BFL's BFA3 bit.
     *
     * Boundary Flag 3 Activation Select
     */
    inline void clear_BFL_BFA3() volatile
    {
        BFL &= ~(1u << 11u);
    }

    /**
     * Toggle BFL's BFA3 bit.
     *
     * Boundary Flag 3 Activation Select
     */
    inline void toggle_BFL_BFA3() volatile
    {
        BFL ^= 1u << 11u;
    }

    /**
     * Get BFL's BFA2 bit.
     *
     * Boundary Flag 2 Activation Select
     */
    inline bool get_BFL_BFA2() volatile
    {
        return BFL & (1u << 10u);
    }

    /**
     * Set BFL's BFA2 bit.
     *
     * Boundary Flag 2 Activation Select
     */
    inline void set_BFL_BFA2() volatile
    {
        BFL |= 1u << 10u;
    }

    /**
     * Clear BFL's BFA2 bit.
     *
     * Boundary Flag 2 Activation Select
     */
    inline void clear_BFL_BFA2() volatile
    {
        BFL &= ~(1u << 10u);
    }

    /**
     * Toggle BFL's BFA2 bit.
     *
     * Boundary Flag 2 Activation Select
     */
    inline void toggle_BFL_BFA2() volatile
    {
        BFL ^= 1u << 10u;
    }

    /**
     * Get BFL's BFA1 bit.
     *
     * Boundary Flag 1 Activation Select
     */
    inline bool get_BFL_BFA1() volatile
    {
        return BFL & (1u << 9u);
    }

    /**
     * Set BFL's BFA1 bit.
     *
     * Boundary Flag 1 Activation Select
     */
    inline void set_BFL_BFA1() volatile
    {
        BFL |= 1u << 9u;
    }

    /**
     * Clear BFL's BFA1 bit.
     *
     * Boundary Flag 1 Activation Select
     */
    inline void clear_BFL_BFA1() volatile
    {
        BFL &= ~(1u << 9u);
    }

    /**
     * Toggle BFL's BFA1 bit.
     *
     * Boundary Flag 1 Activation Select
     */
    inline void toggle_BFL_BFA1() volatile
    {
        BFL ^= 1u << 9u;
    }

    /**
     * Get BFL's BFA0 bit.
     *
     * Boundary Flag 0 Activation Select
     */
    inline bool get_BFL_BFA0() volatile
    {
        return BFL & (1u << 8u);
    }

    /**
     * Set BFL's BFA0 bit.
     *
     * Boundary Flag 0 Activation Select
     */
    inline void set_BFL_BFA0() volatile
    {
        BFL |= 1u << 8u;
    }

    /**
     * Clear BFL's BFA0 bit.
     *
     * Boundary Flag 0 Activation Select
     */
    inline void clear_BFL_BFA0() volatile
    {
        BFL &= ~(1u << 8u);
    }

    /**
     * Toggle BFL's BFA0 bit.
     *
     * Boundary Flag 0 Activation Select
     */
    inline void toggle_BFL_BFA0() volatile
    {
        BFL ^= 1u << 8u;
    }

    /**
     * Get BFL's BFL3 bit.
     *
     * Boundary Flag 3
     */
    inline bool get_BFL_BFL3() volatile
    {
        return BFL & (1u << 3u);
    }

    /**
     * Get BFL's BFL2 bit.
     *
     * Boundary Flag 2
     */
    inline bool get_BFL_BFL2() volatile
    {
        return BFL & (1u << 2u);
    }

    /**
     * Get BFL's BFL1 bit.
     *
     * Boundary Flag 1
     */
    inline bool get_BFL_BFL1() volatile
    {
        return BFL & (1u << 1u);
    }

    /**
     * Get BFL's BFL0 bit.
     *
     * Boundary Flag 0
     */
    inline bool get_BFL_BFL0() volatile
    {
        return BFL & (1u << 0u);
    }

    /**
     * Get all of BFL's bit fields.
     *
     * (read-write) Boundary Flag Register
     */
    inline void get_BFL(bool &BFI3, bool &BFI2, bool &BFI1, bool &BFI0,
                        bool &BFA3, bool &BFA2, bool &BFA1, bool &BFA0,
                        bool &BFL3, bool &BFL2, bool &BFL1,
                        bool &BFL0) volatile
    {
        uint32_t curr = BFL;

        BFI3 = curr & (1u << 19u);
        BFI2 = curr & (1u << 18u);
        BFI1 = curr & (1u << 17u);
        BFI0 = curr & (1u << 16u);
        BFA3 = curr & (1u << 11u);
        BFA2 = curr & (1u << 10u);
        BFA1 = curr & (1u << 9u);
        BFA0 = curr & (1u << 8u);
        BFL3 = curr & (1u << 3u);
        BFL2 = curr & (1u << 2u);
        BFL1 = curr & (1u << 1u);
        BFL0 = curr & (1u << 0u);
    }

    /**
     * Set all of BFL's bit fields.
     *
     * (read-write) Boundary Flag Register
     */
    inline void set_BFL(bool BFI3, bool BFI2, bool BFI1, bool BFI0, bool BFA3,
                        bool BFA2, bool BFA1, bool BFA0) volatile
    {
        uint32_t curr = BFL;

        curr &= ~(0b1u << 19u);
        curr |= (BFI3 & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (BFI2 & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (BFI1 & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (BFI0 & 0b1u) << 16u;
        curr &= ~(0b1u << 11u);
        curr |= (BFA3 & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (BFA2 & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (BFA1 & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (BFA0 & 0b1u) << 8u;

        BFL = curr;
    }

    /**
     * Set BFLS's BFS3 bit.
     *
     * Boundary Flag 3 Set
     */
    inline void set_BFLS_BFS3() volatile
    {
        BFLS |= 1u << 19u;
    }

    /**
     * Clear BFLS's BFS3 bit.
     *
     * Boundary Flag 3 Set
     */
    inline void clear_BFLS_BFS3() volatile
    {
        BFLS &= ~(1u << 19u);
    }

    /**
     * Toggle BFLS's BFS3 bit.
     *
     * Boundary Flag 3 Set
     */
    inline void toggle_BFLS_BFS3() volatile
    {
        BFLS ^= 1u << 19u;
    }

    /**
     * Set BFLS's BFS2 bit.
     *
     * Boundary Flag 2 Set
     */
    inline void set_BFLS_BFS2() volatile
    {
        BFLS |= 1u << 18u;
    }

    /**
     * Clear BFLS's BFS2 bit.
     *
     * Boundary Flag 2 Set
     */
    inline void clear_BFLS_BFS2() volatile
    {
        BFLS &= ~(1u << 18u);
    }

    /**
     * Toggle BFLS's BFS2 bit.
     *
     * Boundary Flag 2 Set
     */
    inline void toggle_BFLS_BFS2() volatile
    {
        BFLS ^= 1u << 18u;
    }

    /**
     * Set BFLS's BFS1 bit.
     *
     * Boundary Flag 1 Set
     */
    inline void set_BFLS_BFS1() volatile
    {
        BFLS |= 1u << 17u;
    }

    /**
     * Clear BFLS's BFS1 bit.
     *
     * Boundary Flag 1 Set
     */
    inline void clear_BFLS_BFS1() volatile
    {
        BFLS &= ~(1u << 17u);
    }

    /**
     * Toggle BFLS's BFS1 bit.
     *
     * Boundary Flag 1 Set
     */
    inline void toggle_BFLS_BFS1() volatile
    {
        BFLS ^= 1u << 17u;
    }

    /**
     * Set BFLS's BFS0 bit.
     *
     * Boundary Flag 0 Set
     */
    inline void set_BFLS_BFS0() volatile
    {
        BFLS |= 1u << 16u;
    }

    /**
     * Clear BFLS's BFS0 bit.
     *
     * Boundary Flag 0 Set
     */
    inline void clear_BFLS_BFS0() volatile
    {
        BFLS &= ~(1u << 16u);
    }

    /**
     * Toggle BFLS's BFS0 bit.
     *
     * Boundary Flag 0 Set
     */
    inline void toggle_BFLS_BFS0() volatile
    {
        BFLS ^= 1u << 16u;
    }

    /**
     * Set BFLS's BFC3 bit.
     *
     * Boundary Flag 3 Clear
     */
    inline void set_BFLS_BFC3() volatile
    {
        BFLS |= 1u << 3u;
    }

    /**
     * Clear BFLS's BFC3 bit.
     *
     * Boundary Flag 3 Clear
     */
    inline void clear_BFLS_BFC3() volatile
    {
        BFLS &= ~(1u << 3u);
    }

    /**
     * Toggle BFLS's BFC3 bit.
     *
     * Boundary Flag 3 Clear
     */
    inline void toggle_BFLS_BFC3() volatile
    {
        BFLS ^= 1u << 3u;
    }

    /**
     * Set BFLS's BFC2 bit.
     *
     * Boundary Flag 2 Clear
     */
    inline void set_BFLS_BFC2() volatile
    {
        BFLS |= 1u << 2u;
    }

    /**
     * Clear BFLS's BFC2 bit.
     *
     * Boundary Flag 2 Clear
     */
    inline void clear_BFLS_BFC2() volatile
    {
        BFLS &= ~(1u << 2u);
    }

    /**
     * Toggle BFLS's BFC2 bit.
     *
     * Boundary Flag 2 Clear
     */
    inline void toggle_BFLS_BFC2() volatile
    {
        BFLS ^= 1u << 2u;
    }

    /**
     * Set BFLS's BFC1 bit.
     *
     * Boundary Flag 1 Clear
     */
    inline void set_BFLS_BFC1() volatile
    {
        BFLS |= 1u << 1u;
    }

    /**
     * Clear BFLS's BFC1 bit.
     *
     * Boundary Flag 1 Clear
     */
    inline void clear_BFLS_BFC1() volatile
    {
        BFLS &= ~(1u << 1u);
    }

    /**
     * Toggle BFLS's BFC1 bit.
     *
     * Boundary Flag 1 Clear
     */
    inline void toggle_BFLS_BFC1() volatile
    {
        BFLS ^= 1u << 1u;
    }

    /**
     * Set BFLS's BFC0 bit.
     *
     * Boundary Flag 0 Clear
     */
    inline void set_BFLS_BFC0() volatile
    {
        BFLS |= 1u << 0u;
    }

    /**
     * Clear BFLS's BFC0 bit.
     *
     * Boundary Flag 0 Clear
     */
    inline void clear_BFLS_BFC0() volatile
    {
        BFLS &= ~(1u << 0u);
    }

    /**
     * Toggle BFLS's BFC0 bit.
     *
     * Boundary Flag 0 Clear
     */
    inline void toggle_BFLS_BFC0() volatile
    {
        BFLS ^= 1u << 0u;
    }

    /**
     * Set all of BFLS's bit fields.
     *
     * (write-only) Boundary Flag Software Register
     */
    inline void set_BFLS(bool BFS3, bool BFS2, bool BFS1, bool BFS0, bool BFC3,
                         bool BFC2, bool BFC1, bool BFC0) volatile
    {
        uint32_t curr = BFLS;

        curr &= ~(0b1u << 19u);
        curr |= (BFS3 & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (BFS2 & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (BFS1 & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (BFS0 & 0b1u) << 16u;
        curr &= ~(0b1u << 3u);
        curr |= (BFC3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (BFC2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (BFC1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (BFC0 & 0b1u) << 0u;

        BFLS = curr;
    }

    /**
     * Get BFLC's BFM3 field.
     *
     * Boundary Flag y Mode Control
     */
    inline VADC_G0_BFLC_BFM3 get_BFLC_BFM3() volatile
    {
        return VADC_G0_BFLC_BFM3((BFLC >> 12u) & 0b1111u);
    }

    /**
     * Set BFLC's BFM3 field.
     *
     * Boundary Flag y Mode Control
     */
    inline void set_BFLC_BFM3(VADC_G0_BFLC_BFM3 value) volatile
    {
        uint32_t curr = BFLC;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(value) & 0b1111u) << 12u;

        BFLC = curr;
    }

    /**
     * Get BFLC's BFM2 field.
     *
     * Boundary Flag y Mode Control
     */
    inline VADC_G0_BFLC_BFM3 get_BFLC_BFM2() volatile
    {
        return VADC_G0_BFLC_BFM3((BFLC >> 8u) & 0b1111u);
    }

    /**
     * Set BFLC's BFM2 field.
     *
     * Boundary Flag y Mode Control
     */
    inline void set_BFLC_BFM2(VADC_G0_BFLC_BFM3 value) volatile
    {
        uint32_t curr = BFLC;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        BFLC = curr;
    }

    /**
     * Get BFLC's BFM1 field.
     *
     * Boundary Flag y Mode Control
     */
    inline VADC_G0_BFLC_BFM3 get_BFLC_BFM1() volatile
    {
        return VADC_G0_BFLC_BFM3((BFLC >> 4u) & 0b1111u);
    }

    /**
     * Set BFLC's BFM1 field.
     *
     * Boundary Flag y Mode Control
     */
    inline void set_BFLC_BFM1(VADC_G0_BFLC_BFM3 value) volatile
    {
        uint32_t curr = BFLC;

        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(value) & 0b1111u) << 4u;

        BFLC = curr;
    }

    /**
     * Get BFLC's BFM0 field.
     *
     * Boundary Flag y Mode Control
     */
    inline VADC_G0_BFLC_BFM3 get_BFLC_BFM0() volatile
    {
        return VADC_G0_BFLC_BFM3((BFLC >> 0u) & 0b1111u);
    }

    /**
     * Set BFLC's BFM0 field.
     *
     * Boundary Flag y Mode Control
     */
    inline void set_BFLC_BFM0(VADC_G0_BFLC_BFM3 value) volatile
    {
        uint32_t curr = BFLC;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        BFLC = curr;
    }

    /**
     * Get all of BFLC's bit fields.
     *
     * (read-write) Boundary Flag Control Register
     */
    inline void get_BFLC(VADC_G0_BFLC_BFM3 &BFM3, VADC_G0_BFLC_BFM3 &BFM2,
                         VADC_G0_BFLC_BFM3 &BFM1,
                         VADC_G0_BFLC_BFM3 &BFM0) volatile
    {
        uint32_t curr = BFLC;

        BFM3 = VADC_G0_BFLC_BFM3((curr >> 12u) & 0b1111u);
        BFM2 = VADC_G0_BFLC_BFM3((curr >> 8u) & 0b1111u);
        BFM1 = VADC_G0_BFLC_BFM3((curr >> 4u) & 0b1111u);
        BFM0 = VADC_G0_BFLC_BFM3((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of BFLC's bit fields.
     *
     * (read-write) Boundary Flag Control Register
     */
    inline void set_BFLC(VADC_G0_BFLC_BFM3 BFM3, VADC_G0_BFLC_BFM3 BFM2,
                         VADC_G0_BFLC_BFM3 BFM1,
                         VADC_G0_BFLC_BFM3 BFM0) volatile
    {
        uint32_t curr = BFLC;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(BFM3) & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(BFM2) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(BFM1) & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(BFM0) & 0b1111u) << 0u;

        BFLC = curr;
    }

    /**
     * Get BFLNP's BFL3NP field.
     *
     * Boundary Flag y Node Pointer
     */
    inline VADC_G0_BFLNP_BFL3NP get_BFLNP_BFL3NP() volatile
    {
        return VADC_G0_BFLNP_BFL3NP((BFLNP >> 12u) & 0b1111u);
    }

    /**
     * Set BFLNP's BFL3NP field.
     *
     * Boundary Flag y Node Pointer
     */
    inline void set_BFLNP_BFL3NP(VADC_G0_BFLNP_BFL3NP value) volatile
    {
        uint32_t curr = BFLNP;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(value) & 0b1111u) << 12u;

        BFLNP = curr;
    }

    /**
     * Get BFLNP's BFL2NP field.
     *
     * Boundary Flag y Node Pointer
     */
    inline VADC_G0_BFLNP_BFL3NP get_BFLNP_BFL2NP() volatile
    {
        return VADC_G0_BFLNP_BFL3NP((BFLNP >> 8u) & 0b1111u);
    }

    /**
     * Set BFLNP's BFL2NP field.
     *
     * Boundary Flag y Node Pointer
     */
    inline void set_BFLNP_BFL2NP(VADC_G0_BFLNP_BFL3NP value) volatile
    {
        uint32_t curr = BFLNP;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        BFLNP = curr;
    }

    /**
     * Get BFLNP's BFL1NP field.
     *
     * Boundary Flag y Node Pointer
     */
    inline VADC_G0_BFLNP_BFL3NP get_BFLNP_BFL1NP() volatile
    {
        return VADC_G0_BFLNP_BFL3NP((BFLNP >> 4u) & 0b1111u);
    }

    /**
     * Set BFLNP's BFL1NP field.
     *
     * Boundary Flag y Node Pointer
     */
    inline void set_BFLNP_BFL1NP(VADC_G0_BFLNP_BFL3NP value) volatile
    {
        uint32_t curr = BFLNP;

        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(value) & 0b1111u) << 4u;

        BFLNP = curr;
    }

    /**
     * Get BFLNP's BFL0NP field.
     *
     * Boundary Flag y Node Pointer
     */
    inline VADC_G0_BFLNP_BFL3NP get_BFLNP_BFL0NP() volatile
    {
        return VADC_G0_BFLNP_BFL3NP((BFLNP >> 0u) & 0b1111u);
    }

    /**
     * Set BFLNP's BFL0NP field.
     *
     * Boundary Flag y Node Pointer
     */
    inline void set_BFLNP_BFL0NP(VADC_G0_BFLNP_BFL3NP value) volatile
    {
        uint32_t curr = BFLNP;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        BFLNP = curr;
    }

    /**
     * Get all of BFLNP's bit fields.
     *
     * (read-write) Boundary Flag Node Pointer Register
     */
    inline void get_BFLNP(VADC_G0_BFLNP_BFL3NP &BFL3NP,
                          VADC_G0_BFLNP_BFL3NP &BFL2NP,
                          VADC_G0_BFLNP_BFL3NP &BFL1NP,
                          VADC_G0_BFLNP_BFL3NP &BFL0NP) volatile
    {
        uint32_t curr = BFLNP;

        BFL3NP = VADC_G0_BFLNP_BFL3NP((curr >> 12u) & 0b1111u);
        BFL2NP = VADC_G0_BFLNP_BFL3NP((curr >> 8u) & 0b1111u);
        BFL1NP = VADC_G0_BFLNP_BFL3NP((curr >> 4u) & 0b1111u);
        BFL0NP = VADC_G0_BFLNP_BFL3NP((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of BFLNP's bit fields.
     *
     * (read-write) Boundary Flag Node Pointer Register
     */
    inline void set_BFLNP(VADC_G0_BFLNP_BFL3NP BFL3NP,
                          VADC_G0_BFLNP_BFL3NP BFL2NP,
                          VADC_G0_BFLNP_BFL3NP BFL1NP,
                          VADC_G0_BFLNP_BFL3NP BFL0NP) volatile
    {
        uint32_t curr = BFLNP;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(BFL3NP) & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(BFL2NP) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(BFL1NP) & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(BFL0NP) & 0b1111u) << 0u;

        BFLNP = curr;
    }

    /**
     * Set QCTRL0's TMWC bit.
     *
     * Write Control for Timer Mode
     */
    inline void set_QCTRL0_TMWC() volatile
    {
        QCTRL0 |= 1u << 31u;
    }

    /**
     * Clear QCTRL0's TMWC bit.
     *
     * Write Control for Timer Mode
     */
    inline void clear_QCTRL0_TMWC() volatile
    {
        QCTRL0 &= ~(1u << 31u);
    }

    /**
     * Toggle QCTRL0's TMWC bit.
     *
     * Write Control for Timer Mode
     */
    inline void toggle_QCTRL0_TMWC() volatile
    {
        QCTRL0 ^= 1u << 31u;
    }

    /**
     * Get QCTRL0's TMEN bit.
     *
     * Timer Mode Enable
     */
    inline bool get_QCTRL0_TMEN() volatile
    {
        return QCTRL0 & (1u << 28u);
    }

    /**
     * Set QCTRL0's TMEN bit.
     *
     * Timer Mode Enable
     */
    inline void set_QCTRL0_TMEN() volatile
    {
        QCTRL0 |= 1u << 28u;
    }

    /**
     * Clear QCTRL0's TMEN bit.
     *
     * Timer Mode Enable
     */
    inline void clear_QCTRL0_TMEN() volatile
    {
        QCTRL0 &= ~(1u << 28u);
    }

    /**
     * Toggle QCTRL0's TMEN bit.
     *
     * Timer Mode Enable
     */
    inline void toggle_QCTRL0_TMEN() volatile
    {
        QCTRL0 ^= 1u << 28u;
    }

    /**
     * Set QCTRL0's GTWC bit.
     *
     * Write Control for Gate Configuration
     */
    inline void set_QCTRL0_GTWC() volatile
    {
        QCTRL0 |= 1u << 23u;
    }

    /**
     * Clear QCTRL0's GTWC bit.
     *
     * Write Control for Gate Configuration
     */
    inline void clear_QCTRL0_GTWC() volatile
    {
        QCTRL0 &= ~(1u << 23u);
    }

    /**
     * Toggle QCTRL0's GTWC bit.
     *
     * Write Control for Gate Configuration
     */
    inline void toggle_QCTRL0_GTWC() volatile
    {
        QCTRL0 ^= 1u << 23u;
    }

    /**
     * Get QCTRL0's GTLVL bit.
     *
     * Gate Input Level
     */
    inline bool get_QCTRL0_GTLVL() volatile
    {
        return QCTRL0 & (1u << 20u);
    }

    /**
     * Get QCTRL0's GTSEL field.
     *
     * Gate Input Selection
     */
    inline uint8_t get_QCTRL0_GTSEL() volatile
    {
        return (QCTRL0 >> 16u) & 0b1111u;
    }

    /**
     * Set QCTRL0's GTSEL field.
     *
     * Gate Input Selection
     */
    inline void set_QCTRL0_GTSEL(uint8_t value) volatile
    {
        uint32_t curr = QCTRL0;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        QCTRL0 = curr;
    }

    /**
     * Set QCTRL0's XTWC bit.
     *
     * Write Control for Trigger Configuration
     */
    inline void set_QCTRL0_XTWC() volatile
    {
        QCTRL0 |= 1u << 15u;
    }

    /**
     * Clear QCTRL0's XTWC bit.
     *
     * Write Control for Trigger Configuration
     */
    inline void clear_QCTRL0_XTWC() volatile
    {
        QCTRL0 &= ~(1u << 15u);
    }

    /**
     * Toggle QCTRL0's XTWC bit.
     *
     * Write Control for Trigger Configuration
     */
    inline void toggle_QCTRL0_XTWC() volatile
    {
        QCTRL0 ^= 1u << 15u;
    }

    /**
     * Get QCTRL0's XTMODE field.
     *
     * Trigger Operating Mode
     */
    inline VADC_G0_QCTRL0_XTMODE get_QCTRL0_XTMODE() volatile
    {
        return VADC_G0_QCTRL0_XTMODE((QCTRL0 >> 13u) & 0b11u);
    }

    /**
     * Set QCTRL0's XTMODE field.
     *
     * Trigger Operating Mode
     */
    inline void set_QCTRL0_XTMODE(VADC_G0_QCTRL0_XTMODE value) volatile
    {
        uint32_t curr = QCTRL0;

        curr &= ~(0b11u << 13u);
        curr |= (std::to_underlying(value) & 0b11u) << 13u;

        QCTRL0 = curr;
    }

    /**
     * Get QCTRL0's XTLVL bit.
     *
     * External Trigger Level
     */
    inline bool get_QCTRL0_XTLVL() volatile
    {
        return QCTRL0 & (1u << 12u);
    }

    /**
     * Get QCTRL0's XTSEL field.
     *
     * External Trigger Input Selection
     */
    inline uint8_t get_QCTRL0_XTSEL() volatile
    {
        return (QCTRL0 >> 8u) & 0b1111u;
    }

    /**
     * Set QCTRL0's XTSEL field.
     *
     * External Trigger Input Selection
     */
    inline void set_QCTRL0_XTSEL(uint8_t value) volatile
    {
        uint32_t curr = QCTRL0;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        QCTRL0 = curr;
    }

    /**
     * Get QCTRL0's SRCRESREG field.
     *
     * Source-specific Result Register
     */
    inline VADC_G0_QCTRL0_SRCRESREG get_QCTRL0_SRCRESREG() volatile
    {
        return VADC_G0_QCTRL0_SRCRESREG((QCTRL0 >> 0u) & 0b1111u);
    }

    /**
     * Set QCTRL0's SRCRESREG field.
     *
     * Source-specific Result Register
     */
    inline void set_QCTRL0_SRCRESREG(VADC_G0_QCTRL0_SRCRESREG value) volatile
    {
        uint32_t curr = QCTRL0;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        QCTRL0 = curr;
    }

    /**
     * Get all of QCTRL0's bit fields.
     *
     * (read-write) Queue 0 Source Control Register
     */
    inline void get_QCTRL0(bool &TMEN, bool &GTLVL, uint8_t &GTSEL,
                           VADC_G0_QCTRL0_XTMODE &XTMODE, bool &XTLVL,
                           uint8_t &XTSEL,
                           VADC_G0_QCTRL0_SRCRESREG &SRCRESREG) volatile
    {
        uint32_t curr = QCTRL0;

        TMEN = curr & (1u << 28u);
        GTLVL = curr & (1u << 20u);
        GTSEL = (curr >> 16u) & 0b1111u;
        XTMODE = VADC_G0_QCTRL0_XTMODE((curr >> 13u) & 0b11u);
        XTLVL = curr & (1u << 12u);
        XTSEL = (curr >> 8u) & 0b1111u;
        SRCRESREG = VADC_G0_QCTRL0_SRCRESREG((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of QCTRL0's bit fields.
     *
     * (read-write) Queue 0 Source Control Register
     */
    inline void set_QCTRL0(bool TMWC, bool TMEN, bool GTWC, uint8_t GTSEL,
                           bool XTWC, VADC_G0_QCTRL0_XTMODE XTMODE,
                           uint8_t XTSEL,
                           VADC_G0_QCTRL0_SRCRESREG SRCRESREG) volatile
    {
        uint32_t curr = QCTRL0;

        curr &= ~(0b1u << 31u);
        curr |= (TMWC & 0b1u) << 31u;
        curr &= ~(0b1u << 28u);
        curr |= (TMEN & 0b1u) << 28u;
        curr &= ~(0b1u << 23u);
        curr |= (GTWC & 0b1u) << 23u;
        curr &= ~(0b1111u << 16u);
        curr |= (GTSEL & 0b1111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (XTWC & 0b1u) << 15u;
        curr &= ~(0b11u << 13u);
        curr |= (std::to_underlying(XTMODE) & 0b11u) << 13u;
        curr &= ~(0b1111u << 8u);
        curr |= (XTSEL & 0b1111u) << 8u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(SRCRESREG) & 0b1111u) << 0u;

        QCTRL0 = curr;
    }

    /**
     * Get QMR0's RPTDIS bit.
     *
     * Repeat Disable
     */
    inline bool get_QMR0_RPTDIS() volatile
    {
        return QMR0 & (1u << 16u);
    }

    /**
     * Set QMR0's RPTDIS bit.
     *
     * Repeat Disable
     */
    inline void set_QMR0_RPTDIS() volatile
    {
        QMR0 |= 1u << 16u;
    }

    /**
     * Clear QMR0's RPTDIS bit.
     *
     * Repeat Disable
     */
    inline void clear_QMR0_RPTDIS() volatile
    {
        QMR0 &= ~(1u << 16u);
    }

    /**
     * Toggle QMR0's RPTDIS bit.
     *
     * Repeat Disable
     */
    inline void toggle_QMR0_RPTDIS() volatile
    {
        QMR0 ^= 1u << 16u;
    }

    /**
     * Set QMR0's CEV bit.
     *
     * Clear Event Flag
     */
    inline void set_QMR0_CEV() volatile
    {
        QMR0 |= 1u << 11u;
    }

    /**
     * Clear QMR0's CEV bit.
     *
     * Clear Event Flag
     */
    inline void clear_QMR0_CEV() volatile
    {
        QMR0 &= ~(1u << 11u);
    }

    /**
     * Toggle QMR0's CEV bit.
     *
     * Clear Event Flag
     */
    inline void toggle_QMR0_CEV() volatile
    {
        QMR0 ^= 1u << 11u;
    }

    /**
     * Set QMR0's FLUSH bit.
     *
     * Flush Queue
     */
    inline void set_QMR0_FLUSH() volatile
    {
        QMR0 |= 1u << 10u;
    }

    /**
     * Clear QMR0's FLUSH bit.
     *
     * Flush Queue
     */
    inline void clear_QMR0_FLUSH() volatile
    {
        QMR0 &= ~(1u << 10u);
    }

    /**
     * Toggle QMR0's FLUSH bit.
     *
     * Flush Queue
     */
    inline void toggle_QMR0_FLUSH() volatile
    {
        QMR0 ^= 1u << 10u;
    }

    /**
     * Set QMR0's TREV bit.
     *
     * Trigger Event
     */
    inline void set_QMR0_TREV() volatile
    {
        QMR0 |= 1u << 9u;
    }

    /**
     * Clear QMR0's TREV bit.
     *
     * Trigger Event
     */
    inline void clear_QMR0_TREV() volatile
    {
        QMR0 &= ~(1u << 9u);
    }

    /**
     * Toggle QMR0's TREV bit.
     *
     * Trigger Event
     */
    inline void toggle_QMR0_TREV() volatile
    {
        QMR0 ^= 1u << 9u;
    }

    /**
     * Set QMR0's CLRV bit.
     *
     * Clear Valid Bit
     */
    inline void set_QMR0_CLRV() volatile
    {
        QMR0 |= 1u << 8u;
    }

    /**
     * Clear QMR0's CLRV bit.
     *
     * Clear Valid Bit
     */
    inline void clear_QMR0_CLRV() volatile
    {
        QMR0 &= ~(1u << 8u);
    }

    /**
     * Toggle QMR0's CLRV bit.
     *
     * Clear Valid Bit
     */
    inline void toggle_QMR0_CLRV() volatile
    {
        QMR0 ^= 1u << 8u;
    }

    /**
     * Get QMR0's ENTR bit.
     *
     * Enable External Trigger
     */
    inline bool get_QMR0_ENTR() volatile
    {
        return QMR0 & (1u << 2u);
    }

    /**
     * Set QMR0's ENTR bit.
     *
     * Enable External Trigger
     */
    inline void set_QMR0_ENTR() volatile
    {
        QMR0 |= 1u << 2u;
    }

    /**
     * Clear QMR0's ENTR bit.
     *
     * Enable External Trigger
     */
    inline void clear_QMR0_ENTR() volatile
    {
        QMR0 &= ~(1u << 2u);
    }

    /**
     * Toggle QMR0's ENTR bit.
     *
     * Enable External Trigger
     */
    inline void toggle_QMR0_ENTR() volatile
    {
        QMR0 ^= 1u << 2u;
    }

    /**
     * Get QMR0's ENGT field.
     *
     * Enable Gate
     */
    inline VADC_G0_QMR0_ENGT get_QMR0_ENGT() volatile
    {
        return VADC_G0_QMR0_ENGT((QMR0 >> 0u) & 0b11u);
    }

    /**
     * Set QMR0's ENGT field.
     *
     * Enable Gate
     */
    inline void set_QMR0_ENGT(VADC_G0_QMR0_ENGT value) volatile
    {
        uint32_t curr = QMR0;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        QMR0 = curr;
    }

    /**
     * Get all of QMR0's bit fields.
     *
     * (read-write) Queue 0 Mode Register
     */
    inline void get_QMR0(bool &RPTDIS, bool &ENTR,
                         VADC_G0_QMR0_ENGT &ENGT) volatile
    {
        uint32_t curr = QMR0;

        RPTDIS = curr & (1u << 16u);
        ENTR = curr & (1u << 2u);
        ENGT = VADC_G0_QMR0_ENGT((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of QMR0's bit fields.
     *
     * (read-write) Queue 0 Mode Register
     */
    inline void set_QMR0(bool RPTDIS, bool CEV, bool FLUSH, bool TREV,
                         bool CLRV, bool ENTR, VADC_G0_QMR0_ENGT ENGT) volatile
    {
        uint32_t curr = QMR0;

        curr &= ~(0b1u << 16u);
        curr |= (RPTDIS & 0b1u) << 16u;
        curr &= ~(0b1u << 11u);
        curr |= (CEV & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (FLUSH & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (TREV & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (CLRV & 0b1u) << 8u;
        curr &= ~(0b1u << 2u);
        curr |= (ENTR & 0b1u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(ENGT) & 0b11u) << 0u;

        QMR0 = curr;
    }

    /**
     * Get QSR0's EV bit.
     *
     * Event Detected
     */
    inline bool get_QSR0_EV() volatile
    {
        return QSR0 & (1u << 8u);
    }

    /**
     * Get QSR0's REQGT bit.
     *
     * Request Gate Level
     */
    inline bool get_QSR0_REQGT() volatile
    {
        return QSR0 & (1u << 7u);
    }

    /**
     * Get QSR0's EMPTY bit.
     *
     * Queue Empty
     */
    inline bool get_QSR0_EMPTY() volatile
    {
        return QSR0 & (1u << 5u);
    }

    /**
     * Get QSR0's FILL field.
     *
     * Filling Level for Queue 2
     */
    inline VADC_G0_QSR0_FILL get_QSR0_FILL() volatile
    {
        return VADC_G0_QSR0_FILL((QSR0 >> 0u) & 0b1111u);
    }

    /**
     * Get all of QSR0's bit fields.
     *
     * (read-only) Queue 0 Status Register
     */
    inline void get_QSR0(bool &EV, bool &REQGT, bool &EMPTY,
                         VADC_G0_QSR0_FILL &FILL) volatile
    {
        uint32_t curr = QSR0;

        EV = curr & (1u << 8u);
        REQGT = curr & (1u << 7u);
        EMPTY = curr & (1u << 5u);
        FILL = VADC_G0_QSR0_FILL((curr >> 0u) & 0b1111u);
    }

    /**
     * Get Q0R0's V bit.
     *
     * Request Channel Number Valid
     */
    inline bool get_Q0R0_V() volatile
    {
        return Q0R0 & (1u << 8u);
    }

    /**
     * Get Q0R0's EXTR bit.
     *
     * External Trigger
     */
    inline bool get_Q0R0_EXTR() volatile
    {
        return Q0R0 & (1u << 7u);
    }

    /**
     * Get Q0R0's ENSI bit.
     *
     * Enable Source Interrupt
     */
    inline bool get_Q0R0_ENSI() volatile
    {
        return Q0R0 & (1u << 6u);
    }

    /**
     * Get Q0R0's RF bit.
     *
     * Refill
     */
    inline bool get_Q0R0_RF() volatile
    {
        return Q0R0 & (1u << 5u);
    }

    /**
     * Get Q0R0's REQCHNR field.
     *
     * Request Channel Number
     */
    inline uint8_t get_Q0R0_REQCHNR() volatile
    {
        return (Q0R0 >> 0u) & 0b11111u;
    }

    /**
     * Get all of Q0R0's bit fields.
     *
     * (read-only) Queue 0 Register 0
     */
    inline void get_Q0R0(bool &V, bool &EXTR, bool &ENSI, bool &RF,
                         uint8_t &REQCHNR) volatile
    {
        uint32_t curr = Q0R0;

        V = curr & (1u << 8u);
        EXTR = curr & (1u << 7u);
        ENSI = curr & (1u << 6u);
        RF = curr & (1u << 5u);
        REQCHNR = (curr >> 0u) & 0b11111u;
    }

    /**
     * Set QINR0's EXTR bit.
     *
     * External Trigger
     */
    inline void set_QINR0_EXTR() volatile
    {
        QINR0 |= 1u << 7u;
    }

    /**
     * Clear QINR0's EXTR bit.
     *
     * External Trigger
     */
    inline void clear_QINR0_EXTR() volatile
    {
        QINR0 &= ~(1u << 7u);
    }

    /**
     * Toggle QINR0's EXTR bit.
     *
     * External Trigger
     */
    inline void toggle_QINR0_EXTR() volatile
    {
        QINR0 ^= 1u << 7u;
    }

    /**
     * Set QINR0's ENSI bit.
     *
     * Enable Source Interrupt
     */
    inline void set_QINR0_ENSI() volatile
    {
        QINR0 |= 1u << 6u;
    }

    /**
     * Clear QINR0's ENSI bit.
     *
     * Enable Source Interrupt
     */
    inline void clear_QINR0_ENSI() volatile
    {
        QINR0 &= ~(1u << 6u);
    }

    /**
     * Toggle QINR0's ENSI bit.
     *
     * Enable Source Interrupt
     */
    inline void toggle_QINR0_ENSI() volatile
    {
        QINR0 ^= 1u << 6u;
    }

    /**
     * Set QINR0's RF bit.
     *
     * Refill
     */
    inline void set_QINR0_RF() volatile
    {
        QINR0 |= 1u << 5u;
    }

    /**
     * Clear QINR0's RF bit.
     *
     * Refill
     */
    inline void clear_QINR0_RF() volatile
    {
        QINR0 &= ~(1u << 5u);
    }

    /**
     * Toggle QINR0's RF bit.
     *
     * Refill
     */
    inline void toggle_QINR0_RF() volatile
    {
        QINR0 ^= 1u << 5u;
    }

    /**
     * Set QINR0's REQCHNR field.
     *
     * Request Channel Number
     */
    inline void set_QINR0_REQCHNR(uint8_t value) volatile
    {
        uint32_t curr = QINR0;

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        QINR0 = curr;
    }

    /**
     * Set all of QINR0's bit fields.
     *
     * (write-only) Queue 0 Input Register
     */
    inline void set_QINR0(bool EXTR, bool ENSI, bool RF,
                          uint8_t REQCHNR) volatile
    {
        uint32_t curr = QINR0;

        curr &= ~(0b1u << 7u);
        curr |= (EXTR & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (ENSI & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (RF & 0b1u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (REQCHNR & 0b11111u) << 0u;

        QINR0 = curr;
    }

    /**
     * Get QINR0's V bit.
     *
     * Request Channel Number Valid
     */
    inline bool get_QBUR0_V() volatile
    {
        return QBUR0 & (1u << 8u);
    }

    /**
     * Get QINR0's EXTR bit.
     *
     * External Trigger
     */
    inline bool get_QBUR0_EXTR() volatile
    {
        return QBUR0 & (1u << 7u);
    }

    /**
     * Get QINR0's ENSI bit.
     *
     * Enable Source Interrupt
     */
    inline bool get_QBUR0_ENSI() volatile
    {
        return QBUR0 & (1u << 6u);
    }

    /**
     * Get QINR0's RF bit.
     *
     * Refill
     */
    inline bool get_QBUR0_RF() volatile
    {
        return QBUR0 & (1u << 5u);
    }

    /**
     * Get QINR0's REQCHNR field.
     *
     * Request Channel Number
     */
    inline uint8_t get_QBUR0_REQCHNR() volatile
    {
        return (QBUR0 >> 0u) & 0b11111u;
    }

    /**
     * Get all of QBUR0's bit fields.
     *
     * (write-only) Queue 0 Input Register
     */
    inline void get_QBUR0(bool &V, bool &EXTR, bool &ENSI, bool &RF,
                          uint8_t &REQCHNR) volatile
    {
        uint32_t curr = QBUR0;

        V = curr & (1u << 8u);
        EXTR = curr & (1u << 7u);
        ENSI = curr & (1u << 6u);
        RF = curr & (1u << 5u);
        REQCHNR = (curr >> 0u) & 0b11111u;
    }

    /**
     * Set ASCTRL's TMWC bit.
     *
     * Write Control for Timer Mode
     */
    inline void set_ASCTRL_TMWC() volatile
    {
        ASCTRL |= 1u << 31u;
    }

    /**
     * Clear ASCTRL's TMWC bit.
     *
     * Write Control for Timer Mode
     */
    inline void clear_ASCTRL_TMWC() volatile
    {
        ASCTRL &= ~(1u << 31u);
    }

    /**
     * Toggle ASCTRL's TMWC bit.
     *
     * Write Control for Timer Mode
     */
    inline void toggle_ASCTRL_TMWC() volatile
    {
        ASCTRL ^= 1u << 31u;
    }

    /**
     * Get ASCTRL's TMEN bit.
     *
     * Timer Mode Enable
     */
    inline bool get_ASCTRL_TMEN() volatile
    {
        return ASCTRL & (1u << 28u);
    }

    /**
     * Set ASCTRL's TMEN bit.
     *
     * Timer Mode Enable
     */
    inline void set_ASCTRL_TMEN() volatile
    {
        ASCTRL |= 1u << 28u;
    }

    /**
     * Clear ASCTRL's TMEN bit.
     *
     * Timer Mode Enable
     */
    inline void clear_ASCTRL_TMEN() volatile
    {
        ASCTRL &= ~(1u << 28u);
    }

    /**
     * Toggle ASCTRL's TMEN bit.
     *
     * Timer Mode Enable
     */
    inline void toggle_ASCTRL_TMEN() volatile
    {
        ASCTRL ^= 1u << 28u;
    }

    /**
     * Set ASCTRL's GTWC bit.
     *
     * Write Control for Gate Configuration
     */
    inline void set_ASCTRL_GTWC() volatile
    {
        ASCTRL |= 1u << 23u;
    }

    /**
     * Clear ASCTRL's GTWC bit.
     *
     * Write Control for Gate Configuration
     */
    inline void clear_ASCTRL_GTWC() volatile
    {
        ASCTRL &= ~(1u << 23u);
    }

    /**
     * Toggle ASCTRL's GTWC bit.
     *
     * Write Control for Gate Configuration
     */
    inline void toggle_ASCTRL_GTWC() volatile
    {
        ASCTRL ^= 1u << 23u;
    }

    /**
     * Get ASCTRL's GTLVL bit.
     *
     * Gate Input Level
     */
    inline bool get_ASCTRL_GTLVL() volatile
    {
        return ASCTRL & (1u << 20u);
    }

    /**
     * Get ASCTRL's GTSEL field.
     *
     * Gate Input Selection
     */
    inline uint8_t get_ASCTRL_GTSEL() volatile
    {
        return (ASCTRL >> 16u) & 0b1111u;
    }

    /**
     * Set ASCTRL's GTSEL field.
     *
     * Gate Input Selection
     */
    inline void set_ASCTRL_GTSEL(uint8_t value) volatile
    {
        uint32_t curr = ASCTRL;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        ASCTRL = curr;
    }

    /**
     * Set ASCTRL's XTWC bit.
     *
     * Write Control for Trigger Configuration
     */
    inline void set_ASCTRL_XTWC() volatile
    {
        ASCTRL |= 1u << 15u;
    }

    /**
     * Clear ASCTRL's XTWC bit.
     *
     * Write Control for Trigger Configuration
     */
    inline void clear_ASCTRL_XTWC() volatile
    {
        ASCTRL &= ~(1u << 15u);
    }

    /**
     * Toggle ASCTRL's XTWC bit.
     *
     * Write Control for Trigger Configuration
     */
    inline void toggle_ASCTRL_XTWC() volatile
    {
        ASCTRL ^= 1u << 15u;
    }

    /**
     * Get ASCTRL's XTMODE field.
     *
     * Trigger Operating Mode
     */
    inline VADC_G0_QCTRL0_XTMODE get_ASCTRL_XTMODE() volatile
    {
        return VADC_G0_QCTRL0_XTMODE((ASCTRL >> 13u) & 0b11u);
    }

    /**
     * Set ASCTRL's XTMODE field.
     *
     * Trigger Operating Mode
     */
    inline void set_ASCTRL_XTMODE(VADC_G0_QCTRL0_XTMODE value) volatile
    {
        uint32_t curr = ASCTRL;

        curr &= ~(0b11u << 13u);
        curr |= (std::to_underlying(value) & 0b11u) << 13u;

        ASCTRL = curr;
    }

    /**
     * Get ASCTRL's XTLVL bit.
     *
     * External Trigger Level
     */
    inline bool get_ASCTRL_XTLVL() volatile
    {
        return ASCTRL & (1u << 12u);
    }

    /**
     * Get ASCTRL's XTSEL field.
     *
     * External Trigger Input Selection
     */
    inline uint8_t get_ASCTRL_XTSEL() volatile
    {
        return (ASCTRL >> 8u) & 0b1111u;
    }

    /**
     * Set ASCTRL's XTSEL field.
     *
     * External Trigger Input Selection
     */
    inline void set_ASCTRL_XTSEL(uint8_t value) volatile
    {
        uint32_t curr = ASCTRL;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        ASCTRL = curr;
    }

    /**
     * Get ASCTRL's SRCRESREG field.
     *
     * Source-specific Result Register
     */
    inline VADC_G0_QCTRL0_SRCRESREG get_ASCTRL_SRCRESREG() volatile
    {
        return VADC_G0_QCTRL0_SRCRESREG((ASCTRL >> 0u) & 0b1111u);
    }

    /**
     * Set ASCTRL's SRCRESREG field.
     *
     * Source-specific Result Register
     */
    inline void set_ASCTRL_SRCRESREG(VADC_G0_QCTRL0_SRCRESREG value) volatile
    {
        uint32_t curr = ASCTRL;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        ASCTRL = curr;
    }

    /**
     * Get all of ASCTRL's bit fields.
     *
     * (read-write) Autoscan Source Control Register
     */
    inline void get_ASCTRL(bool &TMEN, bool &GTLVL, uint8_t &GTSEL,
                           VADC_G0_QCTRL0_XTMODE &XTMODE, bool &XTLVL,
                           uint8_t &XTSEL,
                           VADC_G0_QCTRL0_SRCRESREG &SRCRESREG) volatile
    {
        uint32_t curr = ASCTRL;

        TMEN = curr & (1u << 28u);
        GTLVL = curr & (1u << 20u);
        GTSEL = (curr >> 16u) & 0b1111u;
        XTMODE = VADC_G0_QCTRL0_XTMODE((curr >> 13u) & 0b11u);
        XTLVL = curr & (1u << 12u);
        XTSEL = (curr >> 8u) & 0b1111u;
        SRCRESREG = VADC_G0_QCTRL0_SRCRESREG((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of ASCTRL's bit fields.
     *
     * (read-write) Autoscan Source Control Register
     */
    inline void set_ASCTRL(bool TMWC, bool TMEN, bool GTWC, uint8_t GTSEL,
                           bool XTWC, VADC_G0_QCTRL0_XTMODE XTMODE,
                           uint8_t XTSEL,
                           VADC_G0_QCTRL0_SRCRESREG SRCRESREG) volatile
    {
        uint32_t curr = ASCTRL;

        curr &= ~(0b1u << 31u);
        curr |= (TMWC & 0b1u) << 31u;
        curr &= ~(0b1u << 28u);
        curr |= (TMEN & 0b1u) << 28u;
        curr &= ~(0b1u << 23u);
        curr |= (GTWC & 0b1u) << 23u;
        curr &= ~(0b1111u << 16u);
        curr |= (GTSEL & 0b1111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (XTWC & 0b1u) << 15u;
        curr &= ~(0b11u << 13u);
        curr |= (std::to_underlying(XTMODE) & 0b11u) << 13u;
        curr &= ~(0b1111u << 8u);
        curr |= (XTSEL & 0b1111u) << 8u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(SRCRESREG) & 0b1111u) << 0u;

        ASCTRL = curr;
    }

    /**
     * Get ASMR's RPTDIS bit.
     *
     * Repeat Disable
     */
    inline bool get_ASMR_RPTDIS() volatile
    {
        return ASMR & (1u << 16u);
    }

    /**
     * Set ASMR's RPTDIS bit.
     *
     * Repeat Disable
     */
    inline void set_ASMR_RPTDIS() volatile
    {
        ASMR |= 1u << 16u;
    }

    /**
     * Clear ASMR's RPTDIS bit.
     *
     * Repeat Disable
     */
    inline void clear_ASMR_RPTDIS() volatile
    {
        ASMR &= ~(1u << 16u);
    }

    /**
     * Toggle ASMR's RPTDIS bit.
     *
     * Repeat Disable
     */
    inline void toggle_ASMR_RPTDIS() volatile
    {
        ASMR ^= 1u << 16u;
    }

    /**
     * Set ASMR's LDEV bit.
     *
     * Generate Load Event
     */
    inline void set_ASMR_LDEV() volatile
    {
        ASMR |= 1u << 9u;
    }

    /**
     * Clear ASMR's LDEV bit.
     *
     * Generate Load Event
     */
    inline void clear_ASMR_LDEV() volatile
    {
        ASMR &= ~(1u << 9u);
    }

    /**
     * Toggle ASMR's LDEV bit.
     *
     * Generate Load Event
     */
    inline void toggle_ASMR_LDEV() volatile
    {
        ASMR ^= 1u << 9u;
    }

    /**
     * Set ASMR's CLRPND bit.
     *
     * Clear Pending Bits
     */
    inline void set_ASMR_CLRPND() volatile
    {
        ASMR |= 1u << 8u;
    }

    /**
     * Clear ASMR's CLRPND bit.
     *
     * Clear Pending Bits
     */
    inline void clear_ASMR_CLRPND() volatile
    {
        ASMR &= ~(1u << 8u);
    }

    /**
     * Toggle ASMR's CLRPND bit.
     *
     * Clear Pending Bits
     */
    inline void toggle_ASMR_CLRPND() volatile
    {
        ASMR ^= 1u << 8u;
    }

    /**
     * Get ASMR's REQGT bit.
     *
     * Request Gate Level
     */
    inline bool get_ASMR_REQGT() volatile
    {
        return ASMR & (1u << 7u);
    }

    /**
     * Get ASMR's LDM bit.
     *
     * Autoscan Source Load Event Mode
     */
    inline bool get_ASMR_LDM() volatile
    {
        return ASMR & (1u << 5u);
    }

    /**
     * Set ASMR's LDM bit.
     *
     * Autoscan Source Load Event Mode
     */
    inline void set_ASMR_LDM() volatile
    {
        ASMR |= 1u << 5u;
    }

    /**
     * Clear ASMR's LDM bit.
     *
     * Autoscan Source Load Event Mode
     */
    inline void clear_ASMR_LDM() volatile
    {
        ASMR &= ~(1u << 5u);
    }

    /**
     * Toggle ASMR's LDM bit.
     *
     * Autoscan Source Load Event Mode
     */
    inline void toggle_ASMR_LDM() volatile
    {
        ASMR ^= 1u << 5u;
    }

    /**
     * Get ASMR's SCAN bit.
     *
     * Autoscan Enable
     */
    inline bool get_ASMR_SCAN() volatile
    {
        return ASMR & (1u << 4u);
    }

    /**
     * Set ASMR's SCAN bit.
     *
     * Autoscan Enable
     */
    inline void set_ASMR_SCAN() volatile
    {
        ASMR |= 1u << 4u;
    }

    /**
     * Clear ASMR's SCAN bit.
     *
     * Autoscan Enable
     */
    inline void clear_ASMR_SCAN() volatile
    {
        ASMR &= ~(1u << 4u);
    }

    /**
     * Toggle ASMR's SCAN bit.
     *
     * Autoscan Enable
     */
    inline void toggle_ASMR_SCAN() volatile
    {
        ASMR ^= 1u << 4u;
    }

    /**
     * Get ASMR's ENSI bit.
     *
     * Enable Source Interrupt
     */
    inline bool get_ASMR_ENSI() volatile
    {
        return ASMR & (1u << 3u);
    }

    /**
     * Set ASMR's ENSI bit.
     *
     * Enable Source Interrupt
     */
    inline void set_ASMR_ENSI() volatile
    {
        ASMR |= 1u << 3u;
    }

    /**
     * Clear ASMR's ENSI bit.
     *
     * Enable Source Interrupt
     */
    inline void clear_ASMR_ENSI() volatile
    {
        ASMR &= ~(1u << 3u);
    }

    /**
     * Toggle ASMR's ENSI bit.
     *
     * Enable Source Interrupt
     */
    inline void toggle_ASMR_ENSI() volatile
    {
        ASMR ^= 1u << 3u;
    }

    /**
     * Get ASMR's ENTR bit.
     *
     * Enable External Trigger
     */
    inline bool get_ASMR_ENTR() volatile
    {
        return ASMR & (1u << 2u);
    }

    /**
     * Set ASMR's ENTR bit.
     *
     * Enable External Trigger
     */
    inline void set_ASMR_ENTR() volatile
    {
        ASMR |= 1u << 2u;
    }

    /**
     * Clear ASMR's ENTR bit.
     *
     * Enable External Trigger
     */
    inline void clear_ASMR_ENTR() volatile
    {
        ASMR &= ~(1u << 2u);
    }

    /**
     * Toggle ASMR's ENTR bit.
     *
     * Enable External Trigger
     */
    inline void toggle_ASMR_ENTR() volatile
    {
        ASMR ^= 1u << 2u;
    }

    /**
     * Get ASMR's ENGT field.
     *
     * Enable Gate
     */
    inline VADC_G0_ASMR_ENGT get_ASMR_ENGT() volatile
    {
        return VADC_G0_ASMR_ENGT((ASMR >> 0u) & 0b11u);
    }

    /**
     * Set ASMR's ENGT field.
     *
     * Enable Gate
     */
    inline void set_ASMR_ENGT(VADC_G0_ASMR_ENGT value) volatile
    {
        uint32_t curr = ASMR;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        ASMR = curr;
    }

    /**
     * Get all of ASMR's bit fields.
     *
     * (read-write) Autoscan Source Mode Register
     */
    inline void get_ASMR(bool &RPTDIS, bool &REQGT, bool &LDM, bool &SCAN,
                         bool &ENSI, bool &ENTR,
                         VADC_G0_ASMR_ENGT &ENGT) volatile
    {
        uint32_t curr = ASMR;

        RPTDIS = curr & (1u << 16u);
        REQGT = curr & (1u << 7u);
        LDM = curr & (1u << 5u);
        SCAN = curr & (1u << 4u);
        ENSI = curr & (1u << 3u);
        ENTR = curr & (1u << 2u);
        ENGT = VADC_G0_ASMR_ENGT((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of ASMR's bit fields.
     *
     * (read-write) Autoscan Source Mode Register
     */
    inline void set_ASMR(bool RPTDIS, bool LDEV, bool CLRPND, bool LDM,
                         bool SCAN, bool ENSI, bool ENTR,
                         VADC_G0_ASMR_ENGT ENGT) volatile
    {
        uint32_t curr = ASMR;

        curr &= ~(0b1u << 16u);
        curr |= (RPTDIS & 0b1u) << 16u;
        curr &= ~(0b1u << 9u);
        curr |= (LDEV & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (CLRPND & 0b1u) << 8u;
        curr &= ~(0b1u << 5u);
        curr |= (LDM & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (SCAN & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (ENSI & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ENTR & 0b1u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(ENGT) & 0b11u) << 0u;

        ASMR = curr;
    }

    /**
     * Get ASSEL's CHSEL7 bit.
     *
     * Channel Selection
     */
    inline bool get_ASSEL_CHSEL7() volatile
    {
        return ASSEL & (1u << 7u);
    }

    /**
     * Set ASSEL's CHSEL7 bit.
     *
     * Channel Selection
     */
    inline void set_ASSEL_CHSEL7() volatile
    {
        ASSEL |= 1u << 7u;
    }

    /**
     * Clear ASSEL's CHSEL7 bit.
     *
     * Channel Selection
     */
    inline void clear_ASSEL_CHSEL7() volatile
    {
        ASSEL &= ~(1u << 7u);
    }

    /**
     * Toggle ASSEL's CHSEL7 bit.
     *
     * Channel Selection
     */
    inline void toggle_ASSEL_CHSEL7() volatile
    {
        ASSEL ^= 1u << 7u;
    }

    /**
     * Get ASSEL's CHSEL6 bit.
     *
     * Channel Selection
     */
    inline bool get_ASSEL_CHSEL6() volatile
    {
        return ASSEL & (1u << 6u);
    }

    /**
     * Set ASSEL's CHSEL6 bit.
     *
     * Channel Selection
     */
    inline void set_ASSEL_CHSEL6() volatile
    {
        ASSEL |= 1u << 6u;
    }

    /**
     * Clear ASSEL's CHSEL6 bit.
     *
     * Channel Selection
     */
    inline void clear_ASSEL_CHSEL6() volatile
    {
        ASSEL &= ~(1u << 6u);
    }

    /**
     * Toggle ASSEL's CHSEL6 bit.
     *
     * Channel Selection
     */
    inline void toggle_ASSEL_CHSEL6() volatile
    {
        ASSEL ^= 1u << 6u;
    }

    /**
     * Get ASSEL's CHSEL5 bit.
     *
     * Channel Selection
     */
    inline bool get_ASSEL_CHSEL5() volatile
    {
        return ASSEL & (1u << 5u);
    }

    /**
     * Set ASSEL's CHSEL5 bit.
     *
     * Channel Selection
     */
    inline void set_ASSEL_CHSEL5() volatile
    {
        ASSEL |= 1u << 5u;
    }

    /**
     * Clear ASSEL's CHSEL5 bit.
     *
     * Channel Selection
     */
    inline void clear_ASSEL_CHSEL5() volatile
    {
        ASSEL &= ~(1u << 5u);
    }

    /**
     * Toggle ASSEL's CHSEL5 bit.
     *
     * Channel Selection
     */
    inline void toggle_ASSEL_CHSEL5() volatile
    {
        ASSEL ^= 1u << 5u;
    }

    /**
     * Get ASSEL's CHSEL4 bit.
     *
     * Channel Selection
     */
    inline bool get_ASSEL_CHSEL4() volatile
    {
        return ASSEL & (1u << 4u);
    }

    /**
     * Set ASSEL's CHSEL4 bit.
     *
     * Channel Selection
     */
    inline void set_ASSEL_CHSEL4() volatile
    {
        ASSEL |= 1u << 4u;
    }

    /**
     * Clear ASSEL's CHSEL4 bit.
     *
     * Channel Selection
     */
    inline void clear_ASSEL_CHSEL4() volatile
    {
        ASSEL &= ~(1u << 4u);
    }

    /**
     * Toggle ASSEL's CHSEL4 bit.
     *
     * Channel Selection
     */
    inline void toggle_ASSEL_CHSEL4() volatile
    {
        ASSEL ^= 1u << 4u;
    }

    /**
     * Get ASSEL's CHSEL3 bit.
     *
     * Channel Selection
     */
    inline bool get_ASSEL_CHSEL3() volatile
    {
        return ASSEL & (1u << 3u);
    }

    /**
     * Set ASSEL's CHSEL3 bit.
     *
     * Channel Selection
     */
    inline void set_ASSEL_CHSEL3() volatile
    {
        ASSEL |= 1u << 3u;
    }

    /**
     * Clear ASSEL's CHSEL3 bit.
     *
     * Channel Selection
     */
    inline void clear_ASSEL_CHSEL3() volatile
    {
        ASSEL &= ~(1u << 3u);
    }

    /**
     * Toggle ASSEL's CHSEL3 bit.
     *
     * Channel Selection
     */
    inline void toggle_ASSEL_CHSEL3() volatile
    {
        ASSEL ^= 1u << 3u;
    }

    /**
     * Get ASSEL's CHSEL2 bit.
     *
     * Channel Selection
     */
    inline bool get_ASSEL_CHSEL2() volatile
    {
        return ASSEL & (1u << 2u);
    }

    /**
     * Set ASSEL's CHSEL2 bit.
     *
     * Channel Selection
     */
    inline void set_ASSEL_CHSEL2() volatile
    {
        ASSEL |= 1u << 2u;
    }

    /**
     * Clear ASSEL's CHSEL2 bit.
     *
     * Channel Selection
     */
    inline void clear_ASSEL_CHSEL2() volatile
    {
        ASSEL &= ~(1u << 2u);
    }

    /**
     * Toggle ASSEL's CHSEL2 bit.
     *
     * Channel Selection
     */
    inline void toggle_ASSEL_CHSEL2() volatile
    {
        ASSEL ^= 1u << 2u;
    }

    /**
     * Get ASSEL's CHSEL1 bit.
     *
     * Channel Selection
     */
    inline bool get_ASSEL_CHSEL1() volatile
    {
        return ASSEL & (1u << 1u);
    }

    /**
     * Set ASSEL's CHSEL1 bit.
     *
     * Channel Selection
     */
    inline void set_ASSEL_CHSEL1() volatile
    {
        ASSEL |= 1u << 1u;
    }

    /**
     * Clear ASSEL's CHSEL1 bit.
     *
     * Channel Selection
     */
    inline void clear_ASSEL_CHSEL1() volatile
    {
        ASSEL &= ~(1u << 1u);
    }

    /**
     * Toggle ASSEL's CHSEL1 bit.
     *
     * Channel Selection
     */
    inline void toggle_ASSEL_CHSEL1() volatile
    {
        ASSEL ^= 1u << 1u;
    }

    /**
     * Get ASSEL's CHSEL0 bit.
     *
     * Channel Selection
     */
    inline bool get_ASSEL_CHSEL0() volatile
    {
        return ASSEL & (1u << 0u);
    }

    /**
     * Set ASSEL's CHSEL0 bit.
     *
     * Channel Selection
     */
    inline void set_ASSEL_CHSEL0() volatile
    {
        ASSEL |= 1u << 0u;
    }

    /**
     * Clear ASSEL's CHSEL0 bit.
     *
     * Channel Selection
     */
    inline void clear_ASSEL_CHSEL0() volatile
    {
        ASSEL &= ~(1u << 0u);
    }

    /**
     * Toggle ASSEL's CHSEL0 bit.
     *
     * Channel Selection
     */
    inline void toggle_ASSEL_CHSEL0() volatile
    {
        ASSEL ^= 1u << 0u;
    }

    /**
     * Get all of ASSEL's bit fields.
     *
     * (read-write) Autoscan Source Channel Select Register
     */
    inline void get_ASSEL(bool &CHSEL7, bool &CHSEL6, bool &CHSEL5,
                          bool &CHSEL4, bool &CHSEL3, bool &CHSEL2,
                          bool &CHSEL1, bool &CHSEL0) volatile
    {
        uint32_t curr = ASSEL;

        CHSEL7 = curr & (1u << 7u);
        CHSEL6 = curr & (1u << 6u);
        CHSEL5 = curr & (1u << 5u);
        CHSEL4 = curr & (1u << 4u);
        CHSEL3 = curr & (1u << 3u);
        CHSEL2 = curr & (1u << 2u);
        CHSEL1 = curr & (1u << 1u);
        CHSEL0 = curr & (1u << 0u);
    }

    /**
     * Set all of ASSEL's bit fields.
     *
     * (read-write) Autoscan Source Channel Select Register
     */
    inline void set_ASSEL(bool CHSEL7, bool CHSEL6, bool CHSEL5, bool CHSEL4,
                          bool CHSEL3, bool CHSEL2, bool CHSEL1,
                          bool CHSEL0) volatile
    {
        uint32_t curr = ASSEL;

        curr &= ~(0b1u << 7u);
        curr |= (CHSEL7 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (CHSEL6 & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (CHSEL5 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (CHSEL4 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (CHSEL3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (CHSEL2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (CHSEL1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CHSEL0 & 0b1u) << 0u;

        ASSEL = curr;
    }

    /**
     * Get ASPND's CHPND7 bit.
     *
     * Channels Pending
     */
    inline bool get_ASPND_CHPND7() volatile
    {
        return ASPND & (1u << 7u);
    }

    /**
     * Set ASPND's CHPND7 bit.
     *
     * Channels Pending
     */
    inline void set_ASPND_CHPND7() volatile
    {
        ASPND |= 1u << 7u;
    }

    /**
     * Clear ASPND's CHPND7 bit.
     *
     * Channels Pending
     */
    inline void clear_ASPND_CHPND7() volatile
    {
        ASPND &= ~(1u << 7u);
    }

    /**
     * Toggle ASPND's CHPND7 bit.
     *
     * Channels Pending
     */
    inline void toggle_ASPND_CHPND7() volatile
    {
        ASPND ^= 1u << 7u;
    }

    /**
     * Get ASPND's CHPND6 bit.
     *
     * Channels Pending
     */
    inline bool get_ASPND_CHPND6() volatile
    {
        return ASPND & (1u << 6u);
    }

    /**
     * Set ASPND's CHPND6 bit.
     *
     * Channels Pending
     */
    inline void set_ASPND_CHPND6() volatile
    {
        ASPND |= 1u << 6u;
    }

    /**
     * Clear ASPND's CHPND6 bit.
     *
     * Channels Pending
     */
    inline void clear_ASPND_CHPND6() volatile
    {
        ASPND &= ~(1u << 6u);
    }

    /**
     * Toggle ASPND's CHPND6 bit.
     *
     * Channels Pending
     */
    inline void toggle_ASPND_CHPND6() volatile
    {
        ASPND ^= 1u << 6u;
    }

    /**
     * Get ASPND's CHPND5 bit.
     *
     * Channels Pending
     */
    inline bool get_ASPND_CHPND5() volatile
    {
        return ASPND & (1u << 5u);
    }

    /**
     * Set ASPND's CHPND5 bit.
     *
     * Channels Pending
     */
    inline void set_ASPND_CHPND5() volatile
    {
        ASPND |= 1u << 5u;
    }

    /**
     * Clear ASPND's CHPND5 bit.
     *
     * Channels Pending
     */
    inline void clear_ASPND_CHPND5() volatile
    {
        ASPND &= ~(1u << 5u);
    }

    /**
     * Toggle ASPND's CHPND5 bit.
     *
     * Channels Pending
     */
    inline void toggle_ASPND_CHPND5() volatile
    {
        ASPND ^= 1u << 5u;
    }

    /**
     * Get ASPND's CHPND4 bit.
     *
     * Channels Pending
     */
    inline bool get_ASPND_CHPND4() volatile
    {
        return ASPND & (1u << 4u);
    }

    /**
     * Set ASPND's CHPND4 bit.
     *
     * Channels Pending
     */
    inline void set_ASPND_CHPND4() volatile
    {
        ASPND |= 1u << 4u;
    }

    /**
     * Clear ASPND's CHPND4 bit.
     *
     * Channels Pending
     */
    inline void clear_ASPND_CHPND4() volatile
    {
        ASPND &= ~(1u << 4u);
    }

    /**
     * Toggle ASPND's CHPND4 bit.
     *
     * Channels Pending
     */
    inline void toggle_ASPND_CHPND4() volatile
    {
        ASPND ^= 1u << 4u;
    }

    /**
     * Get ASPND's CHPND3 bit.
     *
     * Channels Pending
     */
    inline bool get_ASPND_CHPND3() volatile
    {
        return ASPND & (1u << 3u);
    }

    /**
     * Set ASPND's CHPND3 bit.
     *
     * Channels Pending
     */
    inline void set_ASPND_CHPND3() volatile
    {
        ASPND |= 1u << 3u;
    }

    /**
     * Clear ASPND's CHPND3 bit.
     *
     * Channels Pending
     */
    inline void clear_ASPND_CHPND3() volatile
    {
        ASPND &= ~(1u << 3u);
    }

    /**
     * Toggle ASPND's CHPND3 bit.
     *
     * Channels Pending
     */
    inline void toggle_ASPND_CHPND3() volatile
    {
        ASPND ^= 1u << 3u;
    }

    /**
     * Get ASPND's CHPND2 bit.
     *
     * Channels Pending
     */
    inline bool get_ASPND_CHPND2() volatile
    {
        return ASPND & (1u << 2u);
    }

    /**
     * Set ASPND's CHPND2 bit.
     *
     * Channels Pending
     */
    inline void set_ASPND_CHPND2() volatile
    {
        ASPND |= 1u << 2u;
    }

    /**
     * Clear ASPND's CHPND2 bit.
     *
     * Channels Pending
     */
    inline void clear_ASPND_CHPND2() volatile
    {
        ASPND &= ~(1u << 2u);
    }

    /**
     * Toggle ASPND's CHPND2 bit.
     *
     * Channels Pending
     */
    inline void toggle_ASPND_CHPND2() volatile
    {
        ASPND ^= 1u << 2u;
    }

    /**
     * Get ASPND's CHPND1 bit.
     *
     * Channels Pending
     */
    inline bool get_ASPND_CHPND1() volatile
    {
        return ASPND & (1u << 1u);
    }

    /**
     * Set ASPND's CHPND1 bit.
     *
     * Channels Pending
     */
    inline void set_ASPND_CHPND1() volatile
    {
        ASPND |= 1u << 1u;
    }

    /**
     * Clear ASPND's CHPND1 bit.
     *
     * Channels Pending
     */
    inline void clear_ASPND_CHPND1() volatile
    {
        ASPND &= ~(1u << 1u);
    }

    /**
     * Toggle ASPND's CHPND1 bit.
     *
     * Channels Pending
     */
    inline void toggle_ASPND_CHPND1() volatile
    {
        ASPND ^= 1u << 1u;
    }

    /**
     * Get ASPND's CHPND0 bit.
     *
     * Channels Pending
     */
    inline bool get_ASPND_CHPND0() volatile
    {
        return ASPND & (1u << 0u);
    }

    /**
     * Set ASPND's CHPND0 bit.
     *
     * Channels Pending
     */
    inline void set_ASPND_CHPND0() volatile
    {
        ASPND |= 1u << 0u;
    }

    /**
     * Clear ASPND's CHPND0 bit.
     *
     * Channels Pending
     */
    inline void clear_ASPND_CHPND0() volatile
    {
        ASPND &= ~(1u << 0u);
    }

    /**
     * Toggle ASPND's CHPND0 bit.
     *
     * Channels Pending
     */
    inline void toggle_ASPND_CHPND0() volatile
    {
        ASPND ^= 1u << 0u;
    }

    /**
     * Get all of ASPND's bit fields.
     *
     * (read-write) Autoscan Source Pending Register
     */
    inline void get_ASPND(bool &CHPND7, bool &CHPND6, bool &CHPND5,
                          bool &CHPND4, bool &CHPND3, bool &CHPND2,
                          bool &CHPND1, bool &CHPND0) volatile
    {
        uint32_t curr = ASPND;

        CHPND7 = curr & (1u << 7u);
        CHPND6 = curr & (1u << 6u);
        CHPND5 = curr & (1u << 5u);
        CHPND4 = curr & (1u << 4u);
        CHPND3 = curr & (1u << 3u);
        CHPND2 = curr & (1u << 2u);
        CHPND1 = curr & (1u << 1u);
        CHPND0 = curr & (1u << 0u);
    }

    /**
     * Set all of ASPND's bit fields.
     *
     * (read-write) Autoscan Source Pending Register
     */
    inline void set_ASPND(bool CHPND7, bool CHPND6, bool CHPND5, bool CHPND4,
                          bool CHPND3, bool CHPND2, bool CHPND1,
                          bool CHPND0) volatile
    {
        uint32_t curr = ASPND;

        curr &= ~(0b1u << 7u);
        curr |= (CHPND7 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (CHPND6 & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (CHPND5 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (CHPND4 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (CHPND3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (CHPND2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (CHPND1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CHPND0 & 0b1u) << 0u;

        ASPND = curr;
    }

    /**
     * Get CEFLAG's CEV7 bit.
     *
     * Channel Event for Channel 7
     */
    inline bool get_CEFLAG_CEV7() volatile
    {
        return CEFLAG & (1u << 7u);
    }

    /**
     * Set CEFLAG's CEV7 bit.
     *
     * Channel Event for Channel 7
     */
    inline void set_CEFLAG_CEV7() volatile
    {
        CEFLAG |= 1u << 7u;
    }

    /**
     * Clear CEFLAG's CEV7 bit.
     *
     * Channel Event for Channel 7
     */
    inline void clear_CEFLAG_CEV7() volatile
    {
        CEFLAG &= ~(1u << 7u);
    }

    /**
     * Toggle CEFLAG's CEV7 bit.
     *
     * Channel Event for Channel 7
     */
    inline void toggle_CEFLAG_CEV7() volatile
    {
        CEFLAG ^= 1u << 7u;
    }

    /**
     * Get CEFLAG's CEV6 bit.
     *
     * Channel Event for Channel 6
     */
    inline bool get_CEFLAG_CEV6() volatile
    {
        return CEFLAG & (1u << 6u);
    }

    /**
     * Set CEFLAG's CEV6 bit.
     *
     * Channel Event for Channel 6
     */
    inline void set_CEFLAG_CEV6() volatile
    {
        CEFLAG |= 1u << 6u;
    }

    /**
     * Clear CEFLAG's CEV6 bit.
     *
     * Channel Event for Channel 6
     */
    inline void clear_CEFLAG_CEV6() volatile
    {
        CEFLAG &= ~(1u << 6u);
    }

    /**
     * Toggle CEFLAG's CEV6 bit.
     *
     * Channel Event for Channel 6
     */
    inline void toggle_CEFLAG_CEV6() volatile
    {
        CEFLAG ^= 1u << 6u;
    }

    /**
     * Get CEFLAG's CEV5 bit.
     *
     * Channel Event for Channel 5
     */
    inline bool get_CEFLAG_CEV5() volatile
    {
        return CEFLAG & (1u << 5u);
    }

    /**
     * Set CEFLAG's CEV5 bit.
     *
     * Channel Event for Channel 5
     */
    inline void set_CEFLAG_CEV5() volatile
    {
        CEFLAG |= 1u << 5u;
    }

    /**
     * Clear CEFLAG's CEV5 bit.
     *
     * Channel Event for Channel 5
     */
    inline void clear_CEFLAG_CEV5() volatile
    {
        CEFLAG &= ~(1u << 5u);
    }

    /**
     * Toggle CEFLAG's CEV5 bit.
     *
     * Channel Event for Channel 5
     */
    inline void toggle_CEFLAG_CEV5() volatile
    {
        CEFLAG ^= 1u << 5u;
    }

    /**
     * Get CEFLAG's CEV4 bit.
     *
     * Channel Event for Channel 4
     */
    inline bool get_CEFLAG_CEV4() volatile
    {
        return CEFLAG & (1u << 4u);
    }

    /**
     * Set CEFLAG's CEV4 bit.
     *
     * Channel Event for Channel 4
     */
    inline void set_CEFLAG_CEV4() volatile
    {
        CEFLAG |= 1u << 4u;
    }

    /**
     * Clear CEFLAG's CEV4 bit.
     *
     * Channel Event for Channel 4
     */
    inline void clear_CEFLAG_CEV4() volatile
    {
        CEFLAG &= ~(1u << 4u);
    }

    /**
     * Toggle CEFLAG's CEV4 bit.
     *
     * Channel Event for Channel 4
     */
    inline void toggle_CEFLAG_CEV4() volatile
    {
        CEFLAG ^= 1u << 4u;
    }

    /**
     * Get CEFLAG's CEV3 bit.
     *
     * Channel Event for Channel 3
     */
    inline bool get_CEFLAG_CEV3() volatile
    {
        return CEFLAG & (1u << 3u);
    }

    /**
     * Set CEFLAG's CEV3 bit.
     *
     * Channel Event for Channel 3
     */
    inline void set_CEFLAG_CEV3() volatile
    {
        CEFLAG |= 1u << 3u;
    }

    /**
     * Clear CEFLAG's CEV3 bit.
     *
     * Channel Event for Channel 3
     */
    inline void clear_CEFLAG_CEV3() volatile
    {
        CEFLAG &= ~(1u << 3u);
    }

    /**
     * Toggle CEFLAG's CEV3 bit.
     *
     * Channel Event for Channel 3
     */
    inline void toggle_CEFLAG_CEV3() volatile
    {
        CEFLAG ^= 1u << 3u;
    }

    /**
     * Get CEFLAG's CEV2 bit.
     *
     * Channel Event for Channel 2
     */
    inline bool get_CEFLAG_CEV2() volatile
    {
        return CEFLAG & (1u << 2u);
    }

    /**
     * Set CEFLAG's CEV2 bit.
     *
     * Channel Event for Channel 2
     */
    inline void set_CEFLAG_CEV2() volatile
    {
        CEFLAG |= 1u << 2u;
    }

    /**
     * Clear CEFLAG's CEV2 bit.
     *
     * Channel Event for Channel 2
     */
    inline void clear_CEFLAG_CEV2() volatile
    {
        CEFLAG &= ~(1u << 2u);
    }

    /**
     * Toggle CEFLAG's CEV2 bit.
     *
     * Channel Event for Channel 2
     */
    inline void toggle_CEFLAG_CEV2() volatile
    {
        CEFLAG ^= 1u << 2u;
    }

    /**
     * Get CEFLAG's CEV1 bit.
     *
     * Channel Event for Channel 1
     */
    inline bool get_CEFLAG_CEV1() volatile
    {
        return CEFLAG & (1u << 1u);
    }

    /**
     * Set CEFLAG's CEV1 bit.
     *
     * Channel Event for Channel 1
     */
    inline void set_CEFLAG_CEV1() volatile
    {
        CEFLAG |= 1u << 1u;
    }

    /**
     * Clear CEFLAG's CEV1 bit.
     *
     * Channel Event for Channel 1
     */
    inline void clear_CEFLAG_CEV1() volatile
    {
        CEFLAG &= ~(1u << 1u);
    }

    /**
     * Toggle CEFLAG's CEV1 bit.
     *
     * Channel Event for Channel 1
     */
    inline void toggle_CEFLAG_CEV1() volatile
    {
        CEFLAG ^= 1u << 1u;
    }

    /**
     * Get CEFLAG's CEV0 bit.
     *
     * Channel Event for Channel 0
     */
    inline bool get_CEFLAG_CEV0() volatile
    {
        return CEFLAG & (1u << 0u);
    }

    /**
     * Set CEFLAG's CEV0 bit.
     *
     * Channel Event for Channel 0
     */
    inline void set_CEFLAG_CEV0() volatile
    {
        CEFLAG |= 1u << 0u;
    }

    /**
     * Clear CEFLAG's CEV0 bit.
     *
     * Channel Event for Channel 0
     */
    inline void clear_CEFLAG_CEV0() volatile
    {
        CEFLAG &= ~(1u << 0u);
    }

    /**
     * Toggle CEFLAG's CEV0 bit.
     *
     * Channel Event for Channel 0
     */
    inline void toggle_CEFLAG_CEV0() volatile
    {
        CEFLAG ^= 1u << 0u;
    }

    /**
     * Get all of CEFLAG's bit fields.
     *
     * (read-write) Channel Event Flag Register
     */
    inline void get_CEFLAG(bool &CEV7, bool &CEV6, bool &CEV5, bool &CEV4,
                           bool &CEV3, bool &CEV2, bool &CEV1,
                           bool &CEV0) volatile
    {
        uint32_t curr = CEFLAG;

        CEV7 = curr & (1u << 7u);
        CEV6 = curr & (1u << 6u);
        CEV5 = curr & (1u << 5u);
        CEV4 = curr & (1u << 4u);
        CEV3 = curr & (1u << 3u);
        CEV2 = curr & (1u << 2u);
        CEV1 = curr & (1u << 1u);
        CEV0 = curr & (1u << 0u);
    }

    /**
     * Set all of CEFLAG's bit fields.
     *
     * (read-write) Channel Event Flag Register
     */
    inline void set_CEFLAG(bool CEV7, bool CEV6, bool CEV5, bool CEV4,
                           bool CEV3, bool CEV2, bool CEV1, bool CEV0) volatile
    {
        uint32_t curr = CEFLAG;

        curr &= ~(0b1u << 7u);
        curr |= (CEV7 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (CEV6 & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (CEV5 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (CEV4 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (CEV3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (CEV2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (CEV1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CEV0 & 0b1u) << 0u;

        CEFLAG = curr;
    }

    /**
     * Get REFLAG's REV15 bit.
     *
     * Result Event for Result Register 15
     */
    inline bool get_REFLAG_REV15() volatile
    {
        return REFLAG & (1u << 15u);
    }

    /**
     * Set REFLAG's REV15 bit.
     *
     * Result Event for Result Register 15
     */
    inline void set_REFLAG_REV15() volatile
    {
        REFLAG |= 1u << 15u;
    }

    /**
     * Clear REFLAG's REV15 bit.
     *
     * Result Event for Result Register 15
     */
    inline void clear_REFLAG_REV15() volatile
    {
        REFLAG &= ~(1u << 15u);
    }

    /**
     * Toggle REFLAG's REV15 bit.
     *
     * Result Event for Result Register 15
     */
    inline void toggle_REFLAG_REV15() volatile
    {
        REFLAG ^= 1u << 15u;
    }

    /**
     * Get REFLAG's REV14 bit.
     *
     * Result Event for Result Register 14
     */
    inline bool get_REFLAG_REV14() volatile
    {
        return REFLAG & (1u << 14u);
    }

    /**
     * Set REFLAG's REV14 bit.
     *
     * Result Event for Result Register 14
     */
    inline void set_REFLAG_REV14() volatile
    {
        REFLAG |= 1u << 14u;
    }

    /**
     * Clear REFLAG's REV14 bit.
     *
     * Result Event for Result Register 14
     */
    inline void clear_REFLAG_REV14() volatile
    {
        REFLAG &= ~(1u << 14u);
    }

    /**
     * Toggle REFLAG's REV14 bit.
     *
     * Result Event for Result Register 14
     */
    inline void toggle_REFLAG_REV14() volatile
    {
        REFLAG ^= 1u << 14u;
    }

    /**
     * Get REFLAG's REV13 bit.
     *
     * Result Event for Result Register 13
     */
    inline bool get_REFLAG_REV13() volatile
    {
        return REFLAG & (1u << 13u);
    }

    /**
     * Set REFLAG's REV13 bit.
     *
     * Result Event for Result Register 13
     */
    inline void set_REFLAG_REV13() volatile
    {
        REFLAG |= 1u << 13u;
    }

    /**
     * Clear REFLAG's REV13 bit.
     *
     * Result Event for Result Register 13
     */
    inline void clear_REFLAG_REV13() volatile
    {
        REFLAG &= ~(1u << 13u);
    }

    /**
     * Toggle REFLAG's REV13 bit.
     *
     * Result Event for Result Register 13
     */
    inline void toggle_REFLAG_REV13() volatile
    {
        REFLAG ^= 1u << 13u;
    }

    /**
     * Get REFLAG's REV12 bit.
     *
     * Result Event for Result Register 12
     */
    inline bool get_REFLAG_REV12() volatile
    {
        return REFLAG & (1u << 12u);
    }

    /**
     * Set REFLAG's REV12 bit.
     *
     * Result Event for Result Register 12
     */
    inline void set_REFLAG_REV12() volatile
    {
        REFLAG |= 1u << 12u;
    }

    /**
     * Clear REFLAG's REV12 bit.
     *
     * Result Event for Result Register 12
     */
    inline void clear_REFLAG_REV12() volatile
    {
        REFLAG &= ~(1u << 12u);
    }

    /**
     * Toggle REFLAG's REV12 bit.
     *
     * Result Event for Result Register 12
     */
    inline void toggle_REFLAG_REV12() volatile
    {
        REFLAG ^= 1u << 12u;
    }

    /**
     * Get REFLAG's REV11 bit.
     *
     * Result Event for Result Register 11
     */
    inline bool get_REFLAG_REV11() volatile
    {
        return REFLAG & (1u << 11u);
    }

    /**
     * Set REFLAG's REV11 bit.
     *
     * Result Event for Result Register 11
     */
    inline void set_REFLAG_REV11() volatile
    {
        REFLAG |= 1u << 11u;
    }

    /**
     * Clear REFLAG's REV11 bit.
     *
     * Result Event for Result Register 11
     */
    inline void clear_REFLAG_REV11() volatile
    {
        REFLAG &= ~(1u << 11u);
    }

    /**
     * Toggle REFLAG's REV11 bit.
     *
     * Result Event for Result Register 11
     */
    inline void toggle_REFLAG_REV11() volatile
    {
        REFLAG ^= 1u << 11u;
    }

    /**
     * Get REFLAG's REV10 bit.
     *
     * Result Event for Result Register 10
     */
    inline bool get_REFLAG_REV10() volatile
    {
        return REFLAG & (1u << 10u);
    }

    /**
     * Set REFLAG's REV10 bit.
     *
     * Result Event for Result Register 10
     */
    inline void set_REFLAG_REV10() volatile
    {
        REFLAG |= 1u << 10u;
    }

    /**
     * Clear REFLAG's REV10 bit.
     *
     * Result Event for Result Register 10
     */
    inline void clear_REFLAG_REV10() volatile
    {
        REFLAG &= ~(1u << 10u);
    }

    /**
     * Toggle REFLAG's REV10 bit.
     *
     * Result Event for Result Register 10
     */
    inline void toggle_REFLAG_REV10() volatile
    {
        REFLAG ^= 1u << 10u;
    }

    /**
     * Get REFLAG's REV9 bit.
     *
     * Result Event for Result Register 9
     */
    inline bool get_REFLAG_REV9() volatile
    {
        return REFLAG & (1u << 9u);
    }

    /**
     * Set REFLAG's REV9 bit.
     *
     * Result Event for Result Register 9
     */
    inline void set_REFLAG_REV9() volatile
    {
        REFLAG |= 1u << 9u;
    }

    /**
     * Clear REFLAG's REV9 bit.
     *
     * Result Event for Result Register 9
     */
    inline void clear_REFLAG_REV9() volatile
    {
        REFLAG &= ~(1u << 9u);
    }

    /**
     * Toggle REFLAG's REV9 bit.
     *
     * Result Event for Result Register 9
     */
    inline void toggle_REFLAG_REV9() volatile
    {
        REFLAG ^= 1u << 9u;
    }

    /**
     * Get REFLAG's REV8 bit.
     *
     * Result Event for Result Register 8
     */
    inline bool get_REFLAG_REV8() volatile
    {
        return REFLAG & (1u << 8u);
    }

    /**
     * Set REFLAG's REV8 bit.
     *
     * Result Event for Result Register 8
     */
    inline void set_REFLAG_REV8() volatile
    {
        REFLAG |= 1u << 8u;
    }

    /**
     * Clear REFLAG's REV8 bit.
     *
     * Result Event for Result Register 8
     */
    inline void clear_REFLAG_REV8() volatile
    {
        REFLAG &= ~(1u << 8u);
    }

    /**
     * Toggle REFLAG's REV8 bit.
     *
     * Result Event for Result Register 8
     */
    inline void toggle_REFLAG_REV8() volatile
    {
        REFLAG ^= 1u << 8u;
    }

    /**
     * Get REFLAG's REV7 bit.
     *
     * Result Event for Result Register 7
     */
    inline bool get_REFLAG_REV7() volatile
    {
        return REFLAG & (1u << 7u);
    }

    /**
     * Set REFLAG's REV7 bit.
     *
     * Result Event for Result Register 7
     */
    inline void set_REFLAG_REV7() volatile
    {
        REFLAG |= 1u << 7u;
    }

    /**
     * Clear REFLAG's REV7 bit.
     *
     * Result Event for Result Register 7
     */
    inline void clear_REFLAG_REV7() volatile
    {
        REFLAG &= ~(1u << 7u);
    }

    /**
     * Toggle REFLAG's REV7 bit.
     *
     * Result Event for Result Register 7
     */
    inline void toggle_REFLAG_REV7() volatile
    {
        REFLAG ^= 1u << 7u;
    }

    /**
     * Get REFLAG's REV6 bit.
     *
     * Result Event for Result Register 6
     */
    inline bool get_REFLAG_REV6() volatile
    {
        return REFLAG & (1u << 6u);
    }

    /**
     * Set REFLAG's REV6 bit.
     *
     * Result Event for Result Register 6
     */
    inline void set_REFLAG_REV6() volatile
    {
        REFLAG |= 1u << 6u;
    }

    /**
     * Clear REFLAG's REV6 bit.
     *
     * Result Event for Result Register 6
     */
    inline void clear_REFLAG_REV6() volatile
    {
        REFLAG &= ~(1u << 6u);
    }

    /**
     * Toggle REFLAG's REV6 bit.
     *
     * Result Event for Result Register 6
     */
    inline void toggle_REFLAG_REV6() volatile
    {
        REFLAG ^= 1u << 6u;
    }

    /**
     * Get REFLAG's REV5 bit.
     *
     * Result Event for Result Register 5
     */
    inline bool get_REFLAG_REV5() volatile
    {
        return REFLAG & (1u << 5u);
    }

    /**
     * Set REFLAG's REV5 bit.
     *
     * Result Event for Result Register 5
     */
    inline void set_REFLAG_REV5() volatile
    {
        REFLAG |= 1u << 5u;
    }

    /**
     * Clear REFLAG's REV5 bit.
     *
     * Result Event for Result Register 5
     */
    inline void clear_REFLAG_REV5() volatile
    {
        REFLAG &= ~(1u << 5u);
    }

    /**
     * Toggle REFLAG's REV5 bit.
     *
     * Result Event for Result Register 5
     */
    inline void toggle_REFLAG_REV5() volatile
    {
        REFLAG ^= 1u << 5u;
    }

    /**
     * Get REFLAG's REV4 bit.
     *
     * Result Event for Result Register 4
     */
    inline bool get_REFLAG_REV4() volatile
    {
        return REFLAG & (1u << 4u);
    }

    /**
     * Set REFLAG's REV4 bit.
     *
     * Result Event for Result Register 4
     */
    inline void set_REFLAG_REV4() volatile
    {
        REFLAG |= 1u << 4u;
    }

    /**
     * Clear REFLAG's REV4 bit.
     *
     * Result Event for Result Register 4
     */
    inline void clear_REFLAG_REV4() volatile
    {
        REFLAG &= ~(1u << 4u);
    }

    /**
     * Toggle REFLAG's REV4 bit.
     *
     * Result Event for Result Register 4
     */
    inline void toggle_REFLAG_REV4() volatile
    {
        REFLAG ^= 1u << 4u;
    }

    /**
     * Get REFLAG's REV3 bit.
     *
     * Result Event for Result Register 3
     */
    inline bool get_REFLAG_REV3() volatile
    {
        return REFLAG & (1u << 3u);
    }

    /**
     * Set REFLAG's REV3 bit.
     *
     * Result Event for Result Register 3
     */
    inline void set_REFLAG_REV3() volatile
    {
        REFLAG |= 1u << 3u;
    }

    /**
     * Clear REFLAG's REV3 bit.
     *
     * Result Event for Result Register 3
     */
    inline void clear_REFLAG_REV3() volatile
    {
        REFLAG &= ~(1u << 3u);
    }

    /**
     * Toggle REFLAG's REV3 bit.
     *
     * Result Event for Result Register 3
     */
    inline void toggle_REFLAG_REV3() volatile
    {
        REFLAG ^= 1u << 3u;
    }

    /**
     * Get REFLAG's REV2 bit.
     *
     * Result Event for Result Register 2
     */
    inline bool get_REFLAG_REV2() volatile
    {
        return REFLAG & (1u << 2u);
    }

    /**
     * Set REFLAG's REV2 bit.
     *
     * Result Event for Result Register 2
     */
    inline void set_REFLAG_REV2() volatile
    {
        REFLAG |= 1u << 2u;
    }

    /**
     * Clear REFLAG's REV2 bit.
     *
     * Result Event for Result Register 2
     */
    inline void clear_REFLAG_REV2() volatile
    {
        REFLAG &= ~(1u << 2u);
    }

    /**
     * Toggle REFLAG's REV2 bit.
     *
     * Result Event for Result Register 2
     */
    inline void toggle_REFLAG_REV2() volatile
    {
        REFLAG ^= 1u << 2u;
    }

    /**
     * Get REFLAG's REV1 bit.
     *
     * Result Event for Result Register 1
     */
    inline bool get_REFLAG_REV1() volatile
    {
        return REFLAG & (1u << 1u);
    }

    /**
     * Set REFLAG's REV1 bit.
     *
     * Result Event for Result Register 1
     */
    inline void set_REFLAG_REV1() volatile
    {
        REFLAG |= 1u << 1u;
    }

    /**
     * Clear REFLAG's REV1 bit.
     *
     * Result Event for Result Register 1
     */
    inline void clear_REFLAG_REV1() volatile
    {
        REFLAG &= ~(1u << 1u);
    }

    /**
     * Toggle REFLAG's REV1 bit.
     *
     * Result Event for Result Register 1
     */
    inline void toggle_REFLAG_REV1() volatile
    {
        REFLAG ^= 1u << 1u;
    }

    /**
     * Get REFLAG's REV0 bit.
     *
     * Result Event for Result Register 0
     */
    inline bool get_REFLAG_REV0() volatile
    {
        return REFLAG & (1u << 0u);
    }

    /**
     * Set REFLAG's REV0 bit.
     *
     * Result Event for Result Register 0
     */
    inline void set_REFLAG_REV0() volatile
    {
        REFLAG |= 1u << 0u;
    }

    /**
     * Clear REFLAG's REV0 bit.
     *
     * Result Event for Result Register 0
     */
    inline void clear_REFLAG_REV0() volatile
    {
        REFLAG &= ~(1u << 0u);
    }

    /**
     * Toggle REFLAG's REV0 bit.
     *
     * Result Event for Result Register 0
     */
    inline void toggle_REFLAG_REV0() volatile
    {
        REFLAG ^= 1u << 0u;
    }

    /**
     * Get all of REFLAG's bit fields.
     *
     * (read-write) Result Event Flag Register
     */
    inline void get_REFLAG(bool &REV15, bool &REV14, bool &REV13, bool &REV12,
                           bool &REV11, bool &REV10, bool &REV9, bool &REV8,
                           bool &REV7, bool &REV6, bool &REV5, bool &REV4,
                           bool &REV3, bool &REV2, bool &REV1,
                           bool &REV0) volatile
    {
        uint32_t curr = REFLAG;

        REV15 = curr & (1u << 15u);
        REV14 = curr & (1u << 14u);
        REV13 = curr & (1u << 13u);
        REV12 = curr & (1u << 12u);
        REV11 = curr & (1u << 11u);
        REV10 = curr & (1u << 10u);
        REV9 = curr & (1u << 9u);
        REV8 = curr & (1u << 8u);
        REV7 = curr & (1u << 7u);
        REV6 = curr & (1u << 6u);
        REV5 = curr & (1u << 5u);
        REV4 = curr & (1u << 4u);
        REV3 = curr & (1u << 3u);
        REV2 = curr & (1u << 2u);
        REV1 = curr & (1u << 1u);
        REV0 = curr & (1u << 0u);
    }

    /**
     * Set all of REFLAG's bit fields.
     *
     * (read-write) Result Event Flag Register
     */
    inline void set_REFLAG(bool REV15, bool REV14, bool REV13, bool REV12,
                           bool REV11, bool REV10, bool REV9, bool REV8,
                           bool REV7, bool REV6, bool REV5, bool REV4,
                           bool REV3, bool REV2, bool REV1, bool REV0) volatile
    {
        uint32_t curr = REFLAG;

        curr &= ~(0b1u << 15u);
        curr |= (REV15 & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (REV14 & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (REV13 & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (REV12 & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (REV11 & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (REV10 & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (REV9 & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (REV8 & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (REV7 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (REV6 & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (REV5 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (REV4 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (REV3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (REV2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (REV1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (REV0 & 0b1u) << 0u;

        REFLAG = curr;
    }

    /**
     * Get SEFLAG's SEV1 bit.
     *
     * Source Event 0/1
     */
    inline bool get_SEFLAG_SEV1() volatile
    {
        return SEFLAG & (1u << 1u);
    }

    /**
     * Set SEFLAG's SEV1 bit.
     *
     * Source Event 0/1
     */
    inline void set_SEFLAG_SEV1() volatile
    {
        SEFLAG |= 1u << 1u;
    }

    /**
     * Clear SEFLAG's SEV1 bit.
     *
     * Source Event 0/1
     */
    inline void clear_SEFLAG_SEV1() volatile
    {
        SEFLAG &= ~(1u << 1u);
    }

    /**
     * Toggle SEFLAG's SEV1 bit.
     *
     * Source Event 0/1
     */
    inline void toggle_SEFLAG_SEV1() volatile
    {
        SEFLAG ^= 1u << 1u;
    }

    /**
     * Get SEFLAG's SEV0 bit.
     *
     * Source Event 0/1
     */
    inline bool get_SEFLAG_SEV0() volatile
    {
        return SEFLAG & (1u << 0u);
    }

    /**
     * Set SEFLAG's SEV0 bit.
     *
     * Source Event 0/1
     */
    inline void set_SEFLAG_SEV0() volatile
    {
        SEFLAG |= 1u << 0u;
    }

    /**
     * Clear SEFLAG's SEV0 bit.
     *
     * Source Event 0/1
     */
    inline void clear_SEFLAG_SEV0() volatile
    {
        SEFLAG &= ~(1u << 0u);
    }

    /**
     * Toggle SEFLAG's SEV0 bit.
     *
     * Source Event 0/1
     */
    inline void toggle_SEFLAG_SEV0() volatile
    {
        SEFLAG ^= 1u << 0u;
    }

    /**
     * Get all of SEFLAG's bit fields.
     *
     * (read-write) Source Event Flag Register
     */
    inline void get_SEFLAG(bool &SEV1, bool &SEV0) volatile
    {
        uint32_t curr = SEFLAG;

        SEV1 = curr & (1u << 1u);
        SEV0 = curr & (1u << 0u);
    }

    /**
     * Set all of SEFLAG's bit fields.
     *
     * (read-write) Source Event Flag Register
     */
    inline void set_SEFLAG(bool SEV1, bool SEV0) volatile
    {
        uint32_t curr = SEFLAG;

        curr &= ~(0b1u << 1u);
        curr |= (SEV1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SEV0 & 0b1u) << 0u;

        SEFLAG = curr;
    }

    /**
     * Set CEFCLR's CEV7 bit.
     *
     * Clear Channel Event for Channel 7
     */
    inline void set_CEFCLR_CEV7() volatile
    {
        CEFCLR |= 1u << 7u;
    }

    /**
     * Clear CEFCLR's CEV7 bit.
     *
     * Clear Channel Event for Channel 7
     */
    inline void clear_CEFCLR_CEV7() volatile
    {
        CEFCLR &= ~(1u << 7u);
    }

    /**
     * Toggle CEFCLR's CEV7 bit.
     *
     * Clear Channel Event for Channel 7
     */
    inline void toggle_CEFCLR_CEV7() volatile
    {
        CEFCLR ^= 1u << 7u;
    }

    /**
     * Set CEFCLR's CEV6 bit.
     *
     * Clear Channel Event for Channel 6
     */
    inline void set_CEFCLR_CEV6() volatile
    {
        CEFCLR |= 1u << 6u;
    }

    /**
     * Clear CEFCLR's CEV6 bit.
     *
     * Clear Channel Event for Channel 6
     */
    inline void clear_CEFCLR_CEV6() volatile
    {
        CEFCLR &= ~(1u << 6u);
    }

    /**
     * Toggle CEFCLR's CEV6 bit.
     *
     * Clear Channel Event for Channel 6
     */
    inline void toggle_CEFCLR_CEV6() volatile
    {
        CEFCLR ^= 1u << 6u;
    }

    /**
     * Set CEFCLR's CEV5 bit.
     *
     * Clear Channel Event for Channel 5
     */
    inline void set_CEFCLR_CEV5() volatile
    {
        CEFCLR |= 1u << 5u;
    }

    /**
     * Clear CEFCLR's CEV5 bit.
     *
     * Clear Channel Event for Channel 5
     */
    inline void clear_CEFCLR_CEV5() volatile
    {
        CEFCLR &= ~(1u << 5u);
    }

    /**
     * Toggle CEFCLR's CEV5 bit.
     *
     * Clear Channel Event for Channel 5
     */
    inline void toggle_CEFCLR_CEV5() volatile
    {
        CEFCLR ^= 1u << 5u;
    }

    /**
     * Set CEFCLR's CEV4 bit.
     *
     * Clear Channel Event for Channel 4
     */
    inline void set_CEFCLR_CEV4() volatile
    {
        CEFCLR |= 1u << 4u;
    }

    /**
     * Clear CEFCLR's CEV4 bit.
     *
     * Clear Channel Event for Channel 4
     */
    inline void clear_CEFCLR_CEV4() volatile
    {
        CEFCLR &= ~(1u << 4u);
    }

    /**
     * Toggle CEFCLR's CEV4 bit.
     *
     * Clear Channel Event for Channel 4
     */
    inline void toggle_CEFCLR_CEV4() volatile
    {
        CEFCLR ^= 1u << 4u;
    }

    /**
     * Set CEFCLR's CEV3 bit.
     *
     * Clear Channel Event for Channel 3
     */
    inline void set_CEFCLR_CEV3() volatile
    {
        CEFCLR |= 1u << 3u;
    }

    /**
     * Clear CEFCLR's CEV3 bit.
     *
     * Clear Channel Event for Channel 3
     */
    inline void clear_CEFCLR_CEV3() volatile
    {
        CEFCLR &= ~(1u << 3u);
    }

    /**
     * Toggle CEFCLR's CEV3 bit.
     *
     * Clear Channel Event for Channel 3
     */
    inline void toggle_CEFCLR_CEV3() volatile
    {
        CEFCLR ^= 1u << 3u;
    }

    /**
     * Set CEFCLR's CEV2 bit.
     *
     * Clear Channel Event for Channel 2
     */
    inline void set_CEFCLR_CEV2() volatile
    {
        CEFCLR |= 1u << 2u;
    }

    /**
     * Clear CEFCLR's CEV2 bit.
     *
     * Clear Channel Event for Channel 2
     */
    inline void clear_CEFCLR_CEV2() volatile
    {
        CEFCLR &= ~(1u << 2u);
    }

    /**
     * Toggle CEFCLR's CEV2 bit.
     *
     * Clear Channel Event for Channel 2
     */
    inline void toggle_CEFCLR_CEV2() volatile
    {
        CEFCLR ^= 1u << 2u;
    }

    /**
     * Set CEFCLR's CEV1 bit.
     *
     * Clear Channel Event for Channel 1
     */
    inline void set_CEFCLR_CEV1() volatile
    {
        CEFCLR |= 1u << 1u;
    }

    /**
     * Clear CEFCLR's CEV1 bit.
     *
     * Clear Channel Event for Channel 1
     */
    inline void clear_CEFCLR_CEV1() volatile
    {
        CEFCLR &= ~(1u << 1u);
    }

    /**
     * Toggle CEFCLR's CEV1 bit.
     *
     * Clear Channel Event for Channel 1
     */
    inline void toggle_CEFCLR_CEV1() volatile
    {
        CEFCLR ^= 1u << 1u;
    }

    /**
     * Set CEFCLR's CEV0 bit.
     *
     * Clear Channel Event for Channel 0
     */
    inline void set_CEFCLR_CEV0() volatile
    {
        CEFCLR |= 1u << 0u;
    }

    /**
     * Clear CEFCLR's CEV0 bit.
     *
     * Clear Channel Event for Channel 0
     */
    inline void clear_CEFCLR_CEV0() volatile
    {
        CEFCLR &= ~(1u << 0u);
    }

    /**
     * Toggle CEFCLR's CEV0 bit.
     *
     * Clear Channel Event for Channel 0
     */
    inline void toggle_CEFCLR_CEV0() volatile
    {
        CEFCLR ^= 1u << 0u;
    }

    /**
     * Set all of CEFCLR's bit fields.
     *
     * (write-only) Channel Event Flag Clear Register
     */
    inline void set_CEFCLR(bool CEV7, bool CEV6, bool CEV5, bool CEV4,
                           bool CEV3, bool CEV2, bool CEV1, bool CEV0) volatile
    {
        uint32_t curr = CEFCLR;

        curr &= ~(0b1u << 7u);
        curr |= (CEV7 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (CEV6 & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (CEV5 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (CEV4 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (CEV3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (CEV2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (CEV1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CEV0 & 0b1u) << 0u;

        CEFCLR = curr;
    }

    /**
     * Set REFCLR's REV15 bit.
     *
     * Clear Result Event for Result Register 15
     */
    inline void set_REFCLR_REV15() volatile
    {
        REFCLR |= 1u << 15u;
    }

    /**
     * Clear REFCLR's REV15 bit.
     *
     * Clear Result Event for Result Register 15
     */
    inline void clear_REFCLR_REV15() volatile
    {
        REFCLR &= ~(1u << 15u);
    }

    /**
     * Toggle REFCLR's REV15 bit.
     *
     * Clear Result Event for Result Register 15
     */
    inline void toggle_REFCLR_REV15() volatile
    {
        REFCLR ^= 1u << 15u;
    }

    /**
     * Set REFCLR's REV14 bit.
     *
     * Clear Result Event for Result Register 14
     */
    inline void set_REFCLR_REV14() volatile
    {
        REFCLR |= 1u << 14u;
    }

    /**
     * Clear REFCLR's REV14 bit.
     *
     * Clear Result Event for Result Register 14
     */
    inline void clear_REFCLR_REV14() volatile
    {
        REFCLR &= ~(1u << 14u);
    }

    /**
     * Toggle REFCLR's REV14 bit.
     *
     * Clear Result Event for Result Register 14
     */
    inline void toggle_REFCLR_REV14() volatile
    {
        REFCLR ^= 1u << 14u;
    }

    /**
     * Set REFCLR's REV13 bit.
     *
     * Clear Result Event for Result Register 13
     */
    inline void set_REFCLR_REV13() volatile
    {
        REFCLR |= 1u << 13u;
    }

    /**
     * Clear REFCLR's REV13 bit.
     *
     * Clear Result Event for Result Register 13
     */
    inline void clear_REFCLR_REV13() volatile
    {
        REFCLR &= ~(1u << 13u);
    }

    /**
     * Toggle REFCLR's REV13 bit.
     *
     * Clear Result Event for Result Register 13
     */
    inline void toggle_REFCLR_REV13() volatile
    {
        REFCLR ^= 1u << 13u;
    }

    /**
     * Set REFCLR's REV12 bit.
     *
     * Clear Result Event for Result Register 12
     */
    inline void set_REFCLR_REV12() volatile
    {
        REFCLR |= 1u << 12u;
    }

    /**
     * Clear REFCLR's REV12 bit.
     *
     * Clear Result Event for Result Register 12
     */
    inline void clear_REFCLR_REV12() volatile
    {
        REFCLR &= ~(1u << 12u);
    }

    /**
     * Toggle REFCLR's REV12 bit.
     *
     * Clear Result Event for Result Register 12
     */
    inline void toggle_REFCLR_REV12() volatile
    {
        REFCLR ^= 1u << 12u;
    }

    /**
     * Set REFCLR's REV11 bit.
     *
     * Clear Result Event for Result Register 11
     */
    inline void set_REFCLR_REV11() volatile
    {
        REFCLR |= 1u << 11u;
    }

    /**
     * Clear REFCLR's REV11 bit.
     *
     * Clear Result Event for Result Register 11
     */
    inline void clear_REFCLR_REV11() volatile
    {
        REFCLR &= ~(1u << 11u);
    }

    /**
     * Toggle REFCLR's REV11 bit.
     *
     * Clear Result Event for Result Register 11
     */
    inline void toggle_REFCLR_REV11() volatile
    {
        REFCLR ^= 1u << 11u;
    }

    /**
     * Set REFCLR's REV10 bit.
     *
     * Clear Result Event for Result Register 10
     */
    inline void set_REFCLR_REV10() volatile
    {
        REFCLR |= 1u << 10u;
    }

    /**
     * Clear REFCLR's REV10 bit.
     *
     * Clear Result Event for Result Register 10
     */
    inline void clear_REFCLR_REV10() volatile
    {
        REFCLR &= ~(1u << 10u);
    }

    /**
     * Toggle REFCLR's REV10 bit.
     *
     * Clear Result Event for Result Register 10
     */
    inline void toggle_REFCLR_REV10() volatile
    {
        REFCLR ^= 1u << 10u;
    }

    /**
     * Set REFCLR's REV9 bit.
     *
     * Clear Result Event for Result Register 9
     */
    inline void set_REFCLR_REV9() volatile
    {
        REFCLR |= 1u << 9u;
    }

    /**
     * Clear REFCLR's REV9 bit.
     *
     * Clear Result Event for Result Register 9
     */
    inline void clear_REFCLR_REV9() volatile
    {
        REFCLR &= ~(1u << 9u);
    }

    /**
     * Toggle REFCLR's REV9 bit.
     *
     * Clear Result Event for Result Register 9
     */
    inline void toggle_REFCLR_REV9() volatile
    {
        REFCLR ^= 1u << 9u;
    }

    /**
     * Set REFCLR's REV8 bit.
     *
     * Clear Result Event for Result Register 8
     */
    inline void set_REFCLR_REV8() volatile
    {
        REFCLR |= 1u << 8u;
    }

    /**
     * Clear REFCLR's REV8 bit.
     *
     * Clear Result Event for Result Register 8
     */
    inline void clear_REFCLR_REV8() volatile
    {
        REFCLR &= ~(1u << 8u);
    }

    /**
     * Toggle REFCLR's REV8 bit.
     *
     * Clear Result Event for Result Register 8
     */
    inline void toggle_REFCLR_REV8() volatile
    {
        REFCLR ^= 1u << 8u;
    }

    /**
     * Set REFCLR's REV7 bit.
     *
     * Clear Result Event for Result Register 7
     */
    inline void set_REFCLR_REV7() volatile
    {
        REFCLR |= 1u << 7u;
    }

    /**
     * Clear REFCLR's REV7 bit.
     *
     * Clear Result Event for Result Register 7
     */
    inline void clear_REFCLR_REV7() volatile
    {
        REFCLR &= ~(1u << 7u);
    }

    /**
     * Toggle REFCLR's REV7 bit.
     *
     * Clear Result Event for Result Register 7
     */
    inline void toggle_REFCLR_REV7() volatile
    {
        REFCLR ^= 1u << 7u;
    }

    /**
     * Set REFCLR's REV6 bit.
     *
     * Clear Result Event for Result Register 6
     */
    inline void set_REFCLR_REV6() volatile
    {
        REFCLR |= 1u << 6u;
    }

    /**
     * Clear REFCLR's REV6 bit.
     *
     * Clear Result Event for Result Register 6
     */
    inline void clear_REFCLR_REV6() volatile
    {
        REFCLR &= ~(1u << 6u);
    }

    /**
     * Toggle REFCLR's REV6 bit.
     *
     * Clear Result Event for Result Register 6
     */
    inline void toggle_REFCLR_REV6() volatile
    {
        REFCLR ^= 1u << 6u;
    }

    /**
     * Set REFCLR's REV5 bit.
     *
     * Clear Result Event for Result Register 5
     */
    inline void set_REFCLR_REV5() volatile
    {
        REFCLR |= 1u << 5u;
    }

    /**
     * Clear REFCLR's REV5 bit.
     *
     * Clear Result Event for Result Register 5
     */
    inline void clear_REFCLR_REV5() volatile
    {
        REFCLR &= ~(1u << 5u);
    }

    /**
     * Toggle REFCLR's REV5 bit.
     *
     * Clear Result Event for Result Register 5
     */
    inline void toggle_REFCLR_REV5() volatile
    {
        REFCLR ^= 1u << 5u;
    }

    /**
     * Set REFCLR's REV4 bit.
     *
     * Clear Result Event for Result Register 4
     */
    inline void set_REFCLR_REV4() volatile
    {
        REFCLR |= 1u << 4u;
    }

    /**
     * Clear REFCLR's REV4 bit.
     *
     * Clear Result Event for Result Register 4
     */
    inline void clear_REFCLR_REV4() volatile
    {
        REFCLR &= ~(1u << 4u);
    }

    /**
     * Toggle REFCLR's REV4 bit.
     *
     * Clear Result Event for Result Register 4
     */
    inline void toggle_REFCLR_REV4() volatile
    {
        REFCLR ^= 1u << 4u;
    }

    /**
     * Set REFCLR's REV3 bit.
     *
     * Clear Result Event for Result Register 3
     */
    inline void set_REFCLR_REV3() volatile
    {
        REFCLR |= 1u << 3u;
    }

    /**
     * Clear REFCLR's REV3 bit.
     *
     * Clear Result Event for Result Register 3
     */
    inline void clear_REFCLR_REV3() volatile
    {
        REFCLR &= ~(1u << 3u);
    }

    /**
     * Toggle REFCLR's REV3 bit.
     *
     * Clear Result Event for Result Register 3
     */
    inline void toggle_REFCLR_REV3() volatile
    {
        REFCLR ^= 1u << 3u;
    }

    /**
     * Set REFCLR's REV2 bit.
     *
     * Clear Result Event for Result Register 2
     */
    inline void set_REFCLR_REV2() volatile
    {
        REFCLR |= 1u << 2u;
    }

    /**
     * Clear REFCLR's REV2 bit.
     *
     * Clear Result Event for Result Register 2
     */
    inline void clear_REFCLR_REV2() volatile
    {
        REFCLR &= ~(1u << 2u);
    }

    /**
     * Toggle REFCLR's REV2 bit.
     *
     * Clear Result Event for Result Register 2
     */
    inline void toggle_REFCLR_REV2() volatile
    {
        REFCLR ^= 1u << 2u;
    }

    /**
     * Set REFCLR's REV1 bit.
     *
     * Clear Result Event for Result Register 1
     */
    inline void set_REFCLR_REV1() volatile
    {
        REFCLR |= 1u << 1u;
    }

    /**
     * Clear REFCLR's REV1 bit.
     *
     * Clear Result Event for Result Register 1
     */
    inline void clear_REFCLR_REV1() volatile
    {
        REFCLR &= ~(1u << 1u);
    }

    /**
     * Toggle REFCLR's REV1 bit.
     *
     * Clear Result Event for Result Register 1
     */
    inline void toggle_REFCLR_REV1() volatile
    {
        REFCLR ^= 1u << 1u;
    }

    /**
     * Set REFCLR's REV0 bit.
     *
     * Clear Result Event for Result Register 0
     */
    inline void set_REFCLR_REV0() volatile
    {
        REFCLR |= 1u << 0u;
    }

    /**
     * Clear REFCLR's REV0 bit.
     *
     * Clear Result Event for Result Register 0
     */
    inline void clear_REFCLR_REV0() volatile
    {
        REFCLR &= ~(1u << 0u);
    }

    /**
     * Toggle REFCLR's REV0 bit.
     *
     * Clear Result Event for Result Register 0
     */
    inline void toggle_REFCLR_REV0() volatile
    {
        REFCLR ^= 1u << 0u;
    }

    /**
     * Set all of REFCLR's bit fields.
     *
     * (write-only) Result Event Flag Clear Register
     */
    inline void set_REFCLR(bool REV15, bool REV14, bool REV13, bool REV12,
                           bool REV11, bool REV10, bool REV9, bool REV8,
                           bool REV7, bool REV6, bool REV5, bool REV4,
                           bool REV3, bool REV2, bool REV1, bool REV0) volatile
    {
        uint32_t curr = REFCLR;

        curr &= ~(0b1u << 15u);
        curr |= (REV15 & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (REV14 & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (REV13 & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (REV12 & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (REV11 & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (REV10 & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (REV9 & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (REV8 & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (REV7 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (REV6 & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (REV5 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (REV4 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (REV3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (REV2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (REV1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (REV0 & 0b1u) << 0u;

        REFCLR = curr;
    }

    /**
     * Set SEFCLR's SEV1 bit.
     *
     * Clear Source Event 0/1
     */
    inline void set_SEFCLR_SEV1() volatile
    {
        SEFCLR |= 1u << 1u;
    }

    /**
     * Clear SEFCLR's SEV1 bit.
     *
     * Clear Source Event 0/1
     */
    inline void clear_SEFCLR_SEV1() volatile
    {
        SEFCLR &= ~(1u << 1u);
    }

    /**
     * Toggle SEFCLR's SEV1 bit.
     *
     * Clear Source Event 0/1
     */
    inline void toggle_SEFCLR_SEV1() volatile
    {
        SEFCLR ^= 1u << 1u;
    }

    /**
     * Set SEFCLR's SEV0 bit.
     *
     * Clear Source Event 0/1
     */
    inline void set_SEFCLR_SEV0() volatile
    {
        SEFCLR |= 1u << 0u;
    }

    /**
     * Clear SEFCLR's SEV0 bit.
     *
     * Clear Source Event 0/1
     */
    inline void clear_SEFCLR_SEV0() volatile
    {
        SEFCLR &= ~(1u << 0u);
    }

    /**
     * Toggle SEFCLR's SEV0 bit.
     *
     * Clear Source Event 0/1
     */
    inline void toggle_SEFCLR_SEV0() volatile
    {
        SEFCLR ^= 1u << 0u;
    }

    /**
     * Set all of SEFCLR's bit fields.
     *
     * (write-only) Source Event Flag Clear Register
     */
    inline void set_SEFCLR(bool SEV1, bool SEV0) volatile
    {
        uint32_t curr = SEFCLR;

        curr &= ~(0b1u << 1u);
        curr |= (SEV1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SEV0 & 0b1u) << 0u;

        SEFCLR = curr;
    }

    /**
     * Get CEVNP0's CEV7NP field.
     *
     * Service Request Node Pointer Channel Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_CEVNP0_CEV7NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((CEVNP0 >> 28u) & 0b1111u);
    }

    /**
     * Set CEVNP0's CEV7NP field.
     *
     * Service Request Node Pointer Channel Event i
     */
    inline void set_CEVNP0_CEV7NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = CEVNP0;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(value) & 0b1111u) << 28u;

        CEVNP0 = curr;
    }

    /**
     * Get CEVNP0's CEV6NP field.
     *
     * Service Request Node Pointer Channel Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_CEVNP0_CEV6NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((CEVNP0 >> 24u) & 0b1111u);
    }

    /**
     * Set CEVNP0's CEV6NP field.
     *
     * Service Request Node Pointer Channel Event i
     */
    inline void set_CEVNP0_CEV6NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = CEVNP0;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        CEVNP0 = curr;
    }

    /**
     * Get CEVNP0's CEV5NP field.
     *
     * Service Request Node Pointer Channel Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_CEVNP0_CEV5NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((CEVNP0 >> 20u) & 0b1111u);
    }

    /**
     * Set CEVNP0's CEV5NP field.
     *
     * Service Request Node Pointer Channel Event i
     */
    inline void set_CEVNP0_CEV5NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = CEVNP0;

        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(value) & 0b1111u) << 20u;

        CEVNP0 = curr;
    }

    /**
     * Get CEVNP0's CEV4NP field.
     *
     * Service Request Node Pointer Channel Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_CEVNP0_CEV4NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((CEVNP0 >> 16u) & 0b1111u);
    }

    /**
     * Set CEVNP0's CEV4NP field.
     *
     * Service Request Node Pointer Channel Event i
     */
    inline void set_CEVNP0_CEV4NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = CEVNP0;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        CEVNP0 = curr;
    }

    /**
     * Get CEVNP0's CEV3NP field.
     *
     * Service Request Node Pointer Channel Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_CEVNP0_CEV3NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((CEVNP0 >> 12u) & 0b1111u);
    }

    /**
     * Set CEVNP0's CEV3NP field.
     *
     * Service Request Node Pointer Channel Event i
     */
    inline void set_CEVNP0_CEV3NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = CEVNP0;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(value) & 0b1111u) << 12u;

        CEVNP0 = curr;
    }

    /**
     * Get CEVNP0's CEV2NP field.
     *
     * Service Request Node Pointer Channel Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_CEVNP0_CEV2NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((CEVNP0 >> 8u) & 0b1111u);
    }

    /**
     * Set CEVNP0's CEV2NP field.
     *
     * Service Request Node Pointer Channel Event i
     */
    inline void set_CEVNP0_CEV2NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = CEVNP0;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        CEVNP0 = curr;
    }

    /**
     * Get CEVNP0's CEV1NP field.
     *
     * Service Request Node Pointer Channel Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_CEVNP0_CEV1NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((CEVNP0 >> 4u) & 0b1111u);
    }

    /**
     * Set CEVNP0's CEV1NP field.
     *
     * Service Request Node Pointer Channel Event i
     */
    inline void set_CEVNP0_CEV1NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = CEVNP0;

        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(value) & 0b1111u) << 4u;

        CEVNP0 = curr;
    }

    /**
     * Get CEVNP0's CEV0NP field.
     *
     * Service Request Node Pointer Channel Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_CEVNP0_CEV0NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((CEVNP0 >> 0u) & 0b1111u);
    }

    /**
     * Set CEVNP0's CEV0NP field.
     *
     * Service Request Node Pointer Channel Event i
     */
    inline void set_CEVNP0_CEV0NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = CEVNP0;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        CEVNP0 = curr;
    }

    /**
     * Get all of CEVNP0's bit fields.
     *
     * (read-write) Channel Event Node Pointer Register 0
     */
    inline void get_CEVNP0(
        VADC_G0_CEVNP0_CEV7NP &CEV7NP, VADC_G0_CEVNP0_CEV7NP &CEV6NP,
        VADC_G0_CEVNP0_CEV7NP &CEV5NP, VADC_G0_CEVNP0_CEV7NP &CEV4NP,
        VADC_G0_CEVNP0_CEV7NP &CEV3NP, VADC_G0_CEVNP0_CEV7NP &CEV2NP,
        VADC_G0_CEVNP0_CEV7NP &CEV1NP, VADC_G0_CEVNP0_CEV7NP &CEV0NP) volatile
    {
        uint32_t curr = CEVNP0;

        CEV7NP = VADC_G0_CEVNP0_CEV7NP((curr >> 28u) & 0b1111u);
        CEV6NP = VADC_G0_CEVNP0_CEV7NP((curr >> 24u) & 0b1111u);
        CEV5NP = VADC_G0_CEVNP0_CEV7NP((curr >> 20u) & 0b1111u);
        CEV4NP = VADC_G0_CEVNP0_CEV7NP((curr >> 16u) & 0b1111u);
        CEV3NP = VADC_G0_CEVNP0_CEV7NP((curr >> 12u) & 0b1111u);
        CEV2NP = VADC_G0_CEVNP0_CEV7NP((curr >> 8u) & 0b1111u);
        CEV1NP = VADC_G0_CEVNP0_CEV7NP((curr >> 4u) & 0b1111u);
        CEV0NP = VADC_G0_CEVNP0_CEV7NP((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of CEVNP0's bit fields.
     *
     * (read-write) Channel Event Node Pointer Register 0
     */
    inline void set_CEVNP0(
        VADC_G0_CEVNP0_CEV7NP CEV7NP, VADC_G0_CEVNP0_CEV7NP CEV6NP,
        VADC_G0_CEVNP0_CEV7NP CEV5NP, VADC_G0_CEVNP0_CEV7NP CEV4NP,
        VADC_G0_CEVNP0_CEV7NP CEV3NP, VADC_G0_CEVNP0_CEV7NP CEV2NP,
        VADC_G0_CEVNP0_CEV7NP CEV1NP, VADC_G0_CEVNP0_CEV7NP CEV0NP) volatile
    {
        uint32_t curr = CEVNP0;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(CEV7NP) & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(CEV6NP) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(CEV5NP) & 0b1111u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(CEV4NP) & 0b1111u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(CEV3NP) & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(CEV2NP) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(CEV1NP) & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(CEV0NP) & 0b1111u) << 0u;

        CEVNP0 = curr;
    }

    /**
     * Get REVNP0's REV7NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_REVNP0_REV7NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((REVNP0 >> 28u) & 0b1111u);
    }

    /**
     * Set REVNP0's REV7NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline void set_REVNP0_REV7NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = REVNP0;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(value) & 0b1111u) << 28u;

        REVNP0 = curr;
    }

    /**
     * Get REVNP0's REV6NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_REVNP0_REV6NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((REVNP0 >> 24u) & 0b1111u);
    }

    /**
     * Set REVNP0's REV6NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline void set_REVNP0_REV6NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = REVNP0;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        REVNP0 = curr;
    }

    /**
     * Get REVNP0's REV5NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_REVNP0_REV5NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((REVNP0 >> 20u) & 0b1111u);
    }

    /**
     * Set REVNP0's REV5NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline void set_REVNP0_REV5NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = REVNP0;

        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(value) & 0b1111u) << 20u;

        REVNP0 = curr;
    }

    /**
     * Get REVNP0's REV4NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_REVNP0_REV4NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((REVNP0 >> 16u) & 0b1111u);
    }

    /**
     * Set REVNP0's REV4NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline void set_REVNP0_REV4NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = REVNP0;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        REVNP0 = curr;
    }

    /**
     * Get REVNP0's REV3NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_REVNP0_REV3NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((REVNP0 >> 12u) & 0b1111u);
    }

    /**
     * Set REVNP0's REV3NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline void set_REVNP0_REV3NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = REVNP0;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(value) & 0b1111u) << 12u;

        REVNP0 = curr;
    }

    /**
     * Get REVNP0's REV2NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_REVNP0_REV2NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((REVNP0 >> 8u) & 0b1111u);
    }

    /**
     * Set REVNP0's REV2NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline void set_REVNP0_REV2NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = REVNP0;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        REVNP0 = curr;
    }

    /**
     * Get REVNP0's REV1NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_REVNP0_REV1NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((REVNP0 >> 4u) & 0b1111u);
    }

    /**
     * Set REVNP0's REV1NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline void set_REVNP0_REV1NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = REVNP0;

        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(value) & 0b1111u) << 4u;

        REVNP0 = curr;
    }

    /**
     * Get REVNP0's REV0NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_REVNP0_REV0NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((REVNP0 >> 0u) & 0b1111u);
    }

    /**
     * Set REVNP0's REV0NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline void set_REVNP0_REV0NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = REVNP0;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        REVNP0 = curr;
    }

    /**
     * Get all of REVNP0's bit fields.
     *
     * (read-write) Result Event Node Pointer Register 0
     */
    inline void get_REVNP0(
        VADC_G0_CEVNP0_CEV7NP &REV7NP, VADC_G0_CEVNP0_CEV7NP &REV6NP,
        VADC_G0_CEVNP0_CEV7NP &REV5NP, VADC_G0_CEVNP0_CEV7NP &REV4NP,
        VADC_G0_CEVNP0_CEV7NP &REV3NP, VADC_G0_CEVNP0_CEV7NP &REV2NP,
        VADC_G0_CEVNP0_CEV7NP &REV1NP, VADC_G0_CEVNP0_CEV7NP &REV0NP) volatile
    {
        uint32_t curr = REVNP0;

        REV7NP = VADC_G0_CEVNP0_CEV7NP((curr >> 28u) & 0b1111u);
        REV6NP = VADC_G0_CEVNP0_CEV7NP((curr >> 24u) & 0b1111u);
        REV5NP = VADC_G0_CEVNP0_CEV7NP((curr >> 20u) & 0b1111u);
        REV4NP = VADC_G0_CEVNP0_CEV7NP((curr >> 16u) & 0b1111u);
        REV3NP = VADC_G0_CEVNP0_CEV7NP((curr >> 12u) & 0b1111u);
        REV2NP = VADC_G0_CEVNP0_CEV7NP((curr >> 8u) & 0b1111u);
        REV1NP = VADC_G0_CEVNP0_CEV7NP((curr >> 4u) & 0b1111u);
        REV0NP = VADC_G0_CEVNP0_CEV7NP((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of REVNP0's bit fields.
     *
     * (read-write) Result Event Node Pointer Register 0
     */
    inline void set_REVNP0(
        VADC_G0_CEVNP0_CEV7NP REV7NP, VADC_G0_CEVNP0_CEV7NP REV6NP,
        VADC_G0_CEVNP0_CEV7NP REV5NP, VADC_G0_CEVNP0_CEV7NP REV4NP,
        VADC_G0_CEVNP0_CEV7NP REV3NP, VADC_G0_CEVNP0_CEV7NP REV2NP,
        VADC_G0_CEVNP0_CEV7NP REV1NP, VADC_G0_CEVNP0_CEV7NP REV0NP) volatile
    {
        uint32_t curr = REVNP0;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(REV7NP) & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(REV6NP) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(REV5NP) & 0b1111u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(REV4NP) & 0b1111u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(REV3NP) & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(REV2NP) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(REV1NP) & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(REV0NP) & 0b1111u) << 0u;

        REVNP0 = curr;
    }

    /**
     * Get REVNP1's REV15NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_REVNP1_REV15NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((REVNP1 >> 28u) & 0b1111u);
    }

    /**
     * Set REVNP1's REV15NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline void set_REVNP1_REV15NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = REVNP1;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(value) & 0b1111u) << 28u;

        REVNP1 = curr;
    }

    /**
     * Get REVNP1's REV14NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_REVNP1_REV14NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((REVNP1 >> 24u) & 0b1111u);
    }

    /**
     * Set REVNP1's REV14NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline void set_REVNP1_REV14NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = REVNP1;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        REVNP1 = curr;
    }

    /**
     * Get REVNP1's REV13NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_REVNP1_REV13NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((REVNP1 >> 20u) & 0b1111u);
    }

    /**
     * Set REVNP1's REV13NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline void set_REVNP1_REV13NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = REVNP1;

        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(value) & 0b1111u) << 20u;

        REVNP1 = curr;
    }

    /**
     * Get REVNP1's REV12NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_REVNP1_REV12NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((REVNP1 >> 16u) & 0b1111u);
    }

    /**
     * Set REVNP1's REV12NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline void set_REVNP1_REV12NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = REVNP1;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        REVNP1 = curr;
    }

    /**
     * Get REVNP1's REV11NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_REVNP1_REV11NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((REVNP1 >> 12u) & 0b1111u);
    }

    /**
     * Set REVNP1's REV11NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline void set_REVNP1_REV11NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = REVNP1;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(value) & 0b1111u) << 12u;

        REVNP1 = curr;
    }

    /**
     * Get REVNP1's REV10NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_REVNP1_REV10NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((REVNP1 >> 8u) & 0b1111u);
    }

    /**
     * Set REVNP1's REV10NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline void set_REVNP1_REV10NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = REVNP1;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        REVNP1 = curr;
    }

    /**
     * Get REVNP1's REV9NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_REVNP1_REV9NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((REVNP1 >> 4u) & 0b1111u);
    }

    /**
     * Set REVNP1's REV9NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline void set_REVNP1_REV9NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = REVNP1;

        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(value) & 0b1111u) << 4u;

        REVNP1 = curr;
    }

    /**
     * Get REVNP1's REV8NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_REVNP1_REV8NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((REVNP1 >> 0u) & 0b1111u);
    }

    /**
     * Set REVNP1's REV8NP field.
     *
     * Service Request Node Pointer Result Event i
     */
    inline void set_REVNP1_REV8NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = REVNP1;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        REVNP1 = curr;
    }

    /**
     * Get all of REVNP1's bit fields.
     *
     * (read-write) Result Event Node Pointer Register 1
     */
    inline void get_REVNP1(
        VADC_G0_CEVNP0_CEV7NP &REV15NP, VADC_G0_CEVNP0_CEV7NP &REV14NP,
        VADC_G0_CEVNP0_CEV7NP &REV13NP, VADC_G0_CEVNP0_CEV7NP &REV12NP,
        VADC_G0_CEVNP0_CEV7NP &REV11NP, VADC_G0_CEVNP0_CEV7NP &REV10NP,
        VADC_G0_CEVNP0_CEV7NP &REV9NP, VADC_G0_CEVNP0_CEV7NP &REV8NP) volatile
    {
        uint32_t curr = REVNP1;

        REV15NP = VADC_G0_CEVNP0_CEV7NP((curr >> 28u) & 0b1111u);
        REV14NP = VADC_G0_CEVNP0_CEV7NP((curr >> 24u) & 0b1111u);
        REV13NP = VADC_G0_CEVNP0_CEV7NP((curr >> 20u) & 0b1111u);
        REV12NP = VADC_G0_CEVNP0_CEV7NP((curr >> 16u) & 0b1111u);
        REV11NP = VADC_G0_CEVNP0_CEV7NP((curr >> 12u) & 0b1111u);
        REV10NP = VADC_G0_CEVNP0_CEV7NP((curr >> 8u) & 0b1111u);
        REV9NP = VADC_G0_CEVNP0_CEV7NP((curr >> 4u) & 0b1111u);
        REV8NP = VADC_G0_CEVNP0_CEV7NP((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of REVNP1's bit fields.
     *
     * (read-write) Result Event Node Pointer Register 1
     */
    inline void set_REVNP1(
        VADC_G0_CEVNP0_CEV7NP REV15NP, VADC_G0_CEVNP0_CEV7NP REV14NP,
        VADC_G0_CEVNP0_CEV7NP REV13NP, VADC_G0_CEVNP0_CEV7NP REV12NP,
        VADC_G0_CEVNP0_CEV7NP REV11NP, VADC_G0_CEVNP0_CEV7NP REV10NP,
        VADC_G0_CEVNP0_CEV7NP REV9NP, VADC_G0_CEVNP0_CEV7NP REV8NP) volatile
    {
        uint32_t curr = REVNP1;

        curr &= ~(0b1111u << 28u);
        curr |= (std::to_underlying(REV15NP) & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(REV14NP) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(REV13NP) & 0b1111u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(REV12NP) & 0b1111u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(REV11NP) & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(REV10NP) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(REV9NP) & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(REV8NP) & 0b1111u) << 0u;

        REVNP1 = curr;
    }

    /**
     * Get SEVNP's SEV1NP field.
     *
     * Service Request Node Pointer Source Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_SEVNP_SEV1NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((SEVNP >> 4u) & 0b1111u);
    }

    /**
     * Set SEVNP's SEV1NP field.
     *
     * Service Request Node Pointer Source Event i
     */
    inline void set_SEVNP_SEV1NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = SEVNP;

        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(value) & 0b1111u) << 4u;

        SEVNP = curr;
    }

    /**
     * Get SEVNP's SEV0NP field.
     *
     * Service Request Node Pointer Source Event i
     */
    inline VADC_G0_CEVNP0_CEV7NP get_SEVNP_SEV0NP() volatile
    {
        return VADC_G0_CEVNP0_CEV7NP((SEVNP >> 0u) & 0b1111u);
    }

    /**
     * Set SEVNP's SEV0NP field.
     *
     * Service Request Node Pointer Source Event i
     */
    inline void set_SEVNP_SEV0NP(VADC_G0_CEVNP0_CEV7NP value) volatile
    {
        uint32_t curr = SEVNP;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SEVNP = curr;
    }

    /**
     * Get all of SEVNP's bit fields.
     *
     * (read-write) Source Event Node Pointer Register
     */
    inline void get_SEVNP(VADC_G0_CEVNP0_CEV7NP &SEV1NP,
                          VADC_G0_CEVNP0_CEV7NP &SEV0NP) volatile
    {
        uint32_t curr = SEVNP;

        SEV1NP = VADC_G0_CEVNP0_CEV7NP((curr >> 4u) & 0b1111u);
        SEV0NP = VADC_G0_CEVNP0_CEV7NP((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SEVNP's bit fields.
     *
     * (read-write) Source Event Node Pointer Register
     */
    inline void set_SEVNP(VADC_G0_CEVNP0_CEV7NP SEV1NP,
                          VADC_G0_CEVNP0_CEV7NP SEV0NP) volatile
    {
        uint32_t curr = SEVNP;

        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(SEV1NP) & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(SEV0NP) & 0b1111u) << 0u;

        SEVNP = curr;
    }

    /**
     * Set SRACT's ASSR3 bit.
     *
     * Activate Shared Service Request Node 3
     */
    inline void set_SRACT_ASSR3() volatile
    {
        SRACT |= 1u << 11u;
    }

    /**
     * Clear SRACT's ASSR3 bit.
     *
     * Activate Shared Service Request Node 3
     */
    inline void clear_SRACT_ASSR3() volatile
    {
        SRACT &= ~(1u << 11u);
    }

    /**
     * Toggle SRACT's ASSR3 bit.
     *
     * Activate Shared Service Request Node 3
     */
    inline void toggle_SRACT_ASSR3() volatile
    {
        SRACT ^= 1u << 11u;
    }

    /**
     * Set SRACT's ASSR2 bit.
     *
     * Activate Shared Service Request Node 2
     */
    inline void set_SRACT_ASSR2() volatile
    {
        SRACT |= 1u << 10u;
    }

    /**
     * Clear SRACT's ASSR2 bit.
     *
     * Activate Shared Service Request Node 2
     */
    inline void clear_SRACT_ASSR2() volatile
    {
        SRACT &= ~(1u << 10u);
    }

    /**
     * Toggle SRACT's ASSR2 bit.
     *
     * Activate Shared Service Request Node 2
     */
    inline void toggle_SRACT_ASSR2() volatile
    {
        SRACT ^= 1u << 10u;
    }

    /**
     * Set SRACT's ASSR1 bit.
     *
     * Activate Shared Service Request Node 1
     */
    inline void set_SRACT_ASSR1() volatile
    {
        SRACT |= 1u << 9u;
    }

    /**
     * Clear SRACT's ASSR1 bit.
     *
     * Activate Shared Service Request Node 1
     */
    inline void clear_SRACT_ASSR1() volatile
    {
        SRACT &= ~(1u << 9u);
    }

    /**
     * Toggle SRACT's ASSR1 bit.
     *
     * Activate Shared Service Request Node 1
     */
    inline void toggle_SRACT_ASSR1() volatile
    {
        SRACT ^= 1u << 9u;
    }

    /**
     * Set SRACT's ASSR0 bit.
     *
     * Activate Shared Service Request Node 0
     */
    inline void set_SRACT_ASSR0() volatile
    {
        SRACT |= 1u << 8u;
    }

    /**
     * Clear SRACT's ASSR0 bit.
     *
     * Activate Shared Service Request Node 0
     */
    inline void clear_SRACT_ASSR0() volatile
    {
        SRACT &= ~(1u << 8u);
    }

    /**
     * Toggle SRACT's ASSR0 bit.
     *
     * Activate Shared Service Request Node 0
     */
    inline void toggle_SRACT_ASSR0() volatile
    {
        SRACT ^= 1u << 8u;
    }

    /**
     * Set SRACT's AGSR3 bit.
     *
     * Activate Group Service Request Node 3
     */
    inline void set_SRACT_AGSR3() volatile
    {
        SRACT |= 1u << 3u;
    }

    /**
     * Clear SRACT's AGSR3 bit.
     *
     * Activate Group Service Request Node 3
     */
    inline void clear_SRACT_AGSR3() volatile
    {
        SRACT &= ~(1u << 3u);
    }

    /**
     * Toggle SRACT's AGSR3 bit.
     *
     * Activate Group Service Request Node 3
     */
    inline void toggle_SRACT_AGSR3() volatile
    {
        SRACT ^= 1u << 3u;
    }

    /**
     * Set SRACT's AGSR2 bit.
     *
     * Activate Group Service Request Node 2
     */
    inline void set_SRACT_AGSR2() volatile
    {
        SRACT |= 1u << 2u;
    }

    /**
     * Clear SRACT's AGSR2 bit.
     *
     * Activate Group Service Request Node 2
     */
    inline void clear_SRACT_AGSR2() volatile
    {
        SRACT &= ~(1u << 2u);
    }

    /**
     * Toggle SRACT's AGSR2 bit.
     *
     * Activate Group Service Request Node 2
     */
    inline void toggle_SRACT_AGSR2() volatile
    {
        SRACT ^= 1u << 2u;
    }

    /**
     * Set SRACT's AGSR1 bit.
     *
     * Activate Group Service Request Node 1
     */
    inline void set_SRACT_AGSR1() volatile
    {
        SRACT |= 1u << 1u;
    }

    /**
     * Clear SRACT's AGSR1 bit.
     *
     * Activate Group Service Request Node 1
     */
    inline void clear_SRACT_AGSR1() volatile
    {
        SRACT &= ~(1u << 1u);
    }

    /**
     * Toggle SRACT's AGSR1 bit.
     *
     * Activate Group Service Request Node 1
     */
    inline void toggle_SRACT_AGSR1() volatile
    {
        SRACT ^= 1u << 1u;
    }

    /**
     * Set SRACT's AGSR0 bit.
     *
     * Activate Group Service Request Node 0
     */
    inline void set_SRACT_AGSR0() volatile
    {
        SRACT |= 1u << 0u;
    }

    /**
     * Clear SRACT's AGSR0 bit.
     *
     * Activate Group Service Request Node 0
     */
    inline void clear_SRACT_AGSR0() volatile
    {
        SRACT &= ~(1u << 0u);
    }

    /**
     * Toggle SRACT's AGSR0 bit.
     *
     * Activate Group Service Request Node 0
     */
    inline void toggle_SRACT_AGSR0() volatile
    {
        SRACT ^= 1u << 0u;
    }

    /**
     * Set all of SRACT's bit fields.
     *
     * (write-only) Service Request Software Activation Trigger
     */
    inline void set_SRACT(bool ASSR3, bool ASSR2, bool ASSR1, bool ASSR0,
                          bool AGSR3, bool AGSR2, bool AGSR1,
                          bool AGSR0) volatile
    {
        uint32_t curr = SRACT;

        curr &= ~(0b1u << 11u);
        curr |= (ASSR3 & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (ASSR2 & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (ASSR1 & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (ASSR0 & 0b1u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (AGSR3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (AGSR2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (AGSR1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (AGSR0 & 0b1u) << 0u;

        SRACT = curr;
    }

    /**
     * Set EMUXCTR's EMXWC bit.
     *
     * Write Control for EMUX Configuration
     */
    inline void set_EMUXCTR_EMXWC() volatile
    {
        EMUXCTR |= 1u << 31u;
    }

    /**
     * Clear EMUXCTR's EMXWC bit.
     *
     * Write Control for EMUX Configuration
     */
    inline void clear_EMUXCTR_EMXWC() volatile
    {
        EMUXCTR &= ~(1u << 31u);
    }

    /**
     * Toggle EMUXCTR's EMXWC bit.
     *
     * Write Control for EMUX Configuration
     */
    inline void toggle_EMUXCTR_EMXWC() volatile
    {
        EMUXCTR ^= 1u << 31u;
    }

    /**
     * Get EMUXCTR's EMXCSS bit.
     *
     * External Multiplexer Channel Selection Style
     */
    inline bool get_EMUXCTR_EMXCSS() volatile
    {
        return EMUXCTR & (1u << 30u);
    }

    /**
     * Get EMUXCTR's EMXST bit.
     *
     * External Multiplexer Sample Time Control
     */
    inline bool get_EMUXCTR_EMXST() volatile
    {
        return EMUXCTR & (1u << 29u);
    }

    /**
     * Set EMUXCTR's EMXST bit.
     *
     * External Multiplexer Sample Time Control
     */
    inline void set_EMUXCTR_EMXST() volatile
    {
        EMUXCTR |= 1u << 29u;
    }

    /**
     * Clear EMUXCTR's EMXST bit.
     *
     * External Multiplexer Sample Time Control
     */
    inline void clear_EMUXCTR_EMXST() volatile
    {
        EMUXCTR &= ~(1u << 29u);
    }

    /**
     * Toggle EMUXCTR's EMXST bit.
     *
     * External Multiplexer Sample Time Control
     */
    inline void toggle_EMUXCTR_EMXST() volatile
    {
        EMUXCTR ^= 1u << 29u;
    }

    /**
     * Get EMUXCTR's EMXCOD bit.
     *
     * External Multiplexer Coding Scheme
     */
    inline bool get_EMUXCTR_EMXCOD() volatile
    {
        return EMUXCTR & (1u << 28u);
    }

    /**
     * Set EMUXCTR's EMXCOD bit.
     *
     * External Multiplexer Coding Scheme
     */
    inline void set_EMUXCTR_EMXCOD() volatile
    {
        EMUXCTR |= 1u << 28u;
    }

    /**
     * Clear EMUXCTR's EMXCOD bit.
     *
     * External Multiplexer Coding Scheme
     */
    inline void clear_EMUXCTR_EMXCOD() volatile
    {
        EMUXCTR &= ~(1u << 28u);
    }

    /**
     * Toggle EMUXCTR's EMXCOD bit.
     *
     * External Multiplexer Coding Scheme
     */
    inline void toggle_EMUXCTR_EMXCOD() volatile
    {
        EMUXCTR ^= 1u << 28u;
    }

    /**
     * Get EMUXCTR's EMUXMODE field.
     *
     * External Multiplexer Mode
     */
    inline VADC_G0_EMUXCTR_EMUXMODE get_EMUXCTR_EMUXMODE() volatile
    {
        return VADC_G0_EMUXCTR_EMUXMODE((EMUXCTR >> 26u) & 0b11u);
    }

    /**
     * Set EMUXCTR's EMUXMODE field.
     *
     * External Multiplexer Mode
     */
    inline void set_EMUXCTR_EMUXMODE(VADC_G0_EMUXCTR_EMUXMODE value) volatile
    {
        uint32_t curr = EMUXCTR;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EMUXCTR = curr;
    }

    /**
     * Get EMUXCTR's EMUXCH field.
     *
     * External Multiplexer Channel Select
     */
    inline uint16_t get_EMUXCTR_EMUXCH() volatile
    {
        return (EMUXCTR >> 16u) & 0b1111111111u;
    }

    /**
     * Set EMUXCTR's EMUXCH field.
     *
     * External Multiplexer Channel Select
     */
    inline void set_EMUXCTR_EMUXCH(uint16_t value) volatile
    {
        uint32_t curr = EMUXCTR;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EMUXCTR = curr;
    }

    /**
     * Get EMUXCTR's EMUXACT field.
     *
     * External Multiplexer Actual Selection
     */
    inline uint8_t get_EMUXCTR_EMUXACT() volatile
    {
        return (EMUXCTR >> 8u) & 0b111u;
    }

    /**
     * Get EMUXCTR's EMUXSET field.
     *
     * External Multiplexer Start Selection
     */
    inline uint8_t get_EMUXCTR_EMUXSET() volatile
    {
        return (EMUXCTR >> 0u) & 0b111u;
    }

    /**
     * Set EMUXCTR's EMUXSET field.
     *
     * External Multiplexer Start Selection
     */
    inline void set_EMUXCTR_EMUXSET(uint8_t value) volatile
    {
        uint32_t curr = EMUXCTR;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        EMUXCTR = curr;
    }

    /**
     * Get all of EMUXCTR's bit fields.
     *
     * (read-write) E0ternal Multiplexer Control Register
     */
    inline void get_EMUXCTR(bool &EMXCSS, bool &EMXST, bool &EMXCOD,
                            VADC_G0_EMUXCTR_EMUXMODE &EMUXMODE,
                            uint16_t &EMUXCH, uint8_t &EMUXACT,
                            uint8_t &EMUXSET) volatile
    {
        uint32_t curr = EMUXCTR;

        EMXCSS = curr & (1u << 30u);
        EMXST = curr & (1u << 29u);
        EMXCOD = curr & (1u << 28u);
        EMUXMODE = VADC_G0_EMUXCTR_EMUXMODE((curr >> 26u) & 0b11u);
        EMUXCH = (curr >> 16u) & 0b1111111111u;
        EMUXACT = (curr >> 8u) & 0b111u;
        EMUXSET = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of EMUXCTR's bit fields.
     *
     * (read-write) E0ternal Multiplexer Control Register
     */
    inline void set_EMUXCTR(bool EMXWC, bool EMXST, bool EMXCOD,
                            VADC_G0_EMUXCTR_EMUXMODE EMUXMODE, uint16_t EMUXCH,
                            uint8_t EMUXSET) volatile
    {
        uint32_t curr = EMUXCTR;

        curr &= ~(0b1u << 31u);
        curr |= (EMXWC & 0b1u) << 31u;
        curr &= ~(0b1u << 29u);
        curr |= (EMXST & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (EMXCOD & 0b1u) << 28u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(EMUXMODE) & 0b11u) << 26u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (EMUXCH & 0b1111111111u) << 16u;
        curr &= ~(0b111u << 0u);
        curr |= (EMUXSET & 0b111u) << 0u;

        EMUXCTR = curr;
    }

    /**
     * Get VFR's VF15 bit.
     *
     * Valid Flag of Result Register x
     */
    inline bool get_VFR_VF15() volatile
    {
        return VFR & (1u << 15u);
    }

    /**
     * Set VFR's VF15 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void set_VFR_VF15() volatile
    {
        VFR |= 1u << 15u;
    }

    /**
     * Clear VFR's VF15 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void clear_VFR_VF15() volatile
    {
        VFR &= ~(1u << 15u);
    }

    /**
     * Toggle VFR's VF15 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void toggle_VFR_VF15() volatile
    {
        VFR ^= 1u << 15u;
    }

    /**
     * Get VFR's VF14 bit.
     *
     * Valid Flag of Result Register x
     */
    inline bool get_VFR_VF14() volatile
    {
        return VFR & (1u << 14u);
    }

    /**
     * Set VFR's VF14 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void set_VFR_VF14() volatile
    {
        VFR |= 1u << 14u;
    }

    /**
     * Clear VFR's VF14 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void clear_VFR_VF14() volatile
    {
        VFR &= ~(1u << 14u);
    }

    /**
     * Toggle VFR's VF14 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void toggle_VFR_VF14() volatile
    {
        VFR ^= 1u << 14u;
    }

    /**
     * Get VFR's VF13 bit.
     *
     * Valid Flag of Result Register x
     */
    inline bool get_VFR_VF13() volatile
    {
        return VFR & (1u << 13u);
    }

    /**
     * Set VFR's VF13 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void set_VFR_VF13() volatile
    {
        VFR |= 1u << 13u;
    }

    /**
     * Clear VFR's VF13 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void clear_VFR_VF13() volatile
    {
        VFR &= ~(1u << 13u);
    }

    /**
     * Toggle VFR's VF13 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void toggle_VFR_VF13() volatile
    {
        VFR ^= 1u << 13u;
    }

    /**
     * Get VFR's VF12 bit.
     *
     * Valid Flag of Result Register x
     */
    inline bool get_VFR_VF12() volatile
    {
        return VFR & (1u << 12u);
    }

    /**
     * Set VFR's VF12 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void set_VFR_VF12() volatile
    {
        VFR |= 1u << 12u;
    }

    /**
     * Clear VFR's VF12 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void clear_VFR_VF12() volatile
    {
        VFR &= ~(1u << 12u);
    }

    /**
     * Toggle VFR's VF12 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void toggle_VFR_VF12() volatile
    {
        VFR ^= 1u << 12u;
    }

    /**
     * Get VFR's VF11 bit.
     *
     * Valid Flag of Result Register x
     */
    inline bool get_VFR_VF11() volatile
    {
        return VFR & (1u << 11u);
    }

    /**
     * Set VFR's VF11 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void set_VFR_VF11() volatile
    {
        VFR |= 1u << 11u;
    }

    /**
     * Clear VFR's VF11 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void clear_VFR_VF11() volatile
    {
        VFR &= ~(1u << 11u);
    }

    /**
     * Toggle VFR's VF11 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void toggle_VFR_VF11() volatile
    {
        VFR ^= 1u << 11u;
    }

    /**
     * Get VFR's VF10 bit.
     *
     * Valid Flag of Result Register x
     */
    inline bool get_VFR_VF10() volatile
    {
        return VFR & (1u << 10u);
    }

    /**
     * Set VFR's VF10 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void set_VFR_VF10() volatile
    {
        VFR |= 1u << 10u;
    }

    /**
     * Clear VFR's VF10 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void clear_VFR_VF10() volatile
    {
        VFR &= ~(1u << 10u);
    }

    /**
     * Toggle VFR's VF10 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void toggle_VFR_VF10() volatile
    {
        VFR ^= 1u << 10u;
    }

    /**
     * Get VFR's VF9 bit.
     *
     * Valid Flag of Result Register x
     */
    inline bool get_VFR_VF9() volatile
    {
        return VFR & (1u << 9u);
    }

    /**
     * Set VFR's VF9 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void set_VFR_VF9() volatile
    {
        VFR |= 1u << 9u;
    }

    /**
     * Clear VFR's VF9 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void clear_VFR_VF9() volatile
    {
        VFR &= ~(1u << 9u);
    }

    /**
     * Toggle VFR's VF9 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void toggle_VFR_VF9() volatile
    {
        VFR ^= 1u << 9u;
    }

    /**
     * Get VFR's VF8 bit.
     *
     * Valid Flag of Result Register x
     */
    inline bool get_VFR_VF8() volatile
    {
        return VFR & (1u << 8u);
    }

    /**
     * Set VFR's VF8 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void set_VFR_VF8() volatile
    {
        VFR |= 1u << 8u;
    }

    /**
     * Clear VFR's VF8 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void clear_VFR_VF8() volatile
    {
        VFR &= ~(1u << 8u);
    }

    /**
     * Toggle VFR's VF8 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void toggle_VFR_VF8() volatile
    {
        VFR ^= 1u << 8u;
    }

    /**
     * Get VFR's VF7 bit.
     *
     * Valid Flag of Result Register x
     */
    inline bool get_VFR_VF7() volatile
    {
        return VFR & (1u << 7u);
    }

    /**
     * Set VFR's VF7 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void set_VFR_VF7() volatile
    {
        VFR |= 1u << 7u;
    }

    /**
     * Clear VFR's VF7 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void clear_VFR_VF7() volatile
    {
        VFR &= ~(1u << 7u);
    }

    /**
     * Toggle VFR's VF7 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void toggle_VFR_VF7() volatile
    {
        VFR ^= 1u << 7u;
    }

    /**
     * Get VFR's VF6 bit.
     *
     * Valid Flag of Result Register x
     */
    inline bool get_VFR_VF6() volatile
    {
        return VFR & (1u << 6u);
    }

    /**
     * Set VFR's VF6 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void set_VFR_VF6() volatile
    {
        VFR |= 1u << 6u;
    }

    /**
     * Clear VFR's VF6 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void clear_VFR_VF6() volatile
    {
        VFR &= ~(1u << 6u);
    }

    /**
     * Toggle VFR's VF6 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void toggle_VFR_VF6() volatile
    {
        VFR ^= 1u << 6u;
    }

    /**
     * Get VFR's VF5 bit.
     *
     * Valid Flag of Result Register x
     */
    inline bool get_VFR_VF5() volatile
    {
        return VFR & (1u << 5u);
    }

    /**
     * Set VFR's VF5 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void set_VFR_VF5() volatile
    {
        VFR |= 1u << 5u;
    }

    /**
     * Clear VFR's VF5 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void clear_VFR_VF5() volatile
    {
        VFR &= ~(1u << 5u);
    }

    /**
     * Toggle VFR's VF5 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void toggle_VFR_VF5() volatile
    {
        VFR ^= 1u << 5u;
    }

    /**
     * Get VFR's VF4 bit.
     *
     * Valid Flag of Result Register x
     */
    inline bool get_VFR_VF4() volatile
    {
        return VFR & (1u << 4u);
    }

    /**
     * Set VFR's VF4 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void set_VFR_VF4() volatile
    {
        VFR |= 1u << 4u;
    }

    /**
     * Clear VFR's VF4 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void clear_VFR_VF4() volatile
    {
        VFR &= ~(1u << 4u);
    }

    /**
     * Toggle VFR's VF4 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void toggle_VFR_VF4() volatile
    {
        VFR ^= 1u << 4u;
    }

    /**
     * Get VFR's VF3 bit.
     *
     * Valid Flag of Result Register x
     */
    inline bool get_VFR_VF3() volatile
    {
        return VFR & (1u << 3u);
    }

    /**
     * Set VFR's VF3 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void set_VFR_VF3() volatile
    {
        VFR |= 1u << 3u;
    }

    /**
     * Clear VFR's VF3 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void clear_VFR_VF3() volatile
    {
        VFR &= ~(1u << 3u);
    }

    /**
     * Toggle VFR's VF3 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void toggle_VFR_VF3() volatile
    {
        VFR ^= 1u << 3u;
    }

    /**
     * Get VFR's VF2 bit.
     *
     * Valid Flag of Result Register x
     */
    inline bool get_VFR_VF2() volatile
    {
        return VFR & (1u << 2u);
    }

    /**
     * Set VFR's VF2 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void set_VFR_VF2() volatile
    {
        VFR |= 1u << 2u;
    }

    /**
     * Clear VFR's VF2 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void clear_VFR_VF2() volatile
    {
        VFR &= ~(1u << 2u);
    }

    /**
     * Toggle VFR's VF2 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void toggle_VFR_VF2() volatile
    {
        VFR ^= 1u << 2u;
    }

    /**
     * Get VFR's VF1 bit.
     *
     * Valid Flag of Result Register x
     */
    inline bool get_VFR_VF1() volatile
    {
        return VFR & (1u << 1u);
    }

    /**
     * Set VFR's VF1 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void set_VFR_VF1() volatile
    {
        VFR |= 1u << 1u;
    }

    /**
     * Clear VFR's VF1 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void clear_VFR_VF1() volatile
    {
        VFR &= ~(1u << 1u);
    }

    /**
     * Toggle VFR's VF1 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void toggle_VFR_VF1() volatile
    {
        VFR ^= 1u << 1u;
    }

    /**
     * Get VFR's VF0 bit.
     *
     * Valid Flag of Result Register x
     */
    inline bool get_VFR_VF0() volatile
    {
        return VFR & (1u << 0u);
    }

    /**
     * Set VFR's VF0 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void set_VFR_VF0() volatile
    {
        VFR |= 1u << 0u;
    }

    /**
     * Clear VFR's VF0 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void clear_VFR_VF0() volatile
    {
        VFR &= ~(1u << 0u);
    }

    /**
     * Toggle VFR's VF0 bit.
     *
     * Valid Flag of Result Register x
     */
    inline void toggle_VFR_VF0() volatile
    {
        VFR ^= 1u << 0u;
    }

    /**
     * Get all of VFR's bit fields.
     *
     * (read-write) Valid Flag Register
     */
    inline void get_VFR(bool &VF15, bool &VF14, bool &VF13, bool &VF12,
                        bool &VF11, bool &VF10, bool &VF9, bool &VF8,
                        bool &VF7, bool &VF6, bool &VF5, bool &VF4, bool &VF3,
                        bool &VF2, bool &VF1, bool &VF0) volatile
    {
        uint32_t curr = VFR;

        VF15 = curr & (1u << 15u);
        VF14 = curr & (1u << 14u);
        VF13 = curr & (1u << 13u);
        VF12 = curr & (1u << 12u);
        VF11 = curr & (1u << 11u);
        VF10 = curr & (1u << 10u);
        VF9 = curr & (1u << 9u);
        VF8 = curr & (1u << 8u);
        VF7 = curr & (1u << 7u);
        VF6 = curr & (1u << 6u);
        VF5 = curr & (1u << 5u);
        VF4 = curr & (1u << 4u);
        VF3 = curr & (1u << 3u);
        VF2 = curr & (1u << 2u);
        VF1 = curr & (1u << 1u);
        VF0 = curr & (1u << 0u);
    }

    /**
     * Set all of VFR's bit fields.
     *
     * (read-write) Valid Flag Register
     */
    inline void set_VFR(bool VF15, bool VF14, bool VF13, bool VF12, bool VF11,
                        bool VF10, bool VF9, bool VF8, bool VF7, bool VF6,
                        bool VF5, bool VF4, bool VF3, bool VF2, bool VF1,
                        bool VF0) volatile
    {
        uint32_t curr = VFR;

        curr &= ~(0b1u << 15u);
        curr |= (VF15 & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (VF14 & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (VF13 & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (VF12 & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (VF11 & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (VF10 & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (VF9 & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (VF8 & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (VF7 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (VF6 & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (VF5 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (VF4 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (VF3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (VF2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (VF1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (VF0 & 0b1u) << 0u;

        VFR = curr;
    }

    /**
     * Get CHCTR's BWDEN bit.
     *
     * Broken Wire Detection Enable
     */
    inline bool get_CHCTR_BWDEN(std::size_t index) volatile
    {
        return CHCTR[index] & (1u << 30u);
    }

    /**
     * Set CHCTR's BWDEN bit.
     *
     * Broken Wire Detection Enable
     */
    inline void set_CHCTR_BWDEN() volatile
    {
        CHCTR |= 1u << 30u;
    }

    /**
     * Clear CHCTR's BWDEN bit.
     *
     * Broken Wire Detection Enable
     */
    inline void clear_CHCTR_BWDEN() volatile
    {
        CHCTR &= ~(1u << 30u);
    }

    /**
     * Toggle CHCTR's BWDEN bit.
     *
     * Broken Wire Detection Enable
     */
    inline void toggle_CHCTR_BWDEN() volatile
    {
        CHCTR ^= 1u << 30u;
    }

    /**
     * Get CHCTR's BWDCH field.
     *
     * Broken Wire Detection Channel
     */
    inline VADC_G0_CHCTR_BWDCH get_CHCTR_BWDCH(std::size_t index) volatile
    {
        return VADC_G0_CHCTR_BWDCH((CHCTR[index] >> 28u) & 0b11u);
    }

    /**
     * Set CHCTR's BWDCH field.
     *
     * Broken Wire Detection Channel
     */
    inline void set_CHCTR_BWDCH(std::size_t index,
                                VADC_G0_CHCTR_BWDCH value) volatile
    {
        uint32_t curr = CHCTR[index];

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        CHCTR[index] = curr;
    }

    /**
     * Get CHCTR's RESPOS bit.
     *
     * Result Position
     */
    inline bool get_CHCTR_RESPOS(std::size_t index) volatile
    {
        return CHCTR[index] & (1u << 21u);
    }

    /**
     * Set CHCTR's RESPOS bit.
     *
     * Result Position
     */
    inline void set_CHCTR_RESPOS() volatile
    {
        CHCTR |= 1u << 21u;
    }

    /**
     * Clear CHCTR's RESPOS bit.
     *
     * Result Position
     */
    inline void clear_CHCTR_RESPOS() volatile
    {
        CHCTR &= ~(1u << 21u);
    }

    /**
     * Toggle CHCTR's RESPOS bit.
     *
     * Result Position
     */
    inline void toggle_CHCTR_RESPOS() volatile
    {
        CHCTR ^= 1u << 21u;
    }

    /**
     * Get CHCTR's RESTBS bit.
     *
     * Result Target for Background Source
     */
    inline bool get_CHCTR_RESTBS(std::size_t index) volatile
    {
        return CHCTR[index] & (1u << 20u);
    }

    /**
     * Set CHCTR's RESTBS bit.
     *
     * Result Target for Background Source
     */
    inline void set_CHCTR_RESTBS() volatile
    {
        CHCTR |= 1u << 20u;
    }

    /**
     * Clear CHCTR's RESTBS bit.
     *
     * Result Target for Background Source
     */
    inline void clear_CHCTR_RESTBS() volatile
    {
        CHCTR &= ~(1u << 20u);
    }

    /**
     * Toggle CHCTR's RESTBS bit.
     *
     * Result Target for Background Source
     */
    inline void toggle_CHCTR_RESTBS() volatile
    {
        CHCTR ^= 1u << 20u;
    }

    /**
     * Get CHCTR's RESREG field.
     *
     * Result Register
     */
    inline VADC_G0_CHCTR_RESREG get_CHCTR_RESREG(std::size_t index) volatile
    {
        return VADC_G0_CHCTR_RESREG((CHCTR[index] >> 16u) & 0b1111u);
    }

    /**
     * Set CHCTR's RESREG field.
     *
     * Result Register
     */
    inline void set_CHCTR_RESREG(std::size_t index,
                                 VADC_G0_CHCTR_RESREG value) volatile
    {
        uint32_t curr = CHCTR[index];

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        CHCTR[index] = curr;
    }

    /**
     * Get CHCTR's REFSEL bit.
     *
     * Reference Input Selection
     */
    inline bool get_CHCTR_REFSEL(std::size_t index) volatile
    {
        return CHCTR[index] & (1u << 11u);
    }

    /**
     * Set CHCTR's REFSEL bit.
     *
     * Reference Input Selection
     */
    inline void set_CHCTR_REFSEL() volatile
    {
        CHCTR |= 1u << 11u;
    }

    /**
     * Clear CHCTR's REFSEL bit.
     *
     * Reference Input Selection
     */
    inline void clear_CHCTR_REFSEL() volatile
    {
        CHCTR &= ~(1u << 11u);
    }

    /**
     * Toggle CHCTR's REFSEL bit.
     *
     * Reference Input Selection
     */
    inline void toggle_CHCTR_REFSEL() volatile
    {
        CHCTR ^= 1u << 11u;
    }

    /**
     * Get CHCTR's SYNC bit.
     *
     * Synchronization Request
     */
    inline bool get_CHCTR_SYNC(std::size_t index) volatile
    {
        return CHCTR[index] & (1u << 10u);
    }

    /**
     * Set CHCTR's SYNC bit.
     *
     * Synchronization Request
     */
    inline void set_CHCTR_SYNC() volatile
    {
        CHCTR |= 1u << 10u;
    }

    /**
     * Clear CHCTR's SYNC bit.
     *
     * Synchronization Request
     */
    inline void clear_CHCTR_SYNC() volatile
    {
        CHCTR &= ~(1u << 10u);
    }

    /**
     * Toggle CHCTR's SYNC bit.
     *
     * Synchronization Request
     */
    inline void toggle_CHCTR_SYNC() volatile
    {
        CHCTR ^= 1u << 10u;
    }

    /**
     * Get CHCTR's CHEVMODE field.
     *
     * Channel Event Mode
     */
    inline VADC_G0_CHCTR_CHEVMODE get_CHCTR_CHEVMODE(
        std::size_t index) volatile
    {
        return VADC_G0_CHCTR_CHEVMODE((CHCTR[index] >> 8u) & 0b11u);
    }

    /**
     * Set CHCTR's CHEVMODE field.
     *
     * Channel Event Mode
     */
    inline void set_CHCTR_CHEVMODE(std::size_t index,
                                   VADC_G0_CHCTR_CHEVMODE value) volatile
    {
        uint32_t curr = CHCTR[index];

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        CHCTR[index] = curr;
    }

    /**
     * Get CHCTR's BNDSELU field.
     *
     * Upper Boundary Select
     */
    inline VADC_G0_CHCTR_BNDSELU get_CHCTR_BNDSELU(std::size_t index) volatile
    {
        return VADC_G0_CHCTR_BNDSELU((CHCTR[index] >> 6u) & 0b11u);
    }

    /**
     * Set CHCTR's BNDSELU field.
     *
     * Upper Boundary Select
     */
    inline void set_CHCTR_BNDSELU(std::size_t index,
                                  VADC_G0_CHCTR_BNDSELU value) volatile
    {
        uint32_t curr = CHCTR[index];

        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(value) & 0b11u) << 6u;

        CHCTR[index] = curr;
    }

    /**
     * Get CHCTR's BNDSELL field.
     *
     * Lower Boundary Select
     */
    inline VADC_G0_CHCTR_BNDSELU get_CHCTR_BNDSELL(std::size_t index) volatile
    {
        return VADC_G0_CHCTR_BNDSELU((CHCTR[index] >> 4u) & 0b11u);
    }

    /**
     * Set CHCTR's BNDSELL field.
     *
     * Lower Boundary Select
     */
    inline void set_CHCTR_BNDSELL(std::size_t index,
                                  VADC_G0_CHCTR_BNDSELU value) volatile
    {
        uint32_t curr = CHCTR[index];

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        CHCTR[index] = curr;
    }

    /**
     * Get CHCTR's ICLSEL field.
     *
     * Input Class Select
     */
    inline VADC_G0_CHCTR_ICLSEL get_CHCTR_ICLSEL(std::size_t index) volatile
    {
        return VADC_G0_CHCTR_ICLSEL((CHCTR[index] >> 0u) & 0b11u);
    }

    /**
     * Set CHCTR's ICLSEL field.
     *
     * Input Class Select
     */
    inline void set_CHCTR_ICLSEL(std::size_t index,
                                 VADC_G0_CHCTR_ICLSEL value) volatile
    {
        uint32_t curr = CHCTR[index];

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CHCTR[index] = curr;
    }

    /**
     * Get all of CHCTR's bit fields.
     *
     * (read-write) Channel Ctrl. Reg.
     */
    inline void get_CHCTR(std::size_t index, bool &BWDEN,
                          VADC_G0_CHCTR_BWDCH &BWDCH, bool &RESPOS,
                          bool &RESTBS, VADC_G0_CHCTR_RESREG &RESREG,
                          bool &REFSEL, bool &SYNC,
                          VADC_G0_CHCTR_CHEVMODE &CHEVMODE,
                          VADC_G0_CHCTR_BNDSELU &BNDSELU,
                          VADC_G0_CHCTR_BNDSELU &BNDSELL,
                          VADC_G0_CHCTR_ICLSEL &ICLSEL) volatile
    {
        uint32_t curr = CHCTR[index];

        BWDEN = curr & (1u << 30u);
        BWDCH = VADC_G0_CHCTR_BWDCH((curr >> 28u) & 0b11u);
        RESPOS = curr & (1u << 21u);
        RESTBS = curr & (1u << 20u);
        RESREG = VADC_G0_CHCTR_RESREG((curr >> 16u) & 0b1111u);
        REFSEL = curr & (1u << 11u);
        SYNC = curr & (1u << 10u);
        CHEVMODE = VADC_G0_CHCTR_CHEVMODE((curr >> 8u) & 0b11u);
        BNDSELU = VADC_G0_CHCTR_BNDSELU((curr >> 6u) & 0b11u);
        BNDSELL = VADC_G0_CHCTR_BNDSELU((curr >> 4u) & 0b11u);
        ICLSEL = VADC_G0_CHCTR_ICLSEL((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of CHCTR's bit fields.
     *
     * (read-write) Channel Ctrl. Reg.
     */
    inline void set_CHCTR(std::size_t index, bool BWDEN,
                          VADC_G0_CHCTR_BWDCH BWDCH, bool RESPOS, bool RESTBS,
                          VADC_G0_CHCTR_RESREG RESREG, bool REFSEL, bool SYNC,
                          VADC_G0_CHCTR_CHEVMODE CHEVMODE,
                          VADC_G0_CHCTR_BNDSELU BNDSELU,
                          VADC_G0_CHCTR_BNDSELU BNDSELL,
                          VADC_G0_CHCTR_ICLSEL ICLSEL) volatile
    {
        uint32_t curr = CHCTR[index];

        curr &= ~(0b1u << 30u);
        curr |= (BWDEN & 0b1u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(BWDCH) & 0b11u) << 28u;
        curr &= ~(0b1u << 21u);
        curr |= (RESPOS & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (RESTBS & 0b1u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(RESREG) & 0b1111u) << 16u;
        curr &= ~(0b1u << 11u);
        curr |= (REFSEL & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (SYNC & 0b1u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(CHEVMODE) & 0b11u) << 8u;
        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(BNDSELU) & 0b11u) << 6u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(BNDSELL) & 0b11u) << 4u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(ICLSEL) & 0b11u) << 0u;

        CHCTR[index] = curr;
    }

    /**
     * Get RCR's SRGEN bit.
     *
     * Service Request Generation Enable
     */
    inline bool get_RCR_SRGEN(std::size_t index) volatile
    {
        return RCR[index] & (1u << 31u);
    }

    /**
     * Set RCR's SRGEN bit.
     *
     * Service Request Generation Enable
     */
    inline void set_RCR_SRGEN() volatile
    {
        RCR |= 1u << 31u;
    }

    /**
     * Clear RCR's SRGEN bit.
     *
     * Service Request Generation Enable
     */
    inline void clear_RCR_SRGEN() volatile
    {
        RCR &= ~(1u << 31u);
    }

    /**
     * Toggle RCR's SRGEN bit.
     *
     * Service Request Generation Enable
     */
    inline void toggle_RCR_SRGEN() volatile
    {
        RCR ^= 1u << 31u;
    }

    /**
     * Get RCR's FEN field.
     *
     * FIFO Mode Enable
     */
    inline VADC_G0_RCR_FEN get_RCR_FEN(std::size_t index) volatile
    {
        return VADC_G0_RCR_FEN((RCR[index] >> 25u) & 0b11u);
    }

    /**
     * Set RCR's FEN field.
     *
     * FIFO Mode Enable
     */
    inline void set_RCR_FEN(std::size_t index, VADC_G0_RCR_FEN value) volatile
    {
        uint32_t curr = RCR[index];

        curr &= ~(0b11u << 25u);
        curr |= (std::to_underlying(value) & 0b11u) << 25u;

        RCR[index] = curr;
    }

    /**
     * Get RCR's WFR bit.
     *
     * Wait-for-Read Mode Enable
     */
    inline bool get_RCR_WFR(std::size_t index) volatile
    {
        return RCR[index] & (1u << 24u);
    }

    /**
     * Set RCR's WFR bit.
     *
     * Wait-for-Read Mode Enable
     */
    inline void set_RCR_WFR() volatile
    {
        RCR |= 1u << 24u;
    }

    /**
     * Clear RCR's WFR bit.
     *
     * Wait-for-Read Mode Enable
     */
    inline void clear_RCR_WFR() volatile
    {
        RCR &= ~(1u << 24u);
    }

    /**
     * Toggle RCR's WFR bit.
     *
     * Wait-for-Read Mode Enable
     */
    inline void toggle_RCR_WFR() volatile
    {
        RCR ^= 1u << 24u;
    }

    /**
     * Get RCR's DMM field.
     *
     * Data Modification Mode
     */
    inline VADC_G0_RCR_DMM get_RCR_DMM(std::size_t index) volatile
    {
        return VADC_G0_RCR_DMM((RCR[index] >> 20u) & 0b11u);
    }

    /**
     * Set RCR's DMM field.
     *
     * Data Modification Mode
     */
    inline void set_RCR_DMM(std::size_t index, VADC_G0_RCR_DMM value) volatile
    {
        uint32_t curr = RCR[index];

        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(value) & 0b11u) << 20u;

        RCR[index] = curr;
    }

    /**
     * Get RCR's DRCTR field.
     *
     * Data Reduction Control
     */
    inline uint8_t get_RCR_DRCTR(std::size_t index) volatile
    {
        return (RCR[index] >> 16u) & 0b1111u;
    }

    /**
     * Set RCR's DRCTR field.
     *
     * Data Reduction Control
     */
    inline void set_RCR_DRCTR(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = RCR[index];

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        RCR[index] = curr;
    }

    /**
     * Get all of RCR's bit fields.
     *
     * (read-write) Result Control Register
     */
    inline void get_RCR(std::size_t index, bool &SRGEN, VADC_G0_RCR_FEN &FEN,
                        bool &WFR, VADC_G0_RCR_DMM &DMM,
                        uint8_t &DRCTR) volatile
    {
        uint32_t curr = RCR[index];

        SRGEN = curr & (1u << 31u);
        FEN = VADC_G0_RCR_FEN((curr >> 25u) & 0b11u);
        WFR = curr & (1u << 24u);
        DMM = VADC_G0_RCR_DMM((curr >> 20u) & 0b11u);
        DRCTR = (curr >> 16u) & 0b1111u;
    }

    /**
     * Set all of RCR's bit fields.
     *
     * (read-write) Result Control Register
     */
    inline void set_RCR(std::size_t index, bool SRGEN, VADC_G0_RCR_FEN FEN,
                        bool WFR, VADC_G0_RCR_DMM DMM, uint8_t DRCTR) volatile
    {
        uint32_t curr = RCR[index];

        curr &= ~(0b1u << 31u);
        curr |= (SRGEN & 0b1u) << 31u;
        curr &= ~(0b11u << 25u);
        curr |= (std::to_underlying(FEN) & 0b11u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (WFR & 0b1u) << 24u;
        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(DMM) & 0b11u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (DRCTR & 0b1111u) << 16u;

        RCR[index] = curr;
    }

    /**
     * Get RES's VF bit.
     *
     * Valid Flag
     */
    inline bool get_RES_VF(std::size_t index) volatile
    {
        return RES[index] & (1u << 31u);
    }

    /**
     * Get RES's FCR bit.
     *
     * Fast Compare Result
     */
    inline bool get_RES_FCR(std::size_t index) volatile
    {
        return RES[index] & (1u << 30u);
    }

    /**
     * Get RES's CRS field.
     *
     * Converted Request Source
     */
    inline VADC_G0_RES_CRS get_RES_CRS(std::size_t index) volatile
    {
        return VADC_G0_RES_CRS((RES[index] >> 28u) & 0b11u);
    }

    /**
     * Get RES's EMUX field.
     *
     * External Multiplexer Setting
     */
    inline uint8_t get_RES_EMUX(std::size_t index) volatile
    {
        return (RES[index] >> 25u) & 0b111u;
    }

    /**
     * Get RES's CHNR field.
     *
     * Channel Number
     */
    inline uint8_t get_RES_CHNR(std::size_t index) volatile
    {
        return (RES[index] >> 20u) & 0b11111u;
    }

    /**
     * Get RES's DRC field.
     *
     * Data Reduction Counter
     */
    inline uint8_t get_RES_DRC(std::size_t index) volatile
    {
        return (RES[index] >> 16u) & 0b1111u;
    }

    /**
     * Get RES's RESULT field.
     *
     * Result of Most Recent Conversion
     */
    inline uint16_t get_RES_RESULT(std::size_t index) volatile
    {
        return (RES[index] >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set RES's RESULT field.
     *
     * Result of Most Recent Conversion
     */
    inline void set_RES_RESULT(std::size_t index, uint16_t value) volatile
    {
        uint32_t curr = RES[index];

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        RES[index] = curr;
    }

    /**
     * Get all of RES's bit fields.
     *
     * (read-write) Result Register
     */
    inline void get_RES(std::size_t index, bool &VF, bool &FCR,
                        VADC_G0_RES_CRS &CRS, uint8_t &EMUX, uint8_t &CHNR,
                        uint8_t &DRC, uint16_t &RESULT) volatile
    {
        uint32_t curr = RES[index];

        VF = curr & (1u << 31u);
        FCR = curr & (1u << 30u);
        CRS = VADC_G0_RES_CRS((curr >> 28u) & 0b11u);
        EMUX = (curr >> 25u) & 0b111u;
        CHNR = (curr >> 20u) & 0b11111u;
        DRC = (curr >> 16u) & 0b1111u;
        RESULT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RESD's VF bit.
     *
     * Valid Flag
     */
    inline bool get_RESD_VF(std::size_t index) volatile
    {
        return RESD[index] & (1u << 31u);
    }

    /**
     * Get RESD's FCR bit.
     *
     * Fast Compare Result
     */
    inline bool get_RESD_FCR(std::size_t index) volatile
    {
        return RESD[index] & (1u << 30u);
    }

    /**
     * Get RESD's CRS field.
     *
     * Converted Request Source
     */
    inline VADC_G0_RES_CRS get_RESD_CRS(std::size_t index) volatile
    {
        return VADC_G0_RES_CRS((RESD[index] >> 28u) & 0b11u);
    }

    /**
     * Get RESD's EMUX field.
     *
     * External Multiplexer Setting
     */
    inline uint8_t get_RESD_EMUX(std::size_t index) volatile
    {
        return (RESD[index] >> 25u) & 0b111u;
    }

    /**
     * Get RESD's CHNR field.
     *
     * Channel Number
     */
    inline uint8_t get_RESD_CHNR(std::size_t index) volatile
    {
        return (RESD[index] >> 20u) & 0b11111u;
    }

    /**
     * Get RESD's DRC field.
     *
     * Data Reduction Counter
     */
    inline uint8_t get_RESD_DRC(std::size_t index) volatile
    {
        return (RESD[index] >> 16u) & 0b1111u;
    }

    /**
     * Get RESD's RESULT field.
     *
     * Result of Most Recent Conversion
     */
    inline uint16_t get_RESD_RESULT(std::size_t index) volatile
    {
        return (RESD[index] >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of RESD's bit fields.
     *
     * (read-only) Result Register, Debug
     */
    inline void get_RESD(std::size_t index, bool &VF, bool &FCR,
                         VADC_G0_RES_CRS &CRS, uint8_t &EMUX, uint8_t &CHNR,
                         uint8_t &DRC, uint16_t &RESULT) volatile
    {
        uint32_t curr = RESD[index];

        VF = curr & (1u << 31u);
        FCR = curr & (1u << 30u);
        CRS = VADC_G0_RES_CRS((curr >> 28u) & 0b11u);
        EMUX = (curr >> 25u) & 0b111u;
        CHNR = (curr >> 20u) & 0b11111u;
        DRC = (curr >> 16u) & 0b1111u;
        RESULT = (curr >> 0u) & 0b1111111111111111u;
    }
};

static_assert(sizeof(vadc_g0) == vadc_g0::size);

static volatile vadc_g0 *const VADC_G0 =
    reinterpret_cast<vadc_g0 *>(0x40004400);

static volatile vadc_g0 *const VADC_G1 =
    reinterpret_cast<vadc_g0 *>(0x40004800);

static volatile vadc_g0 *const VADC_G2 =
    reinterpret_cast<vadc_g0 *>(0x40004C00);

static volatile vadc_g0 *const VADC_G3 =
    reinterpret_cast<vadc_g0 *>(0x40005000);

}; // namespace XMC4700
