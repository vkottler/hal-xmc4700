/**
 * \file
 * \brief Generated by ifgen (3.2.0).
 */
#pragma once

#include "../enums/CCU80_CC80_CMC_CNTS.h"
#include "../enums/CCU80_CC80_DTC_DTCC.h"
#include "../enums/CCU80_CC80_INS_EV2EM.h"
#include "../enums/CCU80_CC80_INS_EV2IS.h"
#include "../enums/CCU80_CC80_INS_LPF2M.h"
#include "../enums/CCU80_CC80_SRS_E0SR.h"
#include "../enums/CCU80_CC80_SRS_E1SR.h"
#include "../enums/CCU80_CC80_SRS_E2SR.h"
#include "../enums/CCU80_CC80_STC_STM.h"
#include "../enums/CCU80_CC80_TC_CAPC.h"
#include "../enums/CCU80_CC80_TC_DITHE.h"
#include "../enums/CCU80_CC80_TC_EME.h"
#include "../enums/CCU80_CC80_TC_ENDM.h"
#include "../enums/CCU80_CC80_TC_STOS.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * Capture Compare Unit 8 - Unit 0
 */
struct [[gnu::packed]] ccu80_cc80
{
    /* Constant attributes. */
    static constexpr std::size_t size =
        192; /*!< ccu80_cc80's size in bytes. */

    /* Fields. */
    uint32_t INS;             /*!< (read-write) Input Selector Configuration */
    uint32_t CMC;             /*!< (read-write) Connection Matrix Control */
    const uint32_t TCST = {}; /*!< (read-only) Slice Timer Status */
    uint32_t TCSET;           /*!< (write-only) Slice Timer Run Set */
    uint32_t TCCLR;           /*!< (write-only) Slice Timer Clear */
    uint32_t TC;              /*!< (read-write) Slice Timer Control */
    uint32_t PSL;             /*!< (read-write) Passive Level Config */
    const uint32_t DIT = {};  /*!< (read-only) Dither Config */
    uint32_t DITS;            /*!< (read-write) Dither Shadow Register */
    uint32_t PSC;             /*!< (read-write) Prescaler Control */
    uint32_t FPC;             /*!< (read-write) Floating Prescaler Control */
    uint32_t FPCS;            /*!< (read-write) Floating Prescaler Shadow */
    const uint32_t PR = {};   /*!< (read-only) Timer Period Value */
    uint32_t PRS;             /*!< (read-write) Timer Shadow Period Value */
    const uint32_t CR1 = {};  /*!< (read-only) Channel 1 Compare Value */
    uint32_t CR1S; /*!< (read-write) Channel 1 Compare Shadow Value */
    const uint32_t CR2 = {}; /*!< (read-only) Channel 2 Compare Value */
    uint32_t CR2S; /*!< (read-write) Channel 2 Compare Shadow Value */
    uint32_t CHC;  /*!< (read-write) Channel Control */
    uint32_t DTC;  /*!< (read-write) Dead Time Control */
    uint32_t DC1R; /*!< (read-write) Channel 1 Dead Time Values */
    uint32_t DC2R; /*!< (read-write) Channel 2 Dead Time Values */
    static constexpr std::size_t reserved_padding0_length = 6;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t TIMER;          /*!< (read-write) Timer Value */
    const uint32_t C0V = {}; /*!< (read-only) Capture Register 0 */
    const uint32_t C1V = {}; /*!< (read-only) Capture Register 1 */
    const uint32_t C2V = {}; /*!< (read-only) Capture Register 2 */
    const uint32_t C3V = {}; /*!< (read-only) Capture Register 3 */
    static constexpr std::size_t reserved_padding1_length = 7;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    const uint32_t INTS = {};  /*!< (read-only) Interrupt Status */
    uint32_t INTE;             /*!< (read-write) Interrupt Enable Control */
    uint32_t SRS;              /*!< (read-write) Service Request Selector */
    uint32_t SWS;              /*!< (write-only) Interrupt Status Set */
    uint32_t SWR;              /*!< (write-only) Interrupt Status Clear */
    uint32_t STC;              /*!< (read-write) Shadow transfer control */
    const uint32_t ECRD0 = {}; /*!< (read-only) Extended Read Back 0 */
    const uint32_t ECRD1 = {}; /*!< (read-only) Extended Read Back 1 */

    /* Methods. */

    /**
     * Get INS's LPF2M field.
     *
     * Event 2 Low Pass Filter Configuration
     */
    inline CCU80_CC80_INS_LPF2M get_INS_LPF2M() volatile
    {
        return CCU80_CC80_INS_LPF2M((INS >> 29u) & 0b11u);
    }

    /**
     * Set INS's LPF2M field.
     *
     * Event 2 Low Pass Filter Configuration
     */
    inline void set_INS_LPF2M(CCU80_CC80_INS_LPF2M value) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b11u << 29u);
        curr |= (std::to_underlying(value) & 0b11u) << 29u;

        INS = curr;
    }

    /**
     * Get INS's LPF1M field.
     *
     * Event 1 Low Pass Filter Configuration
     */
    inline CCU80_CC80_INS_LPF2M get_INS_LPF1M() volatile
    {
        return CCU80_CC80_INS_LPF2M((INS >> 27u) & 0b11u);
    }

    /**
     * Set INS's LPF1M field.
     *
     * Event 1 Low Pass Filter Configuration
     */
    inline void set_INS_LPF1M(CCU80_CC80_INS_LPF2M value) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        INS = curr;
    }

    /**
     * Get INS's LPF0M field.
     *
     * Event 0 Low Pass Filter Configuration
     */
    inline CCU80_CC80_INS_LPF2M get_INS_LPF0M() volatile
    {
        return CCU80_CC80_INS_LPF2M((INS >> 25u) & 0b11u);
    }

    /**
     * Set INS's LPF0M field.
     *
     * Event 0 Low Pass Filter Configuration
     */
    inline void set_INS_LPF0M(CCU80_CC80_INS_LPF2M value) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b11u << 25u);
        curr |= (std::to_underlying(value) & 0b11u) << 25u;

        INS = curr;
    }

    /**
     * Get INS's EV2LM bit.
     *
     * Event 2 Level Selection
     */
    inline bool get_INS_EV2LM() volatile
    {
        return INS & (1u << 24u);
    }

    /**
     * Set INS's EV2LM bit.
     *
     * Event 2 Level Selection
     */
    inline void set_INS_EV2LM() volatile
    {
        INS |= 1u << 24u;
    }

    /**
     * Clear INS's EV2LM bit.
     *
     * Event 2 Level Selection
     */
    inline void clear_INS_EV2LM() volatile
    {
        INS &= ~(1u << 24u);
    }

    /**
     * Toggle INS's EV2LM bit.
     *
     * Event 2 Level Selection
     */
    inline void toggle_INS_EV2LM() volatile
    {
        INS ^= 1u << 24u;
    }

    /**
     * Get INS's EV1LM bit.
     *
     * Event 1 Level Selection
     */
    inline bool get_INS_EV1LM() volatile
    {
        return INS & (1u << 23u);
    }

    /**
     * Set INS's EV1LM bit.
     *
     * Event 1 Level Selection
     */
    inline void set_INS_EV1LM() volatile
    {
        INS |= 1u << 23u;
    }

    /**
     * Clear INS's EV1LM bit.
     *
     * Event 1 Level Selection
     */
    inline void clear_INS_EV1LM() volatile
    {
        INS &= ~(1u << 23u);
    }

    /**
     * Toggle INS's EV1LM bit.
     *
     * Event 1 Level Selection
     */
    inline void toggle_INS_EV1LM() volatile
    {
        INS ^= 1u << 23u;
    }

    /**
     * Get INS's EV0LM bit.
     *
     * Event 0 Level Selection
     */
    inline bool get_INS_EV0LM() volatile
    {
        return INS & (1u << 22u);
    }

    /**
     * Set INS's EV0LM bit.
     *
     * Event 0 Level Selection
     */
    inline void set_INS_EV0LM() volatile
    {
        INS |= 1u << 22u;
    }

    /**
     * Clear INS's EV0LM bit.
     *
     * Event 0 Level Selection
     */
    inline void clear_INS_EV0LM() volatile
    {
        INS &= ~(1u << 22u);
    }

    /**
     * Toggle INS's EV0LM bit.
     *
     * Event 0 Level Selection
     */
    inline void toggle_INS_EV0LM() volatile
    {
        INS ^= 1u << 22u;
    }

    /**
     * Get INS's EV2EM field.
     *
     * Event 2 Edge Selection
     */
    inline CCU80_CC80_INS_EV2EM get_INS_EV2EM() volatile
    {
        return CCU80_CC80_INS_EV2EM((INS >> 20u) & 0b11u);
    }

    /**
     * Set INS's EV2EM field.
     *
     * Event 2 Edge Selection
     */
    inline void set_INS_EV2EM(CCU80_CC80_INS_EV2EM value) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(value) & 0b11u) << 20u;

        INS = curr;
    }

    /**
     * Get INS's EV1EM field.
     *
     * Event 1 Edge Selection
     */
    inline CCU80_CC80_INS_EV2EM get_INS_EV1EM() volatile
    {
        return CCU80_CC80_INS_EV2EM((INS >> 18u) & 0b11u);
    }

    /**
     * Set INS's EV1EM field.
     *
     * Event 1 Edge Selection
     */
    inline void set_INS_EV1EM(CCU80_CC80_INS_EV2EM value) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(value) & 0b11u) << 18u;

        INS = curr;
    }

    /**
     * Get INS's EV0EM field.
     *
     * Event 0 Edge Selection
     */
    inline CCU80_CC80_INS_EV2EM get_INS_EV0EM() volatile
    {
        return CCU80_CC80_INS_EV2EM((INS >> 16u) & 0b11u);
    }

    /**
     * Set INS's EV0EM field.
     *
     * Event 0 Edge Selection
     */
    inline void set_INS_EV0EM(CCU80_CC80_INS_EV2EM value) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        INS = curr;
    }

    /**
     * Get INS's EV2IS field.
     *
     * Event 2 signal selection
     */
    inline CCU80_CC80_INS_EV2IS get_INS_EV2IS() volatile
    {
        return CCU80_CC80_INS_EV2IS((INS >> 8u) & 0b1111u);
    }

    /**
     * Set INS's EV2IS field.
     *
     * Event 2 signal selection
     */
    inline void set_INS_EV2IS(CCU80_CC80_INS_EV2IS value) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        INS = curr;
    }

    /**
     * Get INS's EV1IS field.
     *
     * Event 1 signal selection
     */
    inline CCU80_CC80_INS_EV2IS get_INS_EV1IS() volatile
    {
        return CCU80_CC80_INS_EV2IS((INS >> 4u) & 0b1111u);
    }

    /**
     * Set INS's EV1IS field.
     *
     * Event 1 signal selection
     */
    inline void set_INS_EV1IS(CCU80_CC80_INS_EV2IS value) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(value) & 0b1111u) << 4u;

        INS = curr;
    }

    /**
     * Get INS's EV0IS field.
     *
     * Event 0 signal selection
     */
    inline CCU80_CC80_INS_EV2IS get_INS_EV0IS() volatile
    {
        return CCU80_CC80_INS_EV2IS((INS >> 0u) & 0b1111u);
    }

    /**
     * Set INS's EV0IS field.
     *
     * Event 0 signal selection
     */
    inline void set_INS_EV0IS(CCU80_CC80_INS_EV2IS value) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        INS = curr;
    }

    /**
     * Get all of INS's bit fields.
     *
     * (read-write) Input Selector Configuration
     */
    inline void get_INS(
        CCU80_CC80_INS_LPF2M &LPF2M, CCU80_CC80_INS_LPF2M &LPF1M,
        CCU80_CC80_INS_LPF2M &LPF0M, bool &EV2LM, bool &EV1LM, bool &EV0LM,
        CCU80_CC80_INS_EV2EM &EV2EM, CCU80_CC80_INS_EV2EM &EV1EM,
        CCU80_CC80_INS_EV2EM &EV0EM, CCU80_CC80_INS_EV2IS &EV2IS,
        CCU80_CC80_INS_EV2IS &EV1IS, CCU80_CC80_INS_EV2IS &EV0IS) volatile
    {
        uint32_t curr = INS;

        LPF2M = CCU80_CC80_INS_LPF2M((curr >> 29u) & 0b11u);
        LPF1M = CCU80_CC80_INS_LPF2M((curr >> 27u) & 0b11u);
        LPF0M = CCU80_CC80_INS_LPF2M((curr >> 25u) & 0b11u);
        EV2LM = curr & (1u << 24u);
        EV1LM = curr & (1u << 23u);
        EV0LM = curr & (1u << 22u);
        EV2EM = CCU80_CC80_INS_EV2EM((curr >> 20u) & 0b11u);
        EV1EM = CCU80_CC80_INS_EV2EM((curr >> 18u) & 0b11u);
        EV0EM = CCU80_CC80_INS_EV2EM((curr >> 16u) & 0b11u);
        EV2IS = CCU80_CC80_INS_EV2IS((curr >> 8u) & 0b1111u);
        EV1IS = CCU80_CC80_INS_EV2IS((curr >> 4u) & 0b1111u);
        EV0IS = CCU80_CC80_INS_EV2IS((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of INS's bit fields.
     *
     * (read-write) Input Selector Configuration
     */
    inline void set_INS(CCU80_CC80_INS_LPF2M LPF2M, CCU80_CC80_INS_LPF2M LPF1M,
                        CCU80_CC80_INS_LPF2M LPF0M, bool EV2LM, bool EV1LM,
                        bool EV0LM, CCU80_CC80_INS_EV2EM EV2EM,
                        CCU80_CC80_INS_EV2EM EV1EM, CCU80_CC80_INS_EV2EM EV0EM,
                        CCU80_CC80_INS_EV2IS EV2IS, CCU80_CC80_INS_EV2IS EV1IS,
                        CCU80_CC80_INS_EV2IS EV0IS) volatile
    {
        uint32_t curr = INS;

        curr &= ~(0b11u << 29u);
        curr |= (std::to_underlying(LPF2M) & 0b11u) << 29u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(LPF1M) & 0b11u) << 27u;
        curr &= ~(0b11u << 25u);
        curr |= (std::to_underlying(LPF0M) & 0b11u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (EV2LM & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (EV1LM & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (EV0LM & 0b1u) << 22u;
        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(EV2EM) & 0b11u) << 20u;
        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(EV1EM) & 0b11u) << 18u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(EV0EM) & 0b11u) << 16u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(EV2IS) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(EV1IS) & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(EV0IS) & 0b1111u) << 0u;

        INS = curr;
    }

    /**
     * Get CMC's TCE bit.
     *
     * Timer Concatenation Enable
     */
    inline bool get_CMC_TCE() volatile
    {
        return CMC & (1u << 20u);
    }

    /**
     * Set CMC's TCE bit.
     *
     * Timer Concatenation Enable
     */
    inline void set_CMC_TCE() volatile
    {
        CMC |= 1u << 20u;
    }

    /**
     * Clear CMC's TCE bit.
     *
     * Timer Concatenation Enable
     */
    inline void clear_CMC_TCE() volatile
    {
        CMC &= ~(1u << 20u);
    }

    /**
     * Toggle CMC's TCE bit.
     *
     * Timer Concatenation Enable
     */
    inline void toggle_CMC_TCE() volatile
    {
        CMC ^= 1u << 20u;
    }

    /**
     * Get CMC's MOS field.
     *
     * External Modulation Functionality Selector
     */
    inline uint8_t get_CMC_MOS() volatile
    {
        return (CMC >> 18u) & 0b11u;
    }

    /**
     * Set CMC's MOS field.
     *
     * External Modulation Functionality Selector
     */
    inline void set_CMC_MOS(uint8_t value) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b11u << 18u);
        curr |= (value & 0b11u) << 18u;

        CMC = curr;
    }

    /**
     * Get CMC's TS bit.
     *
     * Trap Function Selector
     */
    inline bool get_CMC_TS() volatile
    {
        return CMC & (1u << 17u);
    }

    /**
     * Set CMC's TS bit.
     *
     * Trap Function Selector
     */
    inline void set_CMC_TS() volatile
    {
        CMC |= 1u << 17u;
    }

    /**
     * Clear CMC's TS bit.
     *
     * Trap Function Selector
     */
    inline void clear_CMC_TS() volatile
    {
        CMC &= ~(1u << 17u);
    }

    /**
     * Toggle CMC's TS bit.
     *
     * Trap Function Selector
     */
    inline void toggle_CMC_TS() volatile
    {
        CMC ^= 1u << 17u;
    }

    /**
     * Get CMC's OFS bit.
     *
     * Override Function Selector
     */
    inline bool get_CMC_OFS() volatile
    {
        return CMC & (1u << 16u);
    }

    /**
     * Set CMC's OFS bit.
     *
     * Override Function Selector
     */
    inline void set_CMC_OFS() volatile
    {
        CMC |= 1u << 16u;
    }

    /**
     * Clear CMC's OFS bit.
     *
     * Override Function Selector
     */
    inline void clear_CMC_OFS() volatile
    {
        CMC &= ~(1u << 16u);
    }

    /**
     * Toggle CMC's OFS bit.
     *
     * Override Function Selector
     */
    inline void toggle_CMC_OFS() volatile
    {
        CMC ^= 1u << 16u;
    }

    /**
     * Get CMC's CNTS field.
     *
     * External Count Selector
     */
    inline CCU80_CC80_CMC_CNTS get_CMC_CNTS() volatile
    {
        return CCU80_CC80_CMC_CNTS((CMC >> 14u) & 0b11u);
    }

    /**
     * Set CMC's CNTS field.
     *
     * External Count Selector
     */
    inline void set_CMC_CNTS(CCU80_CC80_CMC_CNTS value) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(value) & 0b11u) << 14u;

        CMC = curr;
    }

    /**
     * Get CMC's LDS field.
     *
     * External Timer Load Functionality Selector
     */
    inline uint8_t get_CMC_LDS() volatile
    {
        return (CMC >> 12u) & 0b11u;
    }

    /**
     * Set CMC's LDS field.
     *
     * External Timer Load Functionality Selector
     */
    inline void set_CMC_LDS(uint8_t value) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b11u << 12u);
        curr |= (value & 0b11u) << 12u;

        CMC = curr;
    }

    /**
     * Get CMC's UDS field.
     *
     * External Up/Down Functionality Selector
     */
    inline CCU80_CC80_CMC_CNTS get_CMC_UDS() volatile
    {
        return CCU80_CC80_CMC_CNTS((CMC >> 10u) & 0b11u);
    }

    /**
     * Set CMC's UDS field.
     *
     * External Up/Down Functionality Selector
     */
    inline void set_CMC_UDS(CCU80_CC80_CMC_CNTS value) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(value) & 0b11u) << 10u;

        CMC = curr;
    }

    /**
     * Get CMC's GATES field.
     *
     * External Gate Functionality Selector
     */
    inline CCU80_CC80_CMC_CNTS get_CMC_GATES() volatile
    {
        return CCU80_CC80_CMC_CNTS((CMC >> 8u) & 0b11u);
    }

    /**
     * Set CMC's GATES field.
     *
     * External Gate Functionality Selector
     */
    inline void set_CMC_GATES(CCU80_CC80_CMC_CNTS value) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        CMC = curr;
    }

    /**
     * Get CMC's CAP1S field.
     *
     * External Capture 1 Functionality Selector
     */
    inline CCU80_CC80_CMC_CNTS get_CMC_CAP1S() volatile
    {
        return CCU80_CC80_CMC_CNTS((CMC >> 6u) & 0b11u);
    }

    /**
     * Set CMC's CAP1S field.
     *
     * External Capture 1 Functionality Selector
     */
    inline void set_CMC_CAP1S(CCU80_CC80_CMC_CNTS value) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(value) & 0b11u) << 6u;

        CMC = curr;
    }

    /**
     * Get CMC's CAP0S field.
     *
     * External Capture 0 Functionality Selector
     */
    inline CCU80_CC80_CMC_CNTS get_CMC_CAP0S() volatile
    {
        return CCU80_CC80_CMC_CNTS((CMC >> 4u) & 0b11u);
    }

    /**
     * Set CMC's CAP0S field.
     *
     * External Capture 0 Functionality Selector
     */
    inline void set_CMC_CAP0S(CCU80_CC80_CMC_CNTS value) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        CMC = curr;
    }

    /**
     * Get CMC's ENDS field.
     *
     * External Stop Functionality Selector
     */
    inline CCU80_CC80_CMC_CNTS get_CMC_ENDS() volatile
    {
        return CCU80_CC80_CMC_CNTS((CMC >> 2u) & 0b11u);
    }

    /**
     * Set CMC's ENDS field.
     *
     * External Stop Functionality Selector
     */
    inline void set_CMC_ENDS(CCU80_CC80_CMC_CNTS value) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        CMC = curr;
    }

    /**
     * Get CMC's STRTS field.
     *
     * External Start Functionality Selector
     */
    inline CCU80_CC80_CMC_CNTS get_CMC_STRTS() volatile
    {
        return CCU80_CC80_CMC_CNTS((CMC >> 0u) & 0b11u);
    }

    /**
     * Set CMC's STRTS field.
     *
     * External Start Functionality Selector
     */
    inline void set_CMC_STRTS(CCU80_CC80_CMC_CNTS value) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CMC = curr;
    }

    /**
     * Get all of CMC's bit fields.
     *
     * (read-write) Connection Matrix Control
     */
    inline void get_CMC(bool &TCE, uint8_t &MOS, bool &TS, bool &OFS,
                        CCU80_CC80_CMC_CNTS &CNTS, uint8_t &LDS,
                        CCU80_CC80_CMC_CNTS &UDS, CCU80_CC80_CMC_CNTS &GATES,
                        CCU80_CC80_CMC_CNTS &CAP1S, CCU80_CC80_CMC_CNTS &CAP0S,
                        CCU80_CC80_CMC_CNTS &ENDS,
                        CCU80_CC80_CMC_CNTS &STRTS) volatile
    {
        uint32_t curr = CMC;

        TCE = curr & (1u << 20u);
        MOS = (curr >> 18u) & 0b11u;
        TS = curr & (1u << 17u);
        OFS = curr & (1u << 16u);
        CNTS = CCU80_CC80_CMC_CNTS((curr >> 14u) & 0b11u);
        LDS = (curr >> 12u) & 0b11u;
        UDS = CCU80_CC80_CMC_CNTS((curr >> 10u) & 0b11u);
        GATES = CCU80_CC80_CMC_CNTS((curr >> 8u) & 0b11u);
        CAP1S = CCU80_CC80_CMC_CNTS((curr >> 6u) & 0b11u);
        CAP0S = CCU80_CC80_CMC_CNTS((curr >> 4u) & 0b11u);
        ENDS = CCU80_CC80_CMC_CNTS((curr >> 2u) & 0b11u);
        STRTS = CCU80_CC80_CMC_CNTS((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of CMC's bit fields.
     *
     * (read-write) Connection Matrix Control
     */
    inline void set_CMC(bool TCE, uint8_t MOS, bool TS, bool OFS,
                        CCU80_CC80_CMC_CNTS CNTS, uint8_t LDS,
                        CCU80_CC80_CMC_CNTS UDS, CCU80_CC80_CMC_CNTS GATES,
                        CCU80_CC80_CMC_CNTS CAP1S, CCU80_CC80_CMC_CNTS CAP0S,
                        CCU80_CC80_CMC_CNTS ENDS,
                        CCU80_CC80_CMC_CNTS STRTS) volatile
    {
        uint32_t curr = CMC;

        curr &= ~(0b1u << 20u);
        curr |= (TCE & 0b1u) << 20u;
        curr &= ~(0b11u << 18u);
        curr |= (MOS & 0b11u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (TS & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (OFS & 0b1u) << 16u;
        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(CNTS) & 0b11u) << 14u;
        curr &= ~(0b11u << 12u);
        curr |= (LDS & 0b11u) << 12u;
        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(UDS) & 0b11u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(GATES) & 0b11u) << 8u;
        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(CAP1S) & 0b11u) << 6u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(CAP0S) & 0b11u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(ENDS) & 0b11u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(STRTS) & 0b11u) << 0u;

        CMC = curr;
    }

    /**
     * Get TCST's DTR2 bit.
     *
     * Dead Time Counter 2 Run bit
     */
    inline bool get_TCST_DTR2() volatile
    {
        return TCST & (1u << 4u);
    }

    /**
     * Get TCST's DTR1 bit.
     *
     * Dead Time Counter 1 Run bit
     */
    inline bool get_TCST_DTR1() volatile
    {
        return TCST & (1u << 3u);
    }

    /**
     * Get TCST's CDIR bit.
     *
     * Timer Counting Direction
     */
    inline bool get_TCST_CDIR() volatile
    {
        return TCST & (1u << 1u);
    }

    /**
     * Get TCST's TRB bit.
     *
     * Timer Run Bit
     */
    inline bool get_TCST_TRB() volatile
    {
        return TCST & (1u << 0u);
    }

    /**
     * Get all of TCST's bit fields.
     *
     * (read-only) Slice Timer Status
     */
    inline void get_TCST(bool &DTR2, bool &DTR1, bool &CDIR,
                         bool &TRB) volatile
    {
        uint32_t curr = TCST;

        DTR2 = curr & (1u << 4u);
        DTR1 = curr & (1u << 3u);
        CDIR = curr & (1u << 1u);
        TRB = curr & (1u << 0u);
    }

    /**
     * Set TCSET's TRBS bit.
     *
     * Timer Run Bit set
     */
    inline void set_TCSET_TRBS() volatile
    {
        TCSET |= 1u << 0u;
    }

    /**
     * Clear TCSET's TRBS bit.
     *
     * Timer Run Bit set
     */
    inline void clear_TCSET_TRBS() volatile
    {
        TCSET &= ~(1u << 0u);
    }

    /**
     * Toggle TCSET's TRBS bit.
     *
     * Timer Run Bit set
     */
    inline void toggle_TCSET_TRBS() volatile
    {
        TCSET ^= 1u << 0u;
    }

    /**
     * Set TCCLR's DTC2C bit.
     *
     * Dead Time Counter 2 Clear
     */
    inline void set_TCCLR_DTC2C() volatile
    {
        TCCLR |= 1u << 4u;
    }

    /**
     * Clear TCCLR's DTC2C bit.
     *
     * Dead Time Counter 2 Clear
     */
    inline void clear_TCCLR_DTC2C() volatile
    {
        TCCLR &= ~(1u << 4u);
    }

    /**
     * Toggle TCCLR's DTC2C bit.
     *
     * Dead Time Counter 2 Clear
     */
    inline void toggle_TCCLR_DTC2C() volatile
    {
        TCCLR ^= 1u << 4u;
    }

    /**
     * Set TCCLR's DTC1C bit.
     *
     * Dead Time Counter 1 Clear
     */
    inline void set_TCCLR_DTC1C() volatile
    {
        TCCLR |= 1u << 3u;
    }

    /**
     * Clear TCCLR's DTC1C bit.
     *
     * Dead Time Counter 1 Clear
     */
    inline void clear_TCCLR_DTC1C() volatile
    {
        TCCLR &= ~(1u << 3u);
    }

    /**
     * Toggle TCCLR's DTC1C bit.
     *
     * Dead Time Counter 1 Clear
     */
    inline void toggle_TCCLR_DTC1C() volatile
    {
        TCCLR ^= 1u << 3u;
    }

    /**
     * Set TCCLR's DITC bit.
     *
     * Dither Counter Clear
     */
    inline void set_TCCLR_DITC() volatile
    {
        TCCLR |= 1u << 2u;
    }

    /**
     * Clear TCCLR's DITC bit.
     *
     * Dither Counter Clear
     */
    inline void clear_TCCLR_DITC() volatile
    {
        TCCLR &= ~(1u << 2u);
    }

    /**
     * Toggle TCCLR's DITC bit.
     *
     * Dither Counter Clear
     */
    inline void toggle_TCCLR_DITC() volatile
    {
        TCCLR ^= 1u << 2u;
    }

    /**
     * Set TCCLR's TCC bit.
     *
     * Timer Clear
     */
    inline void set_TCCLR_TCC() volatile
    {
        TCCLR |= 1u << 1u;
    }

    /**
     * Clear TCCLR's TCC bit.
     *
     * Timer Clear
     */
    inline void clear_TCCLR_TCC() volatile
    {
        TCCLR &= ~(1u << 1u);
    }

    /**
     * Toggle TCCLR's TCC bit.
     *
     * Timer Clear
     */
    inline void toggle_TCCLR_TCC() volatile
    {
        TCCLR ^= 1u << 1u;
    }

    /**
     * Set TCCLR's TRBC bit.
     *
     * Timer Run Bit Clear
     */
    inline void set_TCCLR_TRBC() volatile
    {
        TCCLR |= 1u << 0u;
    }

    /**
     * Clear TCCLR's TRBC bit.
     *
     * Timer Run Bit Clear
     */
    inline void clear_TCCLR_TRBC() volatile
    {
        TCCLR &= ~(1u << 0u);
    }

    /**
     * Toggle TCCLR's TRBC bit.
     *
     * Timer Run Bit Clear
     */
    inline void toggle_TCCLR_TRBC() volatile
    {
        TCCLR ^= 1u << 0u;
    }

    /**
     * Set all of TCCLR's bit fields.
     *
     * (write-only) Slice Timer Clear
     */
    inline void set_TCCLR(bool DTC2C, bool DTC1C, bool DITC, bool TCC,
                          bool TRBC) volatile
    {
        uint32_t curr = TCCLR;

        curr &= ~(0b1u << 4u);
        curr |= (DTC2C & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (DTC1C & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (DITC & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TCC & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TRBC & 0b1u) << 0u;

        TCCLR = curr;
    }

    /**
     * Get TC's STOS field.
     *
     * Status bit output selector
     */
    inline CCU80_CC80_TC_STOS get_TC_STOS() volatile
    {
        return CCU80_CC80_TC_STOS((TC >> 29u) & 0b11u);
    }

    /**
     * Set TC's STOS field.
     *
     * Status bit output selector
     */
    inline void set_TC_STOS(CCU80_CC80_TC_STOS value) volatile
    {
        uint32_t curr = TC;

        curr &= ~(0b11u << 29u);
        curr |= (std::to_underlying(value) & 0b11u) << 29u;

        TC = curr;
    }

    /**
     * Get TC's EME field.
     *
     * External Modulation Channel enable
     */
    inline CCU80_CC80_TC_EME get_TC_EME() volatile
    {
        return CCU80_CC80_TC_EME((TC >> 27u) & 0b11u);
    }

    /**
     * Set TC's EME field.
     *
     * External Modulation Channel enable
     */
    inline void set_TC_EME(CCU80_CC80_TC_EME value) volatile
    {
        uint32_t curr = TC;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        TC = curr;
    }

    /**
     * Get TC's MCME2 bit.
     *
     * Multi Channel Mode Enable for Channel 2
     */
    inline bool get_TC_MCME2() volatile
    {
        return TC & (1u << 26u);
    }

    /**
     * Set TC's MCME2 bit.
     *
     * Multi Channel Mode Enable for Channel 2
     */
    inline void set_TC_MCME2() volatile
    {
        TC |= 1u << 26u;
    }

    /**
     * Clear TC's MCME2 bit.
     *
     * Multi Channel Mode Enable for Channel 2
     */
    inline void clear_TC_MCME2() volatile
    {
        TC &= ~(1u << 26u);
    }

    /**
     * Toggle TC's MCME2 bit.
     *
     * Multi Channel Mode Enable for Channel 2
     */
    inline void toggle_TC_MCME2() volatile
    {
        TC ^= 1u << 26u;
    }

    /**
     * Get TC's MCME1 bit.
     *
     * Multi Channel Mode Enable for Channel 1
     */
    inline bool get_TC_MCME1() volatile
    {
        return TC & (1u << 25u);
    }

    /**
     * Set TC's MCME1 bit.
     *
     * Multi Channel Mode Enable for Channel 1
     */
    inline void set_TC_MCME1() volatile
    {
        TC |= 1u << 25u;
    }

    /**
     * Clear TC's MCME1 bit.
     *
     * Multi Channel Mode Enable for Channel 1
     */
    inline void clear_TC_MCME1() volatile
    {
        TC &= ~(1u << 25u);
    }

    /**
     * Toggle TC's MCME1 bit.
     *
     * Multi Channel Mode Enable for Channel 1
     */
    inline void toggle_TC_MCME1() volatile
    {
        TC ^= 1u << 25u;
    }

    /**
     * Get TC's EMT bit.
     *
     * External Modulation Type
     */
    inline bool get_TC_EMT() volatile
    {
        return TC & (1u << 24u);
    }

    /**
     * Set TC's EMT bit.
     *
     * External Modulation Type
     */
    inline void set_TC_EMT() volatile
    {
        TC |= 1u << 24u;
    }

    /**
     * Clear TC's EMT bit.
     *
     * External Modulation Type
     */
    inline void clear_TC_EMT() volatile
    {
        TC &= ~(1u << 24u);
    }

    /**
     * Toggle TC's EMT bit.
     *
     * External Modulation Type
     */
    inline void toggle_TC_EMT() volatile
    {
        TC ^= 1u << 24u;
    }

    /**
     * Get TC's EMS bit.
     *
     * External Modulation Synchronization
     */
    inline bool get_TC_EMS() volatile
    {
        return TC & (1u << 23u);
    }

    /**
     * Set TC's EMS bit.
     *
     * External Modulation Synchronization
     */
    inline void set_TC_EMS() volatile
    {
        TC |= 1u << 23u;
    }

    /**
     * Clear TC's EMS bit.
     *
     * External Modulation Synchronization
     */
    inline void clear_TC_EMS() volatile
    {
        TC &= ~(1u << 23u);
    }

    /**
     * Toggle TC's EMS bit.
     *
     * External Modulation Synchronization
     */
    inline void toggle_TC_EMS() volatile
    {
        TC ^= 1u << 23u;
    }

    /**
     * Get TC's TRPSW bit.
     *
     * TRAP State Clear Control
     */
    inline bool get_TC_TRPSW() volatile
    {
        return TC & (1u << 22u);
    }

    /**
     * Set TC's TRPSW bit.
     *
     * TRAP State Clear Control
     */
    inline void set_TC_TRPSW() volatile
    {
        TC |= 1u << 22u;
    }

    /**
     * Clear TC's TRPSW bit.
     *
     * TRAP State Clear Control
     */
    inline void clear_TC_TRPSW() volatile
    {
        TC &= ~(1u << 22u);
    }

    /**
     * Toggle TC's TRPSW bit.
     *
     * TRAP State Clear Control
     */
    inline void toggle_TC_TRPSW() volatile
    {
        TC ^= 1u << 22u;
    }

    /**
     * Get TC's TRPSE bit.
     *
     * TRAP Synchronization Enable
     */
    inline bool get_TC_TRPSE() volatile
    {
        return TC & (1u << 21u);
    }

    /**
     * Set TC's TRPSE bit.
     *
     * TRAP Synchronization Enable
     */
    inline void set_TC_TRPSE() volatile
    {
        TC |= 1u << 21u;
    }

    /**
     * Clear TC's TRPSE bit.
     *
     * TRAP Synchronization Enable
     */
    inline void clear_TC_TRPSE() volatile
    {
        TC &= ~(1u << 21u);
    }

    /**
     * Toggle TC's TRPSE bit.
     *
     * TRAP Synchronization Enable
     */
    inline void toggle_TC_TRPSE() volatile
    {
        TC ^= 1u << 21u;
    }

    /**
     * Get TC's TRAPE3 bit.
     *
     * TRAP enable for CCU8x.OUTy3
     */
    inline bool get_TC_TRAPE3() volatile
    {
        return TC & (1u << 20u);
    }

    /**
     * Set TC's TRAPE3 bit.
     *
     * TRAP enable for CCU8x.OUTy3
     */
    inline void set_TC_TRAPE3() volatile
    {
        TC |= 1u << 20u;
    }

    /**
     * Clear TC's TRAPE3 bit.
     *
     * TRAP enable for CCU8x.OUTy3
     */
    inline void clear_TC_TRAPE3() volatile
    {
        TC &= ~(1u << 20u);
    }

    /**
     * Toggle TC's TRAPE3 bit.
     *
     * TRAP enable for CCU8x.OUTy3
     */
    inline void toggle_TC_TRAPE3() volatile
    {
        TC ^= 1u << 20u;
    }

    /**
     * Get TC's TRAPE2 bit.
     *
     * TRAP enable for CCU8x.OUTy2
     */
    inline bool get_TC_TRAPE2() volatile
    {
        return TC & (1u << 19u);
    }

    /**
     * Set TC's TRAPE2 bit.
     *
     * TRAP enable for CCU8x.OUTy2
     */
    inline void set_TC_TRAPE2() volatile
    {
        TC |= 1u << 19u;
    }

    /**
     * Clear TC's TRAPE2 bit.
     *
     * TRAP enable for CCU8x.OUTy2
     */
    inline void clear_TC_TRAPE2() volatile
    {
        TC &= ~(1u << 19u);
    }

    /**
     * Toggle TC's TRAPE2 bit.
     *
     * TRAP enable for CCU8x.OUTy2
     */
    inline void toggle_TC_TRAPE2() volatile
    {
        TC ^= 1u << 19u;
    }

    /**
     * Get TC's TRAPE1 bit.
     *
     * TRAP enable for CCU8x.OUTy1
     */
    inline bool get_TC_TRAPE1() volatile
    {
        return TC & (1u << 18u);
    }

    /**
     * Set TC's TRAPE1 bit.
     *
     * TRAP enable for CCU8x.OUTy1
     */
    inline void set_TC_TRAPE1() volatile
    {
        TC |= 1u << 18u;
    }

    /**
     * Clear TC's TRAPE1 bit.
     *
     * TRAP enable for CCU8x.OUTy1
     */
    inline void clear_TC_TRAPE1() volatile
    {
        TC &= ~(1u << 18u);
    }

    /**
     * Toggle TC's TRAPE1 bit.
     *
     * TRAP enable for CCU8x.OUTy1
     */
    inline void toggle_TC_TRAPE1() volatile
    {
        TC ^= 1u << 18u;
    }

    /**
     * Get TC's TRAPE0 bit.
     *
     * TRAP enable for CCU8x.OUTy0
     */
    inline bool get_TC_TRAPE0() volatile
    {
        return TC & (1u << 17u);
    }

    /**
     * Set TC's TRAPE0 bit.
     *
     * TRAP enable for CCU8x.OUTy0
     */
    inline void set_TC_TRAPE0() volatile
    {
        TC |= 1u << 17u;
    }

    /**
     * Clear TC's TRAPE0 bit.
     *
     * TRAP enable for CCU8x.OUTy0
     */
    inline void clear_TC_TRAPE0() volatile
    {
        TC &= ~(1u << 17u);
    }

    /**
     * Toggle TC's TRAPE0 bit.
     *
     * TRAP enable for CCU8x.OUTy0
     */
    inline void toggle_TC_TRAPE0() volatile
    {
        TC ^= 1u << 17u;
    }

    /**
     * Get TC's FPE bit.
     *
     * Floating Prescaler enable
     */
    inline bool get_TC_FPE() volatile
    {
        return TC & (1u << 16u);
    }

    /**
     * Set TC's FPE bit.
     *
     * Floating Prescaler enable
     */
    inline void set_TC_FPE() volatile
    {
        TC |= 1u << 16u;
    }

    /**
     * Clear TC's FPE bit.
     *
     * Floating Prescaler enable
     */
    inline void clear_TC_FPE() volatile
    {
        TC &= ~(1u << 16u);
    }

    /**
     * Toggle TC's FPE bit.
     *
     * Floating Prescaler enable
     */
    inline void toggle_TC_FPE() volatile
    {
        TC ^= 1u << 16u;
    }

    /**
     * Get TC's DIM bit.
     *
     * Dither input selector
     */
    inline bool get_TC_DIM() volatile
    {
        return TC & (1u << 15u);
    }

    /**
     * Set TC's DIM bit.
     *
     * Dither input selector
     */
    inline void set_TC_DIM() volatile
    {
        TC |= 1u << 15u;
    }

    /**
     * Clear TC's DIM bit.
     *
     * Dither input selector
     */
    inline void clear_TC_DIM() volatile
    {
        TC &= ~(1u << 15u);
    }

    /**
     * Toggle TC's DIM bit.
     *
     * Dither input selector
     */
    inline void toggle_TC_DIM() volatile
    {
        TC ^= 1u << 15u;
    }

    /**
     * Get TC's DITHE field.
     *
     * Dither Enable
     */
    inline CCU80_CC80_TC_DITHE get_TC_DITHE() volatile
    {
        return CCU80_CC80_TC_DITHE((TC >> 13u) & 0b11u);
    }

    /**
     * Set TC's DITHE field.
     *
     * Dither Enable
     */
    inline void set_TC_DITHE(CCU80_CC80_TC_DITHE value) volatile
    {
        uint32_t curr = TC;

        curr &= ~(0b11u << 13u);
        curr |= (std::to_underlying(value) & 0b11u) << 13u;

        TC = curr;
    }

    /**
     * Get TC's CCS bit.
     *
     * Continuous Capture Enable
     */
    inline bool get_TC_CCS() volatile
    {
        return TC & (1u << 12u);
    }

    /**
     * Set TC's CCS bit.
     *
     * Continuous Capture Enable
     */
    inline void set_TC_CCS() volatile
    {
        TC |= 1u << 12u;
    }

    /**
     * Clear TC's CCS bit.
     *
     * Continuous Capture Enable
     */
    inline void clear_TC_CCS() volatile
    {
        TC &= ~(1u << 12u);
    }

    /**
     * Toggle TC's CCS bit.
     *
     * Continuous Capture Enable
     */
    inline void toggle_TC_CCS() volatile
    {
        TC ^= 1u << 12u;
    }

    /**
     * Get TC's SCE bit.
     *
     * Equal Capture Event enable
     */
    inline bool get_TC_SCE() volatile
    {
        return TC & (1u << 11u);
    }

    /**
     * Set TC's SCE bit.
     *
     * Equal Capture Event enable
     */
    inline void set_TC_SCE() volatile
    {
        TC |= 1u << 11u;
    }

    /**
     * Clear TC's SCE bit.
     *
     * Equal Capture Event enable
     */
    inline void clear_TC_SCE() volatile
    {
        TC &= ~(1u << 11u);
    }

    /**
     * Toggle TC's SCE bit.
     *
     * Equal Capture Event enable
     */
    inline void toggle_TC_SCE() volatile
    {
        TC ^= 1u << 11u;
    }

    /**
     * Get TC's STRM bit.
     *
     * Extended Start Function Control
     */
    inline bool get_TC_STRM() volatile
    {
        return TC & (1u << 10u);
    }

    /**
     * Set TC's STRM bit.
     *
     * Extended Start Function Control
     */
    inline void set_TC_STRM() volatile
    {
        TC |= 1u << 10u;
    }

    /**
     * Clear TC's STRM bit.
     *
     * Extended Start Function Control
     */
    inline void clear_TC_STRM() volatile
    {
        TC &= ~(1u << 10u);
    }

    /**
     * Toggle TC's STRM bit.
     *
     * Extended Start Function Control
     */
    inline void toggle_TC_STRM() volatile
    {
        TC ^= 1u << 10u;
    }

    /**
     * Get TC's ENDM field.
     *
     * Extended Stop Function Control
     */
    inline CCU80_CC80_TC_ENDM get_TC_ENDM() volatile
    {
        return CCU80_CC80_TC_ENDM((TC >> 8u) & 0b11u);
    }

    /**
     * Set TC's ENDM field.
     *
     * Extended Stop Function Control
     */
    inline void set_TC_ENDM(CCU80_CC80_TC_ENDM value) volatile
    {
        uint32_t curr = TC;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        TC = curr;
    }

    /**
     * Get TC's TLS bit.
     *
     * Timer Load selector
     */
    inline bool get_TC_TLS() volatile
    {
        return TC & (1u << 7u);
    }

    /**
     * Set TC's TLS bit.
     *
     * Timer Load selector
     */
    inline void set_TC_TLS() volatile
    {
        TC |= 1u << 7u;
    }

    /**
     * Clear TC's TLS bit.
     *
     * Timer Load selector
     */
    inline void clear_TC_TLS() volatile
    {
        TC &= ~(1u << 7u);
    }

    /**
     * Toggle TC's TLS bit.
     *
     * Timer Load selector
     */
    inline void toggle_TC_TLS() volatile
    {
        TC ^= 1u << 7u;
    }

    /**
     * Get TC's CAPC field.
     *
     * Clear on Capture Control
     */
    inline CCU80_CC80_TC_CAPC get_TC_CAPC() volatile
    {
        return CCU80_CC80_TC_CAPC((TC >> 5u) & 0b11u);
    }

    /**
     * Set TC's CAPC field.
     *
     * Clear on Capture Control
     */
    inline void set_TC_CAPC(CCU80_CC80_TC_CAPC value) volatile
    {
        uint32_t curr = TC;

        curr &= ~(0b11u << 5u);
        curr |= (std::to_underlying(value) & 0b11u) << 5u;

        TC = curr;
    }

    /**
     * Get TC's ECM bit.
     *
     * Extended Capture Mode
     */
    inline bool get_TC_ECM() volatile
    {
        return TC & (1u << 4u);
    }

    /**
     * Set TC's ECM bit.
     *
     * Extended Capture Mode
     */
    inline void set_TC_ECM() volatile
    {
        TC |= 1u << 4u;
    }

    /**
     * Clear TC's ECM bit.
     *
     * Extended Capture Mode
     */
    inline void clear_TC_ECM() volatile
    {
        TC &= ~(1u << 4u);
    }

    /**
     * Toggle TC's ECM bit.
     *
     * Extended Capture Mode
     */
    inline void toggle_TC_ECM() volatile
    {
        TC ^= 1u << 4u;
    }

    /**
     * Get TC's CMOD bit.
     *
     * Capture Compare Mode
     */
    inline bool get_TC_CMOD() volatile
    {
        return TC & (1u << 3u);
    }

    /**
     * Get TC's CLST bit.
     *
     * Shadow Transfer on Clear
     */
    inline bool get_TC_CLST() volatile
    {
        return TC & (1u << 2u);
    }

    /**
     * Set TC's CLST bit.
     *
     * Shadow Transfer on Clear
     */
    inline void set_TC_CLST() volatile
    {
        TC |= 1u << 2u;
    }

    /**
     * Clear TC's CLST bit.
     *
     * Shadow Transfer on Clear
     */
    inline void clear_TC_CLST() volatile
    {
        TC &= ~(1u << 2u);
    }

    /**
     * Toggle TC's CLST bit.
     *
     * Shadow Transfer on Clear
     */
    inline void toggle_TC_CLST() volatile
    {
        TC ^= 1u << 2u;
    }

    /**
     * Get TC's TSSM bit.
     *
     * Timer Single Shot Mode
     */
    inline bool get_TC_TSSM() volatile
    {
        return TC & (1u << 1u);
    }

    /**
     * Set TC's TSSM bit.
     *
     * Timer Single Shot Mode
     */
    inline void set_TC_TSSM() volatile
    {
        TC |= 1u << 1u;
    }

    /**
     * Clear TC's TSSM bit.
     *
     * Timer Single Shot Mode
     */
    inline void clear_TC_TSSM() volatile
    {
        TC &= ~(1u << 1u);
    }

    /**
     * Toggle TC's TSSM bit.
     *
     * Timer Single Shot Mode
     */
    inline void toggle_TC_TSSM() volatile
    {
        TC ^= 1u << 1u;
    }

    /**
     * Get TC's TCM bit.
     *
     * Timer Counting Mode
     */
    inline bool get_TC_TCM() volatile
    {
        return TC & (1u << 0u);
    }

    /**
     * Set TC's TCM bit.
     *
     * Timer Counting Mode
     */
    inline void set_TC_TCM() volatile
    {
        TC |= 1u << 0u;
    }

    /**
     * Clear TC's TCM bit.
     *
     * Timer Counting Mode
     */
    inline void clear_TC_TCM() volatile
    {
        TC &= ~(1u << 0u);
    }

    /**
     * Toggle TC's TCM bit.
     *
     * Timer Counting Mode
     */
    inline void toggle_TC_TCM() volatile
    {
        TC ^= 1u << 0u;
    }

    /**
     * Get all of TC's bit fields.
     *
     * (read-write) Slice Timer Control
     */
    inline void get_TC(CCU80_CC80_TC_STOS &STOS, CCU80_CC80_TC_EME &EME,
                       bool &MCME2, bool &MCME1, bool &EMT, bool &EMS,
                       bool &TRPSW, bool &TRPSE, bool &TRAPE3, bool &TRAPE2,
                       bool &TRAPE1, bool &TRAPE0, bool &FPE, bool &DIM,
                       CCU80_CC80_TC_DITHE &DITHE, bool &CCS, bool &SCE,
                       bool &STRM, CCU80_CC80_TC_ENDM &ENDM, bool &TLS,
                       CCU80_CC80_TC_CAPC &CAPC, bool &ECM, bool &CMOD,
                       bool &CLST, bool &TSSM, bool &TCM) volatile
    {
        uint32_t curr = TC;

        STOS = CCU80_CC80_TC_STOS((curr >> 29u) & 0b11u);
        EME = CCU80_CC80_TC_EME((curr >> 27u) & 0b11u);
        MCME2 = curr & (1u << 26u);
        MCME1 = curr & (1u << 25u);
        EMT = curr & (1u << 24u);
        EMS = curr & (1u << 23u);
        TRPSW = curr & (1u << 22u);
        TRPSE = curr & (1u << 21u);
        TRAPE3 = curr & (1u << 20u);
        TRAPE2 = curr & (1u << 19u);
        TRAPE1 = curr & (1u << 18u);
        TRAPE0 = curr & (1u << 17u);
        FPE = curr & (1u << 16u);
        DIM = curr & (1u << 15u);
        DITHE = CCU80_CC80_TC_DITHE((curr >> 13u) & 0b11u);
        CCS = curr & (1u << 12u);
        SCE = curr & (1u << 11u);
        STRM = curr & (1u << 10u);
        ENDM = CCU80_CC80_TC_ENDM((curr >> 8u) & 0b11u);
        TLS = curr & (1u << 7u);
        CAPC = CCU80_CC80_TC_CAPC((curr >> 5u) & 0b11u);
        ECM = curr & (1u << 4u);
        CMOD = curr & (1u << 3u);
        CLST = curr & (1u << 2u);
        TSSM = curr & (1u << 1u);
        TCM = curr & (1u << 0u);
    }

    /**
     * Set all of TC's bit fields.
     *
     * (read-write) Slice Timer Control
     */
    inline void set_TC(CCU80_CC80_TC_STOS STOS, CCU80_CC80_TC_EME EME,
                       bool MCME2, bool MCME1, bool EMT, bool EMS, bool TRPSW,
                       bool TRPSE, bool TRAPE3, bool TRAPE2, bool TRAPE1,
                       bool TRAPE0, bool FPE, bool DIM,
                       CCU80_CC80_TC_DITHE DITHE, bool CCS, bool SCE,
                       bool STRM, CCU80_CC80_TC_ENDM ENDM, bool TLS,
                       CCU80_CC80_TC_CAPC CAPC, bool ECM, bool CLST, bool TSSM,
                       bool TCM) volatile
    {
        uint32_t curr = TC;

        curr &= ~(0b11u << 29u);
        curr |= (std::to_underlying(STOS) & 0b11u) << 29u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(EME) & 0b11u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (MCME2 & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (MCME1 & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (EMT & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (EMS & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (TRPSW & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (TRPSE & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (TRAPE3 & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (TRAPE2 & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (TRAPE1 & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (TRAPE0 & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (FPE & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (DIM & 0b1u) << 15u;
        curr &= ~(0b11u << 13u);
        curr |= (std::to_underlying(DITHE) & 0b11u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (CCS & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (SCE & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (STRM & 0b1u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(ENDM) & 0b11u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (TLS & 0b1u) << 7u;
        curr &= ~(0b11u << 5u);
        curr |= (std::to_underlying(CAPC) & 0b11u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (ECM & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (CLST & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TSSM & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TCM & 0b1u) << 0u;

        TC = curr;
    }

    /**
     * Get PSL's PSL22 bit.
     *
     * Output Passive Level for CCU8x.OUTy3
     */
    inline bool get_PSL_PSL22() volatile
    {
        return PSL & (1u << 3u);
    }

    /**
     * Set PSL's PSL22 bit.
     *
     * Output Passive Level for CCU8x.OUTy3
     */
    inline void set_PSL_PSL22() volatile
    {
        PSL |= 1u << 3u;
    }

    /**
     * Clear PSL's PSL22 bit.
     *
     * Output Passive Level for CCU8x.OUTy3
     */
    inline void clear_PSL_PSL22() volatile
    {
        PSL &= ~(1u << 3u);
    }

    /**
     * Toggle PSL's PSL22 bit.
     *
     * Output Passive Level for CCU8x.OUTy3
     */
    inline void toggle_PSL_PSL22() volatile
    {
        PSL ^= 1u << 3u;
    }

    /**
     * Get PSL's PSL21 bit.
     *
     * Output Passive Level for CCU8x.OUTy2
     */
    inline bool get_PSL_PSL21() volatile
    {
        return PSL & (1u << 2u);
    }

    /**
     * Set PSL's PSL21 bit.
     *
     * Output Passive Level for CCU8x.OUTy2
     */
    inline void set_PSL_PSL21() volatile
    {
        PSL |= 1u << 2u;
    }

    /**
     * Clear PSL's PSL21 bit.
     *
     * Output Passive Level for CCU8x.OUTy2
     */
    inline void clear_PSL_PSL21() volatile
    {
        PSL &= ~(1u << 2u);
    }

    /**
     * Toggle PSL's PSL21 bit.
     *
     * Output Passive Level for CCU8x.OUTy2
     */
    inline void toggle_PSL_PSL21() volatile
    {
        PSL ^= 1u << 2u;
    }

    /**
     * Get PSL's PSL12 bit.
     *
     * Output Passive Level for CCU8x.OUTy1
     */
    inline bool get_PSL_PSL12() volatile
    {
        return PSL & (1u << 1u);
    }

    /**
     * Set PSL's PSL12 bit.
     *
     * Output Passive Level for CCU8x.OUTy1
     */
    inline void set_PSL_PSL12() volatile
    {
        PSL |= 1u << 1u;
    }

    /**
     * Clear PSL's PSL12 bit.
     *
     * Output Passive Level for CCU8x.OUTy1
     */
    inline void clear_PSL_PSL12() volatile
    {
        PSL &= ~(1u << 1u);
    }

    /**
     * Toggle PSL's PSL12 bit.
     *
     * Output Passive Level for CCU8x.OUTy1
     */
    inline void toggle_PSL_PSL12() volatile
    {
        PSL ^= 1u << 1u;
    }

    /**
     * Get PSL's PSL11 bit.
     *
     * Output Passive Level for CCU8x.OUTy0
     */
    inline bool get_PSL_PSL11() volatile
    {
        return PSL & (1u << 0u);
    }

    /**
     * Set PSL's PSL11 bit.
     *
     * Output Passive Level for CCU8x.OUTy0
     */
    inline void set_PSL_PSL11() volatile
    {
        PSL |= 1u << 0u;
    }

    /**
     * Clear PSL's PSL11 bit.
     *
     * Output Passive Level for CCU8x.OUTy0
     */
    inline void clear_PSL_PSL11() volatile
    {
        PSL &= ~(1u << 0u);
    }

    /**
     * Toggle PSL's PSL11 bit.
     *
     * Output Passive Level for CCU8x.OUTy0
     */
    inline void toggle_PSL_PSL11() volatile
    {
        PSL ^= 1u << 0u;
    }

    /**
     * Get all of PSL's bit fields.
     *
     * (read-write) Passive Level Config
     */
    inline void get_PSL(bool &PSL22, bool &PSL21, bool &PSL12,
                        bool &PSL11) volatile
    {
        uint32_t curr = PSL;

        PSL22 = curr & (1u << 3u);
        PSL21 = curr & (1u << 2u);
        PSL12 = curr & (1u << 1u);
        PSL11 = curr & (1u << 0u);
    }

    /**
     * Set all of PSL's bit fields.
     *
     * (read-write) Passive Level Config
     */
    inline void set_PSL(bool PSL22, bool PSL21, bool PSL12,
                        bool PSL11) volatile
    {
        uint32_t curr = PSL;

        curr &= ~(0b1u << 3u);
        curr |= (PSL22 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PSL21 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PSL12 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PSL11 & 0b1u) << 0u;

        PSL = curr;
    }

    /**
     * Get DIT's DCNT field.
     *
     * Dither counter actual value
     */
    inline uint8_t get_DIT_DCNT() volatile
    {
        return (DIT >> 8u) & 0b1111u;
    }

    /**
     * Get DIT's DCV field.
     *
     * Dither compare Value
     */
    inline uint8_t get_DIT_DCV() volatile
    {
        return (DIT >> 0u) & 0b1111u;
    }

    /**
     * Get all of DIT's bit fields.
     *
     * (read-only) Dither Config
     */
    inline void get_DIT(uint8_t &DCNT, uint8_t &DCV) volatile
    {
        uint32_t curr = DIT;

        DCNT = (curr >> 8u) & 0b1111u;
        DCV = (curr >> 0u) & 0b1111u;
    }

    /**
     * Get DITS's DCVS field.
     *
     * Dither Shadow Compare Value
     */
    inline uint8_t get_DITS_DCVS() volatile
    {
        return (DITS >> 0u) & 0b1111u;
    }

    /**
     * Set DITS's DCVS field.
     *
     * Dither Shadow Compare Value
     */
    inline void set_DITS_DCVS(uint8_t value) volatile
    {
        uint32_t curr = DITS;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        DITS = curr;
    }

    /**
     * Get PSC's PSIV field.
     *
     * Prescaler Initial Value
     */
    inline uint8_t get_PSC_PSIV() volatile
    {
        return (PSC >> 0u) & 0b1111u;
    }

    /**
     * Set PSC's PSIV field.
     *
     * Prescaler Initial Value
     */
    inline void set_PSC_PSIV(uint8_t value) volatile
    {
        uint32_t curr = PSC;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        PSC = curr;
    }

    /**
     * Get FPC's PVAL field.
     *
     * Actual Prescaler Value
     */
    inline uint8_t get_FPC_PVAL() volatile
    {
        return (FPC >> 8u) & 0b1111u;
    }

    /**
     * Set FPC's PVAL field.
     *
     * Actual Prescaler Value
     */
    inline void set_FPC_PVAL(uint8_t value) volatile
    {
        uint32_t curr = FPC;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        FPC = curr;
    }

    /**
     * Get FPC's PCMP field.
     *
     * Floating Prescaler Compare Value
     */
    inline uint8_t get_FPC_PCMP() volatile
    {
        return (FPC >> 0u) & 0b1111u;
    }

    /**
     * Get all of FPC's bit fields.
     *
     * (read-write) Floating Prescaler Control
     */
    inline void get_FPC(uint8_t &PVAL, uint8_t &PCMP) volatile
    {
        uint32_t curr = FPC;

        PVAL = (curr >> 8u) & 0b1111u;
        PCMP = (curr >> 0u) & 0b1111u;
    }

    /**
     * Get FPCS's PCMP field.
     *
     * Floating Prescaler Shadow Compare Value
     */
    inline uint8_t get_FPCS_PCMP() volatile
    {
        return (FPCS >> 0u) & 0b1111u;
    }

    /**
     * Set FPCS's PCMP field.
     *
     * Floating Prescaler Shadow Compare Value
     */
    inline void set_FPCS_PCMP(uint8_t value) volatile
    {
        uint32_t curr = FPCS;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        FPCS = curr;
    }

    /**
     * Get PR's PR field.
     *
     * Period Register
     */
    inline uint16_t get_PR_PR() volatile
    {
        return (PR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get PRS's PRS field.
     *
     * Period Register
     */
    inline uint16_t get_PRS_PRS() volatile
    {
        return (PRS >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set PRS's PRS field.
     *
     * Period Register
     */
    inline void set_PRS_PRS(uint16_t value) volatile
    {
        uint32_t curr = PRS;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        PRS = curr;
    }

    /**
     * Get CR1's CR1 field.
     *
     * Compare Register for Channel 1
     */
    inline uint16_t get_CR1_CR1() volatile
    {
        return (CR1 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get CR1S's CR1S field.
     *
     * Shadow Compare Register for Channel 1
     */
    inline uint16_t get_CR1S_CR1S() volatile
    {
        return (CR1S >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CR1S's CR1S field.
     *
     * Shadow Compare Register for Channel 1
     */
    inline void set_CR1S_CR1S(uint16_t value) volatile
    {
        uint32_t curr = CR1S;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CR1S = curr;
    }

    /**
     * Get CR2's CR2 field.
     *
     * Compare Register for Channel 2
     */
    inline uint16_t get_CR2_CR2() volatile
    {
        return (CR2 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get CR2S's CR2S field.
     *
     * Shadow Compare Register for Channel 2
     */
    inline uint16_t get_CR2S_CR2S() volatile
    {
        return (CR2S >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CR2S's CR2S field.
     *
     * Shadow Compare Register for Channel 2
     */
    inline void set_CR2S_CR2S(uint16_t value) volatile
    {
        uint32_t curr = CR2S;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CR2S = curr;
    }

    /**
     * Get CHC's OCS4 bit.
     *
     * Output selector for CCU8x.OUTy3
     */
    inline bool get_CHC_OCS4() volatile
    {
        return CHC & (1u << 4u);
    }

    /**
     * Set CHC's OCS4 bit.
     *
     * Output selector for CCU8x.OUTy3
     */
    inline void set_CHC_OCS4() volatile
    {
        CHC |= 1u << 4u;
    }

    /**
     * Clear CHC's OCS4 bit.
     *
     * Output selector for CCU8x.OUTy3
     */
    inline void clear_CHC_OCS4() volatile
    {
        CHC &= ~(1u << 4u);
    }

    /**
     * Toggle CHC's OCS4 bit.
     *
     * Output selector for CCU8x.OUTy3
     */
    inline void toggle_CHC_OCS4() volatile
    {
        CHC ^= 1u << 4u;
    }

    /**
     * Get CHC's OCS3 bit.
     *
     * Output selector for CCU8x.OUTy2
     */
    inline bool get_CHC_OCS3() volatile
    {
        return CHC & (1u << 3u);
    }

    /**
     * Set CHC's OCS3 bit.
     *
     * Output selector for CCU8x.OUTy2
     */
    inline void set_CHC_OCS3() volatile
    {
        CHC |= 1u << 3u;
    }

    /**
     * Clear CHC's OCS3 bit.
     *
     * Output selector for CCU8x.OUTy2
     */
    inline void clear_CHC_OCS3() volatile
    {
        CHC &= ~(1u << 3u);
    }

    /**
     * Toggle CHC's OCS3 bit.
     *
     * Output selector for CCU8x.OUTy2
     */
    inline void toggle_CHC_OCS3() volatile
    {
        CHC ^= 1u << 3u;
    }

    /**
     * Get CHC's OCS2 bit.
     *
     * Output selector for CCU8x.OUTy1
     */
    inline bool get_CHC_OCS2() volatile
    {
        return CHC & (1u << 2u);
    }

    /**
     * Set CHC's OCS2 bit.
     *
     * Output selector for CCU8x.OUTy1
     */
    inline void set_CHC_OCS2() volatile
    {
        CHC |= 1u << 2u;
    }

    /**
     * Clear CHC's OCS2 bit.
     *
     * Output selector for CCU8x.OUTy1
     */
    inline void clear_CHC_OCS2() volatile
    {
        CHC &= ~(1u << 2u);
    }

    /**
     * Toggle CHC's OCS2 bit.
     *
     * Output selector for CCU8x.OUTy1
     */
    inline void toggle_CHC_OCS2() volatile
    {
        CHC ^= 1u << 2u;
    }

    /**
     * Get CHC's OCS1 bit.
     *
     * Output selector for CCU8x.OUTy0
     */
    inline bool get_CHC_OCS1() volatile
    {
        return CHC & (1u << 1u);
    }

    /**
     * Set CHC's OCS1 bit.
     *
     * Output selector for CCU8x.OUTy0
     */
    inline void set_CHC_OCS1() volatile
    {
        CHC |= 1u << 1u;
    }

    /**
     * Clear CHC's OCS1 bit.
     *
     * Output selector for CCU8x.OUTy0
     */
    inline void clear_CHC_OCS1() volatile
    {
        CHC &= ~(1u << 1u);
    }

    /**
     * Toggle CHC's OCS1 bit.
     *
     * Output selector for CCU8x.OUTy0
     */
    inline void toggle_CHC_OCS1() volatile
    {
        CHC ^= 1u << 1u;
    }

    /**
     * Get CHC's ASE bit.
     *
     * Asymmetric PWM mode Enable
     */
    inline bool get_CHC_ASE() volatile
    {
        return CHC & (1u << 0u);
    }

    /**
     * Set CHC's ASE bit.
     *
     * Asymmetric PWM mode Enable
     */
    inline void set_CHC_ASE() volatile
    {
        CHC |= 1u << 0u;
    }

    /**
     * Clear CHC's ASE bit.
     *
     * Asymmetric PWM mode Enable
     */
    inline void clear_CHC_ASE() volatile
    {
        CHC &= ~(1u << 0u);
    }

    /**
     * Toggle CHC's ASE bit.
     *
     * Asymmetric PWM mode Enable
     */
    inline void toggle_CHC_ASE() volatile
    {
        CHC ^= 1u << 0u;
    }

    /**
     * Get all of CHC's bit fields.
     *
     * (read-write) Channel Control
     */
    inline void get_CHC(bool &OCS4, bool &OCS3, bool &OCS2, bool &OCS1,
                        bool &ASE) volatile
    {
        uint32_t curr = CHC;

        OCS4 = curr & (1u << 4u);
        OCS3 = curr & (1u << 3u);
        OCS2 = curr & (1u << 2u);
        OCS1 = curr & (1u << 1u);
        ASE = curr & (1u << 0u);
    }

    /**
     * Set all of CHC's bit fields.
     *
     * (read-write) Channel Control
     */
    inline void set_CHC(bool OCS4, bool OCS3, bool OCS2, bool OCS1,
                        bool ASE) volatile
    {
        uint32_t curr = CHC;

        curr &= ~(0b1u << 4u);
        curr |= (OCS4 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (OCS3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (OCS2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (OCS1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ASE & 0b1u) << 0u;

        CHC = curr;
    }

    /**
     * Get DTC's DTCC field.
     *
     * Dead Time clock control
     */
    inline CCU80_CC80_DTC_DTCC get_DTC_DTCC() volatile
    {
        return CCU80_CC80_DTC_DTCC((DTC >> 6u) & 0b11u);
    }

    /**
     * Set DTC's DTCC field.
     *
     * Dead Time clock control
     */
    inline void set_DTC_DTCC(CCU80_CC80_DTC_DTCC value) volatile
    {
        uint32_t curr = DTC;

        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(value) & 0b11u) << 6u;

        DTC = curr;
    }

    /**
     * Get DTC's DCEN4 bit.
     *
     * Dead Time Enable for inverted CC8yST2
     */
    inline bool get_DTC_DCEN4() volatile
    {
        return DTC & (1u << 5u);
    }

    /**
     * Set DTC's DCEN4 bit.
     *
     * Dead Time Enable for inverted CC8yST2
     */
    inline void set_DTC_DCEN4() volatile
    {
        DTC |= 1u << 5u;
    }

    /**
     * Clear DTC's DCEN4 bit.
     *
     * Dead Time Enable for inverted CC8yST2
     */
    inline void clear_DTC_DCEN4() volatile
    {
        DTC &= ~(1u << 5u);
    }

    /**
     * Toggle DTC's DCEN4 bit.
     *
     * Dead Time Enable for inverted CC8yST2
     */
    inline void toggle_DTC_DCEN4() volatile
    {
        DTC ^= 1u << 5u;
    }

    /**
     * Get DTC's DCEN3 bit.
     *
     * Dead Time Enable for CC8yST2
     */
    inline bool get_DTC_DCEN3() volatile
    {
        return DTC & (1u << 4u);
    }

    /**
     * Set DTC's DCEN3 bit.
     *
     * Dead Time Enable for CC8yST2
     */
    inline void set_DTC_DCEN3() volatile
    {
        DTC |= 1u << 4u;
    }

    /**
     * Clear DTC's DCEN3 bit.
     *
     * Dead Time Enable for CC8yST2
     */
    inline void clear_DTC_DCEN3() volatile
    {
        DTC &= ~(1u << 4u);
    }

    /**
     * Toggle DTC's DCEN3 bit.
     *
     * Dead Time Enable for CC8yST2
     */
    inline void toggle_DTC_DCEN3() volatile
    {
        DTC ^= 1u << 4u;
    }

    /**
     * Get DTC's DCEN2 bit.
     *
     * Dead Time Enable for inverted CC8yST1
     */
    inline bool get_DTC_DCEN2() volatile
    {
        return DTC & (1u << 3u);
    }

    /**
     * Set DTC's DCEN2 bit.
     *
     * Dead Time Enable for inverted CC8yST1
     */
    inline void set_DTC_DCEN2() volatile
    {
        DTC |= 1u << 3u;
    }

    /**
     * Clear DTC's DCEN2 bit.
     *
     * Dead Time Enable for inverted CC8yST1
     */
    inline void clear_DTC_DCEN2() volatile
    {
        DTC &= ~(1u << 3u);
    }

    /**
     * Toggle DTC's DCEN2 bit.
     *
     * Dead Time Enable for inverted CC8yST1
     */
    inline void toggle_DTC_DCEN2() volatile
    {
        DTC ^= 1u << 3u;
    }

    /**
     * Get DTC's DCEN1 bit.
     *
     * Dead Time Enable for CC8yST1
     */
    inline bool get_DTC_DCEN1() volatile
    {
        return DTC & (1u << 2u);
    }

    /**
     * Set DTC's DCEN1 bit.
     *
     * Dead Time Enable for CC8yST1
     */
    inline void set_DTC_DCEN1() volatile
    {
        DTC |= 1u << 2u;
    }

    /**
     * Clear DTC's DCEN1 bit.
     *
     * Dead Time Enable for CC8yST1
     */
    inline void clear_DTC_DCEN1() volatile
    {
        DTC &= ~(1u << 2u);
    }

    /**
     * Toggle DTC's DCEN1 bit.
     *
     * Dead Time Enable for CC8yST1
     */
    inline void toggle_DTC_DCEN1() volatile
    {
        DTC ^= 1u << 2u;
    }

    /**
     * Get DTC's DTE2 bit.
     *
     * Dead Time Enable for Channel 2
     */
    inline bool get_DTC_DTE2() volatile
    {
        return DTC & (1u << 1u);
    }

    /**
     * Set DTC's DTE2 bit.
     *
     * Dead Time Enable for Channel 2
     */
    inline void set_DTC_DTE2() volatile
    {
        DTC |= 1u << 1u;
    }

    /**
     * Clear DTC's DTE2 bit.
     *
     * Dead Time Enable for Channel 2
     */
    inline void clear_DTC_DTE2() volatile
    {
        DTC &= ~(1u << 1u);
    }

    /**
     * Toggle DTC's DTE2 bit.
     *
     * Dead Time Enable for Channel 2
     */
    inline void toggle_DTC_DTE2() volatile
    {
        DTC ^= 1u << 1u;
    }

    /**
     * Get DTC's DTE1 bit.
     *
     * Dead Time Enable for Channel 1
     */
    inline bool get_DTC_DTE1() volatile
    {
        return DTC & (1u << 0u);
    }

    /**
     * Set DTC's DTE1 bit.
     *
     * Dead Time Enable for Channel 1
     */
    inline void set_DTC_DTE1() volatile
    {
        DTC |= 1u << 0u;
    }

    /**
     * Clear DTC's DTE1 bit.
     *
     * Dead Time Enable for Channel 1
     */
    inline void clear_DTC_DTE1() volatile
    {
        DTC &= ~(1u << 0u);
    }

    /**
     * Toggle DTC's DTE1 bit.
     *
     * Dead Time Enable for Channel 1
     */
    inline void toggle_DTC_DTE1() volatile
    {
        DTC ^= 1u << 0u;
    }

    /**
     * Get all of DTC's bit fields.
     *
     * (read-write) Dead Time Control
     */
    inline void get_DTC(CCU80_CC80_DTC_DTCC &DTCC, bool &DCEN4, bool &DCEN3,
                        bool &DCEN2, bool &DCEN1, bool &DTE2,
                        bool &DTE1) volatile
    {
        uint32_t curr = DTC;

        DTCC = CCU80_CC80_DTC_DTCC((curr >> 6u) & 0b11u);
        DCEN4 = curr & (1u << 5u);
        DCEN3 = curr & (1u << 4u);
        DCEN2 = curr & (1u << 3u);
        DCEN1 = curr & (1u << 2u);
        DTE2 = curr & (1u << 1u);
        DTE1 = curr & (1u << 0u);
    }

    /**
     * Set all of DTC's bit fields.
     *
     * (read-write) Dead Time Control
     */
    inline void set_DTC(CCU80_CC80_DTC_DTCC DTCC, bool DCEN4, bool DCEN3,
                        bool DCEN2, bool DCEN1, bool DTE2, bool DTE1) volatile
    {
        uint32_t curr = DTC;

        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(DTCC) & 0b11u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (DCEN4 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (DCEN3 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (DCEN2 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (DCEN1 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DTE2 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (DTE1 & 0b1u) << 0u;

        DTC = curr;
    }

    /**
     * Get DC1R's DT1F field.
     *
     * Fall Value for Dead Time of Channel 1
     */
    inline uint8_t get_DC1R_DT1F() volatile
    {
        return (DC1R >> 8u) & 0b11111111u;
    }

    /**
     * Set DC1R's DT1F field.
     *
     * Fall Value for Dead Time of Channel 1
     */
    inline void set_DC1R_DT1F(uint8_t value) volatile
    {
        uint32_t curr = DC1R;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        DC1R = curr;
    }

    /**
     * Get DC1R's DT1R field.
     *
     * Rise Value for Dead Time of Channel 1
     */
    inline uint8_t get_DC1R_DT1R() volatile
    {
        return (DC1R >> 0u) & 0b11111111u;
    }

    /**
     * Set DC1R's DT1R field.
     *
     * Rise Value for Dead Time of Channel 1
     */
    inline void set_DC1R_DT1R(uint8_t value) volatile
    {
        uint32_t curr = DC1R;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        DC1R = curr;
    }

    /**
     * Get all of DC1R's bit fields.
     *
     * (read-write) Channel 1 Dead Time Values
     */
    inline void get_DC1R(uint8_t &DT1F, uint8_t &DT1R) volatile
    {
        uint32_t curr = DC1R;

        DT1F = (curr >> 8u) & 0b11111111u;
        DT1R = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of DC1R's bit fields.
     *
     * (read-write) Channel 1 Dead Time Values
     */
    inline void set_DC1R(uint8_t DT1F, uint8_t DT1R) volatile
    {
        uint32_t curr = DC1R;

        curr &= ~(0b11111111u << 8u);
        curr |= (DT1F & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (DT1R & 0b11111111u) << 0u;

        DC1R = curr;
    }

    /**
     * Get DC2R's DT2F field.
     *
     * Fall Value for Dead Time of Channel 2
     */
    inline uint8_t get_DC2R_DT2F() volatile
    {
        return (DC2R >> 8u) & 0b11111111u;
    }

    /**
     * Set DC2R's DT2F field.
     *
     * Fall Value for Dead Time of Channel 2
     */
    inline void set_DC2R_DT2F(uint8_t value) volatile
    {
        uint32_t curr = DC2R;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        DC2R = curr;
    }

    /**
     * Get DC2R's DT2R field.
     *
     * Rise Value for Dead Time of Channel 2
     */
    inline uint8_t get_DC2R_DT2R() volatile
    {
        return (DC2R >> 0u) & 0b11111111u;
    }

    /**
     * Set DC2R's DT2R field.
     *
     * Rise Value for Dead Time of Channel 2
     */
    inline void set_DC2R_DT2R(uint8_t value) volatile
    {
        uint32_t curr = DC2R;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        DC2R = curr;
    }

    /**
     * Get all of DC2R's bit fields.
     *
     * (read-write) Channel 2 Dead Time Values
     */
    inline void get_DC2R(uint8_t &DT2F, uint8_t &DT2R) volatile
    {
        uint32_t curr = DC2R;

        DT2F = (curr >> 8u) & 0b11111111u;
        DT2R = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of DC2R's bit fields.
     *
     * (read-write) Channel 2 Dead Time Values
     */
    inline void set_DC2R(uint8_t DT2F, uint8_t DT2R) volatile
    {
        uint32_t curr = DC2R;

        curr &= ~(0b11111111u << 8u);
        curr |= (DT2F & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (DT2R & 0b11111111u) << 0u;

        DC2R = curr;
    }

    /**
     * Get TIMER's TVAL field.
     *
     * Timer Value
     */
    inline uint16_t get_TIMER_TVAL() volatile
    {
        return (TIMER >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set TIMER's TVAL field.
     *
     * Timer Value
     */
    inline void set_TIMER_TVAL(uint16_t value) volatile
    {
        uint32_t curr = TIMER;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        TIMER = curr;
    }

    /**
     * Get C0V's FFL bit.
     *
     * Full Flag
     */
    inline bool get_C0V_FFL() volatile
    {
        return C0V & (1u << 20u);
    }

    /**
     * Get C0V's FPCV field.
     *
     * Prescaler Value
     */
    inline uint8_t get_C0V_FPCV() volatile
    {
        return (C0V >> 16u) & 0b1111u;
    }

    /**
     * Get C0V's CAPTV field.
     *
     * Capture Value
     */
    inline uint16_t get_C0V_CAPTV() volatile
    {
        return (C0V >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of C0V's bit fields.
     *
     * (read-only) Capture Register 0
     */
    inline void get_C0V(bool &FFL, uint8_t &FPCV, uint16_t &CAPTV) volatile
    {
        uint32_t curr = C0V;

        FFL = curr & (1u << 20u);
        FPCV = (curr >> 16u) & 0b1111u;
        CAPTV = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get C1V's FFL bit.
     *
     * Full Flag
     */
    inline bool get_C1V_FFL() volatile
    {
        return C1V & (1u << 20u);
    }

    /**
     * Get C1V's FPCV field.
     *
     * Prescaler Value
     */
    inline uint8_t get_C1V_FPCV() volatile
    {
        return (C1V >> 16u) & 0b1111u;
    }

    /**
     * Get C1V's CAPTV field.
     *
     * Capture Value
     */
    inline uint16_t get_C1V_CAPTV() volatile
    {
        return (C1V >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of C1V's bit fields.
     *
     * (read-only) Capture Register 1
     */
    inline void get_C1V(bool &FFL, uint8_t &FPCV, uint16_t &CAPTV) volatile
    {
        uint32_t curr = C1V;

        FFL = curr & (1u << 20u);
        FPCV = (curr >> 16u) & 0b1111u;
        CAPTV = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get C2V's FFL bit.
     *
     * Full Flag
     */
    inline bool get_C2V_FFL() volatile
    {
        return C2V & (1u << 20u);
    }

    /**
     * Get C2V's FPCV field.
     *
     * Prescaler Value
     */
    inline uint8_t get_C2V_FPCV() volatile
    {
        return (C2V >> 16u) & 0b1111u;
    }

    /**
     * Get C2V's CAPTV field.
     *
     * Capture Value
     */
    inline uint16_t get_C2V_CAPTV() volatile
    {
        return (C2V >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of C2V's bit fields.
     *
     * (read-only) Capture Register 2
     */
    inline void get_C2V(bool &FFL, uint8_t &FPCV, uint16_t &CAPTV) volatile
    {
        uint32_t curr = C2V;

        FFL = curr & (1u << 20u);
        FPCV = (curr >> 16u) & 0b1111u;
        CAPTV = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get C3V's FFL bit.
     *
     * Full Flag
     */
    inline bool get_C3V_FFL() volatile
    {
        return C3V & (1u << 20u);
    }

    /**
     * Get C3V's FPCV field.
     *
     * Prescaler Value
     */
    inline uint8_t get_C3V_FPCV() volatile
    {
        return (C3V >> 16u) & 0b1111u;
    }

    /**
     * Get C3V's CAPTV field.
     *
     * Capture Value
     */
    inline uint16_t get_C3V_CAPTV() volatile
    {
        return (C3V >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of C3V's bit fields.
     *
     * (read-only) Capture Register 3
     */
    inline void get_C3V(bool &FFL, uint8_t &FPCV, uint16_t &CAPTV) volatile
    {
        uint32_t curr = C3V;

        FFL = curr & (1u << 20u);
        FPCV = (curr >> 16u) & 0b1111u;
        CAPTV = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get INTS's TRPF bit.
     *
     * Trap Flag Status
     */
    inline bool get_INTS_TRPF() volatile
    {
        return INTS & (1u << 11u);
    }

    /**
     * Get INTS's E2AS bit.
     *
     * Event 2 Detection Status
     */
    inline bool get_INTS_E2AS() volatile
    {
        return INTS & (1u << 10u);
    }

    /**
     * Get INTS's E1AS bit.
     *
     * Event 1 Detection Status
     */
    inline bool get_INTS_E1AS() volatile
    {
        return INTS & (1u << 9u);
    }

    /**
     * Get INTS's E0AS bit.
     *
     * Event 0 Detection Status
     */
    inline bool get_INTS_E0AS() volatile
    {
        return INTS & (1u << 8u);
    }

    /**
     * Get INTS's CMD2S bit.
     *
     * Channel 2 Compare Match while Counting Down
     */
    inline bool get_INTS_CMD2S() volatile
    {
        return INTS & (1u << 5u);
    }

    /**
     * Get INTS's CMU2S bit.
     *
     * Channel 2 Compare Match while Counting Up
     */
    inline bool get_INTS_CMU2S() volatile
    {
        return INTS & (1u << 4u);
    }

    /**
     * Get INTS's CMD1S bit.
     *
     * Channel 1 Compare Match while Counting Down
     */
    inline bool get_INTS_CMD1S() volatile
    {
        return INTS & (1u << 3u);
    }

    /**
     * Get INTS's CMU1S bit.
     *
     * Channel 1 Compare Match while Counting Up
     */
    inline bool get_INTS_CMU1S() volatile
    {
        return INTS & (1u << 2u);
    }

    /**
     * Get INTS's OMDS bit.
     *
     * One Match while Counting Down
     */
    inline bool get_INTS_OMDS() volatile
    {
        return INTS & (1u << 1u);
    }

    /**
     * Get INTS's PMUS bit.
     *
     * Period Match while Counting Up
     */
    inline bool get_INTS_PMUS() volatile
    {
        return INTS & (1u << 0u);
    }

    /**
     * Get all of INTS's bit fields.
     *
     * (read-only) Interrupt Status
     */
    inline void get_INTS(bool &TRPF, bool &E2AS, bool &E1AS, bool &E0AS,
                         bool &CMD2S, bool &CMU2S, bool &CMD1S, bool &CMU1S,
                         bool &OMDS, bool &PMUS) volatile
    {
        uint32_t curr = INTS;

        TRPF = curr & (1u << 11u);
        E2AS = curr & (1u << 10u);
        E1AS = curr & (1u << 9u);
        E0AS = curr & (1u << 8u);
        CMD2S = curr & (1u << 5u);
        CMU2S = curr & (1u << 4u);
        CMD1S = curr & (1u << 3u);
        CMU1S = curr & (1u << 2u);
        OMDS = curr & (1u << 1u);
        PMUS = curr & (1u << 0u);
    }

    /**
     * Get INTE's E2AE bit.
     *
     * Event 2 interrupt enable
     */
    inline bool get_INTE_E2AE() volatile
    {
        return INTE & (1u << 10u);
    }

    /**
     * Set INTE's E2AE bit.
     *
     * Event 2 interrupt enable
     */
    inline void set_INTE_E2AE() volatile
    {
        INTE |= 1u << 10u;
    }

    /**
     * Clear INTE's E2AE bit.
     *
     * Event 2 interrupt enable
     */
    inline void clear_INTE_E2AE() volatile
    {
        INTE &= ~(1u << 10u);
    }

    /**
     * Toggle INTE's E2AE bit.
     *
     * Event 2 interrupt enable
     */
    inline void toggle_INTE_E2AE() volatile
    {
        INTE ^= 1u << 10u;
    }

    /**
     * Get INTE's E1AE bit.
     *
     * Event 1 interrupt enable
     */
    inline bool get_INTE_E1AE() volatile
    {
        return INTE & (1u << 9u);
    }

    /**
     * Set INTE's E1AE bit.
     *
     * Event 1 interrupt enable
     */
    inline void set_INTE_E1AE() volatile
    {
        INTE |= 1u << 9u;
    }

    /**
     * Clear INTE's E1AE bit.
     *
     * Event 1 interrupt enable
     */
    inline void clear_INTE_E1AE() volatile
    {
        INTE &= ~(1u << 9u);
    }

    /**
     * Toggle INTE's E1AE bit.
     *
     * Event 1 interrupt enable
     */
    inline void toggle_INTE_E1AE() volatile
    {
        INTE ^= 1u << 9u;
    }

    /**
     * Get INTE's E0AE bit.
     *
     * Event 0 interrupt enable
     */
    inline bool get_INTE_E0AE() volatile
    {
        return INTE & (1u << 8u);
    }

    /**
     * Set INTE's E0AE bit.
     *
     * Event 0 interrupt enable
     */
    inline void set_INTE_E0AE() volatile
    {
        INTE |= 1u << 8u;
    }

    /**
     * Clear INTE's E0AE bit.
     *
     * Event 0 interrupt enable
     */
    inline void clear_INTE_E0AE() volatile
    {
        INTE &= ~(1u << 8u);
    }

    /**
     * Toggle INTE's E0AE bit.
     *
     * Event 0 interrupt enable
     */
    inline void toggle_INTE_E0AE() volatile
    {
        INTE ^= 1u << 8u;
    }

    /**
     * Get INTE's CMD2E bit.
     *
     * Channel 2 Compare match while counting down enable
     */
    inline bool get_INTE_CMD2E() volatile
    {
        return INTE & (1u << 5u);
    }

    /**
     * Set INTE's CMD2E bit.
     *
     * Channel 2 Compare match while counting down enable
     */
    inline void set_INTE_CMD2E() volatile
    {
        INTE |= 1u << 5u;
    }

    /**
     * Clear INTE's CMD2E bit.
     *
     * Channel 2 Compare match while counting down enable
     */
    inline void clear_INTE_CMD2E() volatile
    {
        INTE &= ~(1u << 5u);
    }

    /**
     * Toggle INTE's CMD2E bit.
     *
     * Channel 2 Compare match while counting down enable
     */
    inline void toggle_INTE_CMD2E() volatile
    {
        INTE ^= 1u << 5u;
    }

    /**
     * Get INTE's CMU2E bit.
     *
     * Channel 2 Compare match while counting up enable
     */
    inline bool get_INTE_CMU2E() volatile
    {
        return INTE & (1u << 4u);
    }

    /**
     * Set INTE's CMU2E bit.
     *
     * Channel 2 Compare match while counting up enable
     */
    inline void set_INTE_CMU2E() volatile
    {
        INTE |= 1u << 4u;
    }

    /**
     * Clear INTE's CMU2E bit.
     *
     * Channel 2 Compare match while counting up enable
     */
    inline void clear_INTE_CMU2E() volatile
    {
        INTE &= ~(1u << 4u);
    }

    /**
     * Toggle INTE's CMU2E bit.
     *
     * Channel 2 Compare match while counting up enable
     */
    inline void toggle_INTE_CMU2E() volatile
    {
        INTE ^= 1u << 4u;
    }

    /**
     * Get INTE's CMD1E bit.
     *
     * Channel 1 Compare match while counting down enable
     */
    inline bool get_INTE_CMD1E() volatile
    {
        return INTE & (1u << 3u);
    }

    /**
     * Set INTE's CMD1E bit.
     *
     * Channel 1 Compare match while counting down enable
     */
    inline void set_INTE_CMD1E() volatile
    {
        INTE |= 1u << 3u;
    }

    /**
     * Clear INTE's CMD1E bit.
     *
     * Channel 1 Compare match while counting down enable
     */
    inline void clear_INTE_CMD1E() volatile
    {
        INTE &= ~(1u << 3u);
    }

    /**
     * Toggle INTE's CMD1E bit.
     *
     * Channel 1 Compare match while counting down enable
     */
    inline void toggle_INTE_CMD1E() volatile
    {
        INTE ^= 1u << 3u;
    }

    /**
     * Get INTE's CMU1E bit.
     *
     * Channel 1 Compare match while counting up enable
     */
    inline bool get_INTE_CMU1E() volatile
    {
        return INTE & (1u << 2u);
    }

    /**
     * Set INTE's CMU1E bit.
     *
     * Channel 1 Compare match while counting up enable
     */
    inline void set_INTE_CMU1E() volatile
    {
        INTE |= 1u << 2u;
    }

    /**
     * Clear INTE's CMU1E bit.
     *
     * Channel 1 Compare match while counting up enable
     */
    inline void clear_INTE_CMU1E() volatile
    {
        INTE &= ~(1u << 2u);
    }

    /**
     * Toggle INTE's CMU1E bit.
     *
     * Channel 1 Compare match while counting up enable
     */
    inline void toggle_INTE_CMU1E() volatile
    {
        INTE ^= 1u << 2u;
    }

    /**
     * Get INTE's OME bit.
     *
     * One match while counting down enable
     */
    inline bool get_INTE_OME() volatile
    {
        return INTE & (1u << 1u);
    }

    /**
     * Set INTE's OME bit.
     *
     * One match while counting down enable
     */
    inline void set_INTE_OME() volatile
    {
        INTE |= 1u << 1u;
    }

    /**
     * Clear INTE's OME bit.
     *
     * One match while counting down enable
     */
    inline void clear_INTE_OME() volatile
    {
        INTE &= ~(1u << 1u);
    }

    /**
     * Toggle INTE's OME bit.
     *
     * One match while counting down enable
     */
    inline void toggle_INTE_OME() volatile
    {
        INTE ^= 1u << 1u;
    }

    /**
     * Get INTE's PME bit.
     *
     * Period match while counting up enable
     */
    inline bool get_INTE_PME() volatile
    {
        return INTE & (1u << 0u);
    }

    /**
     * Set INTE's PME bit.
     *
     * Period match while counting up enable
     */
    inline void set_INTE_PME() volatile
    {
        INTE |= 1u << 0u;
    }

    /**
     * Clear INTE's PME bit.
     *
     * Period match while counting up enable
     */
    inline void clear_INTE_PME() volatile
    {
        INTE &= ~(1u << 0u);
    }

    /**
     * Toggle INTE's PME bit.
     *
     * Period match while counting up enable
     */
    inline void toggle_INTE_PME() volatile
    {
        INTE ^= 1u << 0u;
    }

    /**
     * Get all of INTE's bit fields.
     *
     * (read-write) Interrupt Enable Control
     */
    inline void get_INTE(bool &E2AE, bool &E1AE, bool &E0AE, bool &CMD2E,
                         bool &CMU2E, bool &CMD1E, bool &CMU1E, bool &OME,
                         bool &PME) volatile
    {
        uint32_t curr = INTE;

        E2AE = curr & (1u << 10u);
        E1AE = curr & (1u << 9u);
        E0AE = curr & (1u << 8u);
        CMD2E = curr & (1u << 5u);
        CMU2E = curr & (1u << 4u);
        CMD1E = curr & (1u << 3u);
        CMU1E = curr & (1u << 2u);
        OME = curr & (1u << 1u);
        PME = curr & (1u << 0u);
    }

    /**
     * Set all of INTE's bit fields.
     *
     * (read-write) Interrupt Enable Control
     */
    inline void set_INTE(bool E2AE, bool E1AE, bool E0AE, bool CMD2E,
                         bool CMU2E, bool CMD1E, bool CMU1E, bool OME,
                         bool PME) volatile
    {
        uint32_t curr = INTE;

        curr &= ~(0b1u << 10u);
        curr |= (E2AE & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (E1AE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (E0AE & 0b1u) << 8u;
        curr &= ~(0b1u << 5u);
        curr |= (CMD2E & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (CMU2E & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (CMD1E & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (CMU1E & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (OME & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PME & 0b1u) << 0u;

        INTE = curr;
    }

    /**
     * Get SRS's E2SR field.
     *
     * Event 2 Service request selector
     */
    inline CCU80_CC80_SRS_E2SR get_SRS_E2SR() volatile
    {
        return CCU80_CC80_SRS_E2SR((SRS >> 12u) & 0b11u);
    }

    /**
     * Set SRS's E2SR field.
     *
     * Event 2 Service request selector
     */
    inline void set_SRS_E2SR(CCU80_CC80_SRS_E2SR value) volatile
    {
        uint32_t curr = SRS;

        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(value) & 0b11u) << 12u;

        SRS = curr;
    }

    /**
     * Get SRS's E1SR field.
     *
     * Event 1 Service request selector
     */
    inline CCU80_CC80_SRS_E1SR get_SRS_E1SR() volatile
    {
        return CCU80_CC80_SRS_E1SR((SRS >> 10u) & 0b11u);
    }

    /**
     * Set SRS's E1SR field.
     *
     * Event 1 Service request selector
     */
    inline void set_SRS_E1SR(CCU80_CC80_SRS_E1SR value) volatile
    {
        uint32_t curr = SRS;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(value) & 0b11u) << 10u;

        SRS = curr;
    }

    /**
     * Get SRS's E0SR field.
     *
     * Event 0 Service request selector
     */
    inline CCU80_CC80_SRS_E0SR get_SRS_E0SR() volatile
    {
        return CCU80_CC80_SRS_E0SR((SRS >> 8u) & 0b11u);
    }

    /**
     * Set SRS's E0SR field.
     *
     * Event 0 Service request selector
     */
    inline void set_SRS_E0SR(CCU80_CC80_SRS_E0SR value) volatile
    {
        uint32_t curr = SRS;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        SRS = curr;
    }

    /**
     * Get SRS's CM2SR field.
     *
     * Channel 2 Compare match Service request selector
     */
    inline CCU80_CC80_SRS_E1SR get_SRS_CM2SR() volatile
    {
        return CCU80_CC80_SRS_E1SR((SRS >> 4u) & 0b11u);
    }

    /**
     * Set SRS's CM2SR field.
     *
     * Channel 2 Compare match Service request selector
     */
    inline void set_SRS_CM2SR(CCU80_CC80_SRS_E1SR value) volatile
    {
        uint32_t curr = SRS;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        SRS = curr;
    }

    /**
     * Get SRS's CM1SR field.
     *
     * Channel 1 Compare match Service request selector
     */
    inline CCU80_CC80_SRS_E1SR get_SRS_CM1SR() volatile
    {
        return CCU80_CC80_SRS_E1SR((SRS >> 2u) & 0b11u);
    }

    /**
     * Set SRS's CM1SR field.
     *
     * Channel 1 Compare match Service request selector
     */
    inline void set_SRS_CM1SR(CCU80_CC80_SRS_E1SR value) volatile
    {
        uint32_t curr = SRS;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SRS = curr;
    }

    /**
     * Get SRS's POSR field.
     *
     * Period/One match Service request selector
     */
    inline CCU80_CC80_SRS_E1SR get_SRS_POSR() volatile
    {
        return CCU80_CC80_SRS_E1SR((SRS >> 0u) & 0b11u);
    }

    /**
     * Set SRS's POSR field.
     *
     * Period/One match Service request selector
     */
    inline void set_SRS_POSR(CCU80_CC80_SRS_E1SR value) volatile
    {
        uint32_t curr = SRS;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        SRS = curr;
    }

    /**
     * Get all of SRS's bit fields.
     *
     * (read-write) Service Request Selector
     */
    inline void get_SRS(CCU80_CC80_SRS_E2SR &E2SR, CCU80_CC80_SRS_E1SR &E1SR,
                        CCU80_CC80_SRS_E0SR &E0SR, CCU80_CC80_SRS_E1SR &CM2SR,
                        CCU80_CC80_SRS_E1SR &CM1SR,
                        CCU80_CC80_SRS_E1SR &POSR) volatile
    {
        uint32_t curr = SRS;

        E2SR = CCU80_CC80_SRS_E2SR((curr >> 12u) & 0b11u);
        E1SR = CCU80_CC80_SRS_E1SR((curr >> 10u) & 0b11u);
        E0SR = CCU80_CC80_SRS_E0SR((curr >> 8u) & 0b11u);
        CM2SR = CCU80_CC80_SRS_E1SR((curr >> 4u) & 0b11u);
        CM1SR = CCU80_CC80_SRS_E1SR((curr >> 2u) & 0b11u);
        POSR = CCU80_CC80_SRS_E1SR((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of SRS's bit fields.
     *
     * (read-write) Service Request Selector
     */
    inline void set_SRS(CCU80_CC80_SRS_E2SR E2SR, CCU80_CC80_SRS_E1SR E1SR,
                        CCU80_CC80_SRS_E0SR E0SR, CCU80_CC80_SRS_E1SR CM2SR,
                        CCU80_CC80_SRS_E1SR CM1SR,
                        CCU80_CC80_SRS_E1SR POSR) volatile
    {
        uint32_t curr = SRS;

        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(E2SR) & 0b11u) << 12u;
        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(E1SR) & 0b11u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(E0SR) & 0b11u) << 8u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(CM2SR) & 0b11u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(CM1SR) & 0b11u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(POSR) & 0b11u) << 0u;

        SRS = curr;
    }

    /**
     * Set SWS's STRPF bit.
     *
     * Trap Flag status set
     */
    inline void set_SWS_STRPF() volatile
    {
        SWS |= 1u << 11u;
    }

    /**
     * Clear SWS's STRPF bit.
     *
     * Trap Flag status set
     */
    inline void clear_SWS_STRPF() volatile
    {
        SWS &= ~(1u << 11u);
    }

    /**
     * Toggle SWS's STRPF bit.
     *
     * Trap Flag status set
     */
    inline void toggle_SWS_STRPF() volatile
    {
        SWS ^= 1u << 11u;
    }

    /**
     * Set SWS's SE2A bit.
     *
     * Event 2 detection set
     */
    inline void set_SWS_SE2A() volatile
    {
        SWS |= 1u << 10u;
    }

    /**
     * Clear SWS's SE2A bit.
     *
     * Event 2 detection set
     */
    inline void clear_SWS_SE2A() volatile
    {
        SWS &= ~(1u << 10u);
    }

    /**
     * Toggle SWS's SE2A bit.
     *
     * Event 2 detection set
     */
    inline void toggle_SWS_SE2A() volatile
    {
        SWS ^= 1u << 10u;
    }

    /**
     * Set SWS's SE1A bit.
     *
     * Event 1 detection set
     */
    inline void set_SWS_SE1A() volatile
    {
        SWS |= 1u << 9u;
    }

    /**
     * Clear SWS's SE1A bit.
     *
     * Event 1 detection set
     */
    inline void clear_SWS_SE1A() volatile
    {
        SWS &= ~(1u << 9u);
    }

    /**
     * Toggle SWS's SE1A bit.
     *
     * Event 1 detection set
     */
    inline void toggle_SWS_SE1A() volatile
    {
        SWS ^= 1u << 9u;
    }

    /**
     * Set SWS's SE0A bit.
     *
     * Event 0 detection set
     */
    inline void set_SWS_SE0A() volatile
    {
        SWS |= 1u << 8u;
    }

    /**
     * Clear SWS's SE0A bit.
     *
     * Event 0 detection set
     */
    inline void clear_SWS_SE0A() volatile
    {
        SWS &= ~(1u << 8u);
    }

    /**
     * Toggle SWS's SE0A bit.
     *
     * Event 0 detection set
     */
    inline void toggle_SWS_SE0A() volatile
    {
        SWS ^= 1u << 8u;
    }

    /**
     * Set SWS's SCM2D bit.
     *
     * Compare match while counting down set
     */
    inline void set_SWS_SCM2D() volatile
    {
        SWS |= 1u << 5u;
    }

    /**
     * Clear SWS's SCM2D bit.
     *
     * Compare match while counting down set
     */
    inline void clear_SWS_SCM2D() volatile
    {
        SWS &= ~(1u << 5u);
    }

    /**
     * Toggle SWS's SCM2D bit.
     *
     * Compare match while counting down set
     */
    inline void toggle_SWS_SCM2D() volatile
    {
        SWS ^= 1u << 5u;
    }

    /**
     * Set SWS's SCM2U bit.
     *
     * Compare match while counting up set
     */
    inline void set_SWS_SCM2U() volatile
    {
        SWS |= 1u << 4u;
    }

    /**
     * Clear SWS's SCM2U bit.
     *
     * Compare match while counting up set
     */
    inline void clear_SWS_SCM2U() volatile
    {
        SWS &= ~(1u << 4u);
    }

    /**
     * Toggle SWS's SCM2U bit.
     *
     * Compare match while counting up set
     */
    inline void toggle_SWS_SCM2U() volatile
    {
        SWS ^= 1u << 4u;
    }

    /**
     * Set SWS's SCM1D bit.
     *
     * Channel 1 Compare match while counting down set
     */
    inline void set_SWS_SCM1D() volatile
    {
        SWS |= 1u << 3u;
    }

    /**
     * Clear SWS's SCM1D bit.
     *
     * Channel 1 Compare match while counting down set
     */
    inline void clear_SWS_SCM1D() volatile
    {
        SWS &= ~(1u << 3u);
    }

    /**
     * Toggle SWS's SCM1D bit.
     *
     * Channel 1 Compare match while counting down set
     */
    inline void toggle_SWS_SCM1D() volatile
    {
        SWS ^= 1u << 3u;
    }

    /**
     * Set SWS's SCM1U bit.
     *
     * Channel 1 Compare match while counting up set
     */
    inline void set_SWS_SCM1U() volatile
    {
        SWS |= 1u << 2u;
    }

    /**
     * Clear SWS's SCM1U bit.
     *
     * Channel 1 Compare match while counting up set
     */
    inline void clear_SWS_SCM1U() volatile
    {
        SWS &= ~(1u << 2u);
    }

    /**
     * Toggle SWS's SCM1U bit.
     *
     * Channel 1 Compare match while counting up set
     */
    inline void toggle_SWS_SCM1U() volatile
    {
        SWS ^= 1u << 2u;
    }

    /**
     * Set SWS's SOM bit.
     *
     * One match while counting down set
     */
    inline void set_SWS_SOM() volatile
    {
        SWS |= 1u << 1u;
    }

    /**
     * Clear SWS's SOM bit.
     *
     * One match while counting down set
     */
    inline void clear_SWS_SOM() volatile
    {
        SWS &= ~(1u << 1u);
    }

    /**
     * Toggle SWS's SOM bit.
     *
     * One match while counting down set
     */
    inline void toggle_SWS_SOM() volatile
    {
        SWS ^= 1u << 1u;
    }

    /**
     * Set SWS's SPM bit.
     *
     * Period match while counting up set
     */
    inline void set_SWS_SPM() volatile
    {
        SWS |= 1u << 0u;
    }

    /**
     * Clear SWS's SPM bit.
     *
     * Period match while counting up set
     */
    inline void clear_SWS_SPM() volatile
    {
        SWS &= ~(1u << 0u);
    }

    /**
     * Toggle SWS's SPM bit.
     *
     * Period match while counting up set
     */
    inline void toggle_SWS_SPM() volatile
    {
        SWS ^= 1u << 0u;
    }

    /**
     * Set all of SWS's bit fields.
     *
     * (write-only) Interrupt Status Set
     */
    inline void set_SWS(bool STRPF, bool SE2A, bool SE1A, bool SE0A,
                        bool SCM2D, bool SCM2U, bool SCM1D, bool SCM1U,
                        bool SOM, bool SPM) volatile
    {
        uint32_t curr = SWS;

        curr &= ~(0b1u << 11u);
        curr |= (STRPF & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (SE2A & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (SE1A & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (SE0A & 0b1u) << 8u;
        curr &= ~(0b1u << 5u);
        curr |= (SCM2D & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (SCM2U & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (SCM1D & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (SCM1U & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (SOM & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SPM & 0b1u) << 0u;

        SWS = curr;
    }

    /**
     * Set SWR's RTRPF bit.
     *
     * Trap Flag status clear
     */
    inline void set_SWR_RTRPF() volatile
    {
        SWR |= 1u << 11u;
    }

    /**
     * Clear SWR's RTRPF bit.
     *
     * Trap Flag status clear
     */
    inline void clear_SWR_RTRPF() volatile
    {
        SWR &= ~(1u << 11u);
    }

    /**
     * Toggle SWR's RTRPF bit.
     *
     * Trap Flag status clear
     */
    inline void toggle_SWR_RTRPF() volatile
    {
        SWR ^= 1u << 11u;
    }

    /**
     * Set SWR's RE2A bit.
     *
     * Event 2 detection clear
     */
    inline void set_SWR_RE2A() volatile
    {
        SWR |= 1u << 10u;
    }

    /**
     * Clear SWR's RE2A bit.
     *
     * Event 2 detection clear
     */
    inline void clear_SWR_RE2A() volatile
    {
        SWR &= ~(1u << 10u);
    }

    /**
     * Toggle SWR's RE2A bit.
     *
     * Event 2 detection clear
     */
    inline void toggle_SWR_RE2A() volatile
    {
        SWR ^= 1u << 10u;
    }

    /**
     * Set SWR's RE1A bit.
     *
     * Event 1 detection clear
     */
    inline void set_SWR_RE1A() volatile
    {
        SWR |= 1u << 9u;
    }

    /**
     * Clear SWR's RE1A bit.
     *
     * Event 1 detection clear
     */
    inline void clear_SWR_RE1A() volatile
    {
        SWR &= ~(1u << 9u);
    }

    /**
     * Toggle SWR's RE1A bit.
     *
     * Event 1 detection clear
     */
    inline void toggle_SWR_RE1A() volatile
    {
        SWR ^= 1u << 9u;
    }

    /**
     * Set SWR's RE0A bit.
     *
     * Event 0 detection clear
     */
    inline void set_SWR_RE0A() volatile
    {
        SWR |= 1u << 8u;
    }

    /**
     * Clear SWR's RE0A bit.
     *
     * Event 0 detection clear
     */
    inline void clear_SWR_RE0A() volatile
    {
        SWR &= ~(1u << 8u);
    }

    /**
     * Toggle SWR's RE0A bit.
     *
     * Event 0 detection clear
     */
    inline void toggle_SWR_RE0A() volatile
    {
        SWR ^= 1u << 8u;
    }

    /**
     * Set SWR's RCM2D bit.
     *
     * Channel 2 Compare match while counting down clear
     */
    inline void set_SWR_RCM2D() volatile
    {
        SWR |= 1u << 5u;
    }

    /**
     * Clear SWR's RCM2D bit.
     *
     * Channel 2 Compare match while counting down clear
     */
    inline void clear_SWR_RCM2D() volatile
    {
        SWR &= ~(1u << 5u);
    }

    /**
     * Toggle SWR's RCM2D bit.
     *
     * Channel 2 Compare match while counting down clear
     */
    inline void toggle_SWR_RCM2D() volatile
    {
        SWR ^= 1u << 5u;
    }

    /**
     * Set SWR's RCM2U bit.
     *
     * Channel 2 Compare match while counting up clear
     */
    inline void set_SWR_RCM2U() volatile
    {
        SWR |= 1u << 4u;
    }

    /**
     * Clear SWR's RCM2U bit.
     *
     * Channel 2 Compare match while counting up clear
     */
    inline void clear_SWR_RCM2U() volatile
    {
        SWR &= ~(1u << 4u);
    }

    /**
     * Toggle SWR's RCM2U bit.
     *
     * Channel 2 Compare match while counting up clear
     */
    inline void toggle_SWR_RCM2U() volatile
    {
        SWR ^= 1u << 4u;
    }

    /**
     * Set SWR's RCM1D bit.
     *
     * Channel 1 Compare match while counting down clear
     */
    inline void set_SWR_RCM1D() volatile
    {
        SWR |= 1u << 3u;
    }

    /**
     * Clear SWR's RCM1D bit.
     *
     * Channel 1 Compare match while counting down clear
     */
    inline void clear_SWR_RCM1D() volatile
    {
        SWR &= ~(1u << 3u);
    }

    /**
     * Toggle SWR's RCM1D bit.
     *
     * Channel 1 Compare match while counting down clear
     */
    inline void toggle_SWR_RCM1D() volatile
    {
        SWR ^= 1u << 3u;
    }

    /**
     * Set SWR's RCM1U bit.
     *
     * Channel 1 Compare match while counting up clear
     */
    inline void set_SWR_RCM1U() volatile
    {
        SWR |= 1u << 2u;
    }

    /**
     * Clear SWR's RCM1U bit.
     *
     * Channel 1 Compare match while counting up clear
     */
    inline void clear_SWR_RCM1U() volatile
    {
        SWR &= ~(1u << 2u);
    }

    /**
     * Toggle SWR's RCM1U bit.
     *
     * Channel 1 Compare match while counting up clear
     */
    inline void toggle_SWR_RCM1U() volatile
    {
        SWR ^= 1u << 2u;
    }

    /**
     * Set SWR's ROM bit.
     *
     * One match while counting down clear
     */
    inline void set_SWR_ROM() volatile
    {
        SWR |= 1u << 1u;
    }

    /**
     * Clear SWR's ROM bit.
     *
     * One match while counting down clear
     */
    inline void clear_SWR_ROM() volatile
    {
        SWR &= ~(1u << 1u);
    }

    /**
     * Toggle SWR's ROM bit.
     *
     * One match while counting down clear
     */
    inline void toggle_SWR_ROM() volatile
    {
        SWR ^= 1u << 1u;
    }

    /**
     * Set SWR's RPM bit.
     *
     * Period match while counting up clear
     */
    inline void set_SWR_RPM() volatile
    {
        SWR |= 1u << 0u;
    }

    /**
     * Clear SWR's RPM bit.
     *
     * Period match while counting up clear
     */
    inline void clear_SWR_RPM() volatile
    {
        SWR &= ~(1u << 0u);
    }

    /**
     * Toggle SWR's RPM bit.
     *
     * Period match while counting up clear
     */
    inline void toggle_SWR_RPM() volatile
    {
        SWR ^= 1u << 0u;
    }

    /**
     * Set all of SWR's bit fields.
     *
     * (write-only) Interrupt Status Clear
     */
    inline void set_SWR(bool RTRPF, bool RE2A, bool RE1A, bool RE0A,
                        bool RCM2D, bool RCM2U, bool RCM1D, bool RCM1U,
                        bool ROM, bool RPM) volatile
    {
        uint32_t curr = SWR;

        curr &= ~(0b1u << 11u);
        curr |= (RTRPF & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (RE2A & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (RE1A & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RE0A & 0b1u) << 8u;
        curr &= ~(0b1u << 5u);
        curr |= (RCM2D & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (RCM2U & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (RCM1D & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (RCM1U & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ROM & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (RPM & 0b1u) << 0u;

        SWR = curr;
    }

    /**
     * Get STC's STM field.
     *
     * Shadow transfer mode
     */
    inline CCU80_CC80_STC_STM get_STC_STM() volatile
    {
        return CCU80_CC80_STC_STM((STC >> 1u) & 0b11u);
    }

    /**
     * Set STC's STM field.
     *
     * Shadow transfer mode
     */
    inline void set_STC_STM(CCU80_CC80_STC_STM value) volatile
    {
        uint32_t curr = STC;

        curr &= ~(0b11u << 1u);
        curr |= (std::to_underlying(value) & 0b11u) << 1u;

        STC = curr;
    }

    /**
     * Get STC's CSE bit.
     *
     * Cascaded shadow transfer enable
     */
    inline bool get_STC_CSE() volatile
    {
        return STC & (1u << 0u);
    }

    /**
     * Set STC's CSE bit.
     *
     * Cascaded shadow transfer enable
     */
    inline void set_STC_CSE() volatile
    {
        STC |= 1u << 0u;
    }

    /**
     * Clear STC's CSE bit.
     *
     * Cascaded shadow transfer enable
     */
    inline void clear_STC_CSE() volatile
    {
        STC &= ~(1u << 0u);
    }

    /**
     * Toggle STC's CSE bit.
     *
     * Cascaded shadow transfer enable
     */
    inline void toggle_STC_CSE() volatile
    {
        STC ^= 1u << 0u;
    }

    /**
     * Get all of STC's bit fields.
     *
     * (read-write) Shadow transfer control
     */
    inline void get_STC(CCU80_CC80_STC_STM &STM, bool &CSE) volatile
    {
        uint32_t curr = STC;

        STM = CCU80_CC80_STC_STM((curr >> 1u) & 0b11u);
        CSE = curr & (1u << 0u);
    }

    /**
     * Set all of STC's bit fields.
     *
     * (read-write) Shadow transfer control
     */
    inline void set_STC(CCU80_CC80_STC_STM STM, bool CSE) volatile
    {
        uint32_t curr = STC;

        curr &= ~(0b11u << 1u);
        curr |= (std::to_underlying(STM) & 0b11u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CSE & 0b1u) << 0u;

        STC = curr;
    }

    /**
     * Get ECRD0's LCV bit.
     *
     * Lost Capture Value
     */
    inline bool get_ECRD0_LCV() volatile
    {
        return ECRD0 & (1u << 25u);
    }

    /**
     * Get ECRD0's FFL bit.
     *
     * Full Flag
     */
    inline bool get_ECRD0_FFL() volatile
    {
        return ECRD0 & (1u << 24u);
    }

    /**
     * Get ECRD0's VPTR field.
     *
     * Capture register pointer
     */
    inline CCU80_CC80_SRS_E1SR get_ECRD0_VPTR() volatile
    {
        return CCU80_CC80_SRS_E1SR((ECRD0 >> 22u) & 0b11u);
    }

    /**
     * Get ECRD0's SPTR field.
     *
     * Slice pointer
     */
    inline CCU80_CC80_SRS_E1SR get_ECRD0_SPTR() volatile
    {
        return CCU80_CC80_SRS_E1SR((ECRD0 >> 20u) & 0b11u);
    }

    /**
     * Get ECRD0's FPCV field.
     *
     * Prescaler Capture value
     */
    inline uint8_t get_ECRD0_FPCV() volatile
    {
        return (ECRD0 >> 16u) & 0b1111u;
    }

    /**
     * Get ECRD0's CAPV field.
     *
     * Timer Capture Value
     */
    inline uint16_t get_ECRD0_CAPV() volatile
    {
        return (ECRD0 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of ECRD0's bit fields.
     *
     * (read-only) Extended Read Back 0
     */
    inline void get_ECRD0(bool &LCV, bool &FFL, CCU80_CC80_SRS_E1SR &VPTR,
                          CCU80_CC80_SRS_E1SR &SPTR, uint8_t &FPCV,
                          uint16_t &CAPV) volatile
    {
        uint32_t curr = ECRD0;

        LCV = curr & (1u << 25u);
        FFL = curr & (1u << 24u);
        VPTR = CCU80_CC80_SRS_E1SR((curr >> 22u) & 0b11u);
        SPTR = CCU80_CC80_SRS_E1SR((curr >> 20u) & 0b11u);
        FPCV = (curr >> 16u) & 0b1111u;
        CAPV = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get ECRD1's LCV bit.
     *
     * Lost Capture Value
     */
    inline bool get_ECRD1_LCV() volatile
    {
        return ECRD1 & (1u << 25u);
    }

    /**
     * Get ECRD1's FFL bit.
     *
     * Full Flag
     */
    inline bool get_ECRD1_FFL() volatile
    {
        return ECRD1 & (1u << 24u);
    }

    /**
     * Get ECRD1's VPTR field.
     *
     * Capture register pointer
     */
    inline CCU80_CC80_SRS_E1SR get_ECRD1_VPTR() volatile
    {
        return CCU80_CC80_SRS_E1SR((ECRD1 >> 22u) & 0b11u);
    }

    /**
     * Get ECRD1's SPTR field.
     *
     * Slice pointer
     */
    inline CCU80_CC80_SRS_E1SR get_ECRD1_SPTR() volatile
    {
        return CCU80_CC80_SRS_E1SR((ECRD1 >> 20u) & 0b11u);
    }

    /**
     * Get ECRD1's FPCV field.
     *
     * Prescaler Capture value
     */
    inline uint8_t get_ECRD1_FPCV() volatile
    {
        return (ECRD1 >> 16u) & 0b1111u;
    }

    /**
     * Get ECRD1's CAPV field.
     *
     * Timer Capture Value
     */
    inline uint16_t get_ECRD1_CAPV() volatile
    {
        return (ECRD1 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of ECRD1's bit fields.
     *
     * (read-only) Extended Read Back 1
     */
    inline void get_ECRD1(bool &LCV, bool &FFL, CCU80_CC80_SRS_E1SR &VPTR,
                          CCU80_CC80_SRS_E1SR &SPTR, uint8_t &FPCV,
                          uint16_t &CAPV) volatile
    {
        uint32_t curr = ECRD1;

        LCV = curr & (1u << 25u);
        FFL = curr & (1u << 24u);
        VPTR = CCU80_CC80_SRS_E1SR((curr >> 22u) & 0b11u);
        SPTR = CCU80_CC80_SRS_E1SR((curr >> 20u) & 0b11u);
        FPCV = (curr >> 16u) & 0b1111u;
        CAPV = (curr >> 0u) & 0b1111111111111111u;
    }
};

static_assert(sizeof(ccu80_cc80) == ccu80_cc80::size);

static volatile ccu80_cc80 *const CCU80_CC80 =
    reinterpret_cast<ccu80_cc80 *>(0x40020100);

static volatile ccu80_cc80 *const CCU80_CC81 =
    reinterpret_cast<ccu80_cc80 *>(0x40020200);

static volatile ccu80_cc80 *const CCU80_CC82 =
    reinterpret_cast<ccu80_cc80 *>(0x40020300);

static volatile ccu80_cc80 *const CCU80_CC83 =
    reinterpret_cast<ccu80_cc80 *>(0x40020400);

static volatile ccu80_cc80 *const CCU81_CC80 =
    reinterpret_cast<ccu80_cc80 *>(0x40024100);

static volatile ccu80_cc80 *const CCU81_CC81 =
    reinterpret_cast<ccu80_cc80 *>(0x40024200);

static volatile ccu80_cc80 *const CCU81_CC82 =
    reinterpret_cast<ccu80_cc80 *>(0x40024300);

static volatile ccu80_cc80 *const CCU81_CC83 =
    reinterpret_cast<ccu80_cc80 *>(0x40024400);

}; // namespace XMC4700
