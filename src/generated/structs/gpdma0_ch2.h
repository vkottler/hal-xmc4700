/**
 * \file
 * \brief Generated by ifgen (3.0.1).
 */
#pragma once

#include "../enums/GPDMA0_CH2_CFGH_FCMODE.h"
#include "../enums/GPDMA0_CH2_CFGH_FIFO_MODE.h"
#include "../enums/GPDMA0_CH2_CFGL_CH_SUSP.h"
#include "../enums/GPDMA0_CH2_CFGL_DST_HS_POL.h"
#include "../enums/GPDMA0_CH2_CFGL_FIFO_EMPTY.h"
#include "../enums/GPDMA0_CH2_CFGL_HS_SEL_DST.h"
#include "../enums/GPDMA0_CH2_CFGL_HS_SEL_SRC.h"
#include "../enums/GPDMA0_CH2_CFGL_LOCK_B_L.h"
#include "../enums/GPDMA0_CH2_CFGL_LOCK_CH_L.h"
#include "../enums/GPDMA0_CH2_CFGL_SRC_HS_POL.h"
#include "../enums/GPDMA0_CH2_CTLL_DINC.h"
#include "../enums/GPDMA0_CH2_CTLL_SINC.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * General Purpose DMA Unit 0
 */
struct [[gnu::packed]] gpdma0_ch2
{
    /* Constant attributes. */
    static constexpr uint16_t id = 1;       /*!< gpdma0_ch2's identifier. */
    static constexpr std::size_t size = 72; /*!< gpdma0_ch2's size in bytes. */

    /* Fields. */
    uint32_t SAR;                                                    /*!< (read-write) Source Address Register */
    const uint32_t reserved_padding0 = {};
    uint32_t DAR;                                                    /*!< (read-write) Destination Address Register */
    static constexpr std::size_t reserved_padding1_length = 3;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t CTLL;                                                   /*!< (read-write) Control Register Low */
    uint32_t CTLH;                                                   /*!< (read-write) Control Register High */
    static constexpr std::size_t reserved_padding2_length = 8;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t CFGL;                                                   /*!< (read-write) Configuration Register Low */
    uint32_t CFGH;                                                   /*!< (read-write) Configuration Register High */

    /* Methods. */

    /**
     * Get SAR's SAR field.
     */
    uint32_t get_SAR_SAR()
    {
        return (SAR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set SAR's SAR field.
     */
    inline void set_SAR_SAR(uint32_t value)
    {
        uint32_t curr = SAR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        SAR = curr;
    }

    /**
     * Get DAR's DAR field.
     */
    uint32_t get_DAR_DAR()
    {
        return (DAR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set DAR's DAR field.
     */
    inline void set_DAR_DAR(uint32_t value)
    {
        uint32_t curr = DAR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DAR = curr;
    }

    /**
     * Get CTLL's INT_EN bit.
     */
    bool get_CTLL_INT_EN()
    {
        return CTLL & (1u << 0u);
    }

    /**
     * Set CTLL's INT_EN bit.
     */
    inline void set_CTLL_INT_EN()
    {
        CTLL |= 1u << 0u;
    }

    /**
     * Clear CTLL's INT_EN bit.
     */
    inline void clear_CTLL_INT_EN()
    {
        CTLL &= ~(1u << 0u);
    }

    /**
     * Toggle CTLL's INT_EN bit.
     */
    inline void toggle_CTLL_INT_EN()
    {
        CTLL ^= 1u << 0u;
    }

    /**
     * Get CTLL's DST_TR_WIDTH field.
     */
    uint8_t get_CTLL_DST_TR_WIDTH()
    {
        return (CTLL >> 1u) & 0b111u;
    }

    /**
     * Set CTLL's DST_TR_WIDTH field.
     */
    inline void set_CTLL_DST_TR_WIDTH(uint8_t value)
    {
        uint32_t curr = CTLL;

        curr &= ~(0b111u << 1u);
        curr |= (value & 0b111u) << 1u;

        CTLL = curr;
    }

    /**
     * Get CTLL's SRC_TR_WIDTH field.
     */
    uint8_t get_CTLL_SRC_TR_WIDTH()
    {
        return (CTLL >> 4u) & 0b111u;
    }

    /**
     * Set CTLL's SRC_TR_WIDTH field.
     */
    inline void set_CTLL_SRC_TR_WIDTH(uint8_t value)
    {
        uint32_t curr = CTLL;

        curr &= ~(0b111u << 4u);
        curr |= (value & 0b111u) << 4u;

        CTLL = curr;
    }

    /**
     * Get CTLL's DINC field.
     */
    GPDMA0_CH2_CTLL_DINC get_CTLL_DINC()
    {
        return GPDMA0_CH2_CTLL_DINC((CTLL >> 7u) & 0b11u);
    }

    /**
     * Set CTLL's DINC field.
     */
    inline void set_CTLL_DINC(GPDMA0_CH2_CTLL_DINC value)
    {
        uint32_t curr = CTLL;

        curr &= ~(0b11u << 7u);
        curr |= (std::to_underlying(value) & 0b11u) << 7u;

        CTLL = curr;
    }

    /**
     * Get CTLL's SINC field.
     */
    GPDMA0_CH2_CTLL_SINC get_CTLL_SINC()
    {
        return GPDMA0_CH2_CTLL_SINC((CTLL >> 9u) & 0b11u);
    }

    /**
     * Set CTLL's SINC field.
     */
    inline void set_CTLL_SINC(GPDMA0_CH2_CTLL_SINC value)
    {
        uint32_t curr = CTLL;

        curr &= ~(0b11u << 9u);
        curr |= (std::to_underlying(value) & 0b11u) << 9u;

        CTLL = curr;
    }

    /**
     * Get CTLL's DEST_MSIZE field.
     */
    uint8_t get_CTLL_DEST_MSIZE()
    {
        return (CTLL >> 11u) & 0b111u;
    }

    /**
     * Set CTLL's DEST_MSIZE field.
     */
    inline void set_CTLL_DEST_MSIZE(uint8_t value)
    {
        uint32_t curr = CTLL;

        curr &= ~(0b111u << 11u);
        curr |= (value & 0b111u) << 11u;

        CTLL = curr;
    }

    /**
     * Get CTLL's SRC_MSIZE field.
     */
    uint8_t get_CTLL_SRC_MSIZE()
    {
        return (CTLL >> 14u) & 0b111u;
    }

    /**
     * Set CTLL's SRC_MSIZE field.
     */
    inline void set_CTLL_SRC_MSIZE(uint8_t value)
    {
        uint32_t curr = CTLL;

        curr &= ~(0b111u << 14u);
        curr |= (value & 0b111u) << 14u;

        CTLL = curr;
    }

    /**
     * Get CTLL's TT_FC field.
     */
    uint8_t get_CTLL_TT_FC()
    {
        return (CTLL >> 20u) & 0b111u;
    }

    /**
     * Set CTLL's TT_FC field.
     */
    inline void set_CTLL_TT_FC(uint8_t value)
    {
        uint32_t curr = CTLL;

        curr &= ~(0b111u << 20u);
        curr |= (value & 0b111u) << 20u;

        CTLL = curr;
    }

    /**
     * Get CTLH's BLOCK_TS field.
     */
    uint16_t get_CTLH_BLOCK_TS()
    {
        return (CTLH >> 0u) & 0b111111111111u;
    }

    /**
     * Set CTLH's BLOCK_TS field.
     */
    inline void set_CTLH_BLOCK_TS(uint16_t value)
    {
        uint32_t curr = CTLH;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        CTLH = curr;
    }

    /**
     * Get CTLH's DONE bit.
     */
    bool get_CTLH_DONE()
    {
        return CTLH & (1u << 12u);
    }

    /**
     * Set CTLH's DONE bit.
     */
    inline void set_CTLH_DONE()
    {
        CTLH |= 1u << 12u;
    }

    /**
     * Clear CTLH's DONE bit.
     */
    inline void clear_CTLH_DONE()
    {
        CTLH &= ~(1u << 12u);
    }

    /**
     * Toggle CTLH's DONE bit.
     */
    inline void toggle_CTLH_DONE()
    {
        CTLH ^= 1u << 12u;
    }

    /**
     * Get CFGL's CH_PRIOR field.
     */
    uint8_t get_CFGL_CH_PRIOR()
    {
        return (CFGL >> 5u) & 0b111u;
    }

    /**
     * Set CFGL's CH_PRIOR field.
     */
    inline void set_CFGL_CH_PRIOR(uint8_t value)
    {
        uint32_t curr = CFGL;

        curr &= ~(0b111u << 5u);
        curr |= (value & 0b111u) << 5u;

        CFGL = curr;
    }

    /**
     * Get CFGL's CH_SUSP bit.
     */
    GPDMA0_CH2_CFGL_CH_SUSP get_CFGL_CH_SUSP()
    {
        return GPDMA0_CH2_CFGL_CH_SUSP(CFGL & (1u << 8u));
    }

    /**
     * Set CFGL's CH_SUSP bit.
     */
    inline void set_CFGL_CH_SUSP()
    {
        CFGL |= 1u << 8u;
    }

    /**
     * Clear CFGL's CH_SUSP bit.
     */
    inline void clear_CFGL_CH_SUSP()
    {
        CFGL &= ~(1u << 8u);
    }

    /**
     * Toggle CFGL's CH_SUSP bit.
     */
    inline void toggle_CFGL_CH_SUSP()
    {
        CFGL ^= 1u << 8u;
    }

    /**
     * Get CFGL's FIFO_EMPTY bit.
     */
    GPDMA0_CH2_CFGL_FIFO_EMPTY get_CFGL_FIFO_EMPTY()
    {
        return GPDMA0_CH2_CFGL_FIFO_EMPTY(CFGL & (1u << 9u));
    }

    /**
     * Get CFGL's HS_SEL_DST bit.
     */
    GPDMA0_CH2_CFGL_HS_SEL_DST get_CFGL_HS_SEL_DST()
    {
        return GPDMA0_CH2_CFGL_HS_SEL_DST(CFGL & (1u << 10u));
    }

    /**
     * Set CFGL's HS_SEL_DST bit.
     */
    inline void set_CFGL_HS_SEL_DST()
    {
        CFGL |= 1u << 10u;
    }

    /**
     * Clear CFGL's HS_SEL_DST bit.
     */
    inline void clear_CFGL_HS_SEL_DST()
    {
        CFGL &= ~(1u << 10u);
    }

    /**
     * Toggle CFGL's HS_SEL_DST bit.
     */
    inline void toggle_CFGL_HS_SEL_DST()
    {
        CFGL ^= 1u << 10u;
    }

    /**
     * Get CFGL's HS_SEL_SRC bit.
     */
    GPDMA0_CH2_CFGL_HS_SEL_SRC get_CFGL_HS_SEL_SRC()
    {
        return GPDMA0_CH2_CFGL_HS_SEL_SRC(CFGL & (1u << 11u));
    }

    /**
     * Set CFGL's HS_SEL_SRC bit.
     */
    inline void set_CFGL_HS_SEL_SRC()
    {
        CFGL |= 1u << 11u;
    }

    /**
     * Clear CFGL's HS_SEL_SRC bit.
     */
    inline void clear_CFGL_HS_SEL_SRC()
    {
        CFGL &= ~(1u << 11u);
    }

    /**
     * Toggle CFGL's HS_SEL_SRC bit.
     */
    inline void toggle_CFGL_HS_SEL_SRC()
    {
        CFGL ^= 1u << 11u;
    }

    /**
     * Get CFGL's LOCK_CH_L field.
     */
    GPDMA0_CH2_CFGL_LOCK_CH_L get_CFGL_LOCK_CH_L()
    {
        return GPDMA0_CH2_CFGL_LOCK_CH_L((CFGL >> 12u) & 0b11u);
    }

    /**
     * Set CFGL's LOCK_CH_L field.
     */
    inline void set_CFGL_LOCK_CH_L(GPDMA0_CH2_CFGL_LOCK_CH_L value)
    {
        uint32_t curr = CFGL;

        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(value) & 0b11u) << 12u;

        CFGL = curr;
    }

    /**
     * Get CFGL's LOCK_B_L field.
     */
    GPDMA0_CH2_CFGL_LOCK_B_L get_CFGL_LOCK_B_L()
    {
        return GPDMA0_CH2_CFGL_LOCK_B_L((CFGL >> 14u) & 0b11u);
    }

    /**
     * Set CFGL's LOCK_B_L field.
     */
    inline void set_CFGL_LOCK_B_L(GPDMA0_CH2_CFGL_LOCK_B_L value)
    {
        uint32_t curr = CFGL;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(value) & 0b11u) << 14u;

        CFGL = curr;
    }

    /**
     * Get CFGL's LOCK_CH bit.
     */
    bool get_CFGL_LOCK_CH()
    {
        return CFGL & (1u << 16u);
    }

    /**
     * Set CFGL's LOCK_CH bit.
     */
    inline void set_CFGL_LOCK_CH()
    {
        CFGL |= 1u << 16u;
    }

    /**
     * Clear CFGL's LOCK_CH bit.
     */
    inline void clear_CFGL_LOCK_CH()
    {
        CFGL &= ~(1u << 16u);
    }

    /**
     * Toggle CFGL's LOCK_CH bit.
     */
    inline void toggle_CFGL_LOCK_CH()
    {
        CFGL ^= 1u << 16u;
    }

    /**
     * Get CFGL's LOCK_B bit.
     */
    bool get_CFGL_LOCK_B()
    {
        return CFGL & (1u << 17u);
    }

    /**
     * Set CFGL's LOCK_B bit.
     */
    inline void set_CFGL_LOCK_B()
    {
        CFGL |= 1u << 17u;
    }

    /**
     * Clear CFGL's LOCK_B bit.
     */
    inline void clear_CFGL_LOCK_B()
    {
        CFGL &= ~(1u << 17u);
    }

    /**
     * Toggle CFGL's LOCK_B bit.
     */
    inline void toggle_CFGL_LOCK_B()
    {
        CFGL ^= 1u << 17u;
    }

    /**
     * Get CFGL's DST_HS_POL bit.
     */
    GPDMA0_CH2_CFGL_DST_HS_POL get_CFGL_DST_HS_POL()
    {
        return GPDMA0_CH2_CFGL_DST_HS_POL(CFGL & (1u << 18u));
    }

    /**
     * Set CFGL's DST_HS_POL bit.
     */
    inline void set_CFGL_DST_HS_POL()
    {
        CFGL |= 1u << 18u;
    }

    /**
     * Clear CFGL's DST_HS_POL bit.
     */
    inline void clear_CFGL_DST_HS_POL()
    {
        CFGL &= ~(1u << 18u);
    }

    /**
     * Toggle CFGL's DST_HS_POL bit.
     */
    inline void toggle_CFGL_DST_HS_POL()
    {
        CFGL ^= 1u << 18u;
    }

    /**
     * Get CFGL's SRC_HS_POL bit.
     */
    GPDMA0_CH2_CFGL_SRC_HS_POL get_CFGL_SRC_HS_POL()
    {
        return GPDMA0_CH2_CFGL_SRC_HS_POL(CFGL & (1u << 19u));
    }

    /**
     * Set CFGL's SRC_HS_POL bit.
     */
    inline void set_CFGL_SRC_HS_POL()
    {
        CFGL |= 1u << 19u;
    }

    /**
     * Clear CFGL's SRC_HS_POL bit.
     */
    inline void clear_CFGL_SRC_HS_POL()
    {
        CFGL &= ~(1u << 19u);
    }

    /**
     * Toggle CFGL's SRC_HS_POL bit.
     */
    inline void toggle_CFGL_SRC_HS_POL()
    {
        CFGL ^= 1u << 19u;
    }

    /**
     * Get CFGL's MAX_ABRST field.
     */
    uint16_t get_CFGL_MAX_ABRST()
    {
        return (CFGL >> 20u) & 0b1111111111u;
    }

    /**
     * Set CFGL's MAX_ABRST field.
     */
    inline void set_CFGL_MAX_ABRST(uint16_t value)
    {
        uint32_t curr = CFGL;

        curr &= ~(0b1111111111u << 20u);
        curr |= (value & 0b1111111111u) << 20u;

        CFGL = curr;
    }

    /**
     * Get CFGH's FCMODE bit.
     */
    GPDMA0_CH2_CFGH_FCMODE get_CFGH_FCMODE()
    {
        return GPDMA0_CH2_CFGH_FCMODE(CFGH & (1u << 0u));
    }

    /**
     * Set CFGH's FCMODE bit.
     */
    inline void set_CFGH_FCMODE()
    {
        CFGH |= 1u << 0u;
    }

    /**
     * Clear CFGH's FCMODE bit.
     */
    inline void clear_CFGH_FCMODE()
    {
        CFGH &= ~(1u << 0u);
    }

    /**
     * Toggle CFGH's FCMODE bit.
     */
    inline void toggle_CFGH_FCMODE()
    {
        CFGH ^= 1u << 0u;
    }

    /**
     * Get CFGH's FIFO_MODE bit.
     */
    GPDMA0_CH2_CFGH_FIFO_MODE get_CFGH_FIFO_MODE()
    {
        return GPDMA0_CH2_CFGH_FIFO_MODE(CFGH & (1u << 1u));
    }

    /**
     * Set CFGH's FIFO_MODE bit.
     */
    inline void set_CFGH_FIFO_MODE()
    {
        CFGH |= 1u << 1u;
    }

    /**
     * Clear CFGH's FIFO_MODE bit.
     */
    inline void clear_CFGH_FIFO_MODE()
    {
        CFGH &= ~(1u << 1u);
    }

    /**
     * Toggle CFGH's FIFO_MODE bit.
     */
    inline void toggle_CFGH_FIFO_MODE()
    {
        CFGH ^= 1u << 1u;
    }

    /**
     * Get CFGH's PROTCTL field.
     */
    uint8_t get_CFGH_PROTCTL()
    {
        return (CFGH >> 2u) & 0b111u;
    }

    /**
     * Set CFGH's PROTCTL field.
     */
    inline void set_CFGH_PROTCTL(uint8_t value)
    {
        uint32_t curr = CFGH;

        curr &= ~(0b111u << 2u);
        curr |= (value & 0b111u) << 2u;

        CFGH = curr;
    }

    /**
     * Get CFGH's SRC_PER field.
     */
    uint8_t get_CFGH_SRC_PER()
    {
        return (CFGH >> 7u) & 0b1111u;
    }

    /**
     * Set CFGH's SRC_PER field.
     */
    inline void set_CFGH_SRC_PER(uint8_t value)
    {
        uint32_t curr = CFGH;

        curr &= ~(0b1111u << 7u);
        curr |= (value & 0b1111u) << 7u;

        CFGH = curr;
    }

    /**
     * Get CFGH's DEST_PER field.
     */
    uint8_t get_CFGH_DEST_PER()
    {
        return (CFGH >> 11u) & 0b1111u;
    }

    /**
     * Set CFGH's DEST_PER field.
     */
    inline void set_CFGH_DEST_PER(uint8_t value)
    {
        uint32_t curr = CFGH;

        curr &= ~(0b1111u << 11u);
        curr |= (value & 0b1111u) << 11u;

        CFGH = curr;
    }
};

static_assert(sizeof(gpdma0_ch2) == gpdma0_ch2::size);

static volatile gpdma0_ch2 *const GPDMA0_CH2 = reinterpret_cast<gpdma0_ch2 *>(0x500140B0);

static volatile gpdma0_ch2 *const GPDMA0_CH3 = reinterpret_cast<gpdma0_ch2 *>(0x50014108);

static volatile gpdma0_ch2 *const GPDMA0_CH4 = reinterpret_cast<gpdma0_ch2 *>(0x50014160);

static volatile gpdma0_ch2 *const GPDMA0_CH5 = reinterpret_cast<gpdma0_ch2 *>(0x500141B8);

static volatile gpdma0_ch2 *const GPDMA0_CH6 = reinterpret_cast<gpdma0_ch2 *>(0x50014210);

static volatile gpdma0_ch2 *const GPDMA0_CH7 = reinterpret_cast<gpdma0_ch2 *>(0x50014268);

}; // namespace XMC4700
