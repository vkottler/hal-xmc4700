/**
 * \file
 * \brief Generated by ifgen (3.1.7).
 */
#pragma once

#include "../enums/LEDTS0_EVFR_CTFF.h"
#include "../enums/LEDTS0_EVFR_CTPF.h"
#include "../enums/LEDTS0_EVFR_CTSF.h"
#include "../enums/LEDTS0_EVFR_TSCTROVF.h"
#include "../enums/LEDTS0_FNCTL_ACCCNT.h"
#include "../enums/LEDTS0_FNCTL_COLLEV.h"
#include "../enums/LEDTS0_FNCTL_EPULL.h"
#include "../enums/LEDTS0_FNCTL_NR_LEDCOL.h"
#include "../enums/LEDTS0_FNCTL_NR_TSIN.h"
#include "../enums/LEDTS0_FNCTL_PADT.h"
#include "../enums/LEDTS0_FNCTL_PADTSW.h"
#include "../enums/LEDTS0_FNCTL_TSCCMP.h"
#include "../enums/LEDTS0_FNCTL_TSCTRR.h"
#include "../enums/LEDTS0_FNCTL_TSCTRSAT.h"
#include "../enums/LEDTS0_FNCTL_TSOEXT.h"
#include "../enums/LEDTS0_GLOBCTL_CMTR.h"
#include "../enums/LEDTS0_GLOBCTL_ENSYNC.h"
#include "../enums/LEDTS0_GLOBCTL_ITF_EN.h"
#include "../enums/LEDTS0_GLOBCTL_ITP_EN.h"
#include "../enums/LEDTS0_GLOBCTL_MASKVAL.h"
#include "../enums/LEDTS0_GLOBCTL_SUSCFG.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * LED and Touch Sense Unit 0
 */
struct [[gnu::packed]] ledts0
{
    /* Constant attributes. */
    static constexpr std::size_t size = 44; /*!< ledts0's size in bytes. */

    /* Fields. */
    const uint32_t ID = {}; /*!< (read-only) Module Identification Register */
    uint32_t GLOBCTL;       /*!< (read-write) Global Control Register */
    uint32_t FNCTL;         /*!< (read-write) Function Control Register */
    uint32_t EVFR;          /*!< (read-write) Event Flag Register */
    uint32_t TSVAL;         /*!< (read-write) Touch-sense TS-Counter Value */
    uint32_t LINE0;         /*!< (read-write) Line Pattern Register 0 */
    uint32_t LINE1;         /*!< (read-write) Line Pattern Register 1 */
    uint32_t LDCMP0;        /*!< (read-write) LED Compare Register 0 */
    uint32_t LDCMP1;        /*!< (read-write) LED Compare Register 1 */
    uint32_t TSCMP0;        /*!< (read-write) Touch-sense Compare Register 0 */
    uint32_t TSCMP1;        /*!< (read-write) Touch-sense Compare Register 1 */

    /* Methods. */

    /**
     * Get ID's MOD_NUMBER field.
     *
     * Module Number Value
     */
    inline uint16_t get_ID_MOD_NUMBER() volatile
    {
        return (ID >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get ID's MOD_TYPE field.
     *
     * Module Type
     */
    inline uint8_t get_ID_MOD_TYPE() volatile
    {
        return (ID >> 8u) & 0b11111111u;
    }

    /**
     * Get ID's MOD_REV field.
     *
     * Module Revision Number
     */
    inline uint8_t get_ID_MOD_REV() volatile
    {
        return (ID >> 0u) & 0b11111111u;
    }

    /**
     * Get all of ID's bit fields.
     *
     * (read-only) Module Identification Register
     */
    inline void get_ID(uint16_t &MOD_NUMBER, uint8_t &MOD_TYPE,
                       uint8_t &MOD_REV) volatile
    {
        uint32_t curr = ID;

        MOD_NUMBER = (curr >> 16u) & 0b1111111111111111u;
        MOD_TYPE = (curr >> 8u) & 0b11111111u;
        MOD_REV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get GLOBCTL's CLK_PS field.
     *
     * LEDTS-Counter Clock Pre-Scale Factor
     */
    inline uint16_t get_GLOBCTL_CLK_PS() volatile
    {
        return (GLOBCTL >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set GLOBCTL's CLK_PS field.
     *
     * LEDTS-Counter Clock Pre-Scale Factor
     */
    inline void set_GLOBCTL_CLK_PS(uint16_t value) volatile
    {
        uint32_t curr = GLOBCTL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        GLOBCTL = curr;
    }

    /**
     * Get GLOBCTL's ITP_EN bit.
     *
     * Enable Autoscan Time Period Interrupt
     */
    inline LEDTS0_GLOBCTL_ITP_EN get_GLOBCTL_ITP_EN() volatile
    {
        return LEDTS0_GLOBCTL_ITP_EN(GLOBCTL & (1u << 15u));
    }

    /**
     * Set GLOBCTL's ITP_EN bit.
     *
     * Enable Autoscan Time Period Interrupt
     */
    inline void set_GLOBCTL_ITP_EN() volatile
    {
        GLOBCTL |= 1u << 15u;
    }

    /**
     * Clear GLOBCTL's ITP_EN bit.
     *
     * Enable Autoscan Time Period Interrupt
     */
    inline void clear_GLOBCTL_ITP_EN() volatile
    {
        GLOBCTL &= ~(1u << 15u);
    }

    /**
     * Toggle GLOBCTL's ITP_EN bit.
     *
     * Enable Autoscan Time Period Interrupt
     */
    inline void toggle_GLOBCTL_ITP_EN() volatile
    {
        GLOBCTL ^= 1u << 15u;
    }

    /**
     * Get GLOBCTL's ITF_EN bit.
     *
     * Enable (Extended) Time Frame Interrupt
     */
    inline LEDTS0_GLOBCTL_ITF_EN get_GLOBCTL_ITF_EN() volatile
    {
        return LEDTS0_GLOBCTL_ITF_EN(GLOBCTL & (1u << 14u));
    }

    /**
     * Set GLOBCTL's ITF_EN bit.
     *
     * Enable (Extended) Time Frame Interrupt
     */
    inline void set_GLOBCTL_ITF_EN() volatile
    {
        GLOBCTL |= 1u << 14u;
    }

    /**
     * Clear GLOBCTL's ITF_EN bit.
     *
     * Enable (Extended) Time Frame Interrupt
     */
    inline void clear_GLOBCTL_ITF_EN() volatile
    {
        GLOBCTL &= ~(1u << 14u);
    }

    /**
     * Toggle GLOBCTL's ITF_EN bit.
     *
     * Enable (Extended) Time Frame Interrupt
     */
    inline void toggle_GLOBCTL_ITF_EN() volatile
    {
        GLOBCTL ^= 1u << 14u;
    }

    /**
     * Get GLOBCTL's ITS_EN bit.
     *
     * Enable Time Slice Interrupt
     */
    inline LEDTS0_GLOBCTL_ITF_EN get_GLOBCTL_ITS_EN() volatile
    {
        return LEDTS0_GLOBCTL_ITF_EN(GLOBCTL & (1u << 13u));
    }

    /**
     * Set GLOBCTL's ITS_EN bit.
     *
     * Enable Time Slice Interrupt
     */
    inline void set_GLOBCTL_ITS_EN() volatile
    {
        GLOBCTL |= 1u << 13u;
    }

    /**
     * Clear GLOBCTL's ITS_EN bit.
     *
     * Enable Time Slice Interrupt
     */
    inline void clear_GLOBCTL_ITS_EN() volatile
    {
        GLOBCTL &= ~(1u << 13u);
    }

    /**
     * Toggle GLOBCTL's ITS_EN bit.
     *
     * Enable Time Slice Interrupt
     */
    inline void toggle_GLOBCTL_ITS_EN() volatile
    {
        GLOBCTL ^= 1u << 13u;
    }

    /**
     * Get GLOBCTL's FENVAL bit.
     *
     * Enable (Extended) Time Frame Validation
     */
    inline LEDTS0_GLOBCTL_ITF_EN get_GLOBCTL_FENVAL() volatile
    {
        return LEDTS0_GLOBCTL_ITF_EN(GLOBCTL & (1u << 12u));
    }

    /**
     * Set GLOBCTL's FENVAL bit.
     *
     * Enable (Extended) Time Frame Validation
     */
    inline void set_GLOBCTL_FENVAL() volatile
    {
        GLOBCTL |= 1u << 12u;
    }

    /**
     * Clear GLOBCTL's FENVAL bit.
     *
     * Enable (Extended) Time Frame Validation
     */
    inline void clear_GLOBCTL_FENVAL() volatile
    {
        GLOBCTL &= ~(1u << 12u);
    }

    /**
     * Toggle GLOBCTL's FENVAL bit.
     *
     * Enable (Extended) Time Frame Validation
     */
    inline void toggle_GLOBCTL_FENVAL() volatile
    {
        GLOBCTL ^= 1u << 12u;
    }

    /**
     * Get GLOBCTL's MASKVAL field.
     *
     * Mask Number of LSB Bits for Event Validation
     */
    inline LEDTS0_GLOBCTL_MASKVAL get_GLOBCTL_MASKVAL() volatile
    {
        return LEDTS0_GLOBCTL_MASKVAL((GLOBCTL >> 9u) & 0b111u);
    }

    /**
     * Set GLOBCTL's MASKVAL field.
     *
     * Mask Number of LSB Bits for Event Validation
     */
    inline void set_GLOBCTL_MASKVAL(LEDTS0_GLOBCTL_MASKVAL value) volatile
    {
        uint32_t curr = GLOBCTL;

        curr &= ~(0b111u << 9u);
        curr |= (std::to_underlying(value) & 0b111u) << 9u;

        GLOBCTL = curr;
    }

    /**
     * Get GLOBCTL's SUSCFG bit.
     *
     * Suspend Request Configuration
     */
    inline LEDTS0_GLOBCTL_SUSCFG get_GLOBCTL_SUSCFG() volatile
    {
        return LEDTS0_GLOBCTL_SUSCFG(GLOBCTL & (1u << 8u));
    }

    /**
     * Set GLOBCTL's SUSCFG bit.
     *
     * Suspend Request Configuration
     */
    inline void set_GLOBCTL_SUSCFG() volatile
    {
        GLOBCTL |= 1u << 8u;
    }

    /**
     * Clear GLOBCTL's SUSCFG bit.
     *
     * Suspend Request Configuration
     */
    inline void clear_GLOBCTL_SUSCFG() volatile
    {
        GLOBCTL &= ~(1u << 8u);
    }

    /**
     * Toggle GLOBCTL's SUSCFG bit.
     *
     * Suspend Request Configuration
     */
    inline void toggle_GLOBCTL_SUSCFG() volatile
    {
        GLOBCTL ^= 1u << 8u;
    }

    /**
     * Get GLOBCTL's ENSYNC bit.
     *
     * Enable Autoscan Time Period Synchronization
     */
    inline LEDTS0_GLOBCTL_ENSYNC get_GLOBCTL_ENSYNC() volatile
    {
        return LEDTS0_GLOBCTL_ENSYNC(GLOBCTL & (1u << 3u));
    }

    /**
     * Set GLOBCTL's ENSYNC bit.
     *
     * Enable Autoscan Time Period Synchronization
     */
    inline void set_GLOBCTL_ENSYNC() volatile
    {
        GLOBCTL |= 1u << 3u;
    }

    /**
     * Clear GLOBCTL's ENSYNC bit.
     *
     * Enable Autoscan Time Period Synchronization
     */
    inline void clear_GLOBCTL_ENSYNC() volatile
    {
        GLOBCTL &= ~(1u << 3u);
    }

    /**
     * Toggle GLOBCTL's ENSYNC bit.
     *
     * Enable Autoscan Time Period Synchronization
     */
    inline void toggle_GLOBCTL_ENSYNC() volatile
    {
        GLOBCTL ^= 1u << 3u;
    }

    /**
     * Get GLOBCTL's CMTR bit.
     *
     * Clock Master Disable
     */
    inline LEDTS0_GLOBCTL_CMTR get_GLOBCTL_CMTR() volatile
    {
        return LEDTS0_GLOBCTL_CMTR(GLOBCTL & (1u << 2u));
    }

    /**
     * Set GLOBCTL's CMTR bit.
     *
     * Clock Master Disable
     */
    inline void set_GLOBCTL_CMTR() volatile
    {
        GLOBCTL |= 1u << 2u;
    }

    /**
     * Clear GLOBCTL's CMTR bit.
     *
     * Clock Master Disable
     */
    inline void clear_GLOBCTL_CMTR() volatile
    {
        GLOBCTL &= ~(1u << 2u);
    }

    /**
     * Toggle GLOBCTL's CMTR bit.
     *
     * Clock Master Disable
     */
    inline void toggle_GLOBCTL_CMTR() volatile
    {
        GLOBCTL ^= 1u << 2u;
    }

    /**
     * Get GLOBCTL's LD_EN bit.
     *
     * LED Function Enable
     */
    inline bool get_GLOBCTL_LD_EN() volatile
    {
        return GLOBCTL & (1u << 1u);
    }

    /**
     * Set GLOBCTL's LD_EN bit.
     *
     * LED Function Enable
     */
    inline void set_GLOBCTL_LD_EN() volatile
    {
        GLOBCTL |= 1u << 1u;
    }

    /**
     * Clear GLOBCTL's LD_EN bit.
     *
     * LED Function Enable
     */
    inline void clear_GLOBCTL_LD_EN() volatile
    {
        GLOBCTL &= ~(1u << 1u);
    }

    /**
     * Toggle GLOBCTL's LD_EN bit.
     *
     * LED Function Enable
     */
    inline void toggle_GLOBCTL_LD_EN() volatile
    {
        GLOBCTL ^= 1u << 1u;
    }

    /**
     * Get GLOBCTL's TS_EN bit.
     *
     * Touch-Sense Function Enable
     */
    inline bool get_GLOBCTL_TS_EN() volatile
    {
        return GLOBCTL & (1u << 0u);
    }

    /**
     * Set GLOBCTL's TS_EN bit.
     *
     * Touch-Sense Function Enable
     */
    inline void set_GLOBCTL_TS_EN() volatile
    {
        GLOBCTL |= 1u << 0u;
    }

    /**
     * Clear GLOBCTL's TS_EN bit.
     *
     * Touch-Sense Function Enable
     */
    inline void clear_GLOBCTL_TS_EN() volatile
    {
        GLOBCTL &= ~(1u << 0u);
    }

    /**
     * Toggle GLOBCTL's TS_EN bit.
     *
     * Touch-Sense Function Enable
     */
    inline void toggle_GLOBCTL_TS_EN() volatile
    {
        GLOBCTL ^= 1u << 0u;
    }

    /**
     * Get all of GLOBCTL's bit fields.
     *
     * (read-write) Global Control Register
     */
    inline void get_GLOBCTL(
        uint16_t &CLK_PS, LEDTS0_GLOBCTL_ITP_EN &ITP_EN,
        LEDTS0_GLOBCTL_ITF_EN &ITF_EN, LEDTS0_GLOBCTL_ITF_EN &ITS_EN,
        LEDTS0_GLOBCTL_ITF_EN &FENVAL, LEDTS0_GLOBCTL_MASKVAL &MASKVAL,
        LEDTS0_GLOBCTL_SUSCFG &SUSCFG, LEDTS0_GLOBCTL_ENSYNC &ENSYNC,
        LEDTS0_GLOBCTL_CMTR &CMTR, bool &LD_EN, bool &TS_EN) volatile
    {
        uint32_t curr = GLOBCTL;

        CLK_PS = (curr >> 16u) & 0b1111111111111111u;
        ITP_EN = LEDTS0_GLOBCTL_ITP_EN(curr & (1u << 15u));
        ITF_EN = LEDTS0_GLOBCTL_ITF_EN(curr & (1u << 14u));
        ITS_EN = LEDTS0_GLOBCTL_ITF_EN(curr & (1u << 13u));
        FENVAL = LEDTS0_GLOBCTL_ITF_EN(curr & (1u << 12u));
        MASKVAL = LEDTS0_GLOBCTL_MASKVAL((curr >> 9u) & 0b111u);
        SUSCFG = LEDTS0_GLOBCTL_SUSCFG(curr & (1u << 8u));
        ENSYNC = LEDTS0_GLOBCTL_ENSYNC(curr & (1u << 3u));
        CMTR = LEDTS0_GLOBCTL_CMTR(curr & (1u << 2u));
        LD_EN = curr & (1u << 1u);
        TS_EN = curr & (1u << 0u);
    }

    /**
     * Set all of GLOBCTL's bit fields.
     *
     * (read-write) Global Control Register
     */
    inline void set_GLOBCTL(
        uint16_t CLK_PS, LEDTS0_GLOBCTL_ITP_EN ITP_EN,
        LEDTS0_GLOBCTL_ITF_EN ITF_EN, LEDTS0_GLOBCTL_ITF_EN ITS_EN,
        LEDTS0_GLOBCTL_ITF_EN FENVAL, LEDTS0_GLOBCTL_MASKVAL MASKVAL,
        LEDTS0_GLOBCTL_SUSCFG SUSCFG, LEDTS0_GLOBCTL_ENSYNC ENSYNC,
        LEDTS0_GLOBCTL_CMTR CMTR, bool LD_EN, bool TS_EN) volatile
    {
        uint32_t curr = GLOBCTL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (CLK_PS & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (std::to_underlying(ITP_EN) & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (std::to_underlying(ITF_EN) & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (std::to_underlying(ITS_EN) & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (std::to_underlying(FENVAL) & 0b1u) << 12u;
        curr &= ~(0b111u << 9u);
        curr |= (std::to_underlying(MASKVAL) & 0b111u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (std::to_underlying(SUSCFG) & 0b1u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(ENSYNC) & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (std::to_underlying(CMTR) & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (LD_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TS_EN & 0b1u) << 0u;

        GLOBCTL = curr;
    }

    /**
     * Get FNCTL's NR_LEDCOL field.
     *
     * Number of LED Columns
     */
    inline LEDTS0_FNCTL_NR_LEDCOL get_FNCTL_NR_LEDCOL() volatile
    {
        return LEDTS0_FNCTL_NR_LEDCOL((FNCTL >> 29u) & 0b111u);
    }

    /**
     * Set FNCTL's NR_LEDCOL field.
     *
     * Number of LED Columns
     */
    inline void set_FNCTL_NR_LEDCOL(LEDTS0_FNCTL_NR_LEDCOL value) volatile
    {
        uint32_t curr = FNCTL;

        curr &= ~(0b111u << 29u);
        curr |= (std::to_underlying(value) & 0b111u) << 29u;

        FNCTL = curr;
    }

    /**
     * Get FNCTL's COLLEV bit.
     *
     * Active Level of LED Column
     */
    inline LEDTS0_FNCTL_COLLEV get_FNCTL_COLLEV() volatile
    {
        return LEDTS0_FNCTL_COLLEV(FNCTL & (1u << 28u));
    }

    /**
     * Set FNCTL's COLLEV bit.
     *
     * Active Level of LED Column
     */
    inline void set_FNCTL_COLLEV() volatile
    {
        FNCTL |= 1u << 28u;
    }

    /**
     * Clear FNCTL's COLLEV bit.
     *
     * Active Level of LED Column
     */
    inline void clear_FNCTL_COLLEV() volatile
    {
        FNCTL &= ~(1u << 28u);
    }

    /**
     * Toggle FNCTL's COLLEV bit.
     *
     * Active Level of LED Column
     */
    inline void toggle_FNCTL_COLLEV() volatile
    {
        FNCTL ^= 1u << 28u;
    }

    /**
     * Get FNCTL's NR_TSIN field.
     *
     * Number of Touch-Sense Input
     */
    inline LEDTS0_FNCTL_NR_TSIN get_FNCTL_NR_TSIN() volatile
    {
        return LEDTS0_FNCTL_NR_TSIN((FNCTL >> 25u) & 0b111u);
    }

    /**
     * Set FNCTL's NR_TSIN field.
     *
     * Number of Touch-Sense Input
     */
    inline void set_FNCTL_NR_TSIN(LEDTS0_FNCTL_NR_TSIN value) volatile
    {
        uint32_t curr = FNCTL;

        curr &= ~(0b111u << 25u);
        curr |= (std::to_underlying(value) & 0b111u) << 25u;

        FNCTL = curr;
    }

    /**
     * Get FNCTL's TSCTRSAT bit.
     *
     * Saturation of TS-Counter
     */
    inline LEDTS0_FNCTL_TSCTRSAT get_FNCTL_TSCTRSAT() volatile
    {
        return LEDTS0_FNCTL_TSCTRSAT(FNCTL & (1u << 24u));
    }

    /**
     * Set FNCTL's TSCTRSAT bit.
     *
     * Saturation of TS-Counter
     */
    inline void set_FNCTL_TSCTRSAT() volatile
    {
        FNCTL |= 1u << 24u;
    }

    /**
     * Clear FNCTL's TSCTRSAT bit.
     *
     * Saturation of TS-Counter
     */
    inline void clear_FNCTL_TSCTRSAT() volatile
    {
        FNCTL &= ~(1u << 24u);
    }

    /**
     * Toggle FNCTL's TSCTRSAT bit.
     *
     * Saturation of TS-Counter
     */
    inline void toggle_FNCTL_TSCTRSAT() volatile
    {
        FNCTL ^= 1u << 24u;
    }

    /**
     * Get FNCTL's TSCTRR bit.
     *
     * TS-Counter Auto Reset
     */
    inline LEDTS0_FNCTL_TSCTRR get_FNCTL_TSCTRR() volatile
    {
        return LEDTS0_FNCTL_TSCTRR(FNCTL & (1u << 23u));
    }

    /**
     * Set FNCTL's TSCTRR bit.
     *
     * TS-Counter Auto Reset
     */
    inline void set_FNCTL_TSCTRR() volatile
    {
        FNCTL |= 1u << 23u;
    }

    /**
     * Clear FNCTL's TSCTRR bit.
     *
     * TS-Counter Auto Reset
     */
    inline void clear_FNCTL_TSCTRR() volatile
    {
        FNCTL &= ~(1u << 23u);
    }

    /**
     * Toggle FNCTL's TSCTRR bit.
     *
     * TS-Counter Auto Reset
     */
    inline void toggle_FNCTL_TSCTRR() volatile
    {
        FNCTL ^= 1u << 23u;
    }

    /**
     * Get FNCTL's TSOEXT field.
     *
     * Extension for Touch-Sense Output for Pin-Low-Level
     */
    inline LEDTS0_FNCTL_TSOEXT get_FNCTL_TSOEXT() volatile
    {
        return LEDTS0_FNCTL_TSOEXT((FNCTL >> 21u) & 0b11u);
    }

    /**
     * Set FNCTL's TSOEXT field.
     *
     * Extension for Touch-Sense Output for Pin-Low-Level
     */
    inline void set_FNCTL_TSOEXT(LEDTS0_FNCTL_TSOEXT value) volatile
    {
        uint32_t curr = FNCTL;

        curr &= ~(0b11u << 21u);
        curr |= (std::to_underlying(value) & 0b11u) << 21u;

        FNCTL = curr;
    }

    /**
     * Get FNCTL's TSCCMP bit.
     *
     * Common Compare Enable for Touch-Sense
     */
    inline LEDTS0_FNCTL_TSCCMP get_FNCTL_TSCCMP() volatile
    {
        return LEDTS0_FNCTL_TSCCMP(FNCTL & (1u << 20u));
    }

    /**
     * Set FNCTL's TSCCMP bit.
     *
     * Common Compare Enable for Touch-Sense
     */
    inline void set_FNCTL_TSCCMP() volatile
    {
        FNCTL |= 1u << 20u;
    }

    /**
     * Clear FNCTL's TSCCMP bit.
     *
     * Common Compare Enable for Touch-Sense
     */
    inline void clear_FNCTL_TSCCMP() volatile
    {
        FNCTL &= ~(1u << 20u);
    }

    /**
     * Toggle FNCTL's TSCCMP bit.
     *
     * Common Compare Enable for Touch-Sense
     */
    inline void toggle_FNCTL_TSCCMP() volatile
    {
        FNCTL ^= 1u << 20u;
    }

    /**
     * Get FNCTL's ACCCNT field.
     *
     * Accumulate Count on Touch-Sense Input
     */
    inline LEDTS0_FNCTL_ACCCNT get_FNCTL_ACCCNT() volatile
    {
        return LEDTS0_FNCTL_ACCCNT((FNCTL >> 16u) & 0b1111u);
    }

    /**
     * Set FNCTL's ACCCNT field.
     *
     * Accumulate Count on Touch-Sense Input
     */
    inline void set_FNCTL_ACCCNT(LEDTS0_FNCTL_ACCCNT value) volatile
    {
        uint32_t curr = FNCTL;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        FNCTL = curr;
    }

    /**
     * Get FNCTL's FNCOL field.
     *
     * Previous Active Function/LED Column Status
     */
    inline uint8_t get_FNCTL_FNCOL() volatile
    {
        return (FNCTL >> 5u) & 0b111u;
    }

    /**
     * Get FNCTL's EPULL bit.
     *
     * Enable External Pull-up Configuration on Pin COLA
     */
    inline LEDTS0_FNCTL_EPULL get_FNCTL_EPULL() volatile
    {
        return LEDTS0_FNCTL_EPULL(FNCTL & (1u << 4u));
    }

    /**
     * Set FNCTL's EPULL bit.
     *
     * Enable External Pull-up Configuration on Pin COLA
     */
    inline void set_FNCTL_EPULL() volatile
    {
        FNCTL |= 1u << 4u;
    }

    /**
     * Clear FNCTL's EPULL bit.
     *
     * Enable External Pull-up Configuration on Pin COLA
     */
    inline void clear_FNCTL_EPULL() volatile
    {
        FNCTL &= ~(1u << 4u);
    }

    /**
     * Toggle FNCTL's EPULL bit.
     *
     * Enable External Pull-up Configuration on Pin COLA
     */
    inline void toggle_FNCTL_EPULL() volatile
    {
        FNCTL ^= 1u << 4u;
    }

    /**
     * Get FNCTL's PADTSW bit.
     *
     * Software Control for Touch-Sense Pad Turn
     */
    inline LEDTS0_FNCTL_PADTSW get_FNCTL_PADTSW() volatile
    {
        return LEDTS0_FNCTL_PADTSW(FNCTL & (1u << 3u));
    }

    /**
     * Set FNCTL's PADTSW bit.
     *
     * Software Control for Touch-Sense Pad Turn
     */
    inline void set_FNCTL_PADTSW() volatile
    {
        FNCTL |= 1u << 3u;
    }

    /**
     * Clear FNCTL's PADTSW bit.
     *
     * Software Control for Touch-Sense Pad Turn
     */
    inline void clear_FNCTL_PADTSW() volatile
    {
        FNCTL &= ~(1u << 3u);
    }

    /**
     * Toggle FNCTL's PADTSW bit.
     *
     * Software Control for Touch-Sense Pad Turn
     */
    inline void toggle_FNCTL_PADTSW() volatile
    {
        FNCTL ^= 1u << 3u;
    }

    /**
     * Get FNCTL's PADT field.
     *
     * Touch-Sense TSIN Pad Turn
     */
    inline LEDTS0_FNCTL_PADT get_FNCTL_PADT() volatile
    {
        return LEDTS0_FNCTL_PADT((FNCTL >> 0u) & 0b111u);
    }

    /**
     * Set FNCTL's PADT field.
     *
     * Touch-Sense TSIN Pad Turn
     */
    inline void set_FNCTL_PADT(LEDTS0_FNCTL_PADT value) volatile
    {
        uint32_t curr = FNCTL;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        FNCTL = curr;
    }

    /**
     * Get all of FNCTL's bit fields.
     *
     * (read-write) Function Control Register
     */
    inline void get_FNCTL(
        LEDTS0_FNCTL_NR_LEDCOL &NR_LEDCOL, LEDTS0_FNCTL_COLLEV &COLLEV,
        LEDTS0_FNCTL_NR_TSIN &NR_TSIN, LEDTS0_FNCTL_TSCTRSAT &TSCTRSAT,
        LEDTS0_FNCTL_TSCTRR &TSCTRR, LEDTS0_FNCTL_TSOEXT &TSOEXT,
        LEDTS0_FNCTL_TSCCMP &TSCCMP, LEDTS0_FNCTL_ACCCNT &ACCCNT,
        uint8_t &FNCOL, LEDTS0_FNCTL_EPULL &EPULL, LEDTS0_FNCTL_PADTSW &PADTSW,
        LEDTS0_FNCTL_PADT &PADT) volatile
    {
        uint32_t curr = FNCTL;

        NR_LEDCOL = LEDTS0_FNCTL_NR_LEDCOL((curr >> 29u) & 0b111u);
        COLLEV = LEDTS0_FNCTL_COLLEV(curr & (1u << 28u));
        NR_TSIN = LEDTS0_FNCTL_NR_TSIN((curr >> 25u) & 0b111u);
        TSCTRSAT = LEDTS0_FNCTL_TSCTRSAT(curr & (1u << 24u));
        TSCTRR = LEDTS0_FNCTL_TSCTRR(curr & (1u << 23u));
        TSOEXT = LEDTS0_FNCTL_TSOEXT((curr >> 21u) & 0b11u);
        TSCCMP = LEDTS0_FNCTL_TSCCMP(curr & (1u << 20u));
        ACCCNT = LEDTS0_FNCTL_ACCCNT((curr >> 16u) & 0b1111u);
        FNCOL = (curr >> 5u) & 0b111u;
        EPULL = LEDTS0_FNCTL_EPULL(curr & (1u << 4u));
        PADTSW = LEDTS0_FNCTL_PADTSW(curr & (1u << 3u));
        PADT = LEDTS0_FNCTL_PADT((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of FNCTL's bit fields.
     *
     * (read-write) Function Control Register
     */
    inline void set_FNCTL(
        LEDTS0_FNCTL_NR_LEDCOL NR_LEDCOL, LEDTS0_FNCTL_COLLEV COLLEV,
        LEDTS0_FNCTL_NR_TSIN NR_TSIN, LEDTS0_FNCTL_TSCTRSAT TSCTRSAT,
        LEDTS0_FNCTL_TSCTRR TSCTRR, LEDTS0_FNCTL_TSOEXT TSOEXT,
        LEDTS0_FNCTL_TSCCMP TSCCMP, LEDTS0_FNCTL_ACCCNT ACCCNT,
        LEDTS0_FNCTL_EPULL EPULL, LEDTS0_FNCTL_PADTSW PADTSW,
        LEDTS0_FNCTL_PADT PADT) volatile
    {
        uint32_t curr = FNCTL;

        curr &= ~(0b111u << 29u);
        curr |= (std::to_underlying(NR_LEDCOL) & 0b111u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (std::to_underlying(COLLEV) & 0b1u) << 28u;
        curr &= ~(0b111u << 25u);
        curr |= (std::to_underlying(NR_TSIN) & 0b111u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (std::to_underlying(TSCTRSAT) & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (std::to_underlying(TSCTRR) & 0b1u) << 23u;
        curr &= ~(0b11u << 21u);
        curr |= (std::to_underlying(TSOEXT) & 0b11u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (std::to_underlying(TSCCMP) & 0b1u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(ACCCNT) & 0b1111u) << 16u;
        curr &= ~(0b1u << 4u);
        curr |= (std::to_underlying(EPULL) & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(PADTSW) & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(PADT) & 0b111u) << 0u;

        FNCTL = curr;
    }

    /**
     * Set EVFR's CTPF bit.
     *
     * Clear Autoscan Time Period Interrupt Flag
     */
    inline void set_EVFR_CTPF() volatile
    {
        EVFR |= 1u << 18u;
    }

    /**
     * Clear EVFR's CTPF bit.
     *
     * Clear Autoscan Time Period Interrupt Flag
     */
    inline void clear_EVFR_CTPF() volatile
    {
        EVFR &= ~(1u << 18u);
    }

    /**
     * Toggle EVFR's CTPF bit.
     *
     * Clear Autoscan Time Period Interrupt Flag
     */
    inline void toggle_EVFR_CTPF() volatile
    {
        EVFR ^= 1u << 18u;
    }

    /**
     * Set EVFR's CTFF bit.
     *
     * Clear (Extended) Time Frame Interrupt Flag
     */
    inline void set_EVFR_CTFF() volatile
    {
        EVFR |= 1u << 17u;
    }

    /**
     * Clear EVFR's CTFF bit.
     *
     * Clear (Extended) Time Frame Interrupt Flag
     */
    inline void clear_EVFR_CTFF() volatile
    {
        EVFR &= ~(1u << 17u);
    }

    /**
     * Toggle EVFR's CTFF bit.
     *
     * Clear (Extended) Time Frame Interrupt Flag
     */
    inline void toggle_EVFR_CTFF() volatile
    {
        EVFR ^= 1u << 17u;
    }

    /**
     * Set EVFR's CTSF bit.
     *
     * Clear Time Slice Interrupt Flag
     */
    inline void set_EVFR_CTSF() volatile
    {
        EVFR |= 1u << 16u;
    }

    /**
     * Clear EVFR's CTSF bit.
     *
     * Clear Time Slice Interrupt Flag
     */
    inline void clear_EVFR_CTSF() volatile
    {
        EVFR &= ~(1u << 16u);
    }

    /**
     * Toggle EVFR's CTSF bit.
     *
     * Clear Time Slice Interrupt Flag
     */
    inline void toggle_EVFR_CTSF() volatile
    {
        EVFR ^= 1u << 16u;
    }

    /**
     * Get EVFR's TSCTROVF bit.
     *
     * TS-Counter Overflow Indication
     */
    inline LEDTS0_EVFR_TSCTROVF get_EVFR_TSCTROVF() volatile
    {
        return LEDTS0_EVFR_TSCTROVF(EVFR & (1u << 3u));
    }

    /**
     * Get EVFR's TPF bit.
     *
     * Autoscan Time Period Interrupt Flag
     */
    inline bool get_EVFR_TPF() volatile
    {
        return EVFR & (1u << 2u);
    }

    /**
     * Get EVFR's TFF bit.
     *
     * (Extended) Time Frame Interrupt Flag
     */
    inline bool get_EVFR_TFF() volatile
    {
        return EVFR & (1u << 1u);
    }

    /**
     * Get EVFR's TSF bit.
     *
     * Time Slice Interrupt Flag
     */
    inline bool get_EVFR_TSF() volatile
    {
        return EVFR & (1u << 0u);
    }

    /**
     * Get all of EVFR's bit fields.
     *
     * (read-write) Event Flag Register
     */
    inline void get_EVFR(LEDTS0_EVFR_TSCTROVF &TSCTROVF, bool &TPF, bool &TFF,
                         bool &TSF) volatile
    {
        uint32_t curr = EVFR;

        TSCTROVF = LEDTS0_EVFR_TSCTROVF(curr & (1u << 3u));
        TPF = curr & (1u << 2u);
        TFF = curr & (1u << 1u);
        TSF = curr & (1u << 0u);
    }

    /**
     * Set all of EVFR's bit fields.
     *
     * (read-write) Event Flag Register
     */
    inline void set_EVFR(LEDTS0_EVFR_CTPF CTPF, LEDTS0_EVFR_CTFF CTFF,
                         LEDTS0_EVFR_CTSF CTSF) volatile
    {
        uint32_t curr = EVFR;

        curr &= ~(0b1u << 18u);
        curr |= (std::to_underlying(CTPF) & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(CTFF) & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (std::to_underlying(CTSF) & 0b1u) << 16u;

        EVFR = curr;
    }

    /**
     * Get TSVAL's TSCTRVAL field.
     *
     * TS-Counter Value
     */
    inline uint16_t get_TSVAL_TSCTRVAL() volatile
    {
        return (TSVAL >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set TSVAL's TSCTRVAL field.
     *
     * TS-Counter Value
     */
    inline void set_TSVAL_TSCTRVAL(uint16_t value) volatile
    {
        uint32_t curr = TSVAL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        TSVAL = curr;
    }

    /**
     * Get TSVAL's TSCTRVALR field.
     *
     * Shadow TS-Counter (Read)
     */
    inline uint16_t get_TSVAL_TSCTRVALR() volatile
    {
        return (TSVAL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of TSVAL's bit fields.
     *
     * (read-write) Touch-sense TS-Counter Value
     */
    inline void get_TSVAL(uint16_t &TSCTRVAL, uint16_t &TSCTRVALR) volatile
    {
        uint32_t curr = TSVAL;

        TSCTRVAL = (curr >> 16u) & 0b1111111111111111u;
        TSCTRVALR = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get LINE0's LINE_3 field.
     *
     * Output on LINE[x]
     */
    inline uint8_t get_LINE0_LINE_3() volatile
    {
        return (LINE0 >> 24u) & 0b11111111u;
    }

    /**
     * Set LINE0's LINE_3 field.
     *
     * Output on LINE[x]
     */
    inline void set_LINE0_LINE_3(uint8_t value) volatile
    {
        uint32_t curr = LINE0;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        LINE0 = curr;
    }

    /**
     * Get LINE0's LINE_2 field.
     *
     * Output on LINE[x]
     */
    inline uint8_t get_LINE0_LINE_2() volatile
    {
        return (LINE0 >> 16u) & 0b11111111u;
    }

    /**
     * Set LINE0's LINE_2 field.
     *
     * Output on LINE[x]
     */
    inline void set_LINE0_LINE_2(uint8_t value) volatile
    {
        uint32_t curr = LINE0;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        LINE0 = curr;
    }

    /**
     * Get LINE0's LINE_1 field.
     *
     * Output on LINE[x]
     */
    inline uint8_t get_LINE0_LINE_1() volatile
    {
        return (LINE0 >> 8u) & 0b11111111u;
    }

    /**
     * Set LINE0's LINE_1 field.
     *
     * Output on LINE[x]
     */
    inline void set_LINE0_LINE_1(uint8_t value) volatile
    {
        uint32_t curr = LINE0;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        LINE0 = curr;
    }

    /**
     * Get LINE0's LINE_0 field.
     *
     * Output on LINE[x]
     */
    inline uint8_t get_LINE0_LINE_0() volatile
    {
        return (LINE0 >> 0u) & 0b11111111u;
    }

    /**
     * Set LINE0's LINE_0 field.
     *
     * Output on LINE[x]
     */
    inline void set_LINE0_LINE_0(uint8_t value) volatile
    {
        uint32_t curr = LINE0;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        LINE0 = curr;
    }

    /**
     * Get all of LINE0's bit fields.
     *
     * (read-write) Line Pattern Register 0
     */
    inline void get_LINE0(uint8_t &LINE_3, uint8_t &LINE_2, uint8_t &LINE_1,
                          uint8_t &LINE_0) volatile
    {
        uint32_t curr = LINE0;

        LINE_3 = (curr >> 24u) & 0b11111111u;
        LINE_2 = (curr >> 16u) & 0b11111111u;
        LINE_1 = (curr >> 8u) & 0b11111111u;
        LINE_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of LINE0's bit fields.
     *
     * (read-write) Line Pattern Register 0
     */
    inline void set_LINE0(uint8_t LINE_3, uint8_t LINE_2, uint8_t LINE_1,
                          uint8_t LINE_0) volatile
    {
        uint32_t curr = LINE0;

        curr &= ~(0b11111111u << 24u);
        curr |= (LINE_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (LINE_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (LINE_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (LINE_0 & 0b11111111u) << 0u;

        LINE0 = curr;
    }

    /**
     * Get LINE1's LINE_A field.
     *
     * Output on LINE[x]
     */
    inline uint8_t get_LINE1_LINE_A() volatile
    {
        return (LINE1 >> 24u) & 0b11111111u;
    }

    /**
     * Set LINE1's LINE_A field.
     *
     * Output on LINE[x]
     */
    inline void set_LINE1_LINE_A(uint8_t value) volatile
    {
        uint32_t curr = LINE1;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        LINE1 = curr;
    }

    /**
     * Get LINE1's LINE_6 field.
     *
     * Output on LINE[x]
     */
    inline uint8_t get_LINE1_LINE_6() volatile
    {
        return (LINE1 >> 16u) & 0b11111111u;
    }

    /**
     * Set LINE1's LINE_6 field.
     *
     * Output on LINE[x]
     */
    inline void set_LINE1_LINE_6(uint8_t value) volatile
    {
        uint32_t curr = LINE1;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        LINE1 = curr;
    }

    /**
     * Get LINE1's LINE_5 field.
     *
     * Output on LINE[x]
     */
    inline uint8_t get_LINE1_LINE_5() volatile
    {
        return (LINE1 >> 8u) & 0b11111111u;
    }

    /**
     * Set LINE1's LINE_5 field.
     *
     * Output on LINE[x]
     */
    inline void set_LINE1_LINE_5(uint8_t value) volatile
    {
        uint32_t curr = LINE1;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        LINE1 = curr;
    }

    /**
     * Get LINE1's LINE_4 field.
     *
     * Output on LINE[x]
     */
    inline uint8_t get_LINE1_LINE_4() volatile
    {
        return (LINE1 >> 0u) & 0b11111111u;
    }

    /**
     * Set LINE1's LINE_4 field.
     *
     * Output on LINE[x]
     */
    inline void set_LINE1_LINE_4(uint8_t value) volatile
    {
        uint32_t curr = LINE1;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        LINE1 = curr;
    }

    /**
     * Get all of LINE1's bit fields.
     *
     * (read-write) Line Pattern Register 1
     */
    inline void get_LINE1(uint8_t &LINE_A, uint8_t &LINE_6, uint8_t &LINE_5,
                          uint8_t &LINE_4) volatile
    {
        uint32_t curr = LINE1;

        LINE_A = (curr >> 24u) & 0b11111111u;
        LINE_6 = (curr >> 16u) & 0b11111111u;
        LINE_5 = (curr >> 8u) & 0b11111111u;
        LINE_4 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of LINE1's bit fields.
     *
     * (read-write) Line Pattern Register 1
     */
    inline void set_LINE1(uint8_t LINE_A, uint8_t LINE_6, uint8_t LINE_5,
                          uint8_t LINE_4) volatile
    {
        uint32_t curr = LINE1;

        curr &= ~(0b11111111u << 24u);
        curr |= (LINE_A & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (LINE_6 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (LINE_5 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (LINE_4 & 0b11111111u) << 0u;

        LINE1 = curr;
    }

    /**
     * Get LDCMP0's CMP_LD3 field.
     *
     * Compare Value for LED COL[x]
     */
    inline uint8_t get_LDCMP0_CMP_LD3() volatile
    {
        return (LDCMP0 >> 24u) & 0b11111111u;
    }

    /**
     * Set LDCMP0's CMP_LD3 field.
     *
     * Compare Value for LED COL[x]
     */
    inline void set_LDCMP0_CMP_LD3(uint8_t value) volatile
    {
        uint32_t curr = LDCMP0;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        LDCMP0 = curr;
    }

    /**
     * Get LDCMP0's CMP_LD2 field.
     *
     * Compare Value for LED COL[x]
     */
    inline uint8_t get_LDCMP0_CMP_LD2() volatile
    {
        return (LDCMP0 >> 16u) & 0b11111111u;
    }

    /**
     * Set LDCMP0's CMP_LD2 field.
     *
     * Compare Value for LED COL[x]
     */
    inline void set_LDCMP0_CMP_LD2(uint8_t value) volatile
    {
        uint32_t curr = LDCMP0;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        LDCMP0 = curr;
    }

    /**
     * Get LDCMP0's CMP_LD1 field.
     *
     * Compare Value for LED COL[x]
     */
    inline uint8_t get_LDCMP0_CMP_LD1() volatile
    {
        return (LDCMP0 >> 8u) & 0b11111111u;
    }

    /**
     * Set LDCMP0's CMP_LD1 field.
     *
     * Compare Value for LED COL[x]
     */
    inline void set_LDCMP0_CMP_LD1(uint8_t value) volatile
    {
        uint32_t curr = LDCMP0;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        LDCMP0 = curr;
    }

    /**
     * Get LDCMP0's CMP_LD0 field.
     *
     * Compare Value for LED COL[x]
     */
    inline uint8_t get_LDCMP0_CMP_LD0() volatile
    {
        return (LDCMP0 >> 0u) & 0b11111111u;
    }

    /**
     * Set LDCMP0's CMP_LD0 field.
     *
     * Compare Value for LED COL[x]
     */
    inline void set_LDCMP0_CMP_LD0(uint8_t value) volatile
    {
        uint32_t curr = LDCMP0;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        LDCMP0 = curr;
    }

    /**
     * Get all of LDCMP0's bit fields.
     *
     * (read-write) LED Compare Register 0
     */
    inline void get_LDCMP0(uint8_t &CMP_LD3, uint8_t &CMP_LD2,
                           uint8_t &CMP_LD1, uint8_t &CMP_LD0) volatile
    {
        uint32_t curr = LDCMP0;

        CMP_LD3 = (curr >> 24u) & 0b11111111u;
        CMP_LD2 = (curr >> 16u) & 0b11111111u;
        CMP_LD1 = (curr >> 8u) & 0b11111111u;
        CMP_LD0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of LDCMP0's bit fields.
     *
     * (read-write) LED Compare Register 0
     */
    inline void set_LDCMP0(uint8_t CMP_LD3, uint8_t CMP_LD2, uint8_t CMP_LD1,
                           uint8_t CMP_LD0) volatile
    {
        uint32_t curr = LDCMP0;

        curr &= ~(0b11111111u << 24u);
        curr |= (CMP_LD3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (CMP_LD2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (CMP_LD1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (CMP_LD0 & 0b11111111u) << 0u;

        LDCMP0 = curr;
    }

    /**
     * Get LDCMP1's CMP_LDA_TSCOM field.
     *
     * Compare Value for LED COLA / Common Compare Value for Touch-sense Pad
     * Turns
     */
    inline uint8_t get_LDCMP1_CMP_LDA_TSCOM() volatile
    {
        return (LDCMP1 >> 24u) & 0b11111111u;
    }

    /**
     * Set LDCMP1's CMP_LDA_TSCOM field.
     *
     * Compare Value for LED COLA / Common Compare Value for Touch-sense Pad
     * Turns
     */
    inline void set_LDCMP1_CMP_LDA_TSCOM(uint8_t value) volatile
    {
        uint32_t curr = LDCMP1;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        LDCMP1 = curr;
    }

    /**
     * Get LDCMP1's CMP_LD6 field.
     *
     * Compare Value for LED COL[x]
     */
    inline uint8_t get_LDCMP1_CMP_LD6() volatile
    {
        return (LDCMP1 >> 16u) & 0b11111111u;
    }

    /**
     * Set LDCMP1's CMP_LD6 field.
     *
     * Compare Value for LED COL[x]
     */
    inline void set_LDCMP1_CMP_LD6(uint8_t value) volatile
    {
        uint32_t curr = LDCMP1;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        LDCMP1 = curr;
    }

    /**
     * Get LDCMP1's CMP_LD5 field.
     *
     * Compare Value for LED COL[x]
     */
    inline uint8_t get_LDCMP1_CMP_LD5() volatile
    {
        return (LDCMP1 >> 8u) & 0b11111111u;
    }

    /**
     * Set LDCMP1's CMP_LD5 field.
     *
     * Compare Value for LED COL[x]
     */
    inline void set_LDCMP1_CMP_LD5(uint8_t value) volatile
    {
        uint32_t curr = LDCMP1;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        LDCMP1 = curr;
    }

    /**
     * Get LDCMP1's CMP_LD4 field.
     *
     * Compare Value for LED COL[x]
     */
    inline uint8_t get_LDCMP1_CMP_LD4() volatile
    {
        return (LDCMP1 >> 0u) & 0b11111111u;
    }

    /**
     * Set LDCMP1's CMP_LD4 field.
     *
     * Compare Value for LED COL[x]
     */
    inline void set_LDCMP1_CMP_LD4(uint8_t value) volatile
    {
        uint32_t curr = LDCMP1;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        LDCMP1 = curr;
    }

    /**
     * Get all of LDCMP1's bit fields.
     *
     * (read-write) LED Compare Register 1
     */
    inline void get_LDCMP1(uint8_t &CMP_LDA_TSCOM, uint8_t &CMP_LD6,
                           uint8_t &CMP_LD5, uint8_t &CMP_LD4) volatile
    {
        uint32_t curr = LDCMP1;

        CMP_LDA_TSCOM = (curr >> 24u) & 0b11111111u;
        CMP_LD6 = (curr >> 16u) & 0b11111111u;
        CMP_LD5 = (curr >> 8u) & 0b11111111u;
        CMP_LD4 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of LDCMP1's bit fields.
     *
     * (read-write) LED Compare Register 1
     */
    inline void set_LDCMP1(uint8_t CMP_LDA_TSCOM, uint8_t CMP_LD6,
                           uint8_t CMP_LD5, uint8_t CMP_LD4) volatile
    {
        uint32_t curr = LDCMP1;

        curr &= ~(0b11111111u << 24u);
        curr |= (CMP_LDA_TSCOM & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (CMP_LD6 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (CMP_LD5 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (CMP_LD4 & 0b11111111u) << 0u;

        LDCMP1 = curr;
    }

    /**
     * Get TSCMP0's CMP_TS3 field.
     *
     * Compare Value for Touch-Sense TSIN[x]
     */
    inline uint8_t get_TSCMP0_CMP_TS3() volatile
    {
        return (TSCMP0 >> 24u) & 0b11111111u;
    }

    /**
     * Set TSCMP0's CMP_TS3 field.
     *
     * Compare Value for Touch-Sense TSIN[x]
     */
    inline void set_TSCMP0_CMP_TS3(uint8_t value) volatile
    {
        uint32_t curr = TSCMP0;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        TSCMP0 = curr;
    }

    /**
     * Get TSCMP0's CMP_TS2 field.
     *
     * Compare Value for Touch-Sense TSIN[x]
     */
    inline uint8_t get_TSCMP0_CMP_TS2() volatile
    {
        return (TSCMP0 >> 16u) & 0b11111111u;
    }

    /**
     * Set TSCMP0's CMP_TS2 field.
     *
     * Compare Value for Touch-Sense TSIN[x]
     */
    inline void set_TSCMP0_CMP_TS2(uint8_t value) volatile
    {
        uint32_t curr = TSCMP0;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        TSCMP0 = curr;
    }

    /**
     * Get TSCMP0's CMP_TS1 field.
     *
     * Compare Value for Touch-Sense TSIN[x]
     */
    inline uint8_t get_TSCMP0_CMP_TS1() volatile
    {
        return (TSCMP0 >> 8u) & 0b11111111u;
    }

    /**
     * Set TSCMP0's CMP_TS1 field.
     *
     * Compare Value for Touch-Sense TSIN[x]
     */
    inline void set_TSCMP0_CMP_TS1(uint8_t value) volatile
    {
        uint32_t curr = TSCMP0;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        TSCMP0 = curr;
    }

    /**
     * Get TSCMP0's CMP_TS0 field.
     *
     * Compare Value for Touch-Sense TSIN[x]
     */
    inline uint8_t get_TSCMP0_CMP_TS0() volatile
    {
        return (TSCMP0 >> 0u) & 0b11111111u;
    }

    /**
     * Set TSCMP0's CMP_TS0 field.
     *
     * Compare Value for Touch-Sense TSIN[x]
     */
    inline void set_TSCMP0_CMP_TS0(uint8_t value) volatile
    {
        uint32_t curr = TSCMP0;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        TSCMP0 = curr;
    }

    /**
     * Get all of TSCMP0's bit fields.
     *
     * (read-write) Touch-sense Compare Register 0
     */
    inline void get_TSCMP0(uint8_t &CMP_TS3, uint8_t &CMP_TS2,
                           uint8_t &CMP_TS1, uint8_t &CMP_TS0) volatile
    {
        uint32_t curr = TSCMP0;

        CMP_TS3 = (curr >> 24u) & 0b11111111u;
        CMP_TS2 = (curr >> 16u) & 0b11111111u;
        CMP_TS1 = (curr >> 8u) & 0b11111111u;
        CMP_TS0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of TSCMP0's bit fields.
     *
     * (read-write) Touch-sense Compare Register 0
     */
    inline void set_TSCMP0(uint8_t CMP_TS3, uint8_t CMP_TS2, uint8_t CMP_TS1,
                           uint8_t CMP_TS0) volatile
    {
        uint32_t curr = TSCMP0;

        curr &= ~(0b11111111u << 24u);
        curr |= (CMP_TS3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (CMP_TS2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (CMP_TS1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (CMP_TS0 & 0b11111111u) << 0u;

        TSCMP0 = curr;
    }

    /**
     * Get TSCMP1's CMP_TS7 field.
     *
     * Compare Value for Touch-Sense TSIN[x]
     */
    inline uint8_t get_TSCMP1_CMP_TS7() volatile
    {
        return (TSCMP1 >> 24u) & 0b11111111u;
    }

    /**
     * Set TSCMP1's CMP_TS7 field.
     *
     * Compare Value for Touch-Sense TSIN[x]
     */
    inline void set_TSCMP1_CMP_TS7(uint8_t value) volatile
    {
        uint32_t curr = TSCMP1;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        TSCMP1 = curr;
    }

    /**
     * Get TSCMP1's CMP_TS6 field.
     *
     * Compare Value for Touch-Sense TSIN[x]
     */
    inline uint8_t get_TSCMP1_CMP_TS6() volatile
    {
        return (TSCMP1 >> 16u) & 0b11111111u;
    }

    /**
     * Set TSCMP1's CMP_TS6 field.
     *
     * Compare Value for Touch-Sense TSIN[x]
     */
    inline void set_TSCMP1_CMP_TS6(uint8_t value) volatile
    {
        uint32_t curr = TSCMP1;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        TSCMP1 = curr;
    }

    /**
     * Get TSCMP1's CMP_TS5 field.
     *
     * Compare Value for Touch-Sense TSIN[x]
     */
    inline uint8_t get_TSCMP1_CMP_TS5() volatile
    {
        return (TSCMP1 >> 8u) & 0b11111111u;
    }

    /**
     * Set TSCMP1's CMP_TS5 field.
     *
     * Compare Value for Touch-Sense TSIN[x]
     */
    inline void set_TSCMP1_CMP_TS5(uint8_t value) volatile
    {
        uint32_t curr = TSCMP1;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        TSCMP1 = curr;
    }

    /**
     * Get TSCMP1's CMP_TS4 field.
     *
     * Compare Value for Touch-Sense TSIN[x]
     */
    inline uint8_t get_TSCMP1_CMP_TS4() volatile
    {
        return (TSCMP1 >> 0u) & 0b11111111u;
    }

    /**
     * Set TSCMP1's CMP_TS4 field.
     *
     * Compare Value for Touch-Sense TSIN[x]
     */
    inline void set_TSCMP1_CMP_TS4(uint8_t value) volatile
    {
        uint32_t curr = TSCMP1;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        TSCMP1 = curr;
    }

    /**
     * Get all of TSCMP1's bit fields.
     *
     * (read-write) Touch-sense Compare Register 1
     */
    inline void get_TSCMP1(uint8_t &CMP_TS7, uint8_t &CMP_TS6,
                           uint8_t &CMP_TS5, uint8_t &CMP_TS4) volatile
    {
        uint32_t curr = TSCMP1;

        CMP_TS7 = (curr >> 24u) & 0b11111111u;
        CMP_TS6 = (curr >> 16u) & 0b11111111u;
        CMP_TS5 = (curr >> 8u) & 0b11111111u;
        CMP_TS4 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of TSCMP1's bit fields.
     *
     * (read-write) Touch-sense Compare Register 1
     */
    inline void set_TSCMP1(uint8_t CMP_TS7, uint8_t CMP_TS6, uint8_t CMP_TS5,
                           uint8_t CMP_TS4) volatile
    {
        uint32_t curr = TSCMP1;

        curr &= ~(0b11111111u << 24u);
        curr |= (CMP_TS7 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (CMP_TS6 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (CMP_TS5 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (CMP_TS4 & 0b11111111u) << 0u;

        TSCMP1 = curr;
    }
};

static_assert(sizeof(ledts0) == ledts0::size);

static volatile ledts0 *const LEDTS0 = reinterpret_cast<ledts0 *>(0x48010000);

}; // namespace XMC4700
