/**
 * \file
 * \brief Generated by ifgen (3.2.0).
 */
#pragma once

#include "../enums/VADC_BRSCTRL_SRCRESREG.h"
#include "../enums/VADC_BRSCTRL_XTMODE.h"
#include "../enums/VADC_BRSMR_ENGT.h"
#include "../enums/VADC_GLOBCFG_DIVA.h"
#include "../enums/VADC_GLOBCFG_DIVD.h"
#include "../enums/VADC_GLOBEVNP_REV0NP.h"
#include "../enums/VADC_GLOBICLASS_CME.h"
#include "../enums/VADC_GLOBRCR_DRCTR.h"
#include "../enums/VADC_GLOBTF_CDSEL.h"
#include "../enums/VADC_OCS_SUS.h"
#include "../enums/VADC_OCS_TGS.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * Analog to Digital Converter
 */
struct [[gnu::packed]] vadc
{
    /* Constant attributes. */
    static constexpr std::size_t size = 1012; /*!< vadc's size in bytes. */

    /* Fields. */
    uint32_t CLC; /*!< (read-write) Clock Control Register */
    const uint32_t reserved_padding0 = {};
    const uint32_t ID = {}; /*!< (read-only) Module Identification Register */
    static constexpr std::size_t reserved_padding1_length = 7;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t OCS; /*!< (read-write) OCDS Control and Status Register */
    static constexpr std::size_t reserved_padding2_length = 21;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t GLOBCFG; /*!< (read-write) Global Configuration Register */
    static constexpr std::size_t reserved_padding3_length = 7;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    static constexpr std::size_t GLOBICLASS_length = 2;
    uint32_t GLOBICLASS[GLOBICLASS_length]; /*!< (read-write) Input Class
                                               Register, Global */
    static constexpr std::size_t reserved_padding4_length = 4;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t GLOBBOUND; /*!< (read-write) Global Boundary Select Register */
    static constexpr std::size_t reserved_padding5_length = 9;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t GLOBEFLAG; /*!< (read-write) Global Event Flag Register */
    static constexpr std::size_t reserved_padding6_length = 23;
    const uint32_t reserved_padding6[reserved_padding6_length] = {};
    uint32_t GLOBEVNP; /*!< (read-write) Global Event Node Pointer Register */
    static constexpr std::size_t reserved_padding7_length = 7;
    const uint32_t reserved_padding7[reserved_padding7_length] = {};
    uint32_t GLOBTF; /*!< (read-write) Global Test Functions Register */
    static constexpr std::size_t reserved_padding8_length = 7;
    const uint32_t reserved_padding8[reserved_padding8_length] = {};
    static constexpr std::size_t BRSSEL_length = 4;
    uint32_t BRSSEL[BRSSEL_length]; /*!< (read-write) Background Request Source
                                       Channel Select Register */
    static constexpr std::size_t reserved_padding9_length = 12;
    const uint32_t reserved_padding9[reserved_padding9_length] = {};
    static constexpr std::size_t BRSPND_length = 4;
    uint32_t BRSPND[BRSPND_length]; /*!< (read-write) Background Request Source
                                       Pending Register */
    static constexpr std::size_t reserved_padding10_length = 12;
    const uint32_t reserved_padding10[reserved_padding10_length] = {};
    uint32_t BRSCTRL; /*!< (read-write) Background Request Source Control
                         Register */
    uint32_t
        BRSMR; /*!< (read-write) Background Request Source Mode Register */
    static constexpr std::size_t reserved_padding11_length = 30;
    const uint32_t reserved_padding11[reserved_padding11_length] = {};
    uint32_t GLOBRCR; /*!< (read-write) Global Result Control Register */
    static constexpr std::size_t reserved_padding12_length = 31;
    const uint32_t reserved_padding12[reserved_padding12_length] = {};
    uint32_t GLOBRES; /*!< (read-write) Global Result Register */
    static constexpr std::size_t reserved_padding13_length = 31;
    const uint32_t reserved_padding13[reserved_padding13_length] = {};
    uint32_t GLOBRESD; /*!< (read-write) Global Result Register, Debug */
    static constexpr std::size_t reserved_padding14_length = 27;
    const uint32_t reserved_padding14[reserved_padding14_length] = {};
    uint32_t EMUXSEL; /*!< (read-write) External Multiplexer Select Register */

    /* Methods. */

    /**
     * Get CLC's EDIS bit.
     *
     * Sleep Mode Enable Control
     */
    inline bool get_CLC_EDIS() volatile
    {
        return CLC & (1u << 3u);
    }

    /**
     * Set CLC's EDIS bit.
     *
     * Sleep Mode Enable Control
     */
    inline void set_CLC_EDIS() volatile
    {
        CLC |= 1u << 3u;
    }

    /**
     * Clear CLC's EDIS bit.
     *
     * Sleep Mode Enable Control
     */
    inline void clear_CLC_EDIS() volatile
    {
        CLC &= ~(1u << 3u);
    }

    /**
     * Toggle CLC's EDIS bit.
     *
     * Sleep Mode Enable Control
     */
    inline void toggle_CLC_EDIS() volatile
    {
        CLC ^= 1u << 3u;
    }

    /**
     * Get CLC's DISS bit.
     *
     * Module Disable Status Bit
     */
    inline bool get_CLC_DISS() volatile
    {
        return CLC & (1u << 1u);
    }

    /**
     * Get CLC's DISR bit.
     *
     * Module Disable Request Bit
     */
    inline bool get_CLC_DISR() volatile
    {
        return CLC & (1u << 0u);
    }

    /**
     * Set CLC's DISR bit.
     *
     * Module Disable Request Bit
     */
    inline void set_CLC_DISR() volatile
    {
        CLC |= 1u << 0u;
    }

    /**
     * Clear CLC's DISR bit.
     *
     * Module Disable Request Bit
     */
    inline void clear_CLC_DISR() volatile
    {
        CLC &= ~(1u << 0u);
    }

    /**
     * Toggle CLC's DISR bit.
     *
     * Module Disable Request Bit
     */
    inline void toggle_CLC_DISR() volatile
    {
        CLC ^= 1u << 0u;
    }

    /**
     * Get all of CLC's bit fields.
     *
     * (read-write) Clock Control Register
     */
    inline void get_CLC(bool &EDIS, bool &DISS, bool &DISR) volatile
    {
        uint32_t curr = CLC;

        EDIS = curr & (1u << 3u);
        DISS = curr & (1u << 1u);
        DISR = curr & (1u << 0u);
    }

    /**
     * Set all of CLC's bit fields.
     *
     * (read-write) Clock Control Register
     */
    inline void set_CLC(bool EDIS, bool DISR) volatile
    {
        uint32_t curr = CLC;

        curr &= ~(0b1u << 3u);
        curr |= (EDIS & 0b1u) << 3u;
        curr &= ~(0b1u << 0u);
        curr |= (DISR & 0b1u) << 0u;

        CLC = curr;
    }

    /**
     * Get ID's MOD_NUMBER field.
     *
     * Module Number
     */
    inline uint16_t get_ID_MOD_NUMBER() volatile
    {
        return (ID >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get ID's MOD_TYPE field.
     *
     * Module Type
     */
    inline uint8_t get_ID_MOD_TYPE() volatile
    {
        return (ID >> 8u) & 0b11111111u;
    }

    /**
     * Get ID's MOD_REV field.
     *
     * Module Revision
     */
    inline uint8_t get_ID_MOD_REV() volatile
    {
        return (ID >> 0u) & 0b11111111u;
    }

    /**
     * Get all of ID's bit fields.
     *
     * (read-only) Module Identification Register
     */
    inline void get_ID(uint16_t &MOD_NUMBER, uint8_t &MOD_TYPE,
                       uint8_t &MOD_REV) volatile
    {
        uint32_t curr = ID;

        MOD_NUMBER = (curr >> 16u) & 0b1111111111111111u;
        MOD_TYPE = (curr >> 8u) & 0b11111111u;
        MOD_REV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get OCS's SUSSTA bit.
     *
     * Suspend State
     */
    inline bool get_OCS_SUSSTA() volatile
    {
        return OCS & (1u << 29u);
    }

    /**
     * Set OCS's SUS_P bit.
     *
     * SUS Write Protection
     */
    inline void set_OCS_SUS_P() volatile
    {
        OCS |= 1u << 28u;
    }

    /**
     * Clear OCS's SUS_P bit.
     *
     * SUS Write Protection
     */
    inline void clear_OCS_SUS_P() volatile
    {
        OCS &= ~(1u << 28u);
    }

    /**
     * Toggle OCS's SUS_P bit.
     *
     * SUS Write Protection
     */
    inline void toggle_OCS_SUS_P() volatile
    {
        OCS ^= 1u << 28u;
    }

    /**
     * Get OCS's SUS field.
     *
     * OCDS Suspend Control
     */
    inline VADC_OCS_SUS get_OCS_SUS() volatile
    {
        return VADC_OCS_SUS((OCS >> 24u) & 0b1111u);
    }

    /**
     * Set OCS's SUS field.
     *
     * OCDS Suspend Control
     */
    inline void set_OCS_SUS(VADC_OCS_SUS value) volatile
    {
        uint32_t curr = OCS;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        OCS = curr;
    }

    /**
     * Set OCS's TG_P bit.
     *
     * TGS, TGB Write Protection
     */
    inline void set_OCS_TG_P() volatile
    {
        OCS |= 1u << 3u;
    }

    /**
     * Clear OCS's TG_P bit.
     *
     * TGS, TGB Write Protection
     */
    inline void clear_OCS_TG_P() volatile
    {
        OCS &= ~(1u << 3u);
    }

    /**
     * Toggle OCS's TG_P bit.
     *
     * TGS, TGB Write Protection
     */
    inline void toggle_OCS_TG_P() volatile
    {
        OCS ^= 1u << 3u;
    }

    /**
     * Get OCS's TGB bit.
     *
     * OTGB0/1 Bus Select
     */
    inline bool get_OCS_TGB() volatile
    {
        return OCS & (1u << 2u);
    }

    /**
     * Set OCS's TGB bit.
     *
     * OTGB0/1 Bus Select
     */
    inline void set_OCS_TGB() volatile
    {
        OCS |= 1u << 2u;
    }

    /**
     * Clear OCS's TGB bit.
     *
     * OTGB0/1 Bus Select
     */
    inline void clear_OCS_TGB() volatile
    {
        OCS &= ~(1u << 2u);
    }

    /**
     * Toggle OCS's TGB bit.
     *
     * OTGB0/1 Bus Select
     */
    inline void toggle_OCS_TGB() volatile
    {
        OCS ^= 1u << 2u;
    }

    /**
     * Get OCS's TGS field.
     *
     * Trigger Set for OTGB0/1
     */
    inline VADC_OCS_TGS get_OCS_TGS() volatile
    {
        return VADC_OCS_TGS((OCS >> 0u) & 0b11u);
    }

    /**
     * Set OCS's TGS field.
     *
     * Trigger Set for OTGB0/1
     */
    inline void set_OCS_TGS(VADC_OCS_TGS value) volatile
    {
        uint32_t curr = OCS;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        OCS = curr;
    }

    /**
     * Get all of OCS's bit fields.
     *
     * (read-write) OCDS Control and Status Register
     */
    inline void get_OCS(bool &SUSSTA, VADC_OCS_SUS &SUS, bool &TGB,
                        VADC_OCS_TGS &TGS) volatile
    {
        uint32_t curr = OCS;

        SUSSTA = curr & (1u << 29u);
        SUS = VADC_OCS_SUS((curr >> 24u) & 0b1111u);
        TGB = curr & (1u << 2u);
        TGS = VADC_OCS_TGS((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of OCS's bit fields.
     *
     * (read-write) OCDS Control and Status Register
     */
    inline void set_OCS(bool SUS_P, VADC_OCS_SUS SUS, bool TG_P, bool TGB,
                        VADC_OCS_TGS TGS) volatile
    {
        uint32_t curr = OCS;

        curr &= ~(0b1u << 28u);
        curr |= (SUS_P & 0b1u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(SUS) & 0b1111u) << 24u;
        curr &= ~(0b1u << 3u);
        curr |= (TG_P & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (TGB & 0b1u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(TGS) & 0b11u) << 0u;

        OCS = curr;
    }

    /**
     * Set GLOBCFG's SUCAL bit.
     *
     * Start-Up Calibration
     */
    inline void set_GLOBCFG_SUCAL() volatile
    {
        GLOBCFG |= 1u << 31u;
    }

    /**
     * Clear GLOBCFG's SUCAL bit.
     *
     * Start-Up Calibration
     */
    inline void clear_GLOBCFG_SUCAL() volatile
    {
        GLOBCFG &= ~(1u << 31u);
    }

    /**
     * Toggle GLOBCFG's SUCAL bit.
     *
     * Start-Up Calibration
     */
    inline void toggle_GLOBCFG_SUCAL() volatile
    {
        GLOBCFG ^= 1u << 31u;
    }

    /**
     * Get GLOBCFG's DPCAL3 bit.
     *
     * Disable Post-Calibration
     */
    inline bool get_GLOBCFG_DPCAL3() volatile
    {
        return GLOBCFG & (1u << 19u);
    }

    /**
     * Set GLOBCFG's DPCAL3 bit.
     *
     * Disable Post-Calibration
     */
    inline void set_GLOBCFG_DPCAL3() volatile
    {
        GLOBCFG |= 1u << 19u;
    }

    /**
     * Clear GLOBCFG's DPCAL3 bit.
     *
     * Disable Post-Calibration
     */
    inline void clear_GLOBCFG_DPCAL3() volatile
    {
        GLOBCFG &= ~(1u << 19u);
    }

    /**
     * Toggle GLOBCFG's DPCAL3 bit.
     *
     * Disable Post-Calibration
     */
    inline void toggle_GLOBCFG_DPCAL3() volatile
    {
        GLOBCFG ^= 1u << 19u;
    }

    /**
     * Get GLOBCFG's DPCAL2 bit.
     *
     * Disable Post-Calibration
     */
    inline bool get_GLOBCFG_DPCAL2() volatile
    {
        return GLOBCFG & (1u << 18u);
    }

    /**
     * Set GLOBCFG's DPCAL2 bit.
     *
     * Disable Post-Calibration
     */
    inline void set_GLOBCFG_DPCAL2() volatile
    {
        GLOBCFG |= 1u << 18u;
    }

    /**
     * Clear GLOBCFG's DPCAL2 bit.
     *
     * Disable Post-Calibration
     */
    inline void clear_GLOBCFG_DPCAL2() volatile
    {
        GLOBCFG &= ~(1u << 18u);
    }

    /**
     * Toggle GLOBCFG's DPCAL2 bit.
     *
     * Disable Post-Calibration
     */
    inline void toggle_GLOBCFG_DPCAL2() volatile
    {
        GLOBCFG ^= 1u << 18u;
    }

    /**
     * Get GLOBCFG's DPCAL1 bit.
     *
     * Disable Post-Calibration
     */
    inline bool get_GLOBCFG_DPCAL1() volatile
    {
        return GLOBCFG & (1u << 17u);
    }

    /**
     * Set GLOBCFG's DPCAL1 bit.
     *
     * Disable Post-Calibration
     */
    inline void set_GLOBCFG_DPCAL1() volatile
    {
        GLOBCFG |= 1u << 17u;
    }

    /**
     * Clear GLOBCFG's DPCAL1 bit.
     *
     * Disable Post-Calibration
     */
    inline void clear_GLOBCFG_DPCAL1() volatile
    {
        GLOBCFG &= ~(1u << 17u);
    }

    /**
     * Toggle GLOBCFG's DPCAL1 bit.
     *
     * Disable Post-Calibration
     */
    inline void toggle_GLOBCFG_DPCAL1() volatile
    {
        GLOBCFG ^= 1u << 17u;
    }

    /**
     * Get GLOBCFG's DPCAL0 bit.
     *
     * Disable Post-Calibration
     */
    inline bool get_GLOBCFG_DPCAL0() volatile
    {
        return GLOBCFG & (1u << 16u);
    }

    /**
     * Set GLOBCFG's DPCAL0 bit.
     *
     * Disable Post-Calibration
     */
    inline void set_GLOBCFG_DPCAL0() volatile
    {
        GLOBCFG |= 1u << 16u;
    }

    /**
     * Clear GLOBCFG's DPCAL0 bit.
     *
     * Disable Post-Calibration
     */
    inline void clear_GLOBCFG_DPCAL0() volatile
    {
        GLOBCFG &= ~(1u << 16u);
    }

    /**
     * Toggle GLOBCFG's DPCAL0 bit.
     *
     * Disable Post-Calibration
     */
    inline void toggle_GLOBCFG_DPCAL0() volatile
    {
        GLOBCFG ^= 1u << 16u;
    }

    /**
     * Set GLOBCFG's DIVWC bit.
     *
     * Write Control for Divider Parameters
     */
    inline void set_GLOBCFG_DIVWC() volatile
    {
        GLOBCFG |= 1u << 15u;
    }

    /**
     * Clear GLOBCFG's DIVWC bit.
     *
     * Write Control for Divider Parameters
     */
    inline void clear_GLOBCFG_DIVWC() volatile
    {
        GLOBCFG &= ~(1u << 15u);
    }

    /**
     * Toggle GLOBCFG's DIVWC bit.
     *
     * Write Control for Divider Parameters
     */
    inline void toggle_GLOBCFG_DIVWC() volatile
    {
        GLOBCFG ^= 1u << 15u;
    }

    /**
     * Get GLOBCFG's DIVD field.
     *
     * Divider Factor for the Arbiter Clock
     */
    inline VADC_GLOBCFG_DIVD get_GLOBCFG_DIVD() volatile
    {
        return VADC_GLOBCFG_DIVD((GLOBCFG >> 8u) & 0b11u);
    }

    /**
     * Set GLOBCFG's DIVD field.
     *
     * Divider Factor for the Arbiter Clock
     */
    inline void set_GLOBCFG_DIVD(VADC_GLOBCFG_DIVD value) volatile
    {
        uint32_t curr = GLOBCFG;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        GLOBCFG = curr;
    }

    /**
     * Get GLOBCFG's DCMSB bit.
     *
     * Double Clock for the MSB Conversion
     */
    inline bool get_GLOBCFG_DCMSB() volatile
    {
        return GLOBCFG & (1u << 7u);
    }

    /**
     * Set GLOBCFG's DCMSB bit.
     *
     * Double Clock for the MSB Conversion
     */
    inline void set_GLOBCFG_DCMSB() volatile
    {
        GLOBCFG |= 1u << 7u;
    }

    /**
     * Clear GLOBCFG's DCMSB bit.
     *
     * Double Clock for the MSB Conversion
     */
    inline void clear_GLOBCFG_DCMSB() volatile
    {
        GLOBCFG &= ~(1u << 7u);
    }

    /**
     * Toggle GLOBCFG's DCMSB bit.
     *
     * Double Clock for the MSB Conversion
     */
    inline void toggle_GLOBCFG_DCMSB() volatile
    {
        GLOBCFG ^= 1u << 7u;
    }

    /**
     * Get GLOBCFG's DIVA field.
     *
     * Divider Factor for the Analog Internal Clock
     */
    inline VADC_GLOBCFG_DIVA get_GLOBCFG_DIVA() volatile
    {
        return VADC_GLOBCFG_DIVA((GLOBCFG >> 0u) & 0b11111u);
    }

    /**
     * Set GLOBCFG's DIVA field.
     *
     * Divider Factor for the Analog Internal Clock
     */
    inline void set_GLOBCFG_DIVA(VADC_GLOBCFG_DIVA value) volatile
    {
        uint32_t curr = GLOBCFG;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        GLOBCFG = curr;
    }

    /**
     * Get all of GLOBCFG's bit fields.
     *
     * (read-write) Global Configuration Register
     */
    inline void get_GLOBCFG(bool &DPCAL3, bool &DPCAL2, bool &DPCAL1,
                            bool &DPCAL0, VADC_GLOBCFG_DIVD &DIVD, bool &DCMSB,
                            VADC_GLOBCFG_DIVA &DIVA) volatile
    {
        uint32_t curr = GLOBCFG;

        DPCAL3 = curr & (1u << 19u);
        DPCAL2 = curr & (1u << 18u);
        DPCAL1 = curr & (1u << 17u);
        DPCAL0 = curr & (1u << 16u);
        DIVD = VADC_GLOBCFG_DIVD((curr >> 8u) & 0b11u);
        DCMSB = curr & (1u << 7u);
        DIVA = VADC_GLOBCFG_DIVA((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of GLOBCFG's bit fields.
     *
     * (read-write) Global Configuration Register
     */
    inline void set_GLOBCFG(bool SUCAL, bool DPCAL3, bool DPCAL2, bool DPCAL1,
                            bool DPCAL0, bool DIVWC, VADC_GLOBCFG_DIVD DIVD,
                            bool DCMSB, VADC_GLOBCFG_DIVA DIVA) volatile
    {
        uint32_t curr = GLOBCFG;

        curr &= ~(0b1u << 31u);
        curr |= (SUCAL & 0b1u) << 31u;
        curr &= ~(0b1u << 19u);
        curr |= (DPCAL3 & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (DPCAL2 & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (DPCAL1 & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (DPCAL0 & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (DIVWC & 0b1u) << 15u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(DIVD) & 0b11u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (DCMSB & 0b1u) << 7u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(DIVA) & 0b11111u) << 0u;

        GLOBCFG = curr;
    }

    /**
     * Get GLOBICLASS's CME field.
     *
     * Conversion Mode for EMUX Conversions
     */
    inline VADC_GLOBICLASS_CME get_GLOBICLASS_CME(std::size_t index) volatile
    {
        return VADC_GLOBICLASS_CME((GLOBICLASS[index] >> 24u) & 0b111u);
    }

    /**
     * Set GLOBICLASS's CME field.
     *
     * Conversion Mode for EMUX Conversions
     */
    inline void set_GLOBICLASS_CME(std::size_t index,
                                   VADC_GLOBICLASS_CME value) volatile
    {
        uint32_t curr = GLOBICLASS[index];

        curr &= ~(0b111u << 24u);
        curr |= (std::to_underlying(value) & 0b111u) << 24u;

        GLOBICLASS[index] = curr;
    }

    /**
     * Get GLOBICLASS's STCE field.
     *
     * Sample Time Control for EMUX Conversions
     */
    inline uint8_t get_GLOBICLASS_STCE(std::size_t index) volatile
    {
        return (GLOBICLASS[index] >> 16u) & 0b11111u;
    }

    /**
     * Set GLOBICLASS's STCE field.
     *
     * Sample Time Control for EMUX Conversions
     */
    inline void set_GLOBICLASS_STCE(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = GLOBICLASS[index];

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        GLOBICLASS[index] = curr;
    }

    /**
     * Get GLOBICLASS's CMS field.
     *
     * Conversion Mode for Standard Conversions
     */
    inline VADC_GLOBICLASS_CME get_GLOBICLASS_CMS(std::size_t index) volatile
    {
        return VADC_GLOBICLASS_CME((GLOBICLASS[index] >> 8u) & 0b111u);
    }

    /**
     * Set GLOBICLASS's CMS field.
     *
     * Conversion Mode for Standard Conversions
     */
    inline void set_GLOBICLASS_CMS(std::size_t index,
                                   VADC_GLOBICLASS_CME value) volatile
    {
        uint32_t curr = GLOBICLASS[index];

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        GLOBICLASS[index] = curr;
    }

    /**
     * Get GLOBICLASS's STCS field.
     *
     * Sample Time Control for Standard Conversions
     */
    inline uint8_t get_GLOBICLASS_STCS(std::size_t index) volatile
    {
        return (GLOBICLASS[index] >> 0u) & 0b11111u;
    }

    /**
     * Set GLOBICLASS's STCS field.
     *
     * Sample Time Control for Standard Conversions
     */
    inline void set_GLOBICLASS_STCS(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = GLOBICLASS[index];

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        GLOBICLASS[index] = curr;
    }

    /**
     * Get all of GLOBICLASS's bit fields.
     *
     * (read-write) Input Class Register, Global
     */
    inline void get_GLOBICLASS(std::size_t index, VADC_GLOBICLASS_CME &CME,
                               uint8_t &STCE, VADC_GLOBICLASS_CME &CMS,
                               uint8_t &STCS) volatile
    {
        uint32_t curr = GLOBICLASS[index];

        CME = VADC_GLOBICLASS_CME((curr >> 24u) & 0b111u);
        STCE = (curr >> 16u) & 0b11111u;
        CMS = VADC_GLOBICLASS_CME((curr >> 8u) & 0b111u);
        STCS = (curr >> 0u) & 0b11111u;
    }

    /**
     * Set all of GLOBICLASS's bit fields.
     *
     * (read-write) Input Class Register, Global
     */
    inline void set_GLOBICLASS(std::size_t index, VADC_GLOBICLASS_CME CME,
                               uint8_t STCE, VADC_GLOBICLASS_CME CMS,
                               uint8_t STCS) volatile
    {
        uint32_t curr = GLOBICLASS[index];

        curr &= ~(0b111u << 24u);
        curr |= (std::to_underlying(CME) & 0b111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (STCE & 0b11111u) << 16u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(CMS) & 0b111u) << 8u;
        curr &= ~(0b11111u << 0u);
        curr |= (STCS & 0b11111u) << 0u;

        GLOBICLASS[index] = curr;
    }

    /**
     * Get GLOBBOUND's BOUNDARY1 field.
     *
     * Boundary Value 1 for Limit Checking
     */
    inline uint16_t get_GLOBBOUND_BOUNDARY1() volatile
    {
        return (GLOBBOUND >> 16u) & 0b111111111111u;
    }

    /**
     * Set GLOBBOUND's BOUNDARY1 field.
     *
     * Boundary Value 1 for Limit Checking
     */
    inline void set_GLOBBOUND_BOUNDARY1(uint16_t value) volatile
    {
        uint32_t curr = GLOBBOUND;

        curr &= ~(0b111111111111u << 16u);
        curr |= (value & 0b111111111111u) << 16u;

        GLOBBOUND = curr;
    }

    /**
     * Get GLOBBOUND's BOUNDARY0 field.
     *
     * Boundary Value 0 for Limit Checking
     */
    inline uint16_t get_GLOBBOUND_BOUNDARY0() volatile
    {
        return (GLOBBOUND >> 0u) & 0b111111111111u;
    }

    /**
     * Set GLOBBOUND's BOUNDARY0 field.
     *
     * Boundary Value 0 for Limit Checking
     */
    inline void set_GLOBBOUND_BOUNDARY0(uint16_t value) volatile
    {
        uint32_t curr = GLOBBOUND;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        GLOBBOUND = curr;
    }

    /**
     * Get all of GLOBBOUND's bit fields.
     *
     * (read-write) Global Boundary Select Register
     */
    inline void get_GLOBBOUND(uint16_t &BOUNDARY1,
                              uint16_t &BOUNDARY0) volatile
    {
        uint32_t curr = GLOBBOUND;

        BOUNDARY1 = (curr >> 16u) & 0b111111111111u;
        BOUNDARY0 = (curr >> 0u) & 0b111111111111u;
    }

    /**
     * Set all of GLOBBOUND's bit fields.
     *
     * (read-write) Global Boundary Select Register
     */
    inline void set_GLOBBOUND(uint16_t BOUNDARY1, uint16_t BOUNDARY0) volatile
    {
        uint32_t curr = GLOBBOUND;

        curr &= ~(0b111111111111u << 16u);
        curr |= (BOUNDARY1 & 0b111111111111u) << 16u;
        curr &= ~(0b111111111111u << 0u);
        curr |= (BOUNDARY0 & 0b111111111111u) << 0u;

        GLOBBOUND = curr;
    }

    /**
     * Set GLOBEFLAG's REVGLBCLR bit.
     *
     * Clear Global Result Event
     */
    inline void set_GLOBEFLAG_REVGLBCLR() volatile
    {
        GLOBEFLAG |= 1u << 24u;
    }

    /**
     * Clear GLOBEFLAG's REVGLBCLR bit.
     *
     * Clear Global Result Event
     */
    inline void clear_GLOBEFLAG_REVGLBCLR() volatile
    {
        GLOBEFLAG &= ~(1u << 24u);
    }

    /**
     * Toggle GLOBEFLAG's REVGLBCLR bit.
     *
     * Clear Global Result Event
     */
    inline void toggle_GLOBEFLAG_REVGLBCLR() volatile
    {
        GLOBEFLAG ^= 1u << 24u;
    }

    /**
     * Set GLOBEFLAG's SEVGLBCLR bit.
     *
     * Clear Source Event (Background)
     */
    inline void set_GLOBEFLAG_SEVGLBCLR() volatile
    {
        GLOBEFLAG |= 1u << 16u;
    }

    /**
     * Clear GLOBEFLAG's SEVGLBCLR bit.
     *
     * Clear Source Event (Background)
     */
    inline void clear_GLOBEFLAG_SEVGLBCLR() volatile
    {
        GLOBEFLAG &= ~(1u << 16u);
    }

    /**
     * Toggle GLOBEFLAG's SEVGLBCLR bit.
     *
     * Clear Source Event (Background)
     */
    inline void toggle_GLOBEFLAG_SEVGLBCLR() volatile
    {
        GLOBEFLAG ^= 1u << 16u;
    }

    /**
     * Get GLOBEFLAG's REVGLB bit.
     *
     * Global Result Event
     */
    inline bool get_GLOBEFLAG_REVGLB() volatile
    {
        return GLOBEFLAG & (1u << 8u);
    }

    /**
     * Set GLOBEFLAG's REVGLB bit.
     *
     * Global Result Event
     */
    inline void set_GLOBEFLAG_REVGLB() volatile
    {
        GLOBEFLAG |= 1u << 8u;
    }

    /**
     * Clear GLOBEFLAG's REVGLB bit.
     *
     * Global Result Event
     */
    inline void clear_GLOBEFLAG_REVGLB() volatile
    {
        GLOBEFLAG &= ~(1u << 8u);
    }

    /**
     * Toggle GLOBEFLAG's REVGLB bit.
     *
     * Global Result Event
     */
    inline void toggle_GLOBEFLAG_REVGLB() volatile
    {
        GLOBEFLAG ^= 1u << 8u;
    }

    /**
     * Get GLOBEFLAG's SEVGLB bit.
     *
     * Source Event (Background)
     */
    inline bool get_GLOBEFLAG_SEVGLB() volatile
    {
        return GLOBEFLAG & (1u << 0u);
    }

    /**
     * Set GLOBEFLAG's SEVGLB bit.
     *
     * Source Event (Background)
     */
    inline void set_GLOBEFLAG_SEVGLB() volatile
    {
        GLOBEFLAG |= 1u << 0u;
    }

    /**
     * Clear GLOBEFLAG's SEVGLB bit.
     *
     * Source Event (Background)
     */
    inline void clear_GLOBEFLAG_SEVGLB() volatile
    {
        GLOBEFLAG &= ~(1u << 0u);
    }

    /**
     * Toggle GLOBEFLAG's SEVGLB bit.
     *
     * Source Event (Background)
     */
    inline void toggle_GLOBEFLAG_SEVGLB() volatile
    {
        GLOBEFLAG ^= 1u << 0u;
    }

    /**
     * Get all of GLOBEFLAG's bit fields.
     *
     * (read-write) Global Event Flag Register
     */
    inline void get_GLOBEFLAG(bool &REVGLB, bool &SEVGLB) volatile
    {
        uint32_t curr = GLOBEFLAG;

        REVGLB = curr & (1u << 8u);
        SEVGLB = curr & (1u << 0u);
    }

    /**
     * Set all of GLOBEFLAG's bit fields.
     *
     * (read-write) Global Event Flag Register
     */
    inline void set_GLOBEFLAG(bool REVGLBCLR, bool SEVGLBCLR, bool REVGLB,
                              bool SEVGLB) volatile
    {
        uint32_t curr = GLOBEFLAG;

        curr &= ~(0b1u << 24u);
        curr |= (REVGLBCLR & 0b1u) << 24u;
        curr &= ~(0b1u << 16u);
        curr |= (SEVGLBCLR & 0b1u) << 16u;
        curr &= ~(0b1u << 8u);
        curr |= (REVGLB & 0b1u) << 8u;
        curr &= ~(0b1u << 0u);
        curr |= (SEVGLB & 0b1u) << 0u;

        GLOBEFLAG = curr;
    }

    /**
     * Get GLOBEVNP's REV0NP field.
     *
     * Service Request Node Pointer Backgr. Result
     */
    inline VADC_GLOBEVNP_REV0NP get_GLOBEVNP_REV0NP() volatile
    {
        return VADC_GLOBEVNP_REV0NP((GLOBEVNP >> 16u) & 0b1111u);
    }

    /**
     * Set GLOBEVNP's REV0NP field.
     *
     * Service Request Node Pointer Backgr. Result
     */
    inline void set_GLOBEVNP_REV0NP(VADC_GLOBEVNP_REV0NP value) volatile
    {
        uint32_t curr = GLOBEVNP;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        GLOBEVNP = curr;
    }

    /**
     * Get GLOBEVNP's SEV0NP field.
     *
     * Service Request Node Pointer Backgr. Source
     */
    inline VADC_GLOBEVNP_REV0NP get_GLOBEVNP_SEV0NP() volatile
    {
        return VADC_GLOBEVNP_REV0NP((GLOBEVNP >> 0u) & 0b1111u);
    }

    /**
     * Set GLOBEVNP's SEV0NP field.
     *
     * Service Request Node Pointer Backgr. Source
     */
    inline void set_GLOBEVNP_SEV0NP(VADC_GLOBEVNP_REV0NP value) volatile
    {
        uint32_t curr = GLOBEVNP;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        GLOBEVNP = curr;
    }

    /**
     * Get all of GLOBEVNP's bit fields.
     *
     * (read-write) Global Event Node Pointer Register
     */
    inline void get_GLOBEVNP(VADC_GLOBEVNP_REV0NP &REV0NP,
                             VADC_GLOBEVNP_REV0NP &SEV0NP) volatile
    {
        uint32_t curr = GLOBEVNP;

        REV0NP = VADC_GLOBEVNP_REV0NP((curr >> 16u) & 0b1111u);
        SEV0NP = VADC_GLOBEVNP_REV0NP((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of GLOBEVNP's bit fields.
     *
     * (read-write) Global Event Node Pointer Register
     */
    inline void set_GLOBEVNP(VADC_GLOBEVNP_REV0NP REV0NP,
                             VADC_GLOBEVNP_REV0NP SEV0NP) volatile
    {
        uint32_t curr = GLOBEVNP;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(REV0NP) & 0b1111u) << 16u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(SEV0NP) & 0b1111u) << 0u;

        GLOBEVNP = curr;
    }

    /**
     * Set GLOBTF's MDWC bit.
     *
     * Write Control for Multiplexer Diagnostics
     */
    inline void set_GLOBTF_MDWC() volatile
    {
        GLOBTF |= 1u << 23u;
    }

    /**
     * Clear GLOBTF's MDWC bit.
     *
     * Write Control for Multiplexer Diagnostics
     */
    inline void clear_GLOBTF_MDWC() volatile
    {
        GLOBTF &= ~(1u << 23u);
    }

    /**
     * Toggle GLOBTF's MDWC bit.
     *
     * Write Control for Multiplexer Diagnostics
     */
    inline void toggle_GLOBTF_MDWC() volatile
    {
        GLOBTF ^= 1u << 23u;
    }

    /**
     * Get GLOBTF's PDD bit.
     *
     * Pull-Down Diagnostics Enable
     */
    inline bool get_GLOBTF_PDD() volatile
    {
        return GLOBTF & (1u << 16u);
    }

    /**
     * Set GLOBTF's PDD bit.
     *
     * Pull-Down Diagnostics Enable
     */
    inline void set_GLOBTF_PDD() volatile
    {
        GLOBTF |= 1u << 16u;
    }

    /**
     * Clear GLOBTF's PDD bit.
     *
     * Pull-Down Diagnostics Enable
     */
    inline void clear_GLOBTF_PDD() volatile
    {
        GLOBTF &= ~(1u << 16u);
    }

    /**
     * Toggle GLOBTF's PDD bit.
     *
     * Pull-Down Diagnostics Enable
     */
    inline void toggle_GLOBTF_PDD() volatile
    {
        GLOBTF ^= 1u << 16u;
    }

    /**
     * Set GLOBTF's CDWC bit.
     *
     * Write Control for Conversion Diagnostics
     */
    inline void set_GLOBTF_CDWC() volatile
    {
        GLOBTF |= 1u << 15u;
    }

    /**
     * Clear GLOBTF's CDWC bit.
     *
     * Write Control for Conversion Diagnostics
     */
    inline void clear_GLOBTF_CDWC() volatile
    {
        GLOBTF &= ~(1u << 15u);
    }

    /**
     * Toggle GLOBTF's CDWC bit.
     *
     * Write Control for Conversion Diagnostics
     */
    inline void toggle_GLOBTF_CDWC() volatile
    {
        GLOBTF ^= 1u << 15u;
    }

    /**
     * Get GLOBTF's CDSEL field.
     *
     * Converter Diagnostics Pull-Devices Select
     */
    inline VADC_GLOBTF_CDSEL get_GLOBTF_CDSEL() volatile
    {
        return VADC_GLOBTF_CDSEL((GLOBTF >> 9u) & 0b11u);
    }

    /**
     * Set GLOBTF's CDSEL field.
     *
     * Converter Diagnostics Pull-Devices Select
     */
    inline void set_GLOBTF_CDSEL(VADC_GLOBTF_CDSEL value) volatile
    {
        uint32_t curr = GLOBTF;

        curr &= ~(0b11u << 9u);
        curr |= (std::to_underlying(value) & 0b11u) << 9u;

        GLOBTF = curr;
    }

    /**
     * Get GLOBTF's CDEN bit.
     *
     * Converter Diagnostics Enable
     */
    inline bool get_GLOBTF_CDEN() volatile
    {
        return GLOBTF & (1u << 8u);
    }

    /**
     * Set GLOBTF's CDEN bit.
     *
     * Converter Diagnostics Enable
     */
    inline void set_GLOBTF_CDEN() volatile
    {
        GLOBTF |= 1u << 8u;
    }

    /**
     * Clear GLOBTF's CDEN bit.
     *
     * Converter Diagnostics Enable
     */
    inline void clear_GLOBTF_CDEN() volatile
    {
        GLOBTF &= ~(1u << 8u);
    }

    /**
     * Toggle GLOBTF's CDEN bit.
     *
     * Converter Diagnostics Enable
     */
    inline void toggle_GLOBTF_CDEN() volatile
    {
        GLOBTF ^= 1u << 8u;
    }

    /**
     * Get GLOBTF's CDGR field.
     *
     * Converter Diagnostics Group
     */
    inline uint8_t get_GLOBTF_CDGR() volatile
    {
        return (GLOBTF >> 4u) & 0b1111u;
    }

    /**
     * Set GLOBTF's CDGR field.
     *
     * Converter Diagnostics Group
     */
    inline void set_GLOBTF_CDGR(uint8_t value) volatile
    {
        uint32_t curr = GLOBTF;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        GLOBTF = curr;
    }

    /**
     * Get all of GLOBTF's bit fields.
     *
     * (read-write) Global Test Functions Register
     */
    inline void get_GLOBTF(bool &PDD, VADC_GLOBTF_CDSEL &CDSEL, bool &CDEN,
                           uint8_t &CDGR) volatile
    {
        uint32_t curr = GLOBTF;

        PDD = curr & (1u << 16u);
        CDSEL = VADC_GLOBTF_CDSEL((curr >> 9u) & 0b11u);
        CDEN = curr & (1u << 8u);
        CDGR = (curr >> 4u) & 0b1111u;
    }

    /**
     * Set all of GLOBTF's bit fields.
     *
     * (read-write) Global Test Functions Register
     */
    inline void set_GLOBTF(bool MDWC, bool PDD, bool CDWC,
                           VADC_GLOBTF_CDSEL CDSEL, bool CDEN,
                           uint8_t CDGR) volatile
    {
        uint32_t curr = GLOBTF;

        curr &= ~(0b1u << 23u);
        curr |= (MDWC & 0b1u) << 23u;
        curr &= ~(0b1u << 16u);
        curr |= (PDD & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (CDWC & 0b1u) << 15u;
        curr &= ~(0b11u << 9u);
        curr |= (std::to_underlying(CDSEL) & 0b11u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (CDEN & 0b1u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (CDGR & 0b1111u) << 4u;

        GLOBTF = curr;
    }

    /**
     * Get BRSSEL's CHSELG7 bit.
     *
     * Channel Selection Group x
     */
    inline bool get_BRSSEL_CHSELG7(std::size_t index) volatile
    {
        return BRSSEL[index] & (1u << 7u);
    }

    /**
     * Set BRSSEL's CHSELG7 bit.
     *
     * Channel Selection Group x
     */
    inline void set_BRSSEL_CHSELG7() volatile
    {
        BRSSEL |= 1u << 7u;
    }

    /**
     * Clear BRSSEL's CHSELG7 bit.
     *
     * Channel Selection Group x
     */
    inline void clear_BRSSEL_CHSELG7() volatile
    {
        BRSSEL &= ~(1u << 7u);
    }

    /**
     * Toggle BRSSEL's CHSELG7 bit.
     *
     * Channel Selection Group x
     */
    inline void toggle_BRSSEL_CHSELG7() volatile
    {
        BRSSEL ^= 1u << 7u;
    }

    /**
     * Get BRSSEL's CHSELG6 bit.
     *
     * Channel Selection Group x
     */
    inline bool get_BRSSEL_CHSELG6(std::size_t index) volatile
    {
        return BRSSEL[index] & (1u << 6u);
    }

    /**
     * Set BRSSEL's CHSELG6 bit.
     *
     * Channel Selection Group x
     */
    inline void set_BRSSEL_CHSELG6() volatile
    {
        BRSSEL |= 1u << 6u;
    }

    /**
     * Clear BRSSEL's CHSELG6 bit.
     *
     * Channel Selection Group x
     */
    inline void clear_BRSSEL_CHSELG6() volatile
    {
        BRSSEL &= ~(1u << 6u);
    }

    /**
     * Toggle BRSSEL's CHSELG6 bit.
     *
     * Channel Selection Group x
     */
    inline void toggle_BRSSEL_CHSELG6() volatile
    {
        BRSSEL ^= 1u << 6u;
    }

    /**
     * Get BRSSEL's CHSELG5 bit.
     *
     * Channel Selection Group x
     */
    inline bool get_BRSSEL_CHSELG5(std::size_t index) volatile
    {
        return BRSSEL[index] & (1u << 5u);
    }

    /**
     * Set BRSSEL's CHSELG5 bit.
     *
     * Channel Selection Group x
     */
    inline void set_BRSSEL_CHSELG5() volatile
    {
        BRSSEL |= 1u << 5u;
    }

    /**
     * Clear BRSSEL's CHSELG5 bit.
     *
     * Channel Selection Group x
     */
    inline void clear_BRSSEL_CHSELG5() volatile
    {
        BRSSEL &= ~(1u << 5u);
    }

    /**
     * Toggle BRSSEL's CHSELG5 bit.
     *
     * Channel Selection Group x
     */
    inline void toggle_BRSSEL_CHSELG5() volatile
    {
        BRSSEL ^= 1u << 5u;
    }

    /**
     * Get BRSSEL's CHSELG4 bit.
     *
     * Channel Selection Group x
     */
    inline bool get_BRSSEL_CHSELG4(std::size_t index) volatile
    {
        return BRSSEL[index] & (1u << 4u);
    }

    /**
     * Set BRSSEL's CHSELG4 bit.
     *
     * Channel Selection Group x
     */
    inline void set_BRSSEL_CHSELG4() volatile
    {
        BRSSEL |= 1u << 4u;
    }

    /**
     * Clear BRSSEL's CHSELG4 bit.
     *
     * Channel Selection Group x
     */
    inline void clear_BRSSEL_CHSELG4() volatile
    {
        BRSSEL &= ~(1u << 4u);
    }

    /**
     * Toggle BRSSEL's CHSELG4 bit.
     *
     * Channel Selection Group x
     */
    inline void toggle_BRSSEL_CHSELG4() volatile
    {
        BRSSEL ^= 1u << 4u;
    }

    /**
     * Get BRSSEL's CHSELG3 bit.
     *
     * Channel Selection Group x
     */
    inline bool get_BRSSEL_CHSELG3(std::size_t index) volatile
    {
        return BRSSEL[index] & (1u << 3u);
    }

    /**
     * Set BRSSEL's CHSELG3 bit.
     *
     * Channel Selection Group x
     */
    inline void set_BRSSEL_CHSELG3() volatile
    {
        BRSSEL |= 1u << 3u;
    }

    /**
     * Clear BRSSEL's CHSELG3 bit.
     *
     * Channel Selection Group x
     */
    inline void clear_BRSSEL_CHSELG3() volatile
    {
        BRSSEL &= ~(1u << 3u);
    }

    /**
     * Toggle BRSSEL's CHSELG3 bit.
     *
     * Channel Selection Group x
     */
    inline void toggle_BRSSEL_CHSELG3() volatile
    {
        BRSSEL ^= 1u << 3u;
    }

    /**
     * Get BRSSEL's CHSELG2 bit.
     *
     * Channel Selection Group x
     */
    inline bool get_BRSSEL_CHSELG2(std::size_t index) volatile
    {
        return BRSSEL[index] & (1u << 2u);
    }

    /**
     * Set BRSSEL's CHSELG2 bit.
     *
     * Channel Selection Group x
     */
    inline void set_BRSSEL_CHSELG2() volatile
    {
        BRSSEL |= 1u << 2u;
    }

    /**
     * Clear BRSSEL's CHSELG2 bit.
     *
     * Channel Selection Group x
     */
    inline void clear_BRSSEL_CHSELG2() volatile
    {
        BRSSEL &= ~(1u << 2u);
    }

    /**
     * Toggle BRSSEL's CHSELG2 bit.
     *
     * Channel Selection Group x
     */
    inline void toggle_BRSSEL_CHSELG2() volatile
    {
        BRSSEL ^= 1u << 2u;
    }

    /**
     * Get BRSSEL's CHSELG1 bit.
     *
     * Channel Selection Group x
     */
    inline bool get_BRSSEL_CHSELG1(std::size_t index) volatile
    {
        return BRSSEL[index] & (1u << 1u);
    }

    /**
     * Set BRSSEL's CHSELG1 bit.
     *
     * Channel Selection Group x
     */
    inline void set_BRSSEL_CHSELG1() volatile
    {
        BRSSEL |= 1u << 1u;
    }

    /**
     * Clear BRSSEL's CHSELG1 bit.
     *
     * Channel Selection Group x
     */
    inline void clear_BRSSEL_CHSELG1() volatile
    {
        BRSSEL &= ~(1u << 1u);
    }

    /**
     * Toggle BRSSEL's CHSELG1 bit.
     *
     * Channel Selection Group x
     */
    inline void toggle_BRSSEL_CHSELG1() volatile
    {
        BRSSEL ^= 1u << 1u;
    }

    /**
     * Get BRSSEL's CHSELG0 bit.
     *
     * Channel Selection Group x
     */
    inline bool get_BRSSEL_CHSELG0(std::size_t index) volatile
    {
        return BRSSEL[index] & (1u << 0u);
    }

    /**
     * Set BRSSEL's CHSELG0 bit.
     *
     * Channel Selection Group x
     */
    inline void set_BRSSEL_CHSELG0() volatile
    {
        BRSSEL |= 1u << 0u;
    }

    /**
     * Clear BRSSEL's CHSELG0 bit.
     *
     * Channel Selection Group x
     */
    inline void clear_BRSSEL_CHSELG0() volatile
    {
        BRSSEL &= ~(1u << 0u);
    }

    /**
     * Toggle BRSSEL's CHSELG0 bit.
     *
     * Channel Selection Group x
     */
    inline void toggle_BRSSEL_CHSELG0() volatile
    {
        BRSSEL ^= 1u << 0u;
    }

    /**
     * Get all of BRSSEL's bit fields.
     *
     * (read-write) Background Request Source Channel Select Register
     */
    inline void get_BRSSEL(std::size_t index, bool &CHSELG7, bool &CHSELG6,
                           bool &CHSELG5, bool &CHSELG4, bool &CHSELG3,
                           bool &CHSELG2, bool &CHSELG1,
                           bool &CHSELG0) volatile
    {
        uint32_t curr = BRSSEL[index];

        CHSELG7 = curr & (1u << 7u);
        CHSELG6 = curr & (1u << 6u);
        CHSELG5 = curr & (1u << 5u);
        CHSELG4 = curr & (1u << 4u);
        CHSELG3 = curr & (1u << 3u);
        CHSELG2 = curr & (1u << 2u);
        CHSELG1 = curr & (1u << 1u);
        CHSELG0 = curr & (1u << 0u);
    }

    /**
     * Set all of BRSSEL's bit fields.
     *
     * (read-write) Background Request Source Channel Select Register
     */
    inline void set_BRSSEL(std::size_t index, bool CHSELG7, bool CHSELG6,
                           bool CHSELG5, bool CHSELG4, bool CHSELG3,
                           bool CHSELG2, bool CHSELG1, bool CHSELG0) volatile
    {
        uint32_t curr = BRSSEL[index];

        curr &= ~(0b1u << 7u);
        curr |= (CHSELG7 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (CHSELG6 & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (CHSELG5 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (CHSELG4 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (CHSELG3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (CHSELG2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (CHSELG1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CHSELG0 & 0b1u) << 0u;

        BRSSEL[index] = curr;
    }

    /**
     * Get BRSPND's CHPNDG7 bit.
     *
     * Channels Pending Group x
     */
    inline bool get_BRSPND_CHPNDG7(std::size_t index) volatile
    {
        return BRSPND[index] & (1u << 7u);
    }

    /**
     * Set BRSPND's CHPNDG7 bit.
     *
     * Channels Pending Group x
     */
    inline void set_BRSPND_CHPNDG7() volatile
    {
        BRSPND |= 1u << 7u;
    }

    /**
     * Clear BRSPND's CHPNDG7 bit.
     *
     * Channels Pending Group x
     */
    inline void clear_BRSPND_CHPNDG7() volatile
    {
        BRSPND &= ~(1u << 7u);
    }

    /**
     * Toggle BRSPND's CHPNDG7 bit.
     *
     * Channels Pending Group x
     */
    inline void toggle_BRSPND_CHPNDG7() volatile
    {
        BRSPND ^= 1u << 7u;
    }

    /**
     * Get BRSPND's CHPNDG6 bit.
     *
     * Channels Pending Group x
     */
    inline bool get_BRSPND_CHPNDG6(std::size_t index) volatile
    {
        return BRSPND[index] & (1u << 6u);
    }

    /**
     * Set BRSPND's CHPNDG6 bit.
     *
     * Channels Pending Group x
     */
    inline void set_BRSPND_CHPNDG6() volatile
    {
        BRSPND |= 1u << 6u;
    }

    /**
     * Clear BRSPND's CHPNDG6 bit.
     *
     * Channels Pending Group x
     */
    inline void clear_BRSPND_CHPNDG6() volatile
    {
        BRSPND &= ~(1u << 6u);
    }

    /**
     * Toggle BRSPND's CHPNDG6 bit.
     *
     * Channels Pending Group x
     */
    inline void toggle_BRSPND_CHPNDG6() volatile
    {
        BRSPND ^= 1u << 6u;
    }

    /**
     * Get BRSPND's CHPNDG5 bit.
     *
     * Channels Pending Group x
     */
    inline bool get_BRSPND_CHPNDG5(std::size_t index) volatile
    {
        return BRSPND[index] & (1u << 5u);
    }

    /**
     * Set BRSPND's CHPNDG5 bit.
     *
     * Channels Pending Group x
     */
    inline void set_BRSPND_CHPNDG5() volatile
    {
        BRSPND |= 1u << 5u;
    }

    /**
     * Clear BRSPND's CHPNDG5 bit.
     *
     * Channels Pending Group x
     */
    inline void clear_BRSPND_CHPNDG5() volatile
    {
        BRSPND &= ~(1u << 5u);
    }

    /**
     * Toggle BRSPND's CHPNDG5 bit.
     *
     * Channels Pending Group x
     */
    inline void toggle_BRSPND_CHPNDG5() volatile
    {
        BRSPND ^= 1u << 5u;
    }

    /**
     * Get BRSPND's CHPNDG4 bit.
     *
     * Channels Pending Group x
     */
    inline bool get_BRSPND_CHPNDG4(std::size_t index) volatile
    {
        return BRSPND[index] & (1u << 4u);
    }

    /**
     * Set BRSPND's CHPNDG4 bit.
     *
     * Channels Pending Group x
     */
    inline void set_BRSPND_CHPNDG4() volatile
    {
        BRSPND |= 1u << 4u;
    }

    /**
     * Clear BRSPND's CHPNDG4 bit.
     *
     * Channels Pending Group x
     */
    inline void clear_BRSPND_CHPNDG4() volatile
    {
        BRSPND &= ~(1u << 4u);
    }

    /**
     * Toggle BRSPND's CHPNDG4 bit.
     *
     * Channels Pending Group x
     */
    inline void toggle_BRSPND_CHPNDG4() volatile
    {
        BRSPND ^= 1u << 4u;
    }

    /**
     * Get BRSPND's CHPNDG3 bit.
     *
     * Channels Pending Group x
     */
    inline bool get_BRSPND_CHPNDG3(std::size_t index) volatile
    {
        return BRSPND[index] & (1u << 3u);
    }

    /**
     * Set BRSPND's CHPNDG3 bit.
     *
     * Channels Pending Group x
     */
    inline void set_BRSPND_CHPNDG3() volatile
    {
        BRSPND |= 1u << 3u;
    }

    /**
     * Clear BRSPND's CHPNDG3 bit.
     *
     * Channels Pending Group x
     */
    inline void clear_BRSPND_CHPNDG3() volatile
    {
        BRSPND &= ~(1u << 3u);
    }

    /**
     * Toggle BRSPND's CHPNDG3 bit.
     *
     * Channels Pending Group x
     */
    inline void toggle_BRSPND_CHPNDG3() volatile
    {
        BRSPND ^= 1u << 3u;
    }

    /**
     * Get BRSPND's CHPNDG2 bit.
     *
     * Channels Pending Group x
     */
    inline bool get_BRSPND_CHPNDG2(std::size_t index) volatile
    {
        return BRSPND[index] & (1u << 2u);
    }

    /**
     * Set BRSPND's CHPNDG2 bit.
     *
     * Channels Pending Group x
     */
    inline void set_BRSPND_CHPNDG2() volatile
    {
        BRSPND |= 1u << 2u;
    }

    /**
     * Clear BRSPND's CHPNDG2 bit.
     *
     * Channels Pending Group x
     */
    inline void clear_BRSPND_CHPNDG2() volatile
    {
        BRSPND &= ~(1u << 2u);
    }

    /**
     * Toggle BRSPND's CHPNDG2 bit.
     *
     * Channels Pending Group x
     */
    inline void toggle_BRSPND_CHPNDG2() volatile
    {
        BRSPND ^= 1u << 2u;
    }

    /**
     * Get BRSPND's CHPNDG1 bit.
     *
     * Channels Pending Group x
     */
    inline bool get_BRSPND_CHPNDG1(std::size_t index) volatile
    {
        return BRSPND[index] & (1u << 1u);
    }

    /**
     * Set BRSPND's CHPNDG1 bit.
     *
     * Channels Pending Group x
     */
    inline void set_BRSPND_CHPNDG1() volatile
    {
        BRSPND |= 1u << 1u;
    }

    /**
     * Clear BRSPND's CHPNDG1 bit.
     *
     * Channels Pending Group x
     */
    inline void clear_BRSPND_CHPNDG1() volatile
    {
        BRSPND &= ~(1u << 1u);
    }

    /**
     * Toggle BRSPND's CHPNDG1 bit.
     *
     * Channels Pending Group x
     */
    inline void toggle_BRSPND_CHPNDG1() volatile
    {
        BRSPND ^= 1u << 1u;
    }

    /**
     * Get BRSPND's CHPNDG0 bit.
     *
     * Channels Pending Group x
     */
    inline bool get_BRSPND_CHPNDG0(std::size_t index) volatile
    {
        return BRSPND[index] & (1u << 0u);
    }

    /**
     * Set BRSPND's CHPNDG0 bit.
     *
     * Channels Pending Group x
     */
    inline void set_BRSPND_CHPNDG0() volatile
    {
        BRSPND |= 1u << 0u;
    }

    /**
     * Clear BRSPND's CHPNDG0 bit.
     *
     * Channels Pending Group x
     */
    inline void clear_BRSPND_CHPNDG0() volatile
    {
        BRSPND &= ~(1u << 0u);
    }

    /**
     * Toggle BRSPND's CHPNDG0 bit.
     *
     * Channels Pending Group x
     */
    inline void toggle_BRSPND_CHPNDG0() volatile
    {
        BRSPND ^= 1u << 0u;
    }

    /**
     * Get all of BRSPND's bit fields.
     *
     * (read-write) Background Request Source Pending Register
     */
    inline void get_BRSPND(std::size_t index, bool &CHPNDG7, bool &CHPNDG6,
                           bool &CHPNDG5, bool &CHPNDG4, bool &CHPNDG3,
                           bool &CHPNDG2, bool &CHPNDG1,
                           bool &CHPNDG0) volatile
    {
        uint32_t curr = BRSPND[index];

        CHPNDG7 = curr & (1u << 7u);
        CHPNDG6 = curr & (1u << 6u);
        CHPNDG5 = curr & (1u << 5u);
        CHPNDG4 = curr & (1u << 4u);
        CHPNDG3 = curr & (1u << 3u);
        CHPNDG2 = curr & (1u << 2u);
        CHPNDG1 = curr & (1u << 1u);
        CHPNDG0 = curr & (1u << 0u);
    }

    /**
     * Set all of BRSPND's bit fields.
     *
     * (read-write) Background Request Source Pending Register
     */
    inline void set_BRSPND(std::size_t index, bool CHPNDG7, bool CHPNDG6,
                           bool CHPNDG5, bool CHPNDG4, bool CHPNDG3,
                           bool CHPNDG2, bool CHPNDG1, bool CHPNDG0) volatile
    {
        uint32_t curr = BRSPND[index];

        curr &= ~(0b1u << 7u);
        curr |= (CHPNDG7 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (CHPNDG6 & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (CHPNDG5 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (CHPNDG4 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (CHPNDG3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (CHPNDG2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (CHPNDG1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CHPNDG0 & 0b1u) << 0u;

        BRSPND[index] = curr;
    }

    /**
     * Set BRSCTRL's GTWC bit.
     *
     * Write Control for Gate Configuration
     */
    inline void set_BRSCTRL_GTWC() volatile
    {
        BRSCTRL |= 1u << 23u;
    }

    /**
     * Clear BRSCTRL's GTWC bit.
     *
     * Write Control for Gate Configuration
     */
    inline void clear_BRSCTRL_GTWC() volatile
    {
        BRSCTRL &= ~(1u << 23u);
    }

    /**
     * Toggle BRSCTRL's GTWC bit.
     *
     * Write Control for Gate Configuration
     */
    inline void toggle_BRSCTRL_GTWC() volatile
    {
        BRSCTRL ^= 1u << 23u;
    }

    /**
     * Get BRSCTRL's GTLVL bit.
     *
     * Gate Input Level
     */
    inline bool get_BRSCTRL_GTLVL() volatile
    {
        return BRSCTRL & (1u << 20u);
    }

    /**
     * Get BRSCTRL's GTSEL field.
     *
     * Gate Input Selection
     */
    inline uint8_t get_BRSCTRL_GTSEL() volatile
    {
        return (BRSCTRL >> 16u) & 0b1111u;
    }

    /**
     * Set BRSCTRL's GTSEL field.
     *
     * Gate Input Selection
     */
    inline void set_BRSCTRL_GTSEL(uint8_t value) volatile
    {
        uint32_t curr = BRSCTRL;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        BRSCTRL = curr;
    }

    /**
     * Set BRSCTRL's XTWC bit.
     *
     * Write Control for Trigger Configuration
     */
    inline void set_BRSCTRL_XTWC() volatile
    {
        BRSCTRL |= 1u << 15u;
    }

    /**
     * Clear BRSCTRL's XTWC bit.
     *
     * Write Control for Trigger Configuration
     */
    inline void clear_BRSCTRL_XTWC() volatile
    {
        BRSCTRL &= ~(1u << 15u);
    }

    /**
     * Toggle BRSCTRL's XTWC bit.
     *
     * Write Control for Trigger Configuration
     */
    inline void toggle_BRSCTRL_XTWC() volatile
    {
        BRSCTRL ^= 1u << 15u;
    }

    /**
     * Get BRSCTRL's XTMODE field.
     *
     * Trigger Operating Mode
     */
    inline VADC_BRSCTRL_XTMODE get_BRSCTRL_XTMODE() volatile
    {
        return VADC_BRSCTRL_XTMODE((BRSCTRL >> 13u) & 0b11u);
    }

    /**
     * Set BRSCTRL's XTMODE field.
     *
     * Trigger Operating Mode
     */
    inline void set_BRSCTRL_XTMODE(VADC_BRSCTRL_XTMODE value) volatile
    {
        uint32_t curr = BRSCTRL;

        curr &= ~(0b11u << 13u);
        curr |= (std::to_underlying(value) & 0b11u) << 13u;

        BRSCTRL = curr;
    }

    /**
     * Get BRSCTRL's XTLVL bit.
     *
     * External Trigger Level
     */
    inline bool get_BRSCTRL_XTLVL() volatile
    {
        return BRSCTRL & (1u << 12u);
    }

    /**
     * Get BRSCTRL's XTSEL field.
     *
     * External Trigger Input Selection
     */
    inline uint8_t get_BRSCTRL_XTSEL() volatile
    {
        return (BRSCTRL >> 8u) & 0b1111u;
    }

    /**
     * Set BRSCTRL's XTSEL field.
     *
     * External Trigger Input Selection
     */
    inline void set_BRSCTRL_XTSEL(uint8_t value) volatile
    {
        uint32_t curr = BRSCTRL;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        BRSCTRL = curr;
    }

    /**
     * Get BRSCTRL's SRCRESREG field.
     *
     * Source-specific Result Register
     */
    inline VADC_BRSCTRL_SRCRESREG get_BRSCTRL_SRCRESREG() volatile
    {
        return VADC_BRSCTRL_SRCRESREG((BRSCTRL >> 0u) & 0b1111u);
    }

    /**
     * Set BRSCTRL's SRCRESREG field.
     *
     * Source-specific Result Register
     */
    inline void set_BRSCTRL_SRCRESREG(VADC_BRSCTRL_SRCRESREG value) volatile
    {
        uint32_t curr = BRSCTRL;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        BRSCTRL = curr;
    }

    /**
     * Get all of BRSCTRL's bit fields.
     *
     * (read-write) Background Request Source Control Register
     */
    inline void get_BRSCTRL(bool &GTLVL, uint8_t &GTSEL,
                            VADC_BRSCTRL_XTMODE &XTMODE, bool &XTLVL,
                            uint8_t &XTSEL,
                            VADC_BRSCTRL_SRCRESREG &SRCRESREG) volatile
    {
        uint32_t curr = BRSCTRL;

        GTLVL = curr & (1u << 20u);
        GTSEL = (curr >> 16u) & 0b1111u;
        XTMODE = VADC_BRSCTRL_XTMODE((curr >> 13u) & 0b11u);
        XTLVL = curr & (1u << 12u);
        XTSEL = (curr >> 8u) & 0b1111u;
        SRCRESREG = VADC_BRSCTRL_SRCRESREG((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of BRSCTRL's bit fields.
     *
     * (read-write) Background Request Source Control Register
     */
    inline void set_BRSCTRL(bool GTWC, uint8_t GTSEL, bool XTWC,
                            VADC_BRSCTRL_XTMODE XTMODE, uint8_t XTSEL,
                            VADC_BRSCTRL_SRCRESREG SRCRESREG) volatile
    {
        uint32_t curr = BRSCTRL;

        curr &= ~(0b1u << 23u);
        curr |= (GTWC & 0b1u) << 23u;
        curr &= ~(0b1111u << 16u);
        curr |= (GTSEL & 0b1111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (XTWC & 0b1u) << 15u;
        curr &= ~(0b11u << 13u);
        curr |= (std::to_underlying(XTMODE) & 0b11u) << 13u;
        curr &= ~(0b1111u << 8u);
        curr |= (XTSEL & 0b1111u) << 8u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(SRCRESREG) & 0b1111u) << 0u;

        BRSCTRL = curr;
    }

    /**
     * Get BRSMR's RPTDIS bit.
     *
     * Repeat Disable
     */
    inline bool get_BRSMR_RPTDIS() volatile
    {
        return BRSMR & (1u << 16u);
    }

    /**
     * Set BRSMR's RPTDIS bit.
     *
     * Repeat Disable
     */
    inline void set_BRSMR_RPTDIS() volatile
    {
        BRSMR |= 1u << 16u;
    }

    /**
     * Clear BRSMR's RPTDIS bit.
     *
     * Repeat Disable
     */
    inline void clear_BRSMR_RPTDIS() volatile
    {
        BRSMR &= ~(1u << 16u);
    }

    /**
     * Toggle BRSMR's RPTDIS bit.
     *
     * Repeat Disable
     */
    inline void toggle_BRSMR_RPTDIS() volatile
    {
        BRSMR ^= 1u << 16u;
    }

    /**
     * Set BRSMR's LDEV bit.
     *
     * Generate Load Event
     */
    inline void set_BRSMR_LDEV() volatile
    {
        BRSMR |= 1u << 9u;
    }

    /**
     * Clear BRSMR's LDEV bit.
     *
     * Generate Load Event
     */
    inline void clear_BRSMR_LDEV() volatile
    {
        BRSMR &= ~(1u << 9u);
    }

    /**
     * Toggle BRSMR's LDEV bit.
     *
     * Generate Load Event
     */
    inline void toggle_BRSMR_LDEV() volatile
    {
        BRSMR ^= 1u << 9u;
    }

    /**
     * Set BRSMR's CLRPND bit.
     *
     * Clear Pending Bits
     */
    inline void set_BRSMR_CLRPND() volatile
    {
        BRSMR |= 1u << 8u;
    }

    /**
     * Clear BRSMR's CLRPND bit.
     *
     * Clear Pending Bits
     */
    inline void clear_BRSMR_CLRPND() volatile
    {
        BRSMR &= ~(1u << 8u);
    }

    /**
     * Toggle BRSMR's CLRPND bit.
     *
     * Clear Pending Bits
     */
    inline void toggle_BRSMR_CLRPND() volatile
    {
        BRSMR ^= 1u << 8u;
    }

    /**
     * Get BRSMR's REQGT bit.
     *
     * Request Gate Level
     */
    inline bool get_BRSMR_REQGT() volatile
    {
        return BRSMR & (1u << 7u);
    }

    /**
     * Get BRSMR's LDM bit.
     *
     * Autoscan Source Load Event Mode
     */
    inline bool get_BRSMR_LDM() volatile
    {
        return BRSMR & (1u << 5u);
    }

    /**
     * Set BRSMR's LDM bit.
     *
     * Autoscan Source Load Event Mode
     */
    inline void set_BRSMR_LDM() volatile
    {
        BRSMR |= 1u << 5u;
    }

    /**
     * Clear BRSMR's LDM bit.
     *
     * Autoscan Source Load Event Mode
     */
    inline void clear_BRSMR_LDM() volatile
    {
        BRSMR &= ~(1u << 5u);
    }

    /**
     * Toggle BRSMR's LDM bit.
     *
     * Autoscan Source Load Event Mode
     */
    inline void toggle_BRSMR_LDM() volatile
    {
        BRSMR ^= 1u << 5u;
    }

    /**
     * Get BRSMR's SCAN bit.
     *
     * Autoscan Enable
     */
    inline bool get_BRSMR_SCAN() volatile
    {
        return BRSMR & (1u << 4u);
    }

    /**
     * Set BRSMR's SCAN bit.
     *
     * Autoscan Enable
     */
    inline void set_BRSMR_SCAN() volatile
    {
        BRSMR |= 1u << 4u;
    }

    /**
     * Clear BRSMR's SCAN bit.
     *
     * Autoscan Enable
     */
    inline void clear_BRSMR_SCAN() volatile
    {
        BRSMR &= ~(1u << 4u);
    }

    /**
     * Toggle BRSMR's SCAN bit.
     *
     * Autoscan Enable
     */
    inline void toggle_BRSMR_SCAN() volatile
    {
        BRSMR ^= 1u << 4u;
    }

    /**
     * Get BRSMR's ENSI bit.
     *
     * Enable Source Interrupt
     */
    inline bool get_BRSMR_ENSI() volatile
    {
        return BRSMR & (1u << 3u);
    }

    /**
     * Set BRSMR's ENSI bit.
     *
     * Enable Source Interrupt
     */
    inline void set_BRSMR_ENSI() volatile
    {
        BRSMR |= 1u << 3u;
    }

    /**
     * Clear BRSMR's ENSI bit.
     *
     * Enable Source Interrupt
     */
    inline void clear_BRSMR_ENSI() volatile
    {
        BRSMR &= ~(1u << 3u);
    }

    /**
     * Toggle BRSMR's ENSI bit.
     *
     * Enable Source Interrupt
     */
    inline void toggle_BRSMR_ENSI() volatile
    {
        BRSMR ^= 1u << 3u;
    }

    /**
     * Get BRSMR's ENTR bit.
     *
     * Enable External Trigger
     */
    inline bool get_BRSMR_ENTR() volatile
    {
        return BRSMR & (1u << 2u);
    }

    /**
     * Set BRSMR's ENTR bit.
     *
     * Enable External Trigger
     */
    inline void set_BRSMR_ENTR() volatile
    {
        BRSMR |= 1u << 2u;
    }

    /**
     * Clear BRSMR's ENTR bit.
     *
     * Enable External Trigger
     */
    inline void clear_BRSMR_ENTR() volatile
    {
        BRSMR &= ~(1u << 2u);
    }

    /**
     * Toggle BRSMR's ENTR bit.
     *
     * Enable External Trigger
     */
    inline void toggle_BRSMR_ENTR() volatile
    {
        BRSMR ^= 1u << 2u;
    }

    /**
     * Get BRSMR's ENGT field.
     *
     * Enable Gate
     */
    inline VADC_BRSMR_ENGT get_BRSMR_ENGT() volatile
    {
        return VADC_BRSMR_ENGT((BRSMR >> 0u) & 0b11u);
    }

    /**
     * Set BRSMR's ENGT field.
     *
     * Enable Gate
     */
    inline void set_BRSMR_ENGT(VADC_BRSMR_ENGT value) volatile
    {
        uint32_t curr = BRSMR;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        BRSMR = curr;
    }

    /**
     * Get all of BRSMR's bit fields.
     *
     * (read-write) Background Request Source Mode Register
     */
    inline void get_BRSMR(bool &RPTDIS, bool &REQGT, bool &LDM, bool &SCAN,
                          bool &ENSI, bool &ENTR,
                          VADC_BRSMR_ENGT &ENGT) volatile
    {
        uint32_t curr = BRSMR;

        RPTDIS = curr & (1u << 16u);
        REQGT = curr & (1u << 7u);
        LDM = curr & (1u << 5u);
        SCAN = curr & (1u << 4u);
        ENSI = curr & (1u << 3u);
        ENTR = curr & (1u << 2u);
        ENGT = VADC_BRSMR_ENGT((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of BRSMR's bit fields.
     *
     * (read-write) Background Request Source Mode Register
     */
    inline void set_BRSMR(bool RPTDIS, bool LDEV, bool CLRPND, bool LDM,
                          bool SCAN, bool ENSI, bool ENTR,
                          VADC_BRSMR_ENGT ENGT) volatile
    {
        uint32_t curr = BRSMR;

        curr &= ~(0b1u << 16u);
        curr |= (RPTDIS & 0b1u) << 16u;
        curr &= ~(0b1u << 9u);
        curr |= (LDEV & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (CLRPND & 0b1u) << 8u;
        curr &= ~(0b1u << 5u);
        curr |= (LDM & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (SCAN & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (ENSI & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ENTR & 0b1u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(ENGT) & 0b11u) << 0u;

        BRSMR = curr;
    }

    /**
     * Get GLOBRCR's SRGEN bit.
     *
     * Service Request Generation Enable
     */
    inline bool get_GLOBRCR_SRGEN() volatile
    {
        return GLOBRCR & (1u << 31u);
    }

    /**
     * Set GLOBRCR's SRGEN bit.
     *
     * Service Request Generation Enable
     */
    inline void set_GLOBRCR_SRGEN() volatile
    {
        GLOBRCR |= 1u << 31u;
    }

    /**
     * Clear GLOBRCR's SRGEN bit.
     *
     * Service Request Generation Enable
     */
    inline void clear_GLOBRCR_SRGEN() volatile
    {
        GLOBRCR &= ~(1u << 31u);
    }

    /**
     * Toggle GLOBRCR's SRGEN bit.
     *
     * Service Request Generation Enable
     */
    inline void toggle_GLOBRCR_SRGEN() volatile
    {
        GLOBRCR ^= 1u << 31u;
    }

    /**
     * Get GLOBRCR's WFR bit.
     *
     * Wait-for-Read Mode Enable
     */
    inline bool get_GLOBRCR_WFR() volatile
    {
        return GLOBRCR & (1u << 24u);
    }

    /**
     * Set GLOBRCR's WFR bit.
     *
     * Wait-for-Read Mode Enable
     */
    inline void set_GLOBRCR_WFR() volatile
    {
        GLOBRCR |= 1u << 24u;
    }

    /**
     * Clear GLOBRCR's WFR bit.
     *
     * Wait-for-Read Mode Enable
     */
    inline void clear_GLOBRCR_WFR() volatile
    {
        GLOBRCR &= ~(1u << 24u);
    }

    /**
     * Toggle GLOBRCR's WFR bit.
     *
     * Wait-for-Read Mode Enable
     */
    inline void toggle_GLOBRCR_WFR() volatile
    {
        GLOBRCR ^= 1u << 24u;
    }

    /**
     * Get GLOBRCR's DRCTR field.
     *
     * Data Reduction Control
     */
    inline VADC_GLOBRCR_DRCTR get_GLOBRCR_DRCTR() volatile
    {
        return VADC_GLOBRCR_DRCTR((GLOBRCR >> 16u) & 0b1111u);
    }

    /**
     * Set GLOBRCR's DRCTR field.
     *
     * Data Reduction Control
     */
    inline void set_GLOBRCR_DRCTR(VADC_GLOBRCR_DRCTR value) volatile
    {
        uint32_t curr = GLOBRCR;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        GLOBRCR = curr;
    }

    /**
     * Get all of GLOBRCR's bit fields.
     *
     * (read-write) Global Result Control Register
     */
    inline void get_GLOBRCR(bool &SRGEN, bool &WFR,
                            VADC_GLOBRCR_DRCTR &DRCTR) volatile
    {
        uint32_t curr = GLOBRCR;

        SRGEN = curr & (1u << 31u);
        WFR = curr & (1u << 24u);
        DRCTR = VADC_GLOBRCR_DRCTR((curr >> 16u) & 0b1111u);
    }

    /**
     * Set all of GLOBRCR's bit fields.
     *
     * (read-write) Global Result Control Register
     */
    inline void set_GLOBRCR(bool SRGEN, bool WFR,
                            VADC_GLOBRCR_DRCTR DRCTR) volatile
    {
        uint32_t curr = GLOBRCR;

        curr &= ~(0b1u << 31u);
        curr |= (SRGEN & 0b1u) << 31u;
        curr &= ~(0b1u << 24u);
        curr |= (WFR & 0b1u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(DRCTR) & 0b1111u) << 16u;

        GLOBRCR = curr;
    }

    /**
     * Get GLOBRES's VF bit.
     *
     * Valid Flag
     */
    inline bool get_GLOBRES_VF() volatile
    {
        return GLOBRES & (1u << 31u);
    }

    /**
     * Set GLOBRES's VF bit.
     *
     * Valid Flag
     */
    inline void set_GLOBRES_VF() volatile
    {
        GLOBRES |= 1u << 31u;
    }

    /**
     * Clear GLOBRES's VF bit.
     *
     * Valid Flag
     */
    inline void clear_GLOBRES_VF() volatile
    {
        GLOBRES &= ~(1u << 31u);
    }

    /**
     * Toggle GLOBRES's VF bit.
     *
     * Valid Flag
     */
    inline void toggle_GLOBRES_VF() volatile
    {
        GLOBRES ^= 1u << 31u;
    }

    /**
     * Get GLOBRES's FCR bit.
     *
     * Fast Compare Result
     */
    inline bool get_GLOBRES_FCR() volatile
    {
        return GLOBRES & (1u << 30u);
    }

    /**
     * Get GLOBRES's CRS field.
     *
     * Converted Request Source
     */
    inline uint8_t get_GLOBRES_CRS() volatile
    {
        return (GLOBRES >> 28u) & 0b11u;
    }

    /**
     * Get GLOBRES's EMUX field.
     *
     * External Multiplexer Setting
     */
    inline uint8_t get_GLOBRES_EMUX() volatile
    {
        return (GLOBRES >> 25u) & 0b111u;
    }

    /**
     * Get GLOBRES's CHNR field.
     *
     * Channel Number
     */
    inline uint8_t get_GLOBRES_CHNR() volatile
    {
        return (GLOBRES >> 20u) & 0b11111u;
    }

    /**
     * Get GLOBRES's GNR field.
     *
     * Group Number
     */
    inline uint8_t get_GLOBRES_GNR() volatile
    {
        return (GLOBRES >> 16u) & 0b1111u;
    }

    /**
     * Get GLOBRES's RESULT field.
     *
     * Result of most recent conversion
     */
    inline uint16_t get_GLOBRES_RESULT() volatile
    {
        return (GLOBRES >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set GLOBRES's RESULT field.
     *
     * Result of most recent conversion
     */
    inline void set_GLOBRES_RESULT(uint16_t value) volatile
    {
        uint32_t curr = GLOBRES;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        GLOBRES = curr;
    }

    /**
     * Get all of GLOBRES's bit fields.
     *
     * (read-write) Global Result Register
     */
    inline void get_GLOBRES(bool &VF, bool &FCR, uint8_t &CRS, uint8_t &EMUX,
                            uint8_t &CHNR, uint8_t &GNR,
                            uint16_t &RESULT) volatile
    {
        uint32_t curr = GLOBRES;

        VF = curr & (1u << 31u);
        FCR = curr & (1u << 30u);
        CRS = (curr >> 28u) & 0b11u;
        EMUX = (curr >> 25u) & 0b111u;
        CHNR = (curr >> 20u) & 0b11111u;
        GNR = (curr >> 16u) & 0b1111u;
        RESULT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of GLOBRES's bit fields.
     *
     * (read-write) Global Result Register
     */
    inline void set_GLOBRES(bool VF, uint16_t RESULT) volatile
    {
        uint32_t curr = GLOBRES;

        curr &= ~(0b1u << 31u);
        curr |= (VF & 0b1u) << 31u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (RESULT & 0b1111111111111111u) << 0u;

        GLOBRES = curr;
    }

    /**
     * Get GLOBRESD's VF bit.
     *
     * Valid Flag
     */
    inline bool get_GLOBRESD_VF() volatile
    {
        return GLOBRESD & (1u << 31u);
    }

    /**
     * Set GLOBRESD's VF bit.
     *
     * Valid Flag
     */
    inline void set_GLOBRESD_VF() volatile
    {
        GLOBRESD |= 1u << 31u;
    }

    /**
     * Clear GLOBRESD's VF bit.
     *
     * Valid Flag
     */
    inline void clear_GLOBRESD_VF() volatile
    {
        GLOBRESD &= ~(1u << 31u);
    }

    /**
     * Toggle GLOBRESD's VF bit.
     *
     * Valid Flag
     */
    inline void toggle_GLOBRESD_VF() volatile
    {
        GLOBRESD ^= 1u << 31u;
    }

    /**
     * Get GLOBRESD's FCR bit.
     *
     * Fast Compare Result
     */
    inline bool get_GLOBRESD_FCR() volatile
    {
        return GLOBRESD & (1u << 30u);
    }

    /**
     * Get GLOBRESD's CRS field.
     *
     * Converted Request Source
     */
    inline uint8_t get_GLOBRESD_CRS() volatile
    {
        return (GLOBRESD >> 28u) & 0b11u;
    }

    /**
     * Get GLOBRESD's EMUX field.
     *
     * External Multiplexer Setting
     */
    inline uint8_t get_GLOBRESD_EMUX() volatile
    {
        return (GLOBRESD >> 25u) & 0b111u;
    }

    /**
     * Get GLOBRESD's CHNR field.
     *
     * Channel Number
     */
    inline uint8_t get_GLOBRESD_CHNR() volatile
    {
        return (GLOBRESD >> 20u) & 0b11111u;
    }

    /**
     * Get GLOBRESD's GNR field.
     *
     * Group Number
     */
    inline uint8_t get_GLOBRESD_GNR() volatile
    {
        return (GLOBRESD >> 16u) & 0b1111u;
    }

    /**
     * Get GLOBRESD's RESULT field.
     *
     * Result of most recent conversion
     */
    inline uint16_t get_GLOBRESD_RESULT() volatile
    {
        return (GLOBRESD >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set GLOBRESD's RESULT field.
     *
     * Result of most recent conversion
     */
    inline void set_GLOBRESD_RESULT(uint16_t value) volatile
    {
        uint32_t curr = GLOBRESD;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        GLOBRESD = curr;
    }

    /**
     * Get all of GLOBRESD's bit fields.
     *
     * (read-write) Global Result Register, Debug
     */
    inline void get_GLOBRESD(bool &VF, bool &FCR, uint8_t &CRS, uint8_t &EMUX,
                             uint8_t &CHNR, uint8_t &GNR,
                             uint16_t &RESULT) volatile
    {
        uint32_t curr = GLOBRESD;

        VF = curr & (1u << 31u);
        FCR = curr & (1u << 30u);
        CRS = (curr >> 28u) & 0b11u;
        EMUX = (curr >> 25u) & 0b111u;
        CHNR = (curr >> 20u) & 0b11111u;
        GNR = (curr >> 16u) & 0b1111u;
        RESULT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of GLOBRESD's bit fields.
     *
     * (read-write) Global Result Register, Debug
     */
    inline void set_GLOBRESD(bool VF, uint16_t RESULT) volatile
    {
        uint32_t curr = GLOBRESD;

        curr &= ~(0b1u << 31u);
        curr |= (VF & 0b1u) << 31u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (RESULT & 0b1111111111111111u) << 0u;

        GLOBRESD = curr;
    }

    /**
     * Get EMUXSEL's EMUXGRP1 field.
     *
     * External Multiplexer Group for Interface x
     */
    inline uint8_t get_EMUXSEL_EMUXGRP1() volatile
    {
        return (EMUXSEL >> 4u) & 0b1111u;
    }

    /**
     * Set EMUXSEL's EMUXGRP1 field.
     *
     * External Multiplexer Group for Interface x
     */
    inline void set_EMUXSEL_EMUXGRP1(uint8_t value) volatile
    {
        uint32_t curr = EMUXSEL;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        EMUXSEL = curr;
    }

    /**
     * Get EMUXSEL's EMUXGRP0 field.
     *
     * External Multiplexer Group for Interface x
     */
    inline uint8_t get_EMUXSEL_EMUXGRP0() volatile
    {
        return (EMUXSEL >> 0u) & 0b1111u;
    }

    /**
     * Set EMUXSEL's EMUXGRP0 field.
     *
     * External Multiplexer Group for Interface x
     */
    inline void set_EMUXSEL_EMUXGRP0(uint8_t value) volatile
    {
        uint32_t curr = EMUXSEL;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        EMUXSEL = curr;
    }

    /**
     * Get all of EMUXSEL's bit fields.
     *
     * (read-write) External Multiplexer Select Register
     */
    inline void get_EMUXSEL(uint8_t &EMUXGRP1, uint8_t &EMUXGRP0) volatile
    {
        uint32_t curr = EMUXSEL;

        EMUXGRP1 = (curr >> 4u) & 0b1111u;
        EMUXGRP0 = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of EMUXSEL's bit fields.
     *
     * (read-write) External Multiplexer Select Register
     */
    inline void set_EMUXSEL(uint8_t EMUXGRP1, uint8_t EMUXGRP0) volatile
    {
        uint32_t curr = EMUXSEL;

        curr &= ~(0b1111u << 4u);
        curr |= (EMUXGRP1 & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (EMUXGRP0 & 0b1111u) << 0u;

        EMUXSEL = curr;
    }
};

static_assert(sizeof(vadc) == vadc::size);

static volatile vadc *const VADC = reinterpret_cast<vadc *>(0x40004000);

}; // namespace XMC4700
