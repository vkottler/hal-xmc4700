/**
 * \file
 * \brief Generated by ifgen (3.1.4).
 */
#pragma once

#include "../enums/GPDMA1_CH0_CFGH_FCMODE.h"
#include "../enums/GPDMA1_CH0_CFGH_FIFO_MODE.h"
#include "../enums/GPDMA1_CH0_CFGL_CH_SUSP.h"
#include "../enums/GPDMA1_CH0_CFGL_DST_HS_POL.h"
#include "../enums/GPDMA1_CH0_CFGL_FIFO_EMPTY.h"
#include "../enums/GPDMA1_CH0_CFGL_HS_SEL_DST.h"
#include "../enums/GPDMA1_CH0_CFGL_HS_SEL_SRC.h"
#include "../enums/GPDMA1_CH0_CFGL_LOCK_CH_L.h"
#include "../enums/GPDMA1_CH0_CTLL_DINC.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * General Purpose DMA Unit 1
 */
struct [[gnu::packed]] gpdma1_ch0
{
    /* Constant attributes. */
    static constexpr std::size_t size = 72; /*!< gpdma1_ch0's size in bytes. */

    /* Fields. */
    uint32_t SAR; /*!< (read-write) Source Address Register */
    const uint32_t reserved_padding0 = {};
    uint32_t DAR; /*!< (read-write) Destination Address Register */
    static constexpr std::size_t reserved_padding1_length = 3;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t CTLL; /*!< (read-write) Control Register Low */
    uint32_t CTLH; /*!< (read-write) Control Register High */
    static constexpr std::size_t reserved_padding2_length = 8;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t CFGL; /*!< (read-write) Configuration Register Low */
    uint32_t CFGH; /*!< (read-write) Configuration Register High */

    /* Methods. */

    /**
     * Get SAR's SAR field.
     */
    inline uint32_t get_SAR_SAR() volatile
    {
        return (SAR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set SAR's SAR field.
     */
    inline void set_SAR_SAR(uint32_t value) volatile
    {
        uint32_t curr = SAR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        SAR = curr;
    }

    /**
     * Get DAR's DAR field.
     */
    inline uint32_t get_DAR_DAR() volatile
    {
        return (DAR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set DAR's DAR field.
     */
    inline void set_DAR_DAR(uint32_t value) volatile
    {
        uint32_t curr = DAR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DAR = curr;
    }

    /**
     * Get CTLL's INT_EN bit.
     */
    inline bool get_CTLL_INT_EN() volatile
    {
        return CTLL & (1u << 0u);
    }

    /**
     * Set CTLL's INT_EN bit.
     */
    inline void set_CTLL_INT_EN() volatile
    {
        CTLL |= 1u << 0u;
    }

    /**
     * Clear CTLL's INT_EN bit.
     */
    inline void clear_CTLL_INT_EN() volatile
    {
        CTLL &= ~(1u << 0u);
    }

    /**
     * Toggle CTLL's INT_EN bit.
     */
    inline void toggle_CTLL_INT_EN() volatile
    {
        CTLL ^= 1u << 0u;
    }

    /**
     * Get CTLL's DST_TR_WIDTH field.
     */
    inline uint8_t get_CTLL_DST_TR_WIDTH() volatile
    {
        return (CTLL >> 1u) & 0b111u;
    }

    /**
     * Set CTLL's DST_TR_WIDTH field.
     */
    inline void set_CTLL_DST_TR_WIDTH(uint8_t value) volatile
    {
        uint32_t curr = CTLL;

        curr &= ~(0b111u << 1u);
        curr |= (value & 0b111u) << 1u;

        CTLL = curr;
    }

    /**
     * Get CTLL's SRC_TR_WIDTH field.
     */
    inline uint8_t get_CTLL_SRC_TR_WIDTH() volatile
    {
        return (CTLL >> 4u) & 0b111u;
    }

    /**
     * Set CTLL's SRC_TR_WIDTH field.
     */
    inline void set_CTLL_SRC_TR_WIDTH(uint8_t value) volatile
    {
        uint32_t curr = CTLL;

        curr &= ~(0b111u << 4u);
        curr |= (value & 0b111u) << 4u;

        CTLL = curr;
    }

    /**
     * Get CTLL's DINC field.
     */
    inline GPDMA1_CH0_CTLL_DINC get_CTLL_DINC() volatile
    {
        return GPDMA1_CH0_CTLL_DINC((CTLL >> 7u) & 0b11u);
    }

    /**
     * Set CTLL's DINC field.
     */
    inline void set_CTLL_DINC(GPDMA1_CH0_CTLL_DINC value) volatile
    {
        uint32_t curr = CTLL;

        curr &= ~(0b11u << 7u);
        curr |= (std::to_underlying(value) & 0b11u) << 7u;

        CTLL = curr;
    }

    /**
     * Get CTLL's SINC field.
     */
    inline GPDMA1_CH0_CTLL_DINC get_CTLL_SINC() volatile
    {
        return GPDMA1_CH0_CTLL_DINC((CTLL >> 9u) & 0b11u);
    }

    /**
     * Set CTLL's SINC field.
     */
    inline void set_CTLL_SINC(GPDMA1_CH0_CTLL_DINC value) volatile
    {
        uint32_t curr = CTLL;

        curr &= ~(0b11u << 9u);
        curr |= (std::to_underlying(value) & 0b11u) << 9u;

        CTLL = curr;
    }

    /**
     * Get CTLL's DEST_MSIZE field.
     */
    inline uint8_t get_CTLL_DEST_MSIZE() volatile
    {
        return (CTLL >> 11u) & 0b111u;
    }

    /**
     * Set CTLL's DEST_MSIZE field.
     */
    inline void set_CTLL_DEST_MSIZE(uint8_t value) volatile
    {
        uint32_t curr = CTLL;

        curr &= ~(0b111u << 11u);
        curr |= (value & 0b111u) << 11u;

        CTLL = curr;
    }

    /**
     * Get CTLL's SRC_MSIZE field.
     */
    inline uint8_t get_CTLL_SRC_MSIZE() volatile
    {
        return (CTLL >> 14u) & 0b111u;
    }

    /**
     * Set CTLL's SRC_MSIZE field.
     */
    inline void set_CTLL_SRC_MSIZE(uint8_t value) volatile
    {
        uint32_t curr = CTLL;

        curr &= ~(0b111u << 14u);
        curr |= (value & 0b111u) << 14u;

        CTLL = curr;
    }

    /**
     * Get CTLL's TT_FC field.
     */
    inline uint8_t get_CTLL_TT_FC() volatile
    {
        return (CTLL >> 20u) & 0b111u;
    }

    /**
     * Set CTLL's TT_FC field.
     */
    inline void set_CTLL_TT_FC(uint8_t value) volatile
    {
        uint32_t curr = CTLL;

        curr &= ~(0b111u << 20u);
        curr |= (value & 0b111u) << 20u;

        CTLL = curr;
    }

    /**
     * Get all of CTLL's bit fields.
     */
    inline void get_CTLL(bool &INT_EN, uint8_t &DST_TR_WIDTH,
                         uint8_t &SRC_TR_WIDTH, GPDMA1_CH0_CTLL_DINC &DINC,
                         GPDMA1_CH0_CTLL_DINC &SINC, uint8_t &DEST_MSIZE,
                         uint8_t &SRC_MSIZE, uint8_t &TT_FC) volatile
    {
        uint32_t curr = CTLL;

        INT_EN = curr & (1u << 0u);
        DST_TR_WIDTH = (curr >> 1u) & 0b111u;
        SRC_TR_WIDTH = (curr >> 4u) & 0b111u;
        DINC = GPDMA1_CH0_CTLL_DINC((curr >> 7u) & 0b11u);
        SINC = GPDMA1_CH0_CTLL_DINC((curr >> 9u) & 0b11u);
        DEST_MSIZE = (curr >> 11u) & 0b111u;
        SRC_MSIZE = (curr >> 14u) & 0b111u;
        TT_FC = (curr >> 20u) & 0b111u;
    }

    /**
     * Set all of CTLL's bit fields.
     */
    inline void set_CTLL(bool INT_EN, uint8_t DST_TR_WIDTH,
                         uint8_t SRC_TR_WIDTH, GPDMA1_CH0_CTLL_DINC DINC,
                         GPDMA1_CH0_CTLL_DINC SINC, uint8_t DEST_MSIZE,
                         uint8_t SRC_MSIZE, uint8_t TT_FC) volatile
    {
        uint32_t curr = CTLL;

        curr &= ~(0b1u << 0u);
        curr |= (INT_EN & 0b1u) << 0u;
        curr &= ~(0b111u << 1u);
        curr |= (DST_TR_WIDTH & 0b111u) << 1u;
        curr &= ~(0b111u << 4u);
        curr |= (SRC_TR_WIDTH & 0b111u) << 4u;
        curr &= ~(0b11u << 7u);
        curr |= (std::to_underlying(DINC) & 0b11u) << 7u;
        curr &= ~(0b11u << 9u);
        curr |= (std::to_underlying(SINC) & 0b11u) << 9u;
        curr &= ~(0b111u << 11u);
        curr |= (DEST_MSIZE & 0b111u) << 11u;
        curr &= ~(0b111u << 14u);
        curr |= (SRC_MSIZE & 0b111u) << 14u;
        curr &= ~(0b111u << 20u);
        curr |= (TT_FC & 0b111u) << 20u;

        CTLL = curr;
    }

    /**
     * Get CTLH's BLOCK_TS field.
     */
    inline uint16_t get_CTLH_BLOCK_TS() volatile
    {
        return (CTLH >> 0u) & 0b111111111111u;
    }

    /**
     * Set CTLH's BLOCK_TS field.
     */
    inline void set_CTLH_BLOCK_TS(uint16_t value) volatile
    {
        uint32_t curr = CTLH;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        CTLH = curr;
    }

    /**
     * Get CTLH's DONE bit.
     */
    inline bool get_CTLH_DONE() volatile
    {
        return CTLH & (1u << 12u);
    }

    /**
     * Set CTLH's DONE bit.
     */
    inline void set_CTLH_DONE() volatile
    {
        CTLH |= 1u << 12u;
    }

    /**
     * Clear CTLH's DONE bit.
     */
    inline void clear_CTLH_DONE() volatile
    {
        CTLH &= ~(1u << 12u);
    }

    /**
     * Toggle CTLH's DONE bit.
     */
    inline void toggle_CTLH_DONE() volatile
    {
        CTLH ^= 1u << 12u;
    }

    /**
     * Get all of CTLH's bit fields.
     */
    inline void get_CTLH(uint16_t &BLOCK_TS, bool &DONE) volatile
    {
        uint32_t curr = CTLH;

        BLOCK_TS = (curr >> 0u) & 0b111111111111u;
        DONE = curr & (1u << 12u);
    }

    /**
     * Set all of CTLH's bit fields.
     */
    inline void set_CTLH(uint16_t BLOCK_TS, bool DONE) volatile
    {
        uint32_t curr = CTLH;

        curr &= ~(0b111111111111u << 0u);
        curr |= (BLOCK_TS & 0b111111111111u) << 0u;
        curr &= ~(0b1u << 12u);
        curr |= (DONE & 0b1u) << 12u;

        CTLH = curr;
    }

    /**
     * Get CFGL's CH_PRIOR field.
     */
    inline uint8_t get_CFGL_CH_PRIOR() volatile
    {
        return (CFGL >> 5u) & 0b111u;
    }

    /**
     * Set CFGL's CH_PRIOR field.
     */
    inline void set_CFGL_CH_PRIOR(uint8_t value) volatile
    {
        uint32_t curr = CFGL;

        curr &= ~(0b111u << 5u);
        curr |= (value & 0b111u) << 5u;

        CFGL = curr;
    }

    /**
     * Get CFGL's CH_SUSP bit.
     */
    inline GPDMA1_CH0_CFGL_CH_SUSP get_CFGL_CH_SUSP() volatile
    {
        return GPDMA1_CH0_CFGL_CH_SUSP(CFGL & (1u << 8u));
    }

    /**
     * Set CFGL's CH_SUSP bit.
     */
    inline void set_CFGL_CH_SUSP() volatile
    {
        CFGL |= 1u << 8u;
    }

    /**
     * Clear CFGL's CH_SUSP bit.
     */
    inline void clear_CFGL_CH_SUSP() volatile
    {
        CFGL &= ~(1u << 8u);
    }

    /**
     * Toggle CFGL's CH_SUSP bit.
     */
    inline void toggle_CFGL_CH_SUSP() volatile
    {
        CFGL ^= 1u << 8u;
    }

    /**
     * Get CFGL's FIFO_EMPTY bit.
     */
    inline GPDMA1_CH0_CFGL_FIFO_EMPTY get_CFGL_FIFO_EMPTY() volatile
    {
        return GPDMA1_CH0_CFGL_FIFO_EMPTY(CFGL & (1u << 9u));
    }

    /**
     * Get CFGL's HS_SEL_DST bit.
     */
    inline GPDMA1_CH0_CFGL_HS_SEL_DST get_CFGL_HS_SEL_DST() volatile
    {
        return GPDMA1_CH0_CFGL_HS_SEL_DST(CFGL & (1u << 10u));
    }

    /**
     * Set CFGL's HS_SEL_DST bit.
     */
    inline void set_CFGL_HS_SEL_DST() volatile
    {
        CFGL |= 1u << 10u;
    }

    /**
     * Clear CFGL's HS_SEL_DST bit.
     */
    inline void clear_CFGL_HS_SEL_DST() volatile
    {
        CFGL &= ~(1u << 10u);
    }

    /**
     * Toggle CFGL's HS_SEL_DST bit.
     */
    inline void toggle_CFGL_HS_SEL_DST() volatile
    {
        CFGL ^= 1u << 10u;
    }

    /**
     * Get CFGL's HS_SEL_SRC bit.
     */
    inline GPDMA1_CH0_CFGL_HS_SEL_SRC get_CFGL_HS_SEL_SRC() volatile
    {
        return GPDMA1_CH0_CFGL_HS_SEL_SRC(CFGL & (1u << 11u));
    }

    /**
     * Set CFGL's HS_SEL_SRC bit.
     */
    inline void set_CFGL_HS_SEL_SRC() volatile
    {
        CFGL |= 1u << 11u;
    }

    /**
     * Clear CFGL's HS_SEL_SRC bit.
     */
    inline void clear_CFGL_HS_SEL_SRC() volatile
    {
        CFGL &= ~(1u << 11u);
    }

    /**
     * Toggle CFGL's HS_SEL_SRC bit.
     */
    inline void toggle_CFGL_HS_SEL_SRC() volatile
    {
        CFGL ^= 1u << 11u;
    }

    /**
     * Get CFGL's LOCK_CH_L field.
     */
    inline GPDMA1_CH0_CFGL_LOCK_CH_L get_CFGL_LOCK_CH_L() volatile
    {
        return GPDMA1_CH0_CFGL_LOCK_CH_L((CFGL >> 12u) & 0b11u);
    }

    /**
     * Set CFGL's LOCK_CH_L field.
     */
    inline void set_CFGL_LOCK_CH_L(GPDMA1_CH0_CFGL_LOCK_CH_L value) volatile
    {
        uint32_t curr = CFGL;

        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(value) & 0b11u) << 12u;

        CFGL = curr;
    }

    /**
     * Get CFGL's LOCK_B_L field.
     */
    inline GPDMA1_CH0_CFGL_LOCK_CH_L get_CFGL_LOCK_B_L() volatile
    {
        return GPDMA1_CH0_CFGL_LOCK_CH_L((CFGL >> 14u) & 0b11u);
    }

    /**
     * Set CFGL's LOCK_B_L field.
     */
    inline void set_CFGL_LOCK_B_L(GPDMA1_CH0_CFGL_LOCK_CH_L value) volatile
    {
        uint32_t curr = CFGL;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(value) & 0b11u) << 14u;

        CFGL = curr;
    }

    /**
     * Get CFGL's LOCK_CH bit.
     */
    inline bool get_CFGL_LOCK_CH() volatile
    {
        return CFGL & (1u << 16u);
    }

    /**
     * Set CFGL's LOCK_CH bit.
     */
    inline void set_CFGL_LOCK_CH() volatile
    {
        CFGL |= 1u << 16u;
    }

    /**
     * Clear CFGL's LOCK_CH bit.
     */
    inline void clear_CFGL_LOCK_CH() volatile
    {
        CFGL &= ~(1u << 16u);
    }

    /**
     * Toggle CFGL's LOCK_CH bit.
     */
    inline void toggle_CFGL_LOCK_CH() volatile
    {
        CFGL ^= 1u << 16u;
    }

    /**
     * Get CFGL's LOCK_B bit.
     */
    inline bool get_CFGL_LOCK_B() volatile
    {
        return CFGL & (1u << 17u);
    }

    /**
     * Set CFGL's LOCK_B bit.
     */
    inline void set_CFGL_LOCK_B() volatile
    {
        CFGL |= 1u << 17u;
    }

    /**
     * Clear CFGL's LOCK_B bit.
     */
    inline void clear_CFGL_LOCK_B() volatile
    {
        CFGL &= ~(1u << 17u);
    }

    /**
     * Toggle CFGL's LOCK_B bit.
     */
    inline void toggle_CFGL_LOCK_B() volatile
    {
        CFGL ^= 1u << 17u;
    }

    /**
     * Get CFGL's DST_HS_POL bit.
     */
    inline GPDMA1_CH0_CFGL_DST_HS_POL get_CFGL_DST_HS_POL() volatile
    {
        return GPDMA1_CH0_CFGL_DST_HS_POL(CFGL & (1u << 18u));
    }

    /**
     * Set CFGL's DST_HS_POL bit.
     */
    inline void set_CFGL_DST_HS_POL() volatile
    {
        CFGL |= 1u << 18u;
    }

    /**
     * Clear CFGL's DST_HS_POL bit.
     */
    inline void clear_CFGL_DST_HS_POL() volatile
    {
        CFGL &= ~(1u << 18u);
    }

    /**
     * Toggle CFGL's DST_HS_POL bit.
     */
    inline void toggle_CFGL_DST_HS_POL() volatile
    {
        CFGL ^= 1u << 18u;
    }

    /**
     * Get CFGL's SRC_HS_POL bit.
     */
    inline GPDMA1_CH0_CFGL_DST_HS_POL get_CFGL_SRC_HS_POL() volatile
    {
        return GPDMA1_CH0_CFGL_DST_HS_POL(CFGL & (1u << 19u));
    }

    /**
     * Set CFGL's SRC_HS_POL bit.
     */
    inline void set_CFGL_SRC_HS_POL() volatile
    {
        CFGL |= 1u << 19u;
    }

    /**
     * Clear CFGL's SRC_HS_POL bit.
     */
    inline void clear_CFGL_SRC_HS_POL() volatile
    {
        CFGL &= ~(1u << 19u);
    }

    /**
     * Toggle CFGL's SRC_HS_POL bit.
     */
    inline void toggle_CFGL_SRC_HS_POL() volatile
    {
        CFGL ^= 1u << 19u;
    }

    /**
     * Get CFGL's MAX_ABRST field.
     */
    inline uint16_t get_CFGL_MAX_ABRST() volatile
    {
        return (CFGL >> 20u) & 0b1111111111u;
    }

    /**
     * Set CFGL's MAX_ABRST field.
     */
    inline void set_CFGL_MAX_ABRST(uint16_t value) volatile
    {
        uint32_t curr = CFGL;

        curr &= ~(0b1111111111u << 20u);
        curr |= (value & 0b1111111111u) << 20u;

        CFGL = curr;
    }

    /**
     * Get all of CFGL's bit fields.
     */
    inline void get_CFGL(uint8_t &CH_PRIOR, GPDMA1_CH0_CFGL_CH_SUSP &CH_SUSP,
                         GPDMA1_CH0_CFGL_FIFO_EMPTY &FIFO_EMPTY,
                         GPDMA1_CH0_CFGL_HS_SEL_DST &HS_SEL_DST,
                         GPDMA1_CH0_CFGL_HS_SEL_SRC &HS_SEL_SRC,
                         GPDMA1_CH0_CFGL_LOCK_CH_L &LOCK_CH_L,
                         GPDMA1_CH0_CFGL_LOCK_CH_L &LOCK_B_L, bool &LOCK_CH,
                         bool &LOCK_B, GPDMA1_CH0_CFGL_DST_HS_POL &DST_HS_POL,
                         GPDMA1_CH0_CFGL_DST_HS_POL &SRC_HS_POL,
                         uint16_t &MAX_ABRST) volatile
    {
        uint32_t curr = CFGL;

        CH_PRIOR = (curr >> 5u) & 0b111u;
        CH_SUSP = GPDMA1_CH0_CFGL_CH_SUSP(curr & (1u << 8u));
        FIFO_EMPTY = GPDMA1_CH0_CFGL_FIFO_EMPTY(curr & (1u << 9u));
        HS_SEL_DST = GPDMA1_CH0_CFGL_HS_SEL_DST(curr & (1u << 10u));
        HS_SEL_SRC = GPDMA1_CH0_CFGL_HS_SEL_SRC(curr & (1u << 11u));
        LOCK_CH_L = GPDMA1_CH0_CFGL_LOCK_CH_L((curr >> 12u) & 0b11u);
        LOCK_B_L = GPDMA1_CH0_CFGL_LOCK_CH_L((curr >> 14u) & 0b11u);
        LOCK_CH = curr & (1u << 16u);
        LOCK_B = curr & (1u << 17u);
        DST_HS_POL = GPDMA1_CH0_CFGL_DST_HS_POL(curr & (1u << 18u));
        SRC_HS_POL = GPDMA1_CH0_CFGL_DST_HS_POL(curr & (1u << 19u));
        MAX_ABRST = (curr >> 20u) & 0b1111111111u;
    }

    /**
     * Set all of CFGL's bit fields.
     */
    inline void set_CFGL(uint8_t CH_PRIOR, GPDMA1_CH0_CFGL_CH_SUSP CH_SUSP,
                         GPDMA1_CH0_CFGL_HS_SEL_DST HS_SEL_DST,
                         GPDMA1_CH0_CFGL_HS_SEL_SRC HS_SEL_SRC,
                         GPDMA1_CH0_CFGL_LOCK_CH_L LOCK_CH_L,
                         GPDMA1_CH0_CFGL_LOCK_CH_L LOCK_B_L, bool LOCK_CH,
                         bool LOCK_B, GPDMA1_CH0_CFGL_DST_HS_POL DST_HS_POL,
                         GPDMA1_CH0_CFGL_DST_HS_POL SRC_HS_POL,
                         uint16_t MAX_ABRST) volatile
    {
        uint32_t curr = CFGL;

        curr &= ~(0b111u << 5u);
        curr |= (CH_PRIOR & 0b111u) << 5u;
        curr &= ~(0b1u << 8u);
        curr |= (std::to_underlying(CH_SUSP) & 0b1u) << 8u;
        curr &= ~(0b1u << 10u);
        curr |= (std::to_underlying(HS_SEL_DST) & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (std::to_underlying(HS_SEL_SRC) & 0b1u) << 11u;
        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(LOCK_CH_L) & 0b11u) << 12u;
        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(LOCK_B_L) & 0b11u) << 14u;
        curr &= ~(0b1u << 16u);
        curr |= (LOCK_CH & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (LOCK_B & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (std::to_underlying(DST_HS_POL) & 0b1u) << 18u;
        curr &= ~(0b1u << 19u);
        curr |= (std::to_underlying(SRC_HS_POL) & 0b1u) << 19u;
        curr &= ~(0b1111111111u << 20u);
        curr |= (MAX_ABRST & 0b1111111111u) << 20u;

        CFGL = curr;
    }

    /**
     * Get CFGH's FCMODE bit.
     */
    inline GPDMA1_CH0_CFGH_FCMODE get_CFGH_FCMODE() volatile
    {
        return GPDMA1_CH0_CFGH_FCMODE(CFGH & (1u << 0u));
    }

    /**
     * Set CFGH's FCMODE bit.
     */
    inline void set_CFGH_FCMODE() volatile
    {
        CFGH |= 1u << 0u;
    }

    /**
     * Clear CFGH's FCMODE bit.
     */
    inline void clear_CFGH_FCMODE() volatile
    {
        CFGH &= ~(1u << 0u);
    }

    /**
     * Toggle CFGH's FCMODE bit.
     */
    inline void toggle_CFGH_FCMODE() volatile
    {
        CFGH ^= 1u << 0u;
    }

    /**
     * Get CFGH's FIFO_MODE bit.
     */
    inline GPDMA1_CH0_CFGH_FIFO_MODE get_CFGH_FIFO_MODE() volatile
    {
        return GPDMA1_CH0_CFGH_FIFO_MODE(CFGH & (1u << 1u));
    }

    /**
     * Set CFGH's FIFO_MODE bit.
     */
    inline void set_CFGH_FIFO_MODE() volatile
    {
        CFGH |= 1u << 1u;
    }

    /**
     * Clear CFGH's FIFO_MODE bit.
     */
    inline void clear_CFGH_FIFO_MODE() volatile
    {
        CFGH &= ~(1u << 1u);
    }

    /**
     * Toggle CFGH's FIFO_MODE bit.
     */
    inline void toggle_CFGH_FIFO_MODE() volatile
    {
        CFGH ^= 1u << 1u;
    }

    /**
     * Get CFGH's PROTCTL field.
     */
    inline uint8_t get_CFGH_PROTCTL() volatile
    {
        return (CFGH >> 2u) & 0b111u;
    }

    /**
     * Set CFGH's PROTCTL field.
     */
    inline void set_CFGH_PROTCTL(uint8_t value) volatile
    {
        uint32_t curr = CFGH;

        curr &= ~(0b111u << 2u);
        curr |= (value & 0b111u) << 2u;

        CFGH = curr;
    }

    /**
     * Get CFGH's SRC_PER field.
     */
    inline uint8_t get_CFGH_SRC_PER() volatile
    {
        return (CFGH >> 7u) & 0b1111u;
    }

    /**
     * Set CFGH's SRC_PER field.
     */
    inline void set_CFGH_SRC_PER(uint8_t value) volatile
    {
        uint32_t curr = CFGH;

        curr &= ~(0b1111u << 7u);
        curr |= (value & 0b1111u) << 7u;

        CFGH = curr;
    }

    /**
     * Get CFGH's DEST_PER field.
     */
    inline uint8_t get_CFGH_DEST_PER() volatile
    {
        return (CFGH >> 11u) & 0b1111u;
    }

    /**
     * Set CFGH's DEST_PER field.
     */
    inline void set_CFGH_DEST_PER(uint8_t value) volatile
    {
        uint32_t curr = CFGH;

        curr &= ~(0b1111u << 11u);
        curr |= (value & 0b1111u) << 11u;

        CFGH = curr;
    }

    /**
     * Get all of CFGH's bit fields.
     */
    inline void get_CFGH(GPDMA1_CH0_CFGH_FCMODE &FCMODE,
                         GPDMA1_CH0_CFGH_FIFO_MODE &FIFO_MODE,
                         uint8_t &PROTCTL, uint8_t &SRC_PER,
                         uint8_t &DEST_PER) volatile
    {
        uint32_t curr = CFGH;

        FCMODE = GPDMA1_CH0_CFGH_FCMODE(curr & (1u << 0u));
        FIFO_MODE = GPDMA1_CH0_CFGH_FIFO_MODE(curr & (1u << 1u));
        PROTCTL = (curr >> 2u) & 0b111u;
        SRC_PER = (curr >> 7u) & 0b1111u;
        DEST_PER = (curr >> 11u) & 0b1111u;
    }

    /**
     * Set all of CFGH's bit fields.
     */
    inline void set_CFGH(GPDMA1_CH0_CFGH_FCMODE FCMODE,
                         GPDMA1_CH0_CFGH_FIFO_MODE FIFO_MODE, uint8_t PROTCTL,
                         uint8_t SRC_PER, uint8_t DEST_PER) volatile
    {
        uint32_t curr = CFGH;

        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(FCMODE) & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(FIFO_MODE) & 0b1u) << 1u;
        curr &= ~(0b111u << 2u);
        curr |= (PROTCTL & 0b111u) << 2u;
        curr &= ~(0b1111u << 7u);
        curr |= (SRC_PER & 0b1111u) << 7u;
        curr &= ~(0b1111u << 11u);
        curr |= (DEST_PER & 0b1111u) << 11u;

        CFGH = curr;
    }
};

static_assert(sizeof(gpdma1_ch0) == gpdma1_ch0::size);

static volatile gpdma1_ch0 *const GPDMA1_CH0 =
    reinterpret_cast<gpdma1_ch0 *>(0x50018000);

static volatile gpdma1_ch0 *const GPDMA1_CH2 =
    reinterpret_cast<gpdma1_ch0 *>(0x500180B0);

static volatile gpdma1_ch0 *const GPDMA1_CH3 =
    reinterpret_cast<gpdma1_ch0 *>(0x50018108);

}; // namespace XMC4700
