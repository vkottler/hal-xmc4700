/**
 * \file
 * \brief Generated by ifgen (3.1.0).
 */
#pragma once

#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * Real Time Clock
 */
struct [[gnu::packed]] rtc
{
    /* Constant attributes. */
    static constexpr std::size_t size = 40; /*!< rtc's size in bytes. */

    /* Fields. */
    const uint32_t ID = {};      /*!< (read-only) RTC ID Register */
    uint32_t CTR;                /*!< (read-write) RTC Control Register */
    const uint32_t RAWSTAT = {}; /*!< (read-only) RTC Raw Service Request Register */
    const uint32_t STSSR = {};   /*!< (read-only) RTC Service Request Status Register */
    uint32_t MSKSR;              /*!< (read-write) RTC Service Request Mask Register */
    uint32_t CLRSR;              /*!< (write-only) RTC Clear Service Request Register */
    uint32_t ATIM0;              /*!< (read-write) RTC Alarm Time Register 0 */
    uint32_t ATIM1;              /*!< (read-write) RTC Alarm Time Register 1 */
    uint32_t TIM0;               /*!< (read-write) RTC Time Register 0 */
    uint32_t TIM1;               /*!< (read-write) RTC Time Register 1 */

    /* Methods. */

    /**
     * Get ID's MOD_NUMBER field.
     */
    inline uint16_t get_ID_MOD_NUMBER()
    {
        return (ID >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get ID's MOD_TYPE field.
     */
    inline uint8_t get_ID_MOD_TYPE()
    {
        return (ID >> 8u) & 0b11111111u;
    }

    /**
     * Get ID's MOD_REV field.
     */
    inline uint8_t get_ID_MOD_REV()
    {
        return (ID >> 0u) & 0b11111111u;
    }

    /**
     * Get all of ID's bit fields.
     */
    inline void get_ID(uint16_t &MOD_NUMBER, uint8_t &MOD_TYPE, uint8_t &MOD_REV)
    {
        uint32_t curr = ID;

        MOD_NUMBER = (curr >> 16u) & 0b1111111111111111u;
        MOD_TYPE = (curr >> 8u) & 0b11111111u;
        MOD_REV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get CTR's DIV field.
     */
    inline uint16_t get_CTR_DIV()
    {
        return (CTR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CTR's DIV field.
     */
    inline void set_CTR_DIV(uint16_t value)
    {
        uint32_t curr = CTR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CTR = curr;
    }

    /**
     * Get CTR's EYEC bit.
     */
    inline bool get_CTR_EYEC()
    {
        return CTR & (1u << 14u);
    }

    /**
     * Set CTR's EYEC bit.
     */
    inline void set_CTR_EYEC()
    {
        CTR |= 1u << 14u;
    }

    /**
     * Clear CTR's EYEC bit.
     */
    inline void clear_CTR_EYEC()
    {
        CTR &= ~(1u << 14u);
    }

    /**
     * Toggle CTR's EYEC bit.
     */
    inline void toggle_CTR_EYEC()
    {
        CTR ^= 1u << 14u;
    }

    /**
     * Get CTR's EMOC bit.
     */
    inline bool get_CTR_EMOC()
    {
        return CTR & (1u << 13u);
    }

    /**
     * Set CTR's EMOC bit.
     */
    inline void set_CTR_EMOC()
    {
        CTR |= 1u << 13u;
    }

    /**
     * Clear CTR's EMOC bit.
     */
    inline void clear_CTR_EMOC()
    {
        CTR &= ~(1u << 13u);
    }

    /**
     * Toggle CTR's EMOC bit.
     */
    inline void toggle_CTR_EMOC()
    {
        CTR ^= 1u << 13u;
    }

    /**
     * Get CTR's EDAC bit.
     */
    inline bool get_CTR_EDAC()
    {
        return CTR & (1u << 11u);
    }

    /**
     * Set CTR's EDAC bit.
     */
    inline void set_CTR_EDAC()
    {
        CTR |= 1u << 11u;
    }

    /**
     * Clear CTR's EDAC bit.
     */
    inline void clear_CTR_EDAC()
    {
        CTR &= ~(1u << 11u);
    }

    /**
     * Toggle CTR's EDAC bit.
     */
    inline void toggle_CTR_EDAC()
    {
        CTR ^= 1u << 11u;
    }

    /**
     * Get CTR's EHOC bit.
     */
    inline bool get_CTR_EHOC()
    {
        return CTR & (1u << 10u);
    }

    /**
     * Set CTR's EHOC bit.
     */
    inline void set_CTR_EHOC()
    {
        CTR |= 1u << 10u;
    }

    /**
     * Clear CTR's EHOC bit.
     */
    inline void clear_CTR_EHOC()
    {
        CTR &= ~(1u << 10u);
    }

    /**
     * Toggle CTR's EHOC bit.
     */
    inline void toggle_CTR_EHOC()
    {
        CTR ^= 1u << 10u;
    }

    /**
     * Get CTR's EMIC bit.
     */
    inline bool get_CTR_EMIC()
    {
        return CTR & (1u << 9u);
    }

    /**
     * Set CTR's EMIC bit.
     */
    inline void set_CTR_EMIC()
    {
        CTR |= 1u << 9u;
    }

    /**
     * Clear CTR's EMIC bit.
     */
    inline void clear_CTR_EMIC()
    {
        CTR &= ~(1u << 9u);
    }

    /**
     * Toggle CTR's EMIC bit.
     */
    inline void toggle_CTR_EMIC()
    {
        CTR ^= 1u << 9u;
    }

    /**
     * Get CTR's ESEC bit.
     */
    inline bool get_CTR_ESEC()
    {
        return CTR & (1u << 8u);
    }

    /**
     * Set CTR's ESEC bit.
     */
    inline void set_CTR_ESEC()
    {
        CTR |= 1u << 8u;
    }

    /**
     * Clear CTR's ESEC bit.
     */
    inline void clear_CTR_ESEC()
    {
        CTR &= ~(1u << 8u);
    }

    /**
     * Toggle CTR's ESEC bit.
     */
    inline void toggle_CTR_ESEC()
    {
        CTR ^= 1u << 8u;
    }

    /**
     * Get CTR's TAE bit.
     */
    inline bool get_CTR_TAE()
    {
        return CTR & (1u << 2u);
    }

    /**
     * Set CTR's TAE bit.
     */
    inline void set_CTR_TAE()
    {
        CTR |= 1u << 2u;
    }

    /**
     * Clear CTR's TAE bit.
     */
    inline void clear_CTR_TAE()
    {
        CTR &= ~(1u << 2u);
    }

    /**
     * Toggle CTR's TAE bit.
     */
    inline void toggle_CTR_TAE()
    {
        CTR ^= 1u << 2u;
    }

    /**
     * Get CTR's ENB bit.
     */
    inline bool get_CTR_ENB()
    {
        return CTR & (1u << 0u);
    }

    /**
     * Set CTR's ENB bit.
     */
    inline void set_CTR_ENB()
    {
        CTR |= 1u << 0u;
    }

    /**
     * Clear CTR's ENB bit.
     */
    inline void clear_CTR_ENB()
    {
        CTR &= ~(1u << 0u);
    }

    /**
     * Toggle CTR's ENB bit.
     */
    inline void toggle_CTR_ENB()
    {
        CTR ^= 1u << 0u;
    }

    /**
     * Get all of CTR's bit fields.
     */
    inline void get_CTR(uint16_t &DIV, bool &EYEC, bool &EMOC, bool &EDAC, bool &EHOC, bool &EMIC, bool &ESEC, bool &TAE, bool &ENB)
    {
        uint32_t curr = CTR;

        DIV = (curr >> 16u) & 0b1111111111111111u;
        EYEC = curr & (1u << 14u);
        EMOC = curr & (1u << 13u);
        EDAC = curr & (1u << 11u);
        EHOC = curr & (1u << 10u);
        EMIC = curr & (1u << 9u);
        ESEC = curr & (1u << 8u);
        TAE = curr & (1u << 2u);
        ENB = curr & (1u << 0u);
    }

    /**
     * Set all of CTR's bit fields.
     */
    inline void set_CTR(uint16_t DIV, bool EYEC, bool EMOC, bool EDAC, bool EHOC, bool EMIC, bool ESEC, bool TAE, bool ENB)
    {
        uint32_t curr = CTR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (DIV & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 14u);
        curr |= (EYEC & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (EMOC & 0b1u) << 13u;
        curr &= ~(0b1u << 11u);
        curr |= (EDAC & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (EHOC & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (EMIC & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (ESEC & 0b1u) << 8u;
        curr &= ~(0b1u << 2u);
        curr |= (TAE & 0b1u) << 2u;
        curr &= ~(0b1u << 0u);
        curr |= (ENB & 0b1u) << 0u;

        CTR = curr;
    }

    /**
     * Get RAWSTAT's RAI bit.
     */
    inline bool get_RAWSTAT_RAI()
    {
        return RAWSTAT & (1u << 8u);
    }

    /**
     * Get RAWSTAT's RPYE bit.
     */
    inline bool get_RAWSTAT_RPYE()
    {
        return RAWSTAT & (1u << 6u);
    }

    /**
     * Get RAWSTAT's RPMO bit.
     */
    inline bool get_RAWSTAT_RPMO()
    {
        return RAWSTAT & (1u << 5u);
    }

    /**
     * Get RAWSTAT's RPDA bit.
     */
    inline bool get_RAWSTAT_RPDA()
    {
        return RAWSTAT & (1u << 3u);
    }

    /**
     * Get RAWSTAT's RPHO bit.
     */
    inline bool get_RAWSTAT_RPHO()
    {
        return RAWSTAT & (1u << 2u);
    }

    /**
     * Get RAWSTAT's RPMI bit.
     */
    inline bool get_RAWSTAT_RPMI()
    {
        return RAWSTAT & (1u << 1u);
    }

    /**
     * Get RAWSTAT's RPSE bit.
     */
    inline bool get_RAWSTAT_RPSE()
    {
        return RAWSTAT & (1u << 0u);
    }

    /**
     * Get all of RAWSTAT's bit fields.
     */
    inline void get_RAWSTAT(bool &RAI, bool &RPYE, bool &RPMO, bool &RPDA, bool &RPHO, bool &RPMI, bool &RPSE)
    {
        uint32_t curr = RAWSTAT;

        RAI = curr & (1u << 8u);
        RPYE = curr & (1u << 6u);
        RPMO = curr & (1u << 5u);
        RPDA = curr & (1u << 3u);
        RPHO = curr & (1u << 2u);
        RPMI = curr & (1u << 1u);
        RPSE = curr & (1u << 0u);
    }

    /**
     * Get STSSR's SAI bit.
     */
    inline bool get_STSSR_SAI()
    {
        return STSSR & (1u << 8u);
    }

    /**
     * Get STSSR's SPYE bit.
     */
    inline bool get_STSSR_SPYE()
    {
        return STSSR & (1u << 6u);
    }

    /**
     * Get STSSR's SPMO bit.
     */
    inline bool get_STSSR_SPMO()
    {
        return STSSR & (1u << 5u);
    }

    /**
     * Get STSSR's SPDA bit.
     */
    inline bool get_STSSR_SPDA()
    {
        return STSSR & (1u << 3u);
    }

    /**
     * Get STSSR's SPHO bit.
     */
    inline bool get_STSSR_SPHO()
    {
        return STSSR & (1u << 2u);
    }

    /**
     * Get STSSR's SPMI bit.
     */
    inline bool get_STSSR_SPMI()
    {
        return STSSR & (1u << 1u);
    }

    /**
     * Get STSSR's SPSE bit.
     */
    inline bool get_STSSR_SPSE()
    {
        return STSSR & (1u << 0u);
    }

    /**
     * Get all of STSSR's bit fields.
     */
    inline void get_STSSR(bool &SAI, bool &SPYE, bool &SPMO, bool &SPDA, bool &SPHO, bool &SPMI, bool &SPSE)
    {
        uint32_t curr = STSSR;

        SAI = curr & (1u << 8u);
        SPYE = curr & (1u << 6u);
        SPMO = curr & (1u << 5u);
        SPDA = curr & (1u << 3u);
        SPHO = curr & (1u << 2u);
        SPMI = curr & (1u << 1u);
        SPSE = curr & (1u << 0u);
    }

    /**
     * Get MSKSR's MAI bit.
     */
    inline bool get_MSKSR_MAI()
    {
        return MSKSR & (1u << 8u);
    }

    /**
     * Set MSKSR's MAI bit.
     */
    inline void set_MSKSR_MAI()
    {
        MSKSR |= 1u << 8u;
    }

    /**
     * Clear MSKSR's MAI bit.
     */
    inline void clear_MSKSR_MAI()
    {
        MSKSR &= ~(1u << 8u);
    }

    /**
     * Toggle MSKSR's MAI bit.
     */
    inline void toggle_MSKSR_MAI()
    {
        MSKSR ^= 1u << 8u;
    }

    /**
     * Get MSKSR's MPYE bit.
     */
    inline bool get_MSKSR_MPYE()
    {
        return MSKSR & (1u << 6u);
    }

    /**
     * Set MSKSR's MPYE bit.
     */
    inline void set_MSKSR_MPYE()
    {
        MSKSR |= 1u << 6u;
    }

    /**
     * Clear MSKSR's MPYE bit.
     */
    inline void clear_MSKSR_MPYE()
    {
        MSKSR &= ~(1u << 6u);
    }

    /**
     * Toggle MSKSR's MPYE bit.
     */
    inline void toggle_MSKSR_MPYE()
    {
        MSKSR ^= 1u << 6u;
    }

    /**
     * Get MSKSR's MPMO bit.
     */
    inline bool get_MSKSR_MPMO()
    {
        return MSKSR & (1u << 5u);
    }

    /**
     * Set MSKSR's MPMO bit.
     */
    inline void set_MSKSR_MPMO()
    {
        MSKSR |= 1u << 5u;
    }

    /**
     * Clear MSKSR's MPMO bit.
     */
    inline void clear_MSKSR_MPMO()
    {
        MSKSR &= ~(1u << 5u);
    }

    /**
     * Toggle MSKSR's MPMO bit.
     */
    inline void toggle_MSKSR_MPMO()
    {
        MSKSR ^= 1u << 5u;
    }

    /**
     * Get MSKSR's MPDA bit.
     */
    inline bool get_MSKSR_MPDA()
    {
        return MSKSR & (1u << 3u);
    }

    /**
     * Set MSKSR's MPDA bit.
     */
    inline void set_MSKSR_MPDA()
    {
        MSKSR |= 1u << 3u;
    }

    /**
     * Clear MSKSR's MPDA bit.
     */
    inline void clear_MSKSR_MPDA()
    {
        MSKSR &= ~(1u << 3u);
    }

    /**
     * Toggle MSKSR's MPDA bit.
     */
    inline void toggle_MSKSR_MPDA()
    {
        MSKSR ^= 1u << 3u;
    }

    /**
     * Get MSKSR's MPHO bit.
     */
    inline bool get_MSKSR_MPHO()
    {
        return MSKSR & (1u << 2u);
    }

    /**
     * Set MSKSR's MPHO bit.
     */
    inline void set_MSKSR_MPHO()
    {
        MSKSR |= 1u << 2u;
    }

    /**
     * Clear MSKSR's MPHO bit.
     */
    inline void clear_MSKSR_MPHO()
    {
        MSKSR &= ~(1u << 2u);
    }

    /**
     * Toggle MSKSR's MPHO bit.
     */
    inline void toggle_MSKSR_MPHO()
    {
        MSKSR ^= 1u << 2u;
    }

    /**
     * Get MSKSR's MPMI bit.
     */
    inline bool get_MSKSR_MPMI()
    {
        return MSKSR & (1u << 1u);
    }

    /**
     * Set MSKSR's MPMI bit.
     */
    inline void set_MSKSR_MPMI()
    {
        MSKSR |= 1u << 1u;
    }

    /**
     * Clear MSKSR's MPMI bit.
     */
    inline void clear_MSKSR_MPMI()
    {
        MSKSR &= ~(1u << 1u);
    }

    /**
     * Toggle MSKSR's MPMI bit.
     */
    inline void toggle_MSKSR_MPMI()
    {
        MSKSR ^= 1u << 1u;
    }

    /**
     * Get MSKSR's MPSE bit.
     */
    inline bool get_MSKSR_MPSE()
    {
        return MSKSR & (1u << 0u);
    }

    /**
     * Set MSKSR's MPSE bit.
     */
    inline void set_MSKSR_MPSE()
    {
        MSKSR |= 1u << 0u;
    }

    /**
     * Clear MSKSR's MPSE bit.
     */
    inline void clear_MSKSR_MPSE()
    {
        MSKSR &= ~(1u << 0u);
    }

    /**
     * Toggle MSKSR's MPSE bit.
     */
    inline void toggle_MSKSR_MPSE()
    {
        MSKSR ^= 1u << 0u;
    }

    /**
     * Get all of MSKSR's bit fields.
     */
    inline void get_MSKSR(bool &MAI, bool &MPYE, bool &MPMO, bool &MPDA, bool &MPHO, bool &MPMI, bool &MPSE)
    {
        uint32_t curr = MSKSR;

        MAI = curr & (1u << 8u);
        MPYE = curr & (1u << 6u);
        MPMO = curr & (1u << 5u);
        MPDA = curr & (1u << 3u);
        MPHO = curr & (1u << 2u);
        MPMI = curr & (1u << 1u);
        MPSE = curr & (1u << 0u);
    }

    /**
     * Set all of MSKSR's bit fields.
     */
    inline void set_MSKSR(bool MAI, bool MPYE, bool MPMO, bool MPDA, bool MPHO, bool MPMI, bool MPSE)
    {
        uint32_t curr = MSKSR;

        curr &= ~(0b1u << 8u);
        curr |= (MAI & 0b1u) << 8u;
        curr &= ~(0b1u << 6u);
        curr |= (MPYE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (MPMO & 0b1u) << 5u;
        curr &= ~(0b1u << 3u);
        curr |= (MPDA & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (MPHO & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (MPMI & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (MPSE & 0b1u) << 0u;

        MSKSR = curr;
    }

    /**
     * Set CLRSR's RAI bit.
     */
    inline void set_CLRSR_RAI()
    {
        CLRSR |= 1u << 8u;
    }

    /**
     * Clear CLRSR's RAI bit.
     */
    inline void clear_CLRSR_RAI()
    {
        CLRSR &= ~(1u << 8u);
    }

    /**
     * Toggle CLRSR's RAI bit.
     */
    inline void toggle_CLRSR_RAI()
    {
        CLRSR ^= 1u << 8u;
    }

    /**
     * Set CLRSR's RPYE bit.
     */
    inline void set_CLRSR_RPYE()
    {
        CLRSR |= 1u << 6u;
    }

    /**
     * Clear CLRSR's RPYE bit.
     */
    inline void clear_CLRSR_RPYE()
    {
        CLRSR &= ~(1u << 6u);
    }

    /**
     * Toggle CLRSR's RPYE bit.
     */
    inline void toggle_CLRSR_RPYE()
    {
        CLRSR ^= 1u << 6u;
    }

    /**
     * Set CLRSR's RPMO bit.
     */
    inline void set_CLRSR_RPMO()
    {
        CLRSR |= 1u << 5u;
    }

    /**
     * Clear CLRSR's RPMO bit.
     */
    inline void clear_CLRSR_RPMO()
    {
        CLRSR &= ~(1u << 5u);
    }

    /**
     * Toggle CLRSR's RPMO bit.
     */
    inline void toggle_CLRSR_RPMO()
    {
        CLRSR ^= 1u << 5u;
    }

    /**
     * Set CLRSR's RPDA bit.
     */
    inline void set_CLRSR_RPDA()
    {
        CLRSR |= 1u << 3u;
    }

    /**
     * Clear CLRSR's RPDA bit.
     */
    inline void clear_CLRSR_RPDA()
    {
        CLRSR &= ~(1u << 3u);
    }

    /**
     * Toggle CLRSR's RPDA bit.
     */
    inline void toggle_CLRSR_RPDA()
    {
        CLRSR ^= 1u << 3u;
    }

    /**
     * Set CLRSR's RPHO bit.
     */
    inline void set_CLRSR_RPHO()
    {
        CLRSR |= 1u << 2u;
    }

    /**
     * Clear CLRSR's RPHO bit.
     */
    inline void clear_CLRSR_RPHO()
    {
        CLRSR &= ~(1u << 2u);
    }

    /**
     * Toggle CLRSR's RPHO bit.
     */
    inline void toggle_CLRSR_RPHO()
    {
        CLRSR ^= 1u << 2u;
    }

    /**
     * Set CLRSR's RPMI bit.
     */
    inline void set_CLRSR_RPMI()
    {
        CLRSR |= 1u << 1u;
    }

    /**
     * Clear CLRSR's RPMI bit.
     */
    inline void clear_CLRSR_RPMI()
    {
        CLRSR &= ~(1u << 1u);
    }

    /**
     * Toggle CLRSR's RPMI bit.
     */
    inline void toggle_CLRSR_RPMI()
    {
        CLRSR ^= 1u << 1u;
    }

    /**
     * Set CLRSR's RPSE bit.
     */
    inline void set_CLRSR_RPSE()
    {
        CLRSR |= 1u << 0u;
    }

    /**
     * Clear CLRSR's RPSE bit.
     */
    inline void clear_CLRSR_RPSE()
    {
        CLRSR &= ~(1u << 0u);
    }

    /**
     * Toggle CLRSR's RPSE bit.
     */
    inline void toggle_CLRSR_RPSE()
    {
        CLRSR ^= 1u << 0u;
    }

    /**
     * Set all of CLRSR's bit fields.
     */
    inline void set_CLRSR(bool RAI, bool RPYE, bool RPMO, bool RPDA, bool RPHO, bool RPMI, bool RPSE)
    {
        uint32_t curr = CLRSR;

        curr &= ~(0b1u << 8u);
        curr |= (RAI & 0b1u) << 8u;
        curr &= ~(0b1u << 6u);
        curr |= (RPYE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (RPMO & 0b1u) << 5u;
        curr &= ~(0b1u << 3u);
        curr |= (RPDA & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (RPHO & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (RPMI & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (RPSE & 0b1u) << 0u;

        CLRSR = curr;
    }

    /**
     * Get ATIM0's ADA field.
     */
    inline uint8_t get_ATIM0_ADA()
    {
        return (ATIM0 >> 24u) & 0b11111u;
    }

    /**
     * Set ATIM0's ADA field.
     */
    inline void set_ATIM0_ADA(uint8_t value)
    {
        uint32_t curr = ATIM0;

        curr &= ~(0b11111u << 24u);
        curr |= (value & 0b11111u) << 24u;

        ATIM0 = curr;
    }

    /**
     * Get ATIM0's AHO field.
     */
    inline uint8_t get_ATIM0_AHO()
    {
        return (ATIM0 >> 16u) & 0b11111u;
    }

    /**
     * Set ATIM0's AHO field.
     */
    inline void set_ATIM0_AHO(uint8_t value)
    {
        uint32_t curr = ATIM0;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        ATIM0 = curr;
    }

    /**
     * Get ATIM0's AMI field.
     */
    inline uint8_t get_ATIM0_AMI()
    {
        return (ATIM0 >> 8u) & 0b111111u;
    }

    /**
     * Set ATIM0's AMI field.
     */
    inline void set_ATIM0_AMI(uint8_t value)
    {
        uint32_t curr = ATIM0;

        curr &= ~(0b111111u << 8u);
        curr |= (value & 0b111111u) << 8u;

        ATIM0 = curr;
    }

    /**
     * Get ATIM0's ASE field.
     */
    inline uint8_t get_ATIM0_ASE()
    {
        return (ATIM0 >> 0u) & 0b111111u;
    }

    /**
     * Set ATIM0's ASE field.
     */
    inline void set_ATIM0_ASE(uint8_t value)
    {
        uint32_t curr = ATIM0;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        ATIM0 = curr;
    }

    /**
     * Get all of ATIM0's bit fields.
     */
    inline void get_ATIM0(uint8_t &ADA, uint8_t &AHO, uint8_t &AMI, uint8_t &ASE)
    {
        uint32_t curr = ATIM0;

        ADA = (curr >> 24u) & 0b11111u;
        AHO = (curr >> 16u) & 0b11111u;
        AMI = (curr >> 8u) & 0b111111u;
        ASE = (curr >> 0u) & 0b111111u;
    }

    /**
     * Set all of ATIM0's bit fields.
     */
    inline void set_ATIM0(uint8_t ADA, uint8_t AHO, uint8_t AMI, uint8_t ASE)
    {
        uint32_t curr = ATIM0;

        curr &= ~(0b11111u << 24u);
        curr |= (ADA & 0b11111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (AHO & 0b11111u) << 16u;
        curr &= ~(0b111111u << 8u);
        curr |= (AMI & 0b111111u) << 8u;
        curr &= ~(0b111111u << 0u);
        curr |= (ASE & 0b111111u) << 0u;

        ATIM0 = curr;
    }

    /**
     * Get ATIM1's AYE field.
     */
    inline uint16_t get_ATIM1_AYE()
    {
        return (ATIM1 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set ATIM1's AYE field.
     */
    inline void set_ATIM1_AYE(uint16_t value)
    {
        uint32_t curr = ATIM1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        ATIM1 = curr;
    }

    /**
     * Get ATIM1's AMO field.
     */
    inline uint8_t get_ATIM1_AMO()
    {
        return (ATIM1 >> 8u) & 0b1111u;
    }

    /**
     * Set ATIM1's AMO field.
     */
    inline void set_ATIM1_AMO(uint8_t value)
    {
        uint32_t curr = ATIM1;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        ATIM1 = curr;
    }

    /**
     * Get all of ATIM1's bit fields.
     */
    inline void get_ATIM1(uint16_t &AYE, uint8_t &AMO)
    {
        uint32_t curr = ATIM1;

        AYE = (curr >> 16u) & 0b1111111111111111u;
        AMO = (curr >> 8u) & 0b1111u;
    }

    /**
     * Set all of ATIM1's bit fields.
     */
    inline void set_ATIM1(uint16_t AYE, uint8_t AMO)
    {
        uint32_t curr = ATIM1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (AYE & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111u << 8u);
        curr |= (AMO & 0b1111u) << 8u;

        ATIM1 = curr;
    }

    /**
     * Get TIM0's DA field.
     */
    inline uint8_t get_TIM0_DA()
    {
        return (TIM0 >> 24u) & 0b11111u;
    }

    /**
     * Set TIM0's DA field.
     */
    inline void set_TIM0_DA(uint8_t value)
    {
        uint32_t curr = TIM0;

        curr &= ~(0b11111u << 24u);
        curr |= (value & 0b11111u) << 24u;

        TIM0 = curr;
    }

    /**
     * Get TIM0's HO field.
     */
    inline uint8_t get_TIM0_HO()
    {
        return (TIM0 >> 16u) & 0b11111u;
    }

    /**
     * Set TIM0's HO field.
     */
    inline void set_TIM0_HO(uint8_t value)
    {
        uint32_t curr = TIM0;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        TIM0 = curr;
    }

    /**
     * Get TIM0's MI field.
     */
    inline uint8_t get_TIM0_MI()
    {
        return (TIM0 >> 8u) & 0b111111u;
    }

    /**
     * Set TIM0's MI field.
     */
    inline void set_TIM0_MI(uint8_t value)
    {
        uint32_t curr = TIM0;

        curr &= ~(0b111111u << 8u);
        curr |= (value & 0b111111u) << 8u;

        TIM0 = curr;
    }

    /**
     * Get TIM0's SE field.
     */
    inline uint8_t get_TIM0_SE()
    {
        return (TIM0 >> 0u) & 0b111111u;
    }

    /**
     * Set TIM0's SE field.
     */
    inline void set_TIM0_SE(uint8_t value)
    {
        uint32_t curr = TIM0;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        TIM0 = curr;
    }

    /**
     * Get all of TIM0's bit fields.
     */
    inline void get_TIM0(uint8_t &DA, uint8_t &HO, uint8_t &MI, uint8_t &SE)
    {
        uint32_t curr = TIM0;

        DA = (curr >> 24u) & 0b11111u;
        HO = (curr >> 16u) & 0b11111u;
        MI = (curr >> 8u) & 0b111111u;
        SE = (curr >> 0u) & 0b111111u;
    }

    /**
     * Set all of TIM0's bit fields.
     */
    inline void set_TIM0(uint8_t DA, uint8_t HO, uint8_t MI, uint8_t SE)
    {
        uint32_t curr = TIM0;

        curr &= ~(0b11111u << 24u);
        curr |= (DA & 0b11111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (HO & 0b11111u) << 16u;
        curr &= ~(0b111111u << 8u);
        curr |= (MI & 0b111111u) << 8u;
        curr &= ~(0b111111u << 0u);
        curr |= (SE & 0b111111u) << 0u;

        TIM0 = curr;
    }

    /**
     * Get TIM1's YE field.
     */
    inline uint16_t get_TIM1_YE()
    {
        return (TIM1 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set TIM1's YE field.
     */
    inline void set_TIM1_YE(uint16_t value)
    {
        uint32_t curr = TIM1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        TIM1 = curr;
    }

    /**
     * Get TIM1's MO field.
     */
    inline uint8_t get_TIM1_MO()
    {
        return (TIM1 >> 8u) & 0b1111u;
    }

    /**
     * Set TIM1's MO field.
     */
    inline void set_TIM1_MO(uint8_t value)
    {
        uint32_t curr = TIM1;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        TIM1 = curr;
    }

    /**
     * Get TIM1's DAWE field.
     */
    inline uint8_t get_TIM1_DAWE()
    {
        return (TIM1 >> 0u) & 0b111u;
    }

    /**
     * Set TIM1's DAWE field.
     */
    inline void set_TIM1_DAWE(uint8_t value)
    {
        uint32_t curr = TIM1;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        TIM1 = curr;
    }

    /**
     * Get all of TIM1's bit fields.
     */
    inline void get_TIM1(uint16_t &YE, uint8_t &MO, uint8_t &DAWE)
    {
        uint32_t curr = TIM1;

        YE = (curr >> 16u) & 0b1111111111111111u;
        MO = (curr >> 8u) & 0b1111u;
        DAWE = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of TIM1's bit fields.
     */
    inline void set_TIM1(uint16_t YE, uint8_t MO, uint8_t DAWE)
    {
        uint32_t curr = TIM1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (YE & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111u << 8u);
        curr |= (MO & 0b1111u) << 8u;
        curr &= ~(0b111u << 0u);
        curr |= (DAWE & 0b111u) << 0u;

        TIM1 = curr;
    }
};

static_assert(sizeof(rtc) == rtc::size);

static volatile rtc *const RTC = reinterpret_cast<rtc *>(0x50004A00);

}; // namespace XMC4700
