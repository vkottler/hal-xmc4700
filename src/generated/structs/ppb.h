/**
 * \file
 * \brief Generated by ifgen (3.2.0).
 */
#pragma once

#include "../enums/PPB_CPACR_CP11.h"
#include "../enums/PPB_CPUID_Implementer.h"
#include "../enums/PPB_CPUID_PartNo.h"
#include "../enums/PPB_CPUID_Revision.h"
#include "../enums/PPB_CPUID_Variant.h"
#include "../enums/PPB_ICSR_VECTACTIVE.h"
#include "../enums/PPB_ICSR_VECTPENDING.h"
#include "../enums/PPB_MPU_RASR_SRD.h"
#include "../enums/PPB_NVIC_IABR0_ACTIVE.h"
#include "../enums/PPB_NVIC_ISER0_SETENA.h"
#include "../enums/PPB_NVIC_ISPR0_SETPEND.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * Cortex-M4 Private Peripheral Block
 */
struct [[gnu::packed]] ppb
{
    /* Constant attributes. */
    static constexpr std::size_t size = 3904; /*!< ppb's size in bytes. */

    /* Fields. */
    static constexpr std::size_t reserved_padding0_length = 2;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t ACTLR; /*!< (read-write) Auxiliary Control Register */
    const uint32_t reserved_padding1 = {};
    uint32_t SYST_CSR; /*!< (read-write) SysTick Control and Status Register */
    uint32_t SYST_RVR; /*!< (read-write) SysTick Reload Value Register */
    uint32_t SYST_CVR; /*!< (read-write) SysTick Current Value Register */
    uint32_t
        SYST_CALIB; /*!< (read-write) SysTick Calibration Value Register r */
    static constexpr std::size_t reserved_padding2_length = 56;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t NVIC_ISER0; /*!< (read-write) Interrupt Set-enable Register 0 */
    uint32_t NVIC_ISER1; /*!< (read-write) Interrupt Set-enable Register 1 */
    uint32_t NVIC_ISER2; /*!< (read-write) Interrupt Set-enable Register 2 */
    uint32_t NVIC_ISER3; /*!< (read-write) Interrupt Set-enable Register 3 */
    static constexpr std::size_t reserved_padding3_length = 28;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t NVIC_ICER0; /*!< (read-write) Interrupt Clear-enable Register 0 */
    uint32_t NVIC_ICER1; /*!< (read-write) Interrupt Clear-enable Register 1 */
    uint32_t NVIC_ICER2; /*!< (read-write) Interrupt Clear-enable Register 2 */
    uint32_t NVIC_ICER3; /*!< (read-write) Interrupt Clear-enable Register 3 */
    static constexpr std::size_t reserved_padding4_length = 28;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t NVIC_ISPR0; /*!< (read-write) Interrupt Set-pending Register 0 */
    uint32_t NVIC_ISPR1; /*!< (read-write) Interrupt Set-pending Register 1 */
    uint32_t NVIC_ISPR2; /*!< (read-write) Interrupt Set-pending Register 2 */
    uint32_t NVIC_ISPR3; /*!< (read-write) Interrupt Set-pending Register 3 */
    static constexpr std::size_t reserved_padding5_length = 28;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t
        NVIC_ICPR0; /*!< (read-write) Interrupt Clear-pending Register 0 */
    uint32_t
        NVIC_ICPR1; /*!< (read-write) Interrupt Clear-pending Register 1 */
    uint32_t
        NVIC_ICPR2; /*!< (read-write) Interrupt Clear-pending Register 2 */
    uint32_t
        NVIC_ICPR3; /*!< (read-write) Interrupt Clear-pending Register 3 */
    static constexpr std::size_t reserved_padding6_length = 28;
    const uint32_t reserved_padding6[reserved_padding6_length] = {};
    uint32_t NVIC_IABR0; /*!< (read-write) Interrupt Active Bit Register 0 */
    uint32_t NVIC_IABR1; /*!< (read-write) Interrupt Active Bit Register 1 */
    uint32_t NVIC_IABR2; /*!< (read-write) Interrupt Active Bit Register 2 */
    uint32_t NVIC_IABR3; /*!< (read-write) Interrupt Active Bit Register 3 */
    static constexpr std::size_t reserved_padding7_length = 60;
    const uint32_t reserved_padding7[reserved_padding7_length] = {};
    uint32_t NVIC_IPR0;  /*!< (read-write) Interrupt Priority Register 0 */
    uint32_t NVIC_IPR1;  /*!< (read-write) Interrupt Priority Register 1 */
    uint32_t NVIC_IPR2;  /*!< (read-write) Interrupt Priority Register 2 */
    uint32_t NVIC_IPR3;  /*!< (read-write) Interrupt Priority Register 3 */
    uint32_t NVIC_IPR4;  /*!< (read-write) Interrupt Priority Register 4 */
    uint32_t NVIC_IPR5;  /*!< (read-write) Interrupt Priority Register 5 */
    uint32_t NVIC_IPR6;  /*!< (read-write) Interrupt Priority Register 6 */
    uint32_t NVIC_IPR7;  /*!< (read-write) Interrupt Priority Register 7 */
    uint32_t NVIC_IPR8;  /*!< (read-write) Interrupt Priority Register 8 */
    uint32_t NVIC_IPR9;  /*!< (read-write) Interrupt Priority Register 9 */
    uint32_t NVIC_IPR10; /*!< (read-write) Interrupt Priority Register 10 */
    uint32_t NVIC_IPR11; /*!< (read-write) Interrupt Priority Register 11 */
    uint32_t NVIC_IPR12; /*!< (read-write) Interrupt Priority Register 12 */
    uint32_t NVIC_IPR13; /*!< (read-write) Interrupt Priority Register 13 */
    uint32_t NVIC_IPR14; /*!< (read-write) Interrupt Priority Register 14 */
    uint32_t NVIC_IPR15; /*!< (read-write) Interrupt Priority Register 15 */
    uint32_t NVIC_IPR16; /*!< (read-write) Interrupt Priority Register 16 */
    uint32_t NVIC_IPR17; /*!< (read-write) Interrupt Priority Register 17 */
    uint32_t NVIC_IPR18; /*!< (read-write) Interrupt Priority Register 18 */
    uint32_t NVIC_IPR19; /*!< (read-write) Interrupt Priority Register 19 */
    uint32_t NVIC_IPR20; /*!< (read-write) Interrupt Priority Register 20 */
    uint32_t NVIC_IPR21; /*!< (read-write) Interrupt Priority Register 21 */
    uint32_t NVIC_IPR22; /*!< (read-write) Interrupt Priority Register 22 */
    uint32_t NVIC_IPR23; /*!< (read-write) Interrupt Priority Register 23 */
    uint32_t NVIC_IPR24; /*!< (read-write) Interrupt Priority Register 24 */
    uint32_t NVIC_IPR25; /*!< (read-write) Interrupt Priority Register 25 */
    uint32_t NVIC_IPR26; /*!< (read-write) Interrupt Priority Register 26 */
    uint32_t NVIC_IPR27; /*!< (read-write) Interrupt Priority Register 27 */
    static constexpr std::size_t reserved_padding8_length = 548;
    const uint32_t reserved_padding8[reserved_padding8_length] = {};
    const uint32_t CPUID = {}; /*!< (read-only) CPUID Base Register */
    uint32_t ICSR;  /*!< (read-write) Interrupt Control and State Register */
    uint32_t VTOR;  /*!< (read-write) Vector Table Offset Register */
    uint32_t AIRCR; /*!< (read-write) Application Interrupt and Reset Control
                       Register */
    uint32_t SCR;   /*!< (read-write) System Control Register */
    uint32_t CCR;   /*!< (read-write) Configuration and Control Register */
    uint32_t SHPR1; /*!< (read-write) System Handler Priority Register 1 */
    uint32_t SHPR2; /*!< (read-write) System Handler Priority Register 2 */
    uint32_t SHPR3; /*!< (read-write) System Handler Priority Register 3 */
    uint32_t
        SHCSR; /*!< (read-write) System Handler Control and State Register */
    uint32_t CFSR; /*!< (read-write) Configurable Fault Status Register */
    uint32_t HFSR; /*!< (read-write) HardFault Status Register */
    const uint32_t reserved_padding9 = {};
    uint32_t MMFAR; /*!< (read-write) MemManage Fault Address Register */
    uint32_t BFAR;  /*!< (read-write) BusFault Address Register */
    uint32_t AFSR;  /*!< (read-write) Auxiliary Fault Status Register */
    static constexpr std::size_t reserved_padding10_length = 18;
    const uint32_t reserved_padding10[reserved_padding10_length] = {};
    uint32_t CPACR; /*!< (read-write) Coprocessor Access Control Register */
    const uint32_t reserved_padding11 = {};
    const uint32_t MPU_TYPE = {}; /*!< (read-only) MPU Type Register */
    uint32_t MPU_CTRL;            /*!< (read-write) MPU Control Register */
    uint32_t MPU_RNR;  /*!< (read-write) MPU Region Number Register */
    uint32_t MPU_RBAR; /*!< (read-write) MPU Region Base Address Register */
    uint32_t
        MPU_RASR; /*!< (read-write) MPU Region Attribute and Size Register */
    uint32_t
        MPU_RBAR_A1; /*!< (read-write) MPU Region Base Address Register A1 */
    uint32_t MPU_RASR_A1; /*!< (read-write) MPU Region Attribute and Size
                             Register A1 */
    uint32_t
        MPU_RBAR_A2; /*!< (read-write) MPU Region Base Address Register A2 */
    uint32_t MPU_RASR_A2; /*!< (read-write) MPU Region Attribute and Size
                             Register A2 */
    uint32_t
        MPU_RBAR_A3; /*!< (read-write) MPU Region Base Address Register A3 */
    uint32_t MPU_RASR_A3; /*!< (read-write) MPU Region Attribute and Size
                             Register A3 */
    static constexpr std::size_t reserved_padding12_length = 81;
    const uint32_t reserved_padding12[reserved_padding12_length] = {};
    uint32_t STIR; /*!< (write-only) Software Trigger Interrupt Register */
    static constexpr std::size_t reserved_padding13_length = 12;
    const uint32_t reserved_padding13[reserved_padding13_length] = {};
    uint32_t
        FPCCR; /*!< (read-write) Floating-point Context Control Register */
    uint32_t
        FPCAR; /*!< (read-write) Floating-point Context Address Register */
    uint32_t FPDSCR; /*!< (read-write) Floating-point Default Status Control
                        Register */

    /* Methods. */

    /**
     * Get ACTLR's DISOOFP bit.
     *
     * Disable out of order FP execution
     */
    inline bool get_ACTLR_DISOOFP() volatile
    {
        return ACTLR & (1u << 9u);
    }

    /**
     * Set ACTLR's DISOOFP bit.
     *
     * Disable out of order FP execution
     */
    inline void set_ACTLR_DISOOFP() volatile
    {
        ACTLR |= 1u << 9u;
    }

    /**
     * Clear ACTLR's DISOOFP bit.
     *
     * Disable out of order FP execution
     */
    inline void clear_ACTLR_DISOOFP() volatile
    {
        ACTLR &= ~(1u << 9u);
    }

    /**
     * Toggle ACTLR's DISOOFP bit.
     *
     * Disable out of order FP execution
     */
    inline void toggle_ACTLR_DISOOFP() volatile
    {
        ACTLR ^= 1u << 9u;
    }

    /**
     * Get ACTLR's DISFPCA bit.
     *
     * Disable FPCA update
     */
    inline bool get_ACTLR_DISFPCA() volatile
    {
        return ACTLR & (1u << 8u);
    }

    /**
     * Set ACTLR's DISFPCA bit.
     *
     * Disable FPCA update
     */
    inline void set_ACTLR_DISFPCA() volatile
    {
        ACTLR |= 1u << 8u;
    }

    /**
     * Clear ACTLR's DISFPCA bit.
     *
     * Disable FPCA update
     */
    inline void clear_ACTLR_DISFPCA() volatile
    {
        ACTLR &= ~(1u << 8u);
    }

    /**
     * Toggle ACTLR's DISFPCA bit.
     *
     * Disable FPCA update
     */
    inline void toggle_ACTLR_DISFPCA() volatile
    {
        ACTLR ^= 1u << 8u;
    }

    /**
     * Get ACTLR's DISFOLD bit.
     *
     * Disable IT folding
     */
    inline bool get_ACTLR_DISFOLD() volatile
    {
        return ACTLR & (1u << 2u);
    }

    /**
     * Set ACTLR's DISFOLD bit.
     *
     * Disable IT folding
     */
    inline void set_ACTLR_DISFOLD() volatile
    {
        ACTLR |= 1u << 2u;
    }

    /**
     * Clear ACTLR's DISFOLD bit.
     *
     * Disable IT folding
     */
    inline void clear_ACTLR_DISFOLD() volatile
    {
        ACTLR &= ~(1u << 2u);
    }

    /**
     * Toggle ACTLR's DISFOLD bit.
     *
     * Disable IT folding
     */
    inline void toggle_ACTLR_DISFOLD() volatile
    {
        ACTLR ^= 1u << 2u;
    }

    /**
     * Get ACTLR's DISDEFWBUF bit.
     *
     * Disable write buffer
     */
    inline bool get_ACTLR_DISDEFWBUF() volatile
    {
        return ACTLR & (1u << 1u);
    }

    /**
     * Set ACTLR's DISDEFWBUF bit.
     *
     * Disable write buffer
     */
    inline void set_ACTLR_DISDEFWBUF() volatile
    {
        ACTLR |= 1u << 1u;
    }

    /**
     * Clear ACTLR's DISDEFWBUF bit.
     *
     * Disable write buffer
     */
    inline void clear_ACTLR_DISDEFWBUF() volatile
    {
        ACTLR &= ~(1u << 1u);
    }

    /**
     * Toggle ACTLR's DISDEFWBUF bit.
     *
     * Disable write buffer
     */
    inline void toggle_ACTLR_DISDEFWBUF() volatile
    {
        ACTLR ^= 1u << 1u;
    }

    /**
     * Get ACTLR's DISMCYCINT bit.
     *
     * Disable load/store multiple
     */
    inline bool get_ACTLR_DISMCYCINT() volatile
    {
        return ACTLR & (1u << 0u);
    }

    /**
     * Set ACTLR's DISMCYCINT bit.
     *
     * Disable load/store multiple
     */
    inline void set_ACTLR_DISMCYCINT() volatile
    {
        ACTLR |= 1u << 0u;
    }

    /**
     * Clear ACTLR's DISMCYCINT bit.
     *
     * Disable load/store multiple
     */
    inline void clear_ACTLR_DISMCYCINT() volatile
    {
        ACTLR &= ~(1u << 0u);
    }

    /**
     * Toggle ACTLR's DISMCYCINT bit.
     *
     * Disable load/store multiple
     */
    inline void toggle_ACTLR_DISMCYCINT() volatile
    {
        ACTLR ^= 1u << 0u;
    }

    /**
     * Get all of ACTLR's bit fields.
     *
     * (read-write) Auxiliary Control Register
     */
    inline void get_ACTLR(bool &DISOOFP, bool &DISFPCA, bool &DISFOLD,
                          bool &DISDEFWBUF, bool &DISMCYCINT) volatile
    {
        uint32_t curr = ACTLR;

        DISOOFP = curr & (1u << 9u);
        DISFPCA = curr & (1u << 8u);
        DISFOLD = curr & (1u << 2u);
        DISDEFWBUF = curr & (1u << 1u);
        DISMCYCINT = curr & (1u << 0u);
    }

    /**
     * Set all of ACTLR's bit fields.
     *
     * (read-write) Auxiliary Control Register
     */
    inline void set_ACTLR(bool DISOOFP, bool DISFPCA, bool DISFOLD,
                          bool DISDEFWBUF, bool DISMCYCINT) volatile
    {
        uint32_t curr = ACTLR;

        curr &= ~(0b1u << 9u);
        curr |= (DISOOFP & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (DISFPCA & 0b1u) << 8u;
        curr &= ~(0b1u << 2u);
        curr |= (DISFOLD & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DISDEFWBUF & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (DISMCYCINT & 0b1u) << 0u;

        ACTLR = curr;
    }

    /**
     * Get SYST_CSR's COUNTFLAG bit.
     *
     * Counter Flag
     */
    inline bool get_SYST_CSR_COUNTFLAG() volatile
    {
        return SYST_CSR & (1u << 16u);
    }

    /**
     * Set SYST_CSR's COUNTFLAG bit.
     *
     * Counter Flag
     */
    inline void set_SYST_CSR_COUNTFLAG() volatile
    {
        SYST_CSR |= 1u << 16u;
    }

    /**
     * Clear SYST_CSR's COUNTFLAG bit.
     *
     * Counter Flag
     */
    inline void clear_SYST_CSR_COUNTFLAG() volatile
    {
        SYST_CSR &= ~(1u << 16u);
    }

    /**
     * Toggle SYST_CSR's COUNTFLAG bit.
     *
     * Counter Flag
     */
    inline void toggle_SYST_CSR_COUNTFLAG() volatile
    {
        SYST_CSR ^= 1u << 16u;
    }

    /**
     * Get SYST_CSR's CLKSOURCE bit.
     *
     * Indicates the clock source:
     */
    inline bool get_SYST_CSR_CLKSOURCE() volatile
    {
        return SYST_CSR & (1u << 2u);
    }

    /**
     * Set SYST_CSR's CLKSOURCE bit.
     *
     * Indicates the clock source:
     */
    inline void set_SYST_CSR_CLKSOURCE() volatile
    {
        SYST_CSR |= 1u << 2u;
    }

    /**
     * Clear SYST_CSR's CLKSOURCE bit.
     *
     * Indicates the clock source:
     */
    inline void clear_SYST_CSR_CLKSOURCE() volatile
    {
        SYST_CSR &= ~(1u << 2u);
    }

    /**
     * Toggle SYST_CSR's CLKSOURCE bit.
     *
     * Indicates the clock source:
     */
    inline void toggle_SYST_CSR_CLKSOURCE() volatile
    {
        SYST_CSR ^= 1u << 2u;
    }

    /**
     * Get SYST_CSR's TICKINT bit.
     *
     * Tick Interrupt Enable
     */
    inline bool get_SYST_CSR_TICKINT() volatile
    {
        return SYST_CSR & (1u << 1u);
    }

    /**
     * Set SYST_CSR's TICKINT bit.
     *
     * Tick Interrupt Enable
     */
    inline void set_SYST_CSR_TICKINT() volatile
    {
        SYST_CSR |= 1u << 1u;
    }

    /**
     * Clear SYST_CSR's TICKINT bit.
     *
     * Tick Interrupt Enable
     */
    inline void clear_SYST_CSR_TICKINT() volatile
    {
        SYST_CSR &= ~(1u << 1u);
    }

    /**
     * Toggle SYST_CSR's TICKINT bit.
     *
     * Tick Interrupt Enable
     */
    inline void toggle_SYST_CSR_TICKINT() volatile
    {
        SYST_CSR ^= 1u << 1u;
    }

    /**
     * Get SYST_CSR's ENABLE bit.
     *
     * Enable
     */
    inline bool get_SYST_CSR_ENABLE() volatile
    {
        return SYST_CSR & (1u << 0u);
    }

    /**
     * Set SYST_CSR's ENABLE bit.
     *
     * Enable
     */
    inline void set_SYST_CSR_ENABLE() volatile
    {
        SYST_CSR |= 1u << 0u;
    }

    /**
     * Clear SYST_CSR's ENABLE bit.
     *
     * Enable
     */
    inline void clear_SYST_CSR_ENABLE() volatile
    {
        SYST_CSR &= ~(1u << 0u);
    }

    /**
     * Toggle SYST_CSR's ENABLE bit.
     *
     * Enable
     */
    inline void toggle_SYST_CSR_ENABLE() volatile
    {
        SYST_CSR ^= 1u << 0u;
    }

    /**
     * Get all of SYST_CSR's bit fields.
     *
     * (read-write) SysTick Control and Status Register
     */
    inline void get_SYST_CSR(bool &COUNTFLAG, bool &CLKSOURCE, bool &TICKINT,
                             bool &ENABLE) volatile
    {
        uint32_t curr = SYST_CSR;

        COUNTFLAG = curr & (1u << 16u);
        CLKSOURCE = curr & (1u << 2u);
        TICKINT = curr & (1u << 1u);
        ENABLE = curr & (1u << 0u);
    }

    /**
     * Set all of SYST_CSR's bit fields.
     *
     * (read-write) SysTick Control and Status Register
     */
    inline void set_SYST_CSR(bool COUNTFLAG, bool CLKSOURCE, bool TICKINT,
                             bool ENABLE) volatile
    {
        uint32_t curr = SYST_CSR;

        curr &= ~(0b1u << 16u);
        curr |= (COUNTFLAG & 0b1u) << 16u;
        curr &= ~(0b1u << 2u);
        curr |= (CLKSOURCE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TICKINT & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ENABLE & 0b1u) << 0u;

        SYST_CSR = curr;
    }

    /**
     * Get SYST_RVR's RELOAD field.
     *
     * Reload Value
     */
    inline uint32_t get_SYST_RVR_RELOAD() volatile
    {
        return (SYST_RVR >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set SYST_RVR's RELOAD field.
     *
     * Reload Value
     */
    inline void set_SYST_RVR_RELOAD(uint32_t value) volatile
    {
        uint32_t curr = SYST_RVR;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        SYST_RVR = curr;
    }

    /**
     * Get SYST_CVR's CURRENT field.
     *
     * Current Value
     */
    inline uint32_t get_SYST_CVR_CURRENT() volatile
    {
        return (SYST_CVR >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set SYST_CVR's CURRENT field.
     *
     * Current Value
     */
    inline void set_SYST_CVR_CURRENT(uint32_t value) volatile
    {
        uint32_t curr = SYST_CVR;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        SYST_CVR = curr;
    }

    /**
     * Get SYST_CALIB's NOREF bit.
     *
     * No Reference Clock
     */
    inline bool get_SYST_CALIB_NOREF() volatile
    {
        return SYST_CALIB & (1u << 31u);
    }

    /**
     * Set SYST_CALIB's NOREF bit.
     *
     * No Reference Clock
     */
    inline void set_SYST_CALIB_NOREF() volatile
    {
        SYST_CALIB |= 1u << 31u;
    }

    /**
     * Clear SYST_CALIB's NOREF bit.
     *
     * No Reference Clock
     */
    inline void clear_SYST_CALIB_NOREF() volatile
    {
        SYST_CALIB &= ~(1u << 31u);
    }

    /**
     * Toggle SYST_CALIB's NOREF bit.
     *
     * No Reference Clock
     */
    inline void toggle_SYST_CALIB_NOREF() volatile
    {
        SYST_CALIB ^= 1u << 31u;
    }

    /**
     * Get SYST_CALIB's SKEW bit.
     *
     * Ten Milliseconds Skewed
     */
    inline bool get_SYST_CALIB_SKEW() volatile
    {
        return SYST_CALIB & (1u << 30u);
    }

    /**
     * Set SYST_CALIB's SKEW bit.
     *
     * Ten Milliseconds Skewed
     */
    inline void set_SYST_CALIB_SKEW() volatile
    {
        SYST_CALIB |= 1u << 30u;
    }

    /**
     * Clear SYST_CALIB's SKEW bit.
     *
     * Ten Milliseconds Skewed
     */
    inline void clear_SYST_CALIB_SKEW() volatile
    {
        SYST_CALIB &= ~(1u << 30u);
    }

    /**
     * Toggle SYST_CALIB's SKEW bit.
     *
     * Ten Milliseconds Skewed
     */
    inline void toggle_SYST_CALIB_SKEW() volatile
    {
        SYST_CALIB ^= 1u << 30u;
    }

    /**
     * Get SYST_CALIB's TENMS field.
     *
     * Ten Milliseconds Reload Value
     */
    inline uint32_t get_SYST_CALIB_TENMS() volatile
    {
        return (SYST_CALIB >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set SYST_CALIB's TENMS field.
     *
     * Ten Milliseconds Reload Value
     */
    inline void set_SYST_CALIB_TENMS(uint32_t value) volatile
    {
        uint32_t curr = SYST_CALIB;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        SYST_CALIB = curr;
    }

    /**
     * Get all of SYST_CALIB's bit fields.
     *
     * (read-write) SysTick Calibration Value Register r
     */
    inline void get_SYST_CALIB(bool &NOREF, bool &SKEW,
                               uint32_t &TENMS) volatile
    {
        uint32_t curr = SYST_CALIB;

        NOREF = curr & (1u << 31u);
        SKEW = curr & (1u << 30u);
        TENMS = (curr >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set all of SYST_CALIB's bit fields.
     *
     * (read-write) SysTick Calibration Value Register r
     */
    inline void set_SYST_CALIB(bool NOREF, bool SKEW, uint32_t TENMS) volatile
    {
        uint32_t curr = SYST_CALIB;

        curr &= ~(0b1u << 31u);
        curr |= (NOREF & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SKEW & 0b1u) << 30u;
        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (TENMS & 0b111111111111111111111111u) << 0u;

        SYST_CALIB = curr;
    }

    /**
     * Get NVIC_ISER0's SETENA field.
     *
     * Interrupt set-enable bits
     */
    inline PPB_NVIC_ISER0_SETENA get_NVIC_ISER0_SETENA() volatile
    {
        return PPB_NVIC_ISER0_SETENA((NVIC_ISER0 >> 0u) &
                                     0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_ISER0's SETENA field.
     *
     * Interrupt set-enable bits
     */
    inline void set_NVIC_ISER0_SETENA(PPB_NVIC_ISER0_SETENA value) volatile
    {
        uint32_t curr = NVIC_ISER0;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_ISER0 = curr;
    }

    /**
     * Get NVIC_ISER1's SETENA field.
     *
     * Interrupt set-enable bits
     */
    inline PPB_NVIC_ISER0_SETENA get_NVIC_ISER1_SETENA() volatile
    {
        return PPB_NVIC_ISER0_SETENA((NVIC_ISER1 >> 0u) &
                                     0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_ISER1's SETENA field.
     *
     * Interrupt set-enable bits
     */
    inline void set_NVIC_ISER1_SETENA(PPB_NVIC_ISER0_SETENA value) volatile
    {
        uint32_t curr = NVIC_ISER1;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_ISER1 = curr;
    }

    /**
     * Get NVIC_ISER2's SETENA field.
     *
     * Interrupt set-enable bits
     */
    inline PPB_NVIC_ISER0_SETENA get_NVIC_ISER2_SETENA() volatile
    {
        return PPB_NVIC_ISER0_SETENA((NVIC_ISER2 >> 0u) &
                                     0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_ISER2's SETENA field.
     *
     * Interrupt set-enable bits
     */
    inline void set_NVIC_ISER2_SETENA(PPB_NVIC_ISER0_SETENA value) volatile
    {
        uint32_t curr = NVIC_ISER2;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_ISER2 = curr;
    }

    /**
     * Get NVIC_ISER3's SETENA field.
     *
     * Interrupt set-enable bits
     */
    inline PPB_NVIC_ISER0_SETENA get_NVIC_ISER3_SETENA() volatile
    {
        return PPB_NVIC_ISER0_SETENA((NVIC_ISER3 >> 0u) &
                                     0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_ISER3's SETENA field.
     *
     * Interrupt set-enable bits
     */
    inline void set_NVIC_ISER3_SETENA(PPB_NVIC_ISER0_SETENA value) volatile
    {
        uint32_t curr = NVIC_ISER3;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_ISER3 = curr;
    }

    /**
     * Get NVIC_ICER0's CLRENA field.
     *
     * Interrupt clear-enable bits.
     */
    inline PPB_NVIC_ISER0_SETENA get_NVIC_ICER0_CLRENA() volatile
    {
        return PPB_NVIC_ISER0_SETENA((NVIC_ICER0 >> 0u) &
                                     0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_ICER0's CLRENA field.
     *
     * Interrupt clear-enable bits.
     */
    inline void set_NVIC_ICER0_CLRENA(PPB_NVIC_ISER0_SETENA value) volatile
    {
        uint32_t curr = NVIC_ICER0;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_ICER0 = curr;
    }

    /**
     * Get NVIC_ICER1's CLRENA field.
     *
     * Interrupt clear-enable bits.
     */
    inline PPB_NVIC_ISER0_SETENA get_NVIC_ICER1_CLRENA() volatile
    {
        return PPB_NVIC_ISER0_SETENA((NVIC_ICER1 >> 0u) &
                                     0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_ICER1's CLRENA field.
     *
     * Interrupt clear-enable bits.
     */
    inline void set_NVIC_ICER1_CLRENA(PPB_NVIC_ISER0_SETENA value) volatile
    {
        uint32_t curr = NVIC_ICER1;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_ICER1 = curr;
    }

    /**
     * Get NVIC_ICER2's CLRENA field.
     *
     * Interrupt clear-enable bits.
     */
    inline PPB_NVIC_ISER0_SETENA get_NVIC_ICER2_CLRENA() volatile
    {
        return PPB_NVIC_ISER0_SETENA((NVIC_ICER2 >> 0u) &
                                     0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_ICER2's CLRENA field.
     *
     * Interrupt clear-enable bits.
     */
    inline void set_NVIC_ICER2_CLRENA(PPB_NVIC_ISER0_SETENA value) volatile
    {
        uint32_t curr = NVIC_ICER2;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_ICER2 = curr;
    }

    /**
     * Get NVIC_ICER3's CLRENA field.
     *
     * Interrupt clear-enable bits.
     */
    inline PPB_NVIC_ISER0_SETENA get_NVIC_ICER3_CLRENA() volatile
    {
        return PPB_NVIC_ISER0_SETENA((NVIC_ICER3 >> 0u) &
                                     0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_ICER3's CLRENA field.
     *
     * Interrupt clear-enable bits.
     */
    inline void set_NVIC_ICER3_CLRENA(PPB_NVIC_ISER0_SETENA value) volatile
    {
        uint32_t curr = NVIC_ICER3;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_ICER3 = curr;
    }

    /**
     * Get NVIC_ISPR0's SETPEND field.
     *
     * Interrupt set-pending bits.
     */
    inline PPB_NVIC_ISPR0_SETPEND get_NVIC_ISPR0_SETPEND() volatile
    {
        return PPB_NVIC_ISPR0_SETPEND((NVIC_ISPR0 >> 0u) &
                                      0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_ISPR0's SETPEND field.
     *
     * Interrupt set-pending bits.
     */
    inline void set_NVIC_ISPR0_SETPEND(PPB_NVIC_ISPR0_SETPEND value) volatile
    {
        uint32_t curr = NVIC_ISPR0;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_ISPR0 = curr;
    }

    /**
     * Get NVIC_ISPR1's SETPEND field.
     *
     * Interrupt set-pending bits.
     */
    inline PPB_NVIC_ISPR0_SETPEND get_NVIC_ISPR1_SETPEND() volatile
    {
        return PPB_NVIC_ISPR0_SETPEND((NVIC_ISPR1 >> 0u) &
                                      0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_ISPR1's SETPEND field.
     *
     * Interrupt set-pending bits.
     */
    inline void set_NVIC_ISPR1_SETPEND(PPB_NVIC_ISPR0_SETPEND value) volatile
    {
        uint32_t curr = NVIC_ISPR1;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_ISPR1 = curr;
    }

    /**
     * Get NVIC_ISPR2's SETPEND field.
     *
     * Interrupt set-pending bits.
     */
    inline PPB_NVIC_ISPR0_SETPEND get_NVIC_ISPR2_SETPEND() volatile
    {
        return PPB_NVIC_ISPR0_SETPEND((NVIC_ISPR2 >> 0u) &
                                      0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_ISPR2's SETPEND field.
     *
     * Interrupt set-pending bits.
     */
    inline void set_NVIC_ISPR2_SETPEND(PPB_NVIC_ISPR0_SETPEND value) volatile
    {
        uint32_t curr = NVIC_ISPR2;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_ISPR2 = curr;
    }

    /**
     * Get NVIC_ISPR3's SETPEND field.
     *
     * Interrupt set-pending bits.
     */
    inline PPB_NVIC_ISPR0_SETPEND get_NVIC_ISPR3_SETPEND() volatile
    {
        return PPB_NVIC_ISPR0_SETPEND((NVIC_ISPR3 >> 0u) &
                                      0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_ISPR3's SETPEND field.
     *
     * Interrupt set-pending bits.
     */
    inline void set_NVIC_ISPR3_SETPEND(PPB_NVIC_ISPR0_SETPEND value) volatile
    {
        uint32_t curr = NVIC_ISPR3;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_ISPR3 = curr;
    }

    /**
     * Get NVIC_ICPR0's CLRPEND field.
     *
     * Interrupt set-pending bits.
     */
    inline PPB_NVIC_ISPR0_SETPEND get_NVIC_ICPR0_CLRPEND() volatile
    {
        return PPB_NVIC_ISPR0_SETPEND((NVIC_ICPR0 >> 0u) &
                                      0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_ICPR0's CLRPEND field.
     *
     * Interrupt set-pending bits.
     */
    inline void set_NVIC_ICPR0_CLRPEND(PPB_NVIC_ISPR0_SETPEND value) volatile
    {
        uint32_t curr = NVIC_ICPR0;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_ICPR0 = curr;
    }

    /**
     * Get NVIC_ICPR1's CLRPEND field.
     *
     * Interrupt set-pending bits.
     */
    inline PPB_NVIC_ISPR0_SETPEND get_NVIC_ICPR1_CLRPEND() volatile
    {
        return PPB_NVIC_ISPR0_SETPEND((NVIC_ICPR1 >> 0u) &
                                      0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_ICPR1's CLRPEND field.
     *
     * Interrupt set-pending bits.
     */
    inline void set_NVIC_ICPR1_CLRPEND(PPB_NVIC_ISPR0_SETPEND value) volatile
    {
        uint32_t curr = NVIC_ICPR1;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_ICPR1 = curr;
    }

    /**
     * Get NVIC_ICPR2's CLRPEND field.
     *
     * Interrupt set-pending bits.
     */
    inline PPB_NVIC_ISPR0_SETPEND get_NVIC_ICPR2_CLRPEND() volatile
    {
        return PPB_NVIC_ISPR0_SETPEND((NVIC_ICPR2 >> 0u) &
                                      0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_ICPR2's CLRPEND field.
     *
     * Interrupt set-pending bits.
     */
    inline void set_NVIC_ICPR2_CLRPEND(PPB_NVIC_ISPR0_SETPEND value) volatile
    {
        uint32_t curr = NVIC_ICPR2;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_ICPR2 = curr;
    }

    /**
     * Get NVIC_ICPR3's CLRPEND field.
     *
     * Interrupt set-pending bits.
     */
    inline PPB_NVIC_ISPR0_SETPEND get_NVIC_ICPR3_CLRPEND() volatile
    {
        return PPB_NVIC_ISPR0_SETPEND((NVIC_ICPR3 >> 0u) &
                                      0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_ICPR3's CLRPEND field.
     *
     * Interrupt set-pending bits.
     */
    inline void set_NVIC_ICPR3_CLRPEND(PPB_NVIC_ISPR0_SETPEND value) volatile
    {
        uint32_t curr = NVIC_ICPR3;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_ICPR3 = curr;
    }

    /**
     * Get NVIC_IABR0's ACTIVE field.
     *
     * Interrupt active flags:
     */
    inline PPB_NVIC_IABR0_ACTIVE get_NVIC_IABR0_ACTIVE() volatile
    {
        return PPB_NVIC_IABR0_ACTIVE((NVIC_IABR0 >> 0u) &
                                     0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_IABR0's ACTIVE field.
     *
     * Interrupt active flags:
     */
    inline void set_NVIC_IABR0_ACTIVE(PPB_NVIC_IABR0_ACTIVE value) volatile
    {
        uint32_t curr = NVIC_IABR0;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_IABR0 = curr;
    }

    /**
     * Get NVIC_IABR1's ACTIVE field.
     *
     * Interrupt active flags:
     */
    inline PPB_NVIC_IABR0_ACTIVE get_NVIC_IABR1_ACTIVE() volatile
    {
        return PPB_NVIC_IABR0_ACTIVE((NVIC_IABR1 >> 0u) &
                                     0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_IABR1's ACTIVE field.
     *
     * Interrupt active flags:
     */
    inline void set_NVIC_IABR1_ACTIVE(PPB_NVIC_IABR0_ACTIVE value) volatile
    {
        uint32_t curr = NVIC_IABR1;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_IABR1 = curr;
    }

    /**
     * Get NVIC_IABR2's ACTIVE field.
     *
     * Interrupt active flags:
     */
    inline PPB_NVIC_IABR0_ACTIVE get_NVIC_IABR2_ACTIVE() volatile
    {
        return PPB_NVIC_IABR0_ACTIVE((NVIC_IABR2 >> 0u) &
                                     0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_IABR2's ACTIVE field.
     *
     * Interrupt active flags:
     */
    inline void set_NVIC_IABR2_ACTIVE(PPB_NVIC_IABR0_ACTIVE value) volatile
    {
        uint32_t curr = NVIC_IABR2;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_IABR2 = curr;
    }

    /**
     * Get NVIC_IABR3's ACTIVE field.
     *
     * Interrupt active flags:
     */
    inline PPB_NVIC_IABR0_ACTIVE get_NVIC_IABR3_ACTIVE() volatile
    {
        return PPB_NVIC_IABR0_ACTIVE((NVIC_IABR3 >> 0u) &
                                     0b11111111111111111111111111111111u);
    }

    /**
     * Set NVIC_IABR3's ACTIVE field.
     *
     * Interrupt active flags:
     */
    inline void set_NVIC_IABR3_ACTIVE(PPB_NVIC_IABR0_ACTIVE value) volatile
    {
        uint32_t curr = NVIC_IABR3;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |=
            (std::to_underlying(value) & 0b11111111111111111111111111111111u)
            << 0u;

        NVIC_IABR3 = curr;
    }

    /**
     * Get NVIC_IPR0's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR0_PRI_3() volatile
    {
        return (NVIC_IPR0 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR0's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR0_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR0;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR0 = curr;
    }

    /**
     * Get NVIC_IPR0's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR0_PRI_2() volatile
    {
        return (NVIC_IPR0 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR0's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR0_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR0;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR0 = curr;
    }

    /**
     * Get NVIC_IPR0's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR0_PRI_1() volatile
    {
        return (NVIC_IPR0 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR0's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR0_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR0;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR0 = curr;
    }

    /**
     * Get NVIC_IPR0's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR0_PRI_0() volatile
    {
        return (NVIC_IPR0 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR0's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR0_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR0;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR0 = curr;
    }

    /**
     * Get all of NVIC_IPR0's bit fields.
     *
     * (read-write) Interrupt Priority Register 0
     */
    inline void get_NVIC_IPR0(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                              uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR0;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR0's bit fields.
     *
     * (read-write) Interrupt Priority Register 0
     */
    inline void set_NVIC_IPR0(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                              uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR0;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR0 = curr;
    }

    /**
     * Get NVIC_IPR1's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR1_PRI_3() volatile
    {
        return (NVIC_IPR1 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR1's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR1_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR1;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR1 = curr;
    }

    /**
     * Get NVIC_IPR1's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR1_PRI_2() volatile
    {
        return (NVIC_IPR1 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR1's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR1_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR1;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR1 = curr;
    }

    /**
     * Get NVIC_IPR1's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR1_PRI_1() volatile
    {
        return (NVIC_IPR1 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR1's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR1_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR1;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR1 = curr;
    }

    /**
     * Get NVIC_IPR1's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR1_PRI_0() volatile
    {
        return (NVIC_IPR1 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR1's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR1_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR1;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR1 = curr;
    }

    /**
     * Get all of NVIC_IPR1's bit fields.
     *
     * (read-write) Interrupt Priority Register 1
     */
    inline void get_NVIC_IPR1(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                              uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR1;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR1's bit fields.
     *
     * (read-write) Interrupt Priority Register 1
     */
    inline void set_NVIC_IPR1(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                              uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR1;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR1 = curr;
    }

    /**
     * Get NVIC_IPR2's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR2_PRI_3() volatile
    {
        return (NVIC_IPR2 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR2's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR2_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR2;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR2 = curr;
    }

    /**
     * Get NVIC_IPR2's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR2_PRI_2() volatile
    {
        return (NVIC_IPR2 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR2's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR2_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR2;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR2 = curr;
    }

    /**
     * Get NVIC_IPR2's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR2_PRI_1() volatile
    {
        return (NVIC_IPR2 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR2's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR2_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR2;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR2 = curr;
    }

    /**
     * Get NVIC_IPR2's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR2_PRI_0() volatile
    {
        return (NVIC_IPR2 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR2's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR2_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR2;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR2 = curr;
    }

    /**
     * Get all of NVIC_IPR2's bit fields.
     *
     * (read-write) Interrupt Priority Register 2
     */
    inline void get_NVIC_IPR2(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                              uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR2;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR2's bit fields.
     *
     * (read-write) Interrupt Priority Register 2
     */
    inline void set_NVIC_IPR2(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                              uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR2;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR2 = curr;
    }

    /**
     * Get NVIC_IPR3's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR3_PRI_3() volatile
    {
        return (NVIC_IPR3 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR3's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR3_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR3;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR3 = curr;
    }

    /**
     * Get NVIC_IPR3's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR3_PRI_2() volatile
    {
        return (NVIC_IPR3 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR3's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR3_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR3;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR3 = curr;
    }

    /**
     * Get NVIC_IPR3's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR3_PRI_1() volatile
    {
        return (NVIC_IPR3 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR3's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR3_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR3;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR3 = curr;
    }

    /**
     * Get NVIC_IPR3's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR3_PRI_0() volatile
    {
        return (NVIC_IPR3 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR3's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR3_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR3;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR3 = curr;
    }

    /**
     * Get all of NVIC_IPR3's bit fields.
     *
     * (read-write) Interrupt Priority Register 3
     */
    inline void get_NVIC_IPR3(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                              uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR3;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR3's bit fields.
     *
     * (read-write) Interrupt Priority Register 3
     */
    inline void set_NVIC_IPR3(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                              uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR3;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR3 = curr;
    }

    /**
     * Get NVIC_IPR4's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR4_PRI_3() volatile
    {
        return (NVIC_IPR4 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR4's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR4_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR4;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR4 = curr;
    }

    /**
     * Get NVIC_IPR4's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR4_PRI_2() volatile
    {
        return (NVIC_IPR4 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR4's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR4_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR4;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR4 = curr;
    }

    /**
     * Get NVIC_IPR4's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR4_PRI_1() volatile
    {
        return (NVIC_IPR4 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR4's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR4_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR4;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR4 = curr;
    }

    /**
     * Get NVIC_IPR4's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR4_PRI_0() volatile
    {
        return (NVIC_IPR4 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR4's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR4_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR4;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR4 = curr;
    }

    /**
     * Get all of NVIC_IPR4's bit fields.
     *
     * (read-write) Interrupt Priority Register 4
     */
    inline void get_NVIC_IPR4(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                              uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR4;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR4's bit fields.
     *
     * (read-write) Interrupt Priority Register 4
     */
    inline void set_NVIC_IPR4(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                              uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR4;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR4 = curr;
    }

    /**
     * Get NVIC_IPR5's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR5_PRI_3() volatile
    {
        return (NVIC_IPR5 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR5's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR5_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR5;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR5 = curr;
    }

    /**
     * Get NVIC_IPR5's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR5_PRI_2() volatile
    {
        return (NVIC_IPR5 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR5's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR5_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR5;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR5 = curr;
    }

    /**
     * Get NVIC_IPR5's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR5_PRI_1() volatile
    {
        return (NVIC_IPR5 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR5's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR5_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR5;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR5 = curr;
    }

    /**
     * Get NVIC_IPR5's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR5_PRI_0() volatile
    {
        return (NVIC_IPR5 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR5's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR5_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR5;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR5 = curr;
    }

    /**
     * Get all of NVIC_IPR5's bit fields.
     *
     * (read-write) Interrupt Priority Register 5
     */
    inline void get_NVIC_IPR5(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                              uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR5;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR5's bit fields.
     *
     * (read-write) Interrupt Priority Register 5
     */
    inline void set_NVIC_IPR5(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                              uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR5;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR5 = curr;
    }

    /**
     * Get NVIC_IPR6's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR6_PRI_3() volatile
    {
        return (NVIC_IPR6 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR6's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR6_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR6;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR6 = curr;
    }

    /**
     * Get NVIC_IPR6's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR6_PRI_2() volatile
    {
        return (NVIC_IPR6 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR6's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR6_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR6;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR6 = curr;
    }

    /**
     * Get NVIC_IPR6's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR6_PRI_1() volatile
    {
        return (NVIC_IPR6 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR6's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR6_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR6;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR6 = curr;
    }

    /**
     * Get NVIC_IPR6's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR6_PRI_0() volatile
    {
        return (NVIC_IPR6 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR6's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR6_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR6;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR6 = curr;
    }

    /**
     * Get all of NVIC_IPR6's bit fields.
     *
     * (read-write) Interrupt Priority Register 6
     */
    inline void get_NVIC_IPR6(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                              uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR6;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR6's bit fields.
     *
     * (read-write) Interrupt Priority Register 6
     */
    inline void set_NVIC_IPR6(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                              uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR6;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR6 = curr;
    }

    /**
     * Get NVIC_IPR7's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR7_PRI_3() volatile
    {
        return (NVIC_IPR7 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR7's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR7_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR7;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR7 = curr;
    }

    /**
     * Get NVIC_IPR7's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR7_PRI_2() volatile
    {
        return (NVIC_IPR7 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR7's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR7_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR7;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR7 = curr;
    }

    /**
     * Get NVIC_IPR7's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR7_PRI_1() volatile
    {
        return (NVIC_IPR7 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR7's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR7_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR7;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR7 = curr;
    }

    /**
     * Get NVIC_IPR7's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR7_PRI_0() volatile
    {
        return (NVIC_IPR7 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR7's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR7_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR7;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR7 = curr;
    }

    /**
     * Get all of NVIC_IPR7's bit fields.
     *
     * (read-write) Interrupt Priority Register 7
     */
    inline void get_NVIC_IPR7(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                              uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR7;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR7's bit fields.
     *
     * (read-write) Interrupt Priority Register 7
     */
    inline void set_NVIC_IPR7(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                              uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR7;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR7 = curr;
    }

    /**
     * Get NVIC_IPR8's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR8_PRI_3() volatile
    {
        return (NVIC_IPR8 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR8's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR8_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR8;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR8 = curr;
    }

    /**
     * Get NVIC_IPR8's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR8_PRI_2() volatile
    {
        return (NVIC_IPR8 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR8's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR8_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR8;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR8 = curr;
    }

    /**
     * Get NVIC_IPR8's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR8_PRI_1() volatile
    {
        return (NVIC_IPR8 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR8's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR8_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR8;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR8 = curr;
    }

    /**
     * Get NVIC_IPR8's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR8_PRI_0() volatile
    {
        return (NVIC_IPR8 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR8's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR8_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR8;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR8 = curr;
    }

    /**
     * Get all of NVIC_IPR8's bit fields.
     *
     * (read-write) Interrupt Priority Register 8
     */
    inline void get_NVIC_IPR8(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                              uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR8;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR8's bit fields.
     *
     * (read-write) Interrupt Priority Register 8
     */
    inline void set_NVIC_IPR8(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                              uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR8;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR8 = curr;
    }

    /**
     * Get NVIC_IPR9's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR9_PRI_3() volatile
    {
        return (NVIC_IPR9 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR9's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR9_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR9;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR9 = curr;
    }

    /**
     * Get NVIC_IPR9's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR9_PRI_2() volatile
    {
        return (NVIC_IPR9 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR9's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR9_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR9;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR9 = curr;
    }

    /**
     * Get NVIC_IPR9's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR9_PRI_1() volatile
    {
        return (NVIC_IPR9 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR9's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR9_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR9;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR9 = curr;
    }

    /**
     * Get NVIC_IPR9's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR9_PRI_0() volatile
    {
        return (NVIC_IPR9 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR9's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR9_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR9;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR9 = curr;
    }

    /**
     * Get all of NVIC_IPR9's bit fields.
     *
     * (read-write) Interrupt Priority Register 9
     */
    inline void get_NVIC_IPR9(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                              uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR9;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR9's bit fields.
     *
     * (read-write) Interrupt Priority Register 9
     */
    inline void set_NVIC_IPR9(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                              uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR9;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR9 = curr;
    }

    /**
     * Get NVIC_IPR10's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR10_PRI_3() volatile
    {
        return (NVIC_IPR10 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR10's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR10_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR10;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR10 = curr;
    }

    /**
     * Get NVIC_IPR10's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR10_PRI_2() volatile
    {
        return (NVIC_IPR10 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR10's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR10_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR10;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR10 = curr;
    }

    /**
     * Get NVIC_IPR10's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR10_PRI_1() volatile
    {
        return (NVIC_IPR10 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR10's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR10_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR10;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR10 = curr;
    }

    /**
     * Get NVIC_IPR10's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR10_PRI_0() volatile
    {
        return (NVIC_IPR10 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR10's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR10_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR10;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR10 = curr;
    }

    /**
     * Get all of NVIC_IPR10's bit fields.
     *
     * (read-write) Interrupt Priority Register 10
     */
    inline void get_NVIC_IPR10(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                               uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR10;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR10's bit fields.
     *
     * (read-write) Interrupt Priority Register 10
     */
    inline void set_NVIC_IPR10(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                               uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR10;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR10 = curr;
    }

    /**
     * Get NVIC_IPR11's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR11_PRI_3() volatile
    {
        return (NVIC_IPR11 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR11's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR11_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR11;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR11 = curr;
    }

    /**
     * Get NVIC_IPR11's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR11_PRI_2() volatile
    {
        return (NVIC_IPR11 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR11's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR11_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR11;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR11 = curr;
    }

    /**
     * Get NVIC_IPR11's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR11_PRI_1() volatile
    {
        return (NVIC_IPR11 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR11's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR11_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR11;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR11 = curr;
    }

    /**
     * Get NVIC_IPR11's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR11_PRI_0() volatile
    {
        return (NVIC_IPR11 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR11's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR11_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR11;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR11 = curr;
    }

    /**
     * Get all of NVIC_IPR11's bit fields.
     *
     * (read-write) Interrupt Priority Register 11
     */
    inline void get_NVIC_IPR11(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                               uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR11;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR11's bit fields.
     *
     * (read-write) Interrupt Priority Register 11
     */
    inline void set_NVIC_IPR11(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                               uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR11;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR11 = curr;
    }

    /**
     * Get NVIC_IPR12's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR12_PRI_3() volatile
    {
        return (NVIC_IPR12 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR12's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR12_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR12;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR12 = curr;
    }

    /**
     * Get NVIC_IPR12's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR12_PRI_2() volatile
    {
        return (NVIC_IPR12 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR12's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR12_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR12;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR12 = curr;
    }

    /**
     * Get NVIC_IPR12's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR12_PRI_1() volatile
    {
        return (NVIC_IPR12 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR12's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR12_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR12;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR12 = curr;
    }

    /**
     * Get NVIC_IPR12's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR12_PRI_0() volatile
    {
        return (NVIC_IPR12 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR12's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR12_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR12;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR12 = curr;
    }

    /**
     * Get all of NVIC_IPR12's bit fields.
     *
     * (read-write) Interrupt Priority Register 12
     */
    inline void get_NVIC_IPR12(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                               uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR12;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR12's bit fields.
     *
     * (read-write) Interrupt Priority Register 12
     */
    inline void set_NVIC_IPR12(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                               uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR12;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR12 = curr;
    }

    /**
     * Get NVIC_IPR13's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR13_PRI_3() volatile
    {
        return (NVIC_IPR13 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR13's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR13_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR13;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR13 = curr;
    }

    /**
     * Get NVIC_IPR13's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR13_PRI_2() volatile
    {
        return (NVIC_IPR13 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR13's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR13_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR13;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR13 = curr;
    }

    /**
     * Get NVIC_IPR13's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR13_PRI_1() volatile
    {
        return (NVIC_IPR13 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR13's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR13_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR13;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR13 = curr;
    }

    /**
     * Get NVIC_IPR13's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR13_PRI_0() volatile
    {
        return (NVIC_IPR13 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR13's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR13_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR13;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR13 = curr;
    }

    /**
     * Get all of NVIC_IPR13's bit fields.
     *
     * (read-write) Interrupt Priority Register 13
     */
    inline void get_NVIC_IPR13(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                               uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR13;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR13's bit fields.
     *
     * (read-write) Interrupt Priority Register 13
     */
    inline void set_NVIC_IPR13(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                               uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR13;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR13 = curr;
    }

    /**
     * Get NVIC_IPR14's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR14_PRI_3() volatile
    {
        return (NVIC_IPR14 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR14's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR14_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR14;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR14 = curr;
    }

    /**
     * Get NVIC_IPR14's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR14_PRI_2() volatile
    {
        return (NVIC_IPR14 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR14's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR14_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR14;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR14 = curr;
    }

    /**
     * Get NVIC_IPR14's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR14_PRI_1() volatile
    {
        return (NVIC_IPR14 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR14's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR14_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR14;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR14 = curr;
    }

    /**
     * Get NVIC_IPR14's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR14_PRI_0() volatile
    {
        return (NVIC_IPR14 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR14's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR14_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR14;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR14 = curr;
    }

    /**
     * Get all of NVIC_IPR14's bit fields.
     *
     * (read-write) Interrupt Priority Register 14
     */
    inline void get_NVIC_IPR14(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                               uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR14;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR14's bit fields.
     *
     * (read-write) Interrupt Priority Register 14
     */
    inline void set_NVIC_IPR14(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                               uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR14;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR14 = curr;
    }

    /**
     * Get NVIC_IPR15's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR15_PRI_3() volatile
    {
        return (NVIC_IPR15 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR15's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR15_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR15;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR15 = curr;
    }

    /**
     * Get NVIC_IPR15's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR15_PRI_2() volatile
    {
        return (NVIC_IPR15 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR15's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR15_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR15;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR15 = curr;
    }

    /**
     * Get NVIC_IPR15's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR15_PRI_1() volatile
    {
        return (NVIC_IPR15 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR15's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR15_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR15;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR15 = curr;
    }

    /**
     * Get NVIC_IPR15's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR15_PRI_0() volatile
    {
        return (NVIC_IPR15 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR15's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR15_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR15;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR15 = curr;
    }

    /**
     * Get all of NVIC_IPR15's bit fields.
     *
     * (read-write) Interrupt Priority Register 15
     */
    inline void get_NVIC_IPR15(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                               uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR15;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR15's bit fields.
     *
     * (read-write) Interrupt Priority Register 15
     */
    inline void set_NVIC_IPR15(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                               uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR15;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR15 = curr;
    }

    /**
     * Get NVIC_IPR16's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR16_PRI_3() volatile
    {
        return (NVIC_IPR16 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR16's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR16_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR16;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR16 = curr;
    }

    /**
     * Get NVIC_IPR16's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR16_PRI_2() volatile
    {
        return (NVIC_IPR16 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR16's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR16_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR16;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR16 = curr;
    }

    /**
     * Get NVIC_IPR16's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR16_PRI_1() volatile
    {
        return (NVIC_IPR16 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR16's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR16_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR16;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR16 = curr;
    }

    /**
     * Get NVIC_IPR16's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR16_PRI_0() volatile
    {
        return (NVIC_IPR16 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR16's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR16_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR16;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR16 = curr;
    }

    /**
     * Get all of NVIC_IPR16's bit fields.
     *
     * (read-write) Interrupt Priority Register 16
     */
    inline void get_NVIC_IPR16(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                               uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR16;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR16's bit fields.
     *
     * (read-write) Interrupt Priority Register 16
     */
    inline void set_NVIC_IPR16(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                               uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR16;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR16 = curr;
    }

    /**
     * Get NVIC_IPR17's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR17_PRI_3() volatile
    {
        return (NVIC_IPR17 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR17's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR17_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR17;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR17 = curr;
    }

    /**
     * Get NVIC_IPR17's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR17_PRI_2() volatile
    {
        return (NVIC_IPR17 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR17's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR17_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR17;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR17 = curr;
    }

    /**
     * Get NVIC_IPR17's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR17_PRI_1() volatile
    {
        return (NVIC_IPR17 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR17's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR17_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR17;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR17 = curr;
    }

    /**
     * Get NVIC_IPR17's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR17_PRI_0() volatile
    {
        return (NVIC_IPR17 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR17's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR17_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR17;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR17 = curr;
    }

    /**
     * Get all of NVIC_IPR17's bit fields.
     *
     * (read-write) Interrupt Priority Register 17
     */
    inline void get_NVIC_IPR17(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                               uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR17;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR17's bit fields.
     *
     * (read-write) Interrupt Priority Register 17
     */
    inline void set_NVIC_IPR17(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                               uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR17;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR17 = curr;
    }

    /**
     * Get NVIC_IPR18's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR18_PRI_3() volatile
    {
        return (NVIC_IPR18 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR18's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR18_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR18;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR18 = curr;
    }

    /**
     * Get NVIC_IPR18's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR18_PRI_2() volatile
    {
        return (NVIC_IPR18 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR18's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR18_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR18;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR18 = curr;
    }

    /**
     * Get NVIC_IPR18's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR18_PRI_1() volatile
    {
        return (NVIC_IPR18 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR18's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR18_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR18;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR18 = curr;
    }

    /**
     * Get NVIC_IPR18's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR18_PRI_0() volatile
    {
        return (NVIC_IPR18 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR18's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR18_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR18;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR18 = curr;
    }

    /**
     * Get all of NVIC_IPR18's bit fields.
     *
     * (read-write) Interrupt Priority Register 18
     */
    inline void get_NVIC_IPR18(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                               uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR18;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR18's bit fields.
     *
     * (read-write) Interrupt Priority Register 18
     */
    inline void set_NVIC_IPR18(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                               uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR18;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR18 = curr;
    }

    /**
     * Get NVIC_IPR19's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR19_PRI_3() volatile
    {
        return (NVIC_IPR19 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR19's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR19_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR19;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR19 = curr;
    }

    /**
     * Get NVIC_IPR19's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR19_PRI_2() volatile
    {
        return (NVIC_IPR19 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR19's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR19_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR19;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR19 = curr;
    }

    /**
     * Get NVIC_IPR19's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR19_PRI_1() volatile
    {
        return (NVIC_IPR19 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR19's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR19_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR19;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR19 = curr;
    }

    /**
     * Get NVIC_IPR19's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR19_PRI_0() volatile
    {
        return (NVIC_IPR19 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR19's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR19_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR19;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR19 = curr;
    }

    /**
     * Get all of NVIC_IPR19's bit fields.
     *
     * (read-write) Interrupt Priority Register 19
     */
    inline void get_NVIC_IPR19(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                               uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR19;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR19's bit fields.
     *
     * (read-write) Interrupt Priority Register 19
     */
    inline void set_NVIC_IPR19(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                               uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR19;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR19 = curr;
    }

    /**
     * Get NVIC_IPR20's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR20_PRI_3() volatile
    {
        return (NVIC_IPR20 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR20's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR20_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR20;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR20 = curr;
    }

    /**
     * Get NVIC_IPR20's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR20_PRI_2() volatile
    {
        return (NVIC_IPR20 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR20's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR20_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR20;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR20 = curr;
    }

    /**
     * Get NVIC_IPR20's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR20_PRI_1() volatile
    {
        return (NVIC_IPR20 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR20's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR20_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR20;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR20 = curr;
    }

    /**
     * Get NVIC_IPR20's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR20_PRI_0() volatile
    {
        return (NVIC_IPR20 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR20's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR20_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR20;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR20 = curr;
    }

    /**
     * Get all of NVIC_IPR20's bit fields.
     *
     * (read-write) Interrupt Priority Register 20
     */
    inline void get_NVIC_IPR20(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                               uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR20;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR20's bit fields.
     *
     * (read-write) Interrupt Priority Register 20
     */
    inline void set_NVIC_IPR20(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                               uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR20;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR20 = curr;
    }

    /**
     * Get NVIC_IPR21's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR21_PRI_3() volatile
    {
        return (NVIC_IPR21 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR21's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR21_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR21;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR21 = curr;
    }

    /**
     * Get NVIC_IPR21's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR21_PRI_2() volatile
    {
        return (NVIC_IPR21 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR21's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR21_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR21;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR21 = curr;
    }

    /**
     * Get NVIC_IPR21's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR21_PRI_1() volatile
    {
        return (NVIC_IPR21 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR21's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR21_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR21;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR21 = curr;
    }

    /**
     * Get NVIC_IPR21's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR21_PRI_0() volatile
    {
        return (NVIC_IPR21 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR21's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR21_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR21;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR21 = curr;
    }

    /**
     * Get all of NVIC_IPR21's bit fields.
     *
     * (read-write) Interrupt Priority Register 21
     */
    inline void get_NVIC_IPR21(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                               uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR21;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR21's bit fields.
     *
     * (read-write) Interrupt Priority Register 21
     */
    inline void set_NVIC_IPR21(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                               uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR21;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR21 = curr;
    }

    /**
     * Get NVIC_IPR22's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR22_PRI_3() volatile
    {
        return (NVIC_IPR22 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR22's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR22_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR22;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR22 = curr;
    }

    /**
     * Get NVIC_IPR22's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR22_PRI_2() volatile
    {
        return (NVIC_IPR22 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR22's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR22_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR22;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR22 = curr;
    }

    /**
     * Get NVIC_IPR22's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR22_PRI_1() volatile
    {
        return (NVIC_IPR22 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR22's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR22_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR22;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR22 = curr;
    }

    /**
     * Get NVIC_IPR22's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR22_PRI_0() volatile
    {
        return (NVIC_IPR22 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR22's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR22_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR22;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR22 = curr;
    }

    /**
     * Get all of NVIC_IPR22's bit fields.
     *
     * (read-write) Interrupt Priority Register 22
     */
    inline void get_NVIC_IPR22(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                               uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR22;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR22's bit fields.
     *
     * (read-write) Interrupt Priority Register 22
     */
    inline void set_NVIC_IPR22(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                               uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR22;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR22 = curr;
    }

    /**
     * Get NVIC_IPR23's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR23_PRI_3() volatile
    {
        return (NVIC_IPR23 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR23's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR23_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR23;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR23 = curr;
    }

    /**
     * Get NVIC_IPR23's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR23_PRI_2() volatile
    {
        return (NVIC_IPR23 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR23's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR23_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR23;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR23 = curr;
    }

    /**
     * Get NVIC_IPR23's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR23_PRI_1() volatile
    {
        return (NVIC_IPR23 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR23's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR23_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR23;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR23 = curr;
    }

    /**
     * Get NVIC_IPR23's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR23_PRI_0() volatile
    {
        return (NVIC_IPR23 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR23's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR23_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR23;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR23 = curr;
    }

    /**
     * Get all of NVIC_IPR23's bit fields.
     *
     * (read-write) Interrupt Priority Register 23
     */
    inline void get_NVIC_IPR23(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                               uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR23;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR23's bit fields.
     *
     * (read-write) Interrupt Priority Register 23
     */
    inline void set_NVIC_IPR23(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                               uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR23;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR23 = curr;
    }

    /**
     * Get NVIC_IPR24's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR24_PRI_3() volatile
    {
        return (NVIC_IPR24 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR24's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR24_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR24;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR24 = curr;
    }

    /**
     * Get NVIC_IPR24's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR24_PRI_2() volatile
    {
        return (NVIC_IPR24 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR24's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR24_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR24;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR24 = curr;
    }

    /**
     * Get NVIC_IPR24's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR24_PRI_1() volatile
    {
        return (NVIC_IPR24 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR24's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR24_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR24;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR24 = curr;
    }

    /**
     * Get NVIC_IPR24's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR24_PRI_0() volatile
    {
        return (NVIC_IPR24 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR24's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR24_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR24;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR24 = curr;
    }

    /**
     * Get all of NVIC_IPR24's bit fields.
     *
     * (read-write) Interrupt Priority Register 24
     */
    inline void get_NVIC_IPR24(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                               uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR24;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR24's bit fields.
     *
     * (read-write) Interrupt Priority Register 24
     */
    inline void set_NVIC_IPR24(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                               uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR24;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR24 = curr;
    }

    /**
     * Get NVIC_IPR25's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR25_PRI_3() volatile
    {
        return (NVIC_IPR25 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR25's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR25_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR25;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR25 = curr;
    }

    /**
     * Get NVIC_IPR25's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR25_PRI_2() volatile
    {
        return (NVIC_IPR25 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR25's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR25_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR25;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR25 = curr;
    }

    /**
     * Get NVIC_IPR25's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR25_PRI_1() volatile
    {
        return (NVIC_IPR25 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR25's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR25_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR25;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR25 = curr;
    }

    /**
     * Get NVIC_IPR25's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR25_PRI_0() volatile
    {
        return (NVIC_IPR25 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR25's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR25_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR25;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR25 = curr;
    }

    /**
     * Get all of NVIC_IPR25's bit fields.
     *
     * (read-write) Interrupt Priority Register 25
     */
    inline void get_NVIC_IPR25(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                               uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR25;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR25's bit fields.
     *
     * (read-write) Interrupt Priority Register 25
     */
    inline void set_NVIC_IPR25(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                               uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR25;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR25 = curr;
    }

    /**
     * Get NVIC_IPR26's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR26_PRI_3() volatile
    {
        return (NVIC_IPR26 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR26's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR26_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR26;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR26 = curr;
    }

    /**
     * Get NVIC_IPR26's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR26_PRI_2() volatile
    {
        return (NVIC_IPR26 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR26's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR26_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR26;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR26 = curr;
    }

    /**
     * Get NVIC_IPR26's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR26_PRI_1() volatile
    {
        return (NVIC_IPR26 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR26's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR26_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR26;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR26 = curr;
    }

    /**
     * Get NVIC_IPR26's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR26_PRI_0() volatile
    {
        return (NVIC_IPR26 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR26's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR26_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR26;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR26 = curr;
    }

    /**
     * Get all of NVIC_IPR26's bit fields.
     *
     * (read-write) Interrupt Priority Register 26
     */
    inline void get_NVIC_IPR26(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                               uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR26;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR26's bit fields.
     *
     * (read-write) Interrupt Priority Register 26
     */
    inline void set_NVIC_IPR26(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                               uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR26;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR26 = curr;
    }

    /**
     * Get NVIC_IPR27's PRI_3 field.
     *
     * Priority value 3
     */
    inline uint8_t get_NVIC_IPR27_PRI_3() volatile
    {
        return (NVIC_IPR27 >> 24u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR27's PRI_3 field.
     *
     * Priority value 3
     */
    inline void set_NVIC_IPR27_PRI_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR27;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        NVIC_IPR27 = curr;
    }

    /**
     * Get NVIC_IPR27's PRI_2 field.
     *
     * Priority value 2
     */
    inline uint8_t get_NVIC_IPR27_PRI_2() volatile
    {
        return (NVIC_IPR27 >> 16u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR27's PRI_2 field.
     *
     * Priority value 2
     */
    inline void set_NVIC_IPR27_PRI_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR27;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        NVIC_IPR27 = curr;
    }

    /**
     * Get NVIC_IPR27's PRI_1 field.
     *
     * Priority value 1
     */
    inline uint8_t get_NVIC_IPR27_PRI_1() volatile
    {
        return (NVIC_IPR27 >> 8u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR27's PRI_1 field.
     *
     * Priority value 1
     */
    inline void set_NVIC_IPR27_PRI_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR27;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        NVIC_IPR27 = curr;
    }

    /**
     * Get NVIC_IPR27's PRI_0 field.
     *
     * Priority value 0
     */
    inline uint8_t get_NVIC_IPR27_PRI_0() volatile
    {
        return (NVIC_IPR27 >> 0u) & 0b11111111u;
    }

    /**
     * Set NVIC_IPR27's PRI_0 field.
     *
     * Priority value 0
     */
    inline void set_NVIC_IPR27_PRI_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR27;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        NVIC_IPR27 = curr;
    }

    /**
     * Get all of NVIC_IPR27's bit fields.
     *
     * (read-write) Interrupt Priority Register 27
     */
    inline void get_NVIC_IPR27(uint8_t &PRI_3, uint8_t &PRI_2, uint8_t &PRI_1,
                               uint8_t &PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR27;

        PRI_3 = (curr >> 24u) & 0b11111111u;
        PRI_2 = (curr >> 16u) & 0b11111111u;
        PRI_1 = (curr >> 8u) & 0b11111111u;
        PRI_0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of NVIC_IPR27's bit fields.
     *
     * (read-write) Interrupt Priority Register 27
     */
    inline void set_NVIC_IPR27(uint8_t PRI_3, uint8_t PRI_2, uint8_t PRI_1,
                               uint8_t PRI_0) volatile
    {
        uint32_t curr = NVIC_IPR27;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_0 & 0b11111111u) << 0u;

        NVIC_IPR27 = curr;
    }

    /**
     * Get CPUID's Implementer field.
     *
     * Implementer code
     */
    inline PPB_CPUID_Implementer get_CPUID_Implementer() volatile
    {
        return PPB_CPUID_Implementer((CPUID >> 24u) & 0b11111111u);
    }

    /**
     * Get CPUID's Variant field.
     *
     * Variant number
     */
    inline PPB_CPUID_Variant get_CPUID_Variant() volatile
    {
        return PPB_CPUID_Variant((CPUID >> 20u) & 0b1111u);
    }

    /**
     * Get CPUID's Constant field.
     *
     * Reads as 0xF
     */
    inline uint8_t get_CPUID_Constant() volatile
    {
        return (CPUID >> 16u) & 0b1111u;
    }

    /**
     * Get CPUID's PartNo field.
     *
     * Part number of the processor
     */
    inline PPB_CPUID_PartNo get_CPUID_PartNo() volatile
    {
        return PPB_CPUID_PartNo((CPUID >> 4u) & 0b111111111111u);
    }

    /**
     * Get CPUID's Revision field.
     *
     * Revision number
     */
    inline PPB_CPUID_Revision get_CPUID_Revision() volatile
    {
        return PPB_CPUID_Revision((CPUID >> 0u) & 0b1111u);
    }

    /**
     * Get all of CPUID's bit fields.
     *
     * (read-only) CPUID Base Register
     */
    inline void get_CPUID(PPB_CPUID_Implementer &Implementer,
                          PPB_CPUID_Variant &Variant, uint8_t &Constant,
                          PPB_CPUID_PartNo &PartNo,
                          PPB_CPUID_Revision &Revision) volatile
    {
        uint32_t curr = CPUID;

        Implementer = PPB_CPUID_Implementer((curr >> 24u) & 0b11111111u);
        Variant = PPB_CPUID_Variant((curr >> 20u) & 0b1111u);
        Constant = (curr >> 16u) & 0b1111u;
        PartNo = PPB_CPUID_PartNo((curr >> 4u) & 0b111111111111u);
        Revision = PPB_CPUID_Revision((curr >> 0u) & 0b1111u);
    }

    /**
     * Get ICSR's NMIPENDSET bit.
     *
     * NMI set-pending bit: 0b0=no effect, 0b1=changes NMI exception state to
     * pending., 0b0=NMI exception is not pending, 0b1=NMI exception is
     * pending.,
     */
    inline bool get_ICSR_NMIPENDSET() volatile
    {
        return ICSR & (1u << 31u);
    }

    /**
     * Set ICSR's NMIPENDSET bit.
     *
     * NMI set-pending bit: 0b0=no effect, 0b1=changes NMI exception state to
     * pending., 0b0=NMI exception is not pending, 0b1=NMI exception is
     * pending.,
     */
    inline void set_ICSR_NMIPENDSET() volatile
    {
        ICSR |= 1u << 31u;
    }

    /**
     * Clear ICSR's NMIPENDSET bit.
     *
     * NMI set-pending bit: 0b0=no effect, 0b1=changes NMI exception state to
     * pending., 0b0=NMI exception is not pending, 0b1=NMI exception is
     * pending.,
     */
    inline void clear_ICSR_NMIPENDSET() volatile
    {
        ICSR &= ~(1u << 31u);
    }

    /**
     * Toggle ICSR's NMIPENDSET bit.
     *
     * NMI set-pending bit: 0b0=no effect, 0b1=changes NMI exception state to
     * pending., 0b0=NMI exception is not pending, 0b1=NMI exception is
     * pending.,
     */
    inline void toggle_ICSR_NMIPENDSET() volatile
    {
        ICSR ^= 1u << 31u;
    }

    /**
     * Get ICSR's PENDSVSET bit.
     *
     * PendSV set-pending bit: 0b0=no effect, 0b1=changes PendSV exception
     * state to pending., 0b0=PendSV exception is not pending, 0b1=PendSV
     * exception is pending.,
     */
    inline bool get_ICSR_PENDSVSET() volatile
    {
        return ICSR & (1u << 28u);
    }

    /**
     * Set ICSR's PENDSVSET bit.
     *
     * PendSV set-pending bit: 0b0=no effect, 0b1=changes PendSV exception
     * state to pending., 0b0=PendSV exception is not pending, 0b1=PendSV
     * exception is pending.,
     */
    inline void set_ICSR_PENDSVSET() volatile
    {
        ICSR |= 1u << 28u;
    }

    /**
     * Clear ICSR's PENDSVSET bit.
     *
     * PendSV set-pending bit: 0b0=no effect, 0b1=changes PendSV exception
     * state to pending., 0b0=PendSV exception is not pending, 0b1=PendSV
     * exception is pending.,
     */
    inline void clear_ICSR_PENDSVSET() volatile
    {
        ICSR &= ~(1u << 28u);
    }

    /**
     * Toggle ICSR's PENDSVSET bit.
     *
     * PendSV set-pending bit: 0b0=no effect, 0b1=changes PendSV exception
     * state to pending., 0b0=PendSV exception is not pending, 0b1=PendSV
     * exception is pending.,
     */
    inline void toggle_ICSR_PENDSVSET() volatile
    {
        ICSR ^= 1u << 28u;
    }

    /**
     * Set ICSR's PENDSVCLR bit.
     *
     * PendSV clear-pending bit
     */
    inline void set_ICSR_PENDSVCLR() volatile
    {
        ICSR |= 1u << 27u;
    }

    /**
     * Clear ICSR's PENDSVCLR bit.
     *
     * PendSV clear-pending bit
     */
    inline void clear_ICSR_PENDSVCLR() volatile
    {
        ICSR &= ~(1u << 27u);
    }

    /**
     * Toggle ICSR's PENDSVCLR bit.
     *
     * PendSV clear-pending bit
     */
    inline void toggle_ICSR_PENDSVCLR() volatile
    {
        ICSR ^= 1u << 27u;
    }

    /**
     * Get ICSR's PENDSTSET bit.
     *
     * SysTick exception set-pending bit
     */
    inline bool get_ICSR_PENDSTSET() volatile
    {
        return ICSR & (1u << 26u);
    }

    /**
     * Set ICSR's PENDSTSET bit.
     *
     * SysTick exception set-pending bit
     */
    inline void set_ICSR_PENDSTSET() volatile
    {
        ICSR |= 1u << 26u;
    }

    /**
     * Clear ICSR's PENDSTSET bit.
     *
     * SysTick exception set-pending bit
     */
    inline void clear_ICSR_PENDSTSET() volatile
    {
        ICSR &= ~(1u << 26u);
    }

    /**
     * Toggle ICSR's PENDSTSET bit.
     *
     * SysTick exception set-pending bit
     */
    inline void toggle_ICSR_PENDSTSET() volatile
    {
        ICSR ^= 1u << 26u;
    }

    /**
     * Set ICSR's PENDSTCLR bit.
     *
     * SysTick exception clear-pending bit
     */
    inline void set_ICSR_PENDSTCLR() volatile
    {
        ICSR |= 1u << 25u;
    }

    /**
     * Clear ICSR's PENDSTCLR bit.
     *
     * SysTick exception clear-pending bit
     */
    inline void clear_ICSR_PENDSTCLR() volatile
    {
        ICSR &= ~(1u << 25u);
    }

    /**
     * Toggle ICSR's PENDSTCLR bit.
     *
     * SysTick exception clear-pending bit
     */
    inline void toggle_ICSR_PENDSTCLR() volatile
    {
        ICSR ^= 1u << 25u;
    }

    /**
     * Get ICSR's ISRPENDING bit.
     *
     * Interrupt pending flag
     */
    inline bool get_ICSR_ISRPENDING() volatile
    {
        return ICSR & (1u << 22u);
    }

    /**
     * Get ICSR's VECTPENDING field.
     *
     * Vector Pending
     */
    inline PPB_ICSR_VECTPENDING get_ICSR_VECTPENDING() volatile
    {
        return PPB_ICSR_VECTPENDING((ICSR >> 12u) & 0b111111u);
    }

    /**
     * Get ICSR's RETTOBASE bit.
     *
     * Return to Base
     */
    inline bool get_ICSR_RETTOBASE() volatile
    {
        return ICSR & (1u << 11u);
    }

    /**
     * Get ICSR's VECTACTIVE field.
     *
     * Active exception number
     */
    inline PPB_ICSR_VECTACTIVE get_ICSR_VECTACTIVE() volatile
    {
        return PPB_ICSR_VECTACTIVE((ICSR >> 0u) & 0b111111111u);
    }

    /**
     * Get all of ICSR's bit fields.
     *
     * (read-write) Interrupt Control and State Register
     */
    inline void get_ICSR(bool &NMIPENDSET, bool &PENDSVSET, bool &PENDSTSET,
                         bool &ISRPENDING, PPB_ICSR_VECTPENDING &VECTPENDING,
                         bool &RETTOBASE,
                         PPB_ICSR_VECTACTIVE &VECTACTIVE) volatile
    {
        uint32_t curr = ICSR;

        NMIPENDSET = curr & (1u << 31u);
        PENDSVSET = curr & (1u << 28u);
        PENDSTSET = curr & (1u << 26u);
        ISRPENDING = curr & (1u << 22u);
        VECTPENDING = PPB_ICSR_VECTPENDING((curr >> 12u) & 0b111111u);
        RETTOBASE = curr & (1u << 11u);
        VECTACTIVE = PPB_ICSR_VECTACTIVE((curr >> 0u) & 0b111111111u);
    }

    /**
     * Set all of ICSR's bit fields.
     *
     * (read-write) Interrupt Control and State Register
     */
    inline void set_ICSR(bool NMIPENDSET, bool PENDSVSET, bool PENDSVCLR,
                         bool PENDSTSET, bool PENDSTCLR) volatile
    {
        uint32_t curr = ICSR;

        curr &= ~(0b1u << 31u);
        curr |= (NMIPENDSET & 0b1u) << 31u;
        curr &= ~(0b1u << 28u);
        curr |= (PENDSVSET & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (PENDSVCLR & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (PENDSTSET & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (PENDSTCLR & 0b1u) << 25u;

        ICSR = curr;
    }

    /**
     * Get VTOR's TBLOFF field.
     *
     * Vector table base offset field
     */
    inline uint32_t get_VTOR_TBLOFF() volatile
    {
        return (VTOR >> 10u) & 0b1111111111111111111111u;
    }

    /**
     * Set VTOR's TBLOFF field.
     *
     * Vector table base offset field
     */
    inline void set_VTOR_TBLOFF(uint32_t value) volatile
    {
        uint32_t curr = VTOR;

        curr &= ~(0b1111111111111111111111u << 10u);
        curr |= (value & 0b1111111111111111111111u) << 10u;

        VTOR = curr;
    }

    /**
     * Get AIRCR's VECTKEY field.
     *
     * Register key
     */
    inline uint16_t get_AIRCR_VECTKEY() volatile
    {
        return (AIRCR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set AIRCR's VECTKEY field.
     *
     * Register key
     */
    inline void set_AIRCR_VECTKEY(uint16_t value) volatile
    {
        uint32_t curr = AIRCR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        AIRCR = curr;
    }

    /**
     * Get AIRCR's ENDIANNESS bit.
     *
     * Data endianness bit
     */
    inline bool get_AIRCR_ENDIANNESS() volatile
    {
        return AIRCR & (1u << 15u);
    }

    /**
     * Get AIRCR's PRIGROUP field.
     *
     * Interrupt priority grouping field
     */
    inline uint8_t get_AIRCR_PRIGROUP() volatile
    {
        return (AIRCR >> 8u) & 0b111u;
    }

    /**
     * Set AIRCR's PRIGROUP field.
     *
     * Interrupt priority grouping field
     */
    inline void set_AIRCR_PRIGROUP(uint8_t value) volatile
    {
        uint32_t curr = AIRCR;

        curr &= ~(0b111u << 8u);
        curr |= (value & 0b111u) << 8u;

        AIRCR = curr;
    }

    /**
     * Set AIRCR's SYSRESETREQ bit.
     *
     * System reset request
     */
    inline void set_AIRCR_SYSRESETREQ() volatile
    {
        AIRCR |= 1u << 2u;
    }

    /**
     * Clear AIRCR's SYSRESETREQ bit.
     *
     * System reset request
     */
    inline void clear_AIRCR_SYSRESETREQ() volatile
    {
        AIRCR &= ~(1u << 2u);
    }

    /**
     * Toggle AIRCR's SYSRESETREQ bit.
     *
     * System reset request
     */
    inline void toggle_AIRCR_SYSRESETREQ() volatile
    {
        AIRCR ^= 1u << 2u;
    }

    /**
     * Set AIRCR's VECTCLRACTIVE bit.
     *
     * Reserved for Debug use.
     */
    inline void set_AIRCR_VECTCLRACTIVE() volatile
    {
        AIRCR |= 1u << 1u;
    }

    /**
     * Clear AIRCR's VECTCLRACTIVE bit.
     *
     * Reserved for Debug use.
     */
    inline void clear_AIRCR_VECTCLRACTIVE() volatile
    {
        AIRCR &= ~(1u << 1u);
    }

    /**
     * Toggle AIRCR's VECTCLRACTIVE bit.
     *
     * Reserved for Debug use.
     */
    inline void toggle_AIRCR_VECTCLRACTIVE() volatile
    {
        AIRCR ^= 1u << 1u;
    }

    /**
     * Set AIRCR's VECTRESET bit.
     *
     * Reserved for Debug use.
     */
    inline void set_AIRCR_VECTRESET() volatile
    {
        AIRCR |= 1u << 0u;
    }

    /**
     * Clear AIRCR's VECTRESET bit.
     *
     * Reserved for Debug use.
     */
    inline void clear_AIRCR_VECTRESET() volatile
    {
        AIRCR &= ~(1u << 0u);
    }

    /**
     * Toggle AIRCR's VECTRESET bit.
     *
     * Reserved for Debug use.
     */
    inline void toggle_AIRCR_VECTRESET() volatile
    {
        AIRCR ^= 1u << 0u;
    }

    /**
     * Get all of AIRCR's bit fields.
     *
     * (read-write) Application Interrupt and Reset Control Register
     */
    inline void get_AIRCR(uint16_t &VECTKEY, bool &ENDIANNESS,
                          uint8_t &PRIGROUP) volatile
    {
        uint32_t curr = AIRCR;

        VECTKEY = (curr >> 16u) & 0b1111111111111111u;
        ENDIANNESS = curr & (1u << 15u);
        PRIGROUP = (curr >> 8u) & 0b111u;
    }

    /**
     * Set all of AIRCR's bit fields.
     *
     * (read-write) Application Interrupt and Reset Control Register
     */
    inline void set_AIRCR(uint16_t VECTKEY, uint8_t PRIGROUP, bool SYSRESETREQ,
                          bool VECTCLRACTIVE, bool VECTRESET) volatile
    {
        uint32_t curr = AIRCR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (VECTKEY & 0b1111111111111111u) << 16u;
        curr &= ~(0b111u << 8u);
        curr |= (PRIGROUP & 0b111u) << 8u;
        curr &= ~(0b1u << 2u);
        curr |= (SYSRESETREQ & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (VECTCLRACTIVE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (VECTRESET & 0b1u) << 0u;

        AIRCR = curr;
    }

    /**
     * Get SCR's SEVONPEND bit.
     *
     * Send Event on Pending bit:
     */
    inline bool get_SCR_SEVONPEND() volatile
    {
        return SCR & (1u << 4u);
    }

    /**
     * Set SCR's SEVONPEND bit.
     *
     * Send Event on Pending bit:
     */
    inline void set_SCR_SEVONPEND() volatile
    {
        SCR |= 1u << 4u;
    }

    /**
     * Clear SCR's SEVONPEND bit.
     *
     * Send Event on Pending bit:
     */
    inline void clear_SCR_SEVONPEND() volatile
    {
        SCR &= ~(1u << 4u);
    }

    /**
     * Toggle SCR's SEVONPEND bit.
     *
     * Send Event on Pending bit:
     */
    inline void toggle_SCR_SEVONPEND() volatile
    {
        SCR ^= 1u << 4u;
    }

    /**
     * Get SCR's SLEEPDEEP bit.
     *
     * Sleep or Deep Sleep
     */
    inline bool get_SCR_SLEEPDEEP() volatile
    {
        return SCR & (1u << 2u);
    }

    /**
     * Set SCR's SLEEPDEEP bit.
     *
     * Sleep or Deep Sleep
     */
    inline void set_SCR_SLEEPDEEP() volatile
    {
        SCR |= 1u << 2u;
    }

    /**
     * Clear SCR's SLEEPDEEP bit.
     *
     * Sleep or Deep Sleep
     */
    inline void clear_SCR_SLEEPDEEP() volatile
    {
        SCR &= ~(1u << 2u);
    }

    /**
     * Toggle SCR's SLEEPDEEP bit.
     *
     * Sleep or Deep Sleep
     */
    inline void toggle_SCR_SLEEPDEEP() volatile
    {
        SCR ^= 1u << 2u;
    }

    /**
     * Get SCR's SLEEPONEXIT bit.
     *
     * Sleep on Exit
     */
    inline bool get_SCR_SLEEPONEXIT() volatile
    {
        return SCR & (1u << 1u);
    }

    /**
     * Set SCR's SLEEPONEXIT bit.
     *
     * Sleep on Exit
     */
    inline void set_SCR_SLEEPONEXIT() volatile
    {
        SCR |= 1u << 1u;
    }

    /**
     * Clear SCR's SLEEPONEXIT bit.
     *
     * Sleep on Exit
     */
    inline void clear_SCR_SLEEPONEXIT() volatile
    {
        SCR &= ~(1u << 1u);
    }

    /**
     * Toggle SCR's SLEEPONEXIT bit.
     *
     * Sleep on Exit
     */
    inline void toggle_SCR_SLEEPONEXIT() volatile
    {
        SCR ^= 1u << 1u;
    }

    /**
     * Get all of SCR's bit fields.
     *
     * (read-write) System Control Register
     */
    inline void get_SCR(bool &SEVONPEND, bool &SLEEPDEEP,
                        bool &SLEEPONEXIT) volatile
    {
        uint32_t curr = SCR;

        SEVONPEND = curr & (1u << 4u);
        SLEEPDEEP = curr & (1u << 2u);
        SLEEPONEXIT = curr & (1u << 1u);
    }

    /**
     * Set all of SCR's bit fields.
     *
     * (read-write) System Control Register
     */
    inline void set_SCR(bool SEVONPEND, bool SLEEPDEEP,
                        bool SLEEPONEXIT) volatile
    {
        uint32_t curr = SCR;

        curr &= ~(0b1u << 4u);
        curr |= (SEVONPEND & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (SLEEPDEEP & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (SLEEPONEXIT & 0b1u) << 1u;

        SCR = curr;
    }

    /**
     * Get CCR's STKALIGN bit.
     *
     * Stack Alignment
     */
    inline bool get_CCR_STKALIGN() volatile
    {
        return CCR & (1u << 9u);
    }

    /**
     * Set CCR's STKALIGN bit.
     *
     * Stack Alignment
     */
    inline void set_CCR_STKALIGN() volatile
    {
        CCR |= 1u << 9u;
    }

    /**
     * Clear CCR's STKALIGN bit.
     *
     * Stack Alignment
     */
    inline void clear_CCR_STKALIGN() volatile
    {
        CCR &= ~(1u << 9u);
    }

    /**
     * Toggle CCR's STKALIGN bit.
     *
     * Stack Alignment
     */
    inline void toggle_CCR_STKALIGN() volatile
    {
        CCR ^= 1u << 9u;
    }

    /**
     * Get CCR's BFHFNMIGN bit.
     *
     * Bus Fault Hard Fault and NMI Ignore
     */
    inline bool get_CCR_BFHFNMIGN() volatile
    {
        return CCR & (1u << 8u);
    }

    /**
     * Set CCR's BFHFNMIGN bit.
     *
     * Bus Fault Hard Fault and NMI Ignore
     */
    inline void set_CCR_BFHFNMIGN() volatile
    {
        CCR |= 1u << 8u;
    }

    /**
     * Clear CCR's BFHFNMIGN bit.
     *
     * Bus Fault Hard Fault and NMI Ignore
     */
    inline void clear_CCR_BFHFNMIGN() volatile
    {
        CCR &= ~(1u << 8u);
    }

    /**
     * Toggle CCR's BFHFNMIGN bit.
     *
     * Bus Fault Hard Fault and NMI Ignore
     */
    inline void toggle_CCR_BFHFNMIGN() volatile
    {
        CCR ^= 1u << 8u;
    }

    /**
     * Get CCR's DIV_0_TRP bit.
     *
     * Divide by Zero Trap Enable
     */
    inline bool get_CCR_DIV_0_TRP() volatile
    {
        return CCR & (1u << 4u);
    }

    /**
     * Set CCR's DIV_0_TRP bit.
     *
     * Divide by Zero Trap Enable
     */
    inline void set_CCR_DIV_0_TRP() volatile
    {
        CCR |= 1u << 4u;
    }

    /**
     * Clear CCR's DIV_0_TRP bit.
     *
     * Divide by Zero Trap Enable
     */
    inline void clear_CCR_DIV_0_TRP() volatile
    {
        CCR &= ~(1u << 4u);
    }

    /**
     * Toggle CCR's DIV_0_TRP bit.
     *
     * Divide by Zero Trap Enable
     */
    inline void toggle_CCR_DIV_0_TRP() volatile
    {
        CCR ^= 1u << 4u;
    }

    /**
     * Get CCR's UNALIGN_TRP bit.
     *
     * Unaligned Access Trap Enable
     */
    inline bool get_CCR_UNALIGN_TRP() volatile
    {
        return CCR & (1u << 3u);
    }

    /**
     * Set CCR's UNALIGN_TRP bit.
     *
     * Unaligned Access Trap Enable
     */
    inline void set_CCR_UNALIGN_TRP() volatile
    {
        CCR |= 1u << 3u;
    }

    /**
     * Clear CCR's UNALIGN_TRP bit.
     *
     * Unaligned Access Trap Enable
     */
    inline void clear_CCR_UNALIGN_TRP() volatile
    {
        CCR &= ~(1u << 3u);
    }

    /**
     * Toggle CCR's UNALIGN_TRP bit.
     *
     * Unaligned Access Trap Enable
     */
    inline void toggle_CCR_UNALIGN_TRP() volatile
    {
        CCR ^= 1u << 3u;
    }

    /**
     * Get CCR's USERSETMPEND bit.
     *
     * User Set Pending Enable
     */
    inline bool get_CCR_USERSETMPEND() volatile
    {
        return CCR & (1u << 1u);
    }

    /**
     * Set CCR's USERSETMPEND bit.
     *
     * User Set Pending Enable
     */
    inline void set_CCR_USERSETMPEND() volatile
    {
        CCR |= 1u << 1u;
    }

    /**
     * Clear CCR's USERSETMPEND bit.
     *
     * User Set Pending Enable
     */
    inline void clear_CCR_USERSETMPEND() volatile
    {
        CCR &= ~(1u << 1u);
    }

    /**
     * Toggle CCR's USERSETMPEND bit.
     *
     * User Set Pending Enable
     */
    inline void toggle_CCR_USERSETMPEND() volatile
    {
        CCR ^= 1u << 1u;
    }

    /**
     * Get CCR's NONBASETHRDENA bit.
     *
     * Non Base Thread Mode Enable
     */
    inline bool get_CCR_NONBASETHRDENA() volatile
    {
        return CCR & (1u << 0u);
    }

    /**
     * Set CCR's NONBASETHRDENA bit.
     *
     * Non Base Thread Mode Enable
     */
    inline void set_CCR_NONBASETHRDENA() volatile
    {
        CCR |= 1u << 0u;
    }

    /**
     * Clear CCR's NONBASETHRDENA bit.
     *
     * Non Base Thread Mode Enable
     */
    inline void clear_CCR_NONBASETHRDENA() volatile
    {
        CCR &= ~(1u << 0u);
    }

    /**
     * Toggle CCR's NONBASETHRDENA bit.
     *
     * Non Base Thread Mode Enable
     */
    inline void toggle_CCR_NONBASETHRDENA() volatile
    {
        CCR ^= 1u << 0u;
    }

    /**
     * Get all of CCR's bit fields.
     *
     * (read-write) Configuration and Control Register
     */
    inline void get_CCR(bool &STKALIGN, bool &BFHFNMIGN, bool &DIV_0_TRP,
                        bool &UNALIGN_TRP, bool &USERSETMPEND,
                        bool &NONBASETHRDENA) volatile
    {
        uint32_t curr = CCR;

        STKALIGN = curr & (1u << 9u);
        BFHFNMIGN = curr & (1u << 8u);
        DIV_0_TRP = curr & (1u << 4u);
        UNALIGN_TRP = curr & (1u << 3u);
        USERSETMPEND = curr & (1u << 1u);
        NONBASETHRDENA = curr & (1u << 0u);
    }

    /**
     * Set all of CCR's bit fields.
     *
     * (read-write) Configuration and Control Register
     */
    inline void set_CCR(bool STKALIGN, bool BFHFNMIGN, bool DIV_0_TRP,
                        bool UNALIGN_TRP, bool USERSETMPEND,
                        bool NONBASETHRDENA) volatile
    {
        uint32_t curr = CCR;

        curr &= ~(0b1u << 9u);
        curr |= (STKALIGN & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (BFHFNMIGN & 0b1u) << 8u;
        curr &= ~(0b1u << 4u);
        curr |= (DIV_0_TRP & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (UNALIGN_TRP & 0b1u) << 3u;
        curr &= ~(0b1u << 1u);
        curr |= (USERSETMPEND & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (NONBASETHRDENA & 0b1u) << 0u;

        CCR = curr;
    }

    /**
     * Get SHPR1's PRI_6 field.
     *
     * Priority of system handler 6, UsageFault
     */
    inline uint8_t get_SHPR1_PRI_6() volatile
    {
        return (SHPR1 >> 16u) & 0b11111111u;
    }

    /**
     * Set SHPR1's PRI_6 field.
     *
     * Priority of system handler 6, UsageFault
     */
    inline void set_SHPR1_PRI_6(uint8_t value) volatile
    {
        uint32_t curr = SHPR1;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        SHPR1 = curr;
    }

    /**
     * Get SHPR1's PRI_5 field.
     *
     * Priority of system handler 5, BusFault
     */
    inline uint8_t get_SHPR1_PRI_5() volatile
    {
        return (SHPR1 >> 8u) & 0b11111111u;
    }

    /**
     * Set SHPR1's PRI_5 field.
     *
     * Priority of system handler 5, BusFault
     */
    inline void set_SHPR1_PRI_5(uint8_t value) volatile
    {
        uint32_t curr = SHPR1;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        SHPR1 = curr;
    }

    /**
     * Get SHPR1's PRI_4 field.
     *
     * Priority of system handler 4, MemManage
     */
    inline uint8_t get_SHPR1_PRI_4() volatile
    {
        return (SHPR1 >> 0u) & 0b11111111u;
    }

    /**
     * Set SHPR1's PRI_4 field.
     *
     * Priority of system handler 4, MemManage
     */
    inline void set_SHPR1_PRI_4(uint8_t value) volatile
    {
        uint32_t curr = SHPR1;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        SHPR1 = curr;
    }

    /**
     * Get all of SHPR1's bit fields.
     *
     * (read-write) System Handler Priority Register 1
     */
    inline void get_SHPR1(uint8_t &PRI_6, uint8_t &PRI_5,
                          uint8_t &PRI_4) volatile
    {
        uint32_t curr = SHPR1;

        PRI_6 = (curr >> 16u) & 0b11111111u;
        PRI_5 = (curr >> 8u) & 0b11111111u;
        PRI_4 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of SHPR1's bit fields.
     *
     * (read-write) System Handler Priority Register 1
     */
    inline void set_SHPR1(uint8_t PRI_6, uint8_t PRI_5, uint8_t PRI_4) volatile
    {
        uint32_t curr = SHPR1;

        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_6 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_5 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_4 & 0b11111111u) << 0u;

        SHPR1 = curr;
    }

    /**
     * Get SHPR2's PRI_11 field.
     *
     * Priority of system handler 11, SVCall
     */
    inline uint8_t get_SHPR2_PRI_11() volatile
    {
        return (SHPR2 >> 24u) & 0b11111111u;
    }

    /**
     * Set SHPR2's PRI_11 field.
     *
     * Priority of system handler 11, SVCall
     */
    inline void set_SHPR2_PRI_11(uint8_t value) volatile
    {
        uint32_t curr = SHPR2;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        SHPR2 = curr;
    }

    /**
     * Get SHPR3's PRI_15 field.
     *
     * Priority of system handler 15
     */
    inline uint8_t get_SHPR3_PRI_15() volatile
    {
        return (SHPR3 >> 24u) & 0b11111111u;
    }

    /**
     * Set SHPR3's PRI_15 field.
     *
     * Priority of system handler 15
     */
    inline void set_SHPR3_PRI_15(uint8_t value) volatile
    {
        uint32_t curr = SHPR3;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        SHPR3 = curr;
    }

    /**
     * Get SHPR3's PRI_14 field.
     *
     * Priority of system handler 14
     */
    inline uint8_t get_SHPR3_PRI_14() volatile
    {
        return (SHPR3 >> 16u) & 0b11111111u;
    }

    /**
     * Set SHPR3's PRI_14 field.
     *
     * Priority of system handler 14
     */
    inline void set_SHPR3_PRI_14(uint8_t value) volatile
    {
        uint32_t curr = SHPR3;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        SHPR3 = curr;
    }

    /**
     * Get all of SHPR3's bit fields.
     *
     * (read-write) System Handler Priority Register 3
     */
    inline void get_SHPR3(uint8_t &PRI_15, uint8_t &PRI_14) volatile
    {
        uint32_t curr = SHPR3;

        PRI_15 = (curr >> 24u) & 0b11111111u;
        PRI_14 = (curr >> 16u) & 0b11111111u;
    }

    /**
     * Set all of SHPR3's bit fields.
     *
     * (read-write) System Handler Priority Register 3
     */
    inline void set_SHPR3(uint8_t PRI_15, uint8_t PRI_14) volatile
    {
        uint32_t curr = SHPR3;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_15 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_14 & 0b11111111u) << 16u;

        SHPR3 = curr;
    }

    /**
     * Get SHCSR's USGFAULTENA bit.
     *
     * UsageFault enable bit
     */
    inline bool get_SHCSR_USGFAULTENA() volatile
    {
        return SHCSR & (1u << 18u);
    }

    /**
     * Set SHCSR's USGFAULTENA bit.
     *
     * UsageFault enable bit
     */
    inline void set_SHCSR_USGFAULTENA() volatile
    {
        SHCSR |= 1u << 18u;
    }

    /**
     * Clear SHCSR's USGFAULTENA bit.
     *
     * UsageFault enable bit
     */
    inline void clear_SHCSR_USGFAULTENA() volatile
    {
        SHCSR &= ~(1u << 18u);
    }

    /**
     * Toggle SHCSR's USGFAULTENA bit.
     *
     * UsageFault enable bit
     */
    inline void toggle_SHCSR_USGFAULTENA() volatile
    {
        SHCSR ^= 1u << 18u;
    }

    /**
     * Get SHCSR's BUSFAULTENA bit.
     *
     * BusFault enable bit
     */
    inline bool get_SHCSR_BUSFAULTENA() volatile
    {
        return SHCSR & (1u << 17u);
    }

    /**
     * Set SHCSR's BUSFAULTENA bit.
     *
     * BusFault enable bit
     */
    inline void set_SHCSR_BUSFAULTENA() volatile
    {
        SHCSR |= 1u << 17u;
    }

    /**
     * Clear SHCSR's BUSFAULTENA bit.
     *
     * BusFault enable bit
     */
    inline void clear_SHCSR_BUSFAULTENA() volatile
    {
        SHCSR &= ~(1u << 17u);
    }

    /**
     * Toggle SHCSR's BUSFAULTENA bit.
     *
     * BusFault enable bit
     */
    inline void toggle_SHCSR_BUSFAULTENA() volatile
    {
        SHCSR ^= 1u << 17u;
    }

    /**
     * Get SHCSR's MEMFAULTENA bit.
     *
     * MemManage enable bit
     */
    inline bool get_SHCSR_MEMFAULTENA() volatile
    {
        return SHCSR & (1u << 16u);
    }

    /**
     * Set SHCSR's MEMFAULTENA bit.
     *
     * MemManage enable bit
     */
    inline void set_SHCSR_MEMFAULTENA() volatile
    {
        SHCSR |= 1u << 16u;
    }

    /**
     * Clear SHCSR's MEMFAULTENA bit.
     *
     * MemManage enable bit
     */
    inline void clear_SHCSR_MEMFAULTENA() volatile
    {
        SHCSR &= ~(1u << 16u);
    }

    /**
     * Toggle SHCSR's MEMFAULTENA bit.
     *
     * MemManage enable bit
     */
    inline void toggle_SHCSR_MEMFAULTENA() volatile
    {
        SHCSR ^= 1u << 16u;
    }

    /**
     * Get SHCSR's SVCALLPENDED bit.
     *
     * SVCall pending bit
     */
    inline bool get_SHCSR_SVCALLPENDED() volatile
    {
        return SHCSR & (1u << 15u);
    }

    /**
     * Set SHCSR's SVCALLPENDED bit.
     *
     * SVCall pending bit
     */
    inline void set_SHCSR_SVCALLPENDED() volatile
    {
        SHCSR |= 1u << 15u;
    }

    /**
     * Clear SHCSR's SVCALLPENDED bit.
     *
     * SVCall pending bit
     */
    inline void clear_SHCSR_SVCALLPENDED() volatile
    {
        SHCSR &= ~(1u << 15u);
    }

    /**
     * Toggle SHCSR's SVCALLPENDED bit.
     *
     * SVCall pending bit
     */
    inline void toggle_SHCSR_SVCALLPENDED() volatile
    {
        SHCSR ^= 1u << 15u;
    }

    /**
     * Get SHCSR's BUSFAULTPENDED bit.
     *
     * BusFault exception pending bit
     */
    inline bool get_SHCSR_BUSFAULTPENDED() volatile
    {
        return SHCSR & (1u << 14u);
    }

    /**
     * Set SHCSR's BUSFAULTPENDED bit.
     *
     * BusFault exception pending bit
     */
    inline void set_SHCSR_BUSFAULTPENDED() volatile
    {
        SHCSR |= 1u << 14u;
    }

    /**
     * Clear SHCSR's BUSFAULTPENDED bit.
     *
     * BusFault exception pending bit
     */
    inline void clear_SHCSR_BUSFAULTPENDED() volatile
    {
        SHCSR &= ~(1u << 14u);
    }

    /**
     * Toggle SHCSR's BUSFAULTPENDED bit.
     *
     * BusFault exception pending bit
     */
    inline void toggle_SHCSR_BUSFAULTPENDED() volatile
    {
        SHCSR ^= 1u << 14u;
    }

    /**
     * Get SHCSR's MEMFAULTPENDED bit.
     *
     * MemManage exception pending bit
     */
    inline bool get_SHCSR_MEMFAULTPENDED() volatile
    {
        return SHCSR & (1u << 13u);
    }

    /**
     * Set SHCSR's MEMFAULTPENDED bit.
     *
     * MemManage exception pending bit
     */
    inline void set_SHCSR_MEMFAULTPENDED() volatile
    {
        SHCSR |= 1u << 13u;
    }

    /**
     * Clear SHCSR's MEMFAULTPENDED bit.
     *
     * MemManage exception pending bit
     */
    inline void clear_SHCSR_MEMFAULTPENDED() volatile
    {
        SHCSR &= ~(1u << 13u);
    }

    /**
     * Toggle SHCSR's MEMFAULTPENDED bit.
     *
     * MemManage exception pending bit
     */
    inline void toggle_SHCSR_MEMFAULTPENDED() volatile
    {
        SHCSR ^= 1u << 13u;
    }

    /**
     * Get SHCSR's USGFAULTPENDED bit.
     *
     * UsageFault exception pending bit
     */
    inline bool get_SHCSR_USGFAULTPENDED() volatile
    {
        return SHCSR & (1u << 12u);
    }

    /**
     * Set SHCSR's USGFAULTPENDED bit.
     *
     * UsageFault exception pending bit
     */
    inline void set_SHCSR_USGFAULTPENDED() volatile
    {
        SHCSR |= 1u << 12u;
    }

    /**
     * Clear SHCSR's USGFAULTPENDED bit.
     *
     * UsageFault exception pending bit
     */
    inline void clear_SHCSR_USGFAULTPENDED() volatile
    {
        SHCSR &= ~(1u << 12u);
    }

    /**
     * Toggle SHCSR's USGFAULTPENDED bit.
     *
     * UsageFault exception pending bit
     */
    inline void toggle_SHCSR_USGFAULTPENDED() volatile
    {
        SHCSR ^= 1u << 12u;
    }

    /**
     * Get SHCSR's SYSTICKACT bit.
     *
     * SysTick exception active bit
     */
    inline bool get_SHCSR_SYSTICKACT() volatile
    {
        return SHCSR & (1u << 11u);
    }

    /**
     * Set SHCSR's SYSTICKACT bit.
     *
     * SysTick exception active bit
     */
    inline void set_SHCSR_SYSTICKACT() volatile
    {
        SHCSR |= 1u << 11u;
    }

    /**
     * Clear SHCSR's SYSTICKACT bit.
     *
     * SysTick exception active bit
     */
    inline void clear_SHCSR_SYSTICKACT() volatile
    {
        SHCSR &= ~(1u << 11u);
    }

    /**
     * Toggle SHCSR's SYSTICKACT bit.
     *
     * SysTick exception active bit
     */
    inline void toggle_SHCSR_SYSTICKACT() volatile
    {
        SHCSR ^= 1u << 11u;
    }

    /**
     * Get SHCSR's PENDSVACT bit.
     *
     * PendSV exception active bit
     */
    inline bool get_SHCSR_PENDSVACT() volatile
    {
        return SHCSR & (1u << 10u);
    }

    /**
     * Set SHCSR's PENDSVACT bit.
     *
     * PendSV exception active bit
     */
    inline void set_SHCSR_PENDSVACT() volatile
    {
        SHCSR |= 1u << 10u;
    }

    /**
     * Clear SHCSR's PENDSVACT bit.
     *
     * PendSV exception active bit
     */
    inline void clear_SHCSR_PENDSVACT() volatile
    {
        SHCSR &= ~(1u << 10u);
    }

    /**
     * Toggle SHCSR's PENDSVACT bit.
     *
     * PendSV exception active bit
     */
    inline void toggle_SHCSR_PENDSVACT() volatile
    {
        SHCSR ^= 1u << 10u;
    }

    /**
     * Get SHCSR's MONITORACT bit.
     *
     * Debug monitor active bit
     */
    inline bool get_SHCSR_MONITORACT() volatile
    {
        return SHCSR & (1u << 8u);
    }

    /**
     * Set SHCSR's MONITORACT bit.
     *
     * Debug monitor active bit
     */
    inline void set_SHCSR_MONITORACT() volatile
    {
        SHCSR |= 1u << 8u;
    }

    /**
     * Clear SHCSR's MONITORACT bit.
     *
     * Debug monitor active bit
     */
    inline void clear_SHCSR_MONITORACT() volatile
    {
        SHCSR &= ~(1u << 8u);
    }

    /**
     * Toggle SHCSR's MONITORACT bit.
     *
     * Debug monitor active bit
     */
    inline void toggle_SHCSR_MONITORACT() volatile
    {
        SHCSR ^= 1u << 8u;
    }

    /**
     * Get SHCSR's SVCALLACT bit.
     *
     * SVCall active bit
     */
    inline bool get_SHCSR_SVCALLACT() volatile
    {
        return SHCSR & (1u << 7u);
    }

    /**
     * Set SHCSR's SVCALLACT bit.
     *
     * SVCall active bit
     */
    inline void set_SHCSR_SVCALLACT() volatile
    {
        SHCSR |= 1u << 7u;
    }

    /**
     * Clear SHCSR's SVCALLACT bit.
     *
     * SVCall active bit
     */
    inline void clear_SHCSR_SVCALLACT() volatile
    {
        SHCSR &= ~(1u << 7u);
    }

    /**
     * Toggle SHCSR's SVCALLACT bit.
     *
     * SVCall active bit
     */
    inline void toggle_SHCSR_SVCALLACT() volatile
    {
        SHCSR ^= 1u << 7u;
    }

    /**
     * Get SHCSR's USGFAULTACT bit.
     *
     * UsageFault exception active bit
     */
    inline bool get_SHCSR_USGFAULTACT() volatile
    {
        return SHCSR & (1u << 3u);
    }

    /**
     * Set SHCSR's USGFAULTACT bit.
     *
     * UsageFault exception active bit
     */
    inline void set_SHCSR_USGFAULTACT() volatile
    {
        SHCSR |= 1u << 3u;
    }

    /**
     * Clear SHCSR's USGFAULTACT bit.
     *
     * UsageFault exception active bit
     */
    inline void clear_SHCSR_USGFAULTACT() volatile
    {
        SHCSR &= ~(1u << 3u);
    }

    /**
     * Toggle SHCSR's USGFAULTACT bit.
     *
     * UsageFault exception active bit
     */
    inline void toggle_SHCSR_USGFAULTACT() volatile
    {
        SHCSR ^= 1u << 3u;
    }

    /**
     * Get SHCSR's BUSFAULTACT bit.
     *
     * BusFault exception active bit
     */
    inline bool get_SHCSR_BUSFAULTACT() volatile
    {
        return SHCSR & (1u << 1u);
    }

    /**
     * Set SHCSR's BUSFAULTACT bit.
     *
     * BusFault exception active bit
     */
    inline void set_SHCSR_BUSFAULTACT() volatile
    {
        SHCSR |= 1u << 1u;
    }

    /**
     * Clear SHCSR's BUSFAULTACT bit.
     *
     * BusFault exception active bit
     */
    inline void clear_SHCSR_BUSFAULTACT() volatile
    {
        SHCSR &= ~(1u << 1u);
    }

    /**
     * Toggle SHCSR's BUSFAULTACT bit.
     *
     * BusFault exception active bit
     */
    inline void toggle_SHCSR_BUSFAULTACT() volatile
    {
        SHCSR ^= 1u << 1u;
    }

    /**
     * Get SHCSR's MEMFAULTACT bit.
     *
     * MemManage exception active bit
     */
    inline bool get_SHCSR_MEMFAULTACT() volatile
    {
        return SHCSR & (1u << 0u);
    }

    /**
     * Set SHCSR's MEMFAULTACT bit.
     *
     * MemManage exception active bit
     */
    inline void set_SHCSR_MEMFAULTACT() volatile
    {
        SHCSR |= 1u << 0u;
    }

    /**
     * Clear SHCSR's MEMFAULTACT bit.
     *
     * MemManage exception active bit
     */
    inline void clear_SHCSR_MEMFAULTACT() volatile
    {
        SHCSR &= ~(1u << 0u);
    }

    /**
     * Toggle SHCSR's MEMFAULTACT bit.
     *
     * MemManage exception active bit
     */
    inline void toggle_SHCSR_MEMFAULTACT() volatile
    {
        SHCSR ^= 1u << 0u;
    }

    /**
     * Get all of SHCSR's bit fields.
     *
     * (read-write) System Handler Control and State Register
     */
    inline void get_SHCSR(bool &USGFAULTENA, bool &BUSFAULTENA,
                          bool &MEMFAULTENA, bool &SVCALLPENDED,
                          bool &BUSFAULTPENDED, bool &MEMFAULTPENDED,
                          bool &USGFAULTPENDED, bool &SYSTICKACT,
                          bool &PENDSVACT, bool &MONITORACT, bool &SVCALLACT,
                          bool &USGFAULTACT, bool &BUSFAULTACT,
                          bool &MEMFAULTACT) volatile
    {
        uint32_t curr = SHCSR;

        USGFAULTENA = curr & (1u << 18u);
        BUSFAULTENA = curr & (1u << 17u);
        MEMFAULTENA = curr & (1u << 16u);
        SVCALLPENDED = curr & (1u << 15u);
        BUSFAULTPENDED = curr & (1u << 14u);
        MEMFAULTPENDED = curr & (1u << 13u);
        USGFAULTPENDED = curr & (1u << 12u);
        SYSTICKACT = curr & (1u << 11u);
        PENDSVACT = curr & (1u << 10u);
        MONITORACT = curr & (1u << 8u);
        SVCALLACT = curr & (1u << 7u);
        USGFAULTACT = curr & (1u << 3u);
        BUSFAULTACT = curr & (1u << 1u);
        MEMFAULTACT = curr & (1u << 0u);
    }

    /**
     * Set all of SHCSR's bit fields.
     *
     * (read-write) System Handler Control and State Register
     */
    inline void set_SHCSR(bool USGFAULTENA, bool BUSFAULTENA, bool MEMFAULTENA,
                          bool SVCALLPENDED, bool BUSFAULTPENDED,
                          bool MEMFAULTPENDED, bool USGFAULTPENDED,
                          bool SYSTICKACT, bool PENDSVACT, bool MONITORACT,
                          bool SVCALLACT, bool USGFAULTACT, bool BUSFAULTACT,
                          bool MEMFAULTACT) volatile
    {
        uint32_t curr = SHCSR;

        curr &= ~(0b1u << 18u);
        curr |= (USGFAULTENA & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (BUSFAULTENA & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (MEMFAULTENA & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (SVCALLPENDED & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (BUSFAULTPENDED & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (MEMFAULTPENDED & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (USGFAULTPENDED & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (SYSTICKACT & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (PENDSVACT & 0b1u) << 10u;
        curr &= ~(0b1u << 8u);
        curr |= (MONITORACT & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (SVCALLACT & 0b1u) << 7u;
        curr &= ~(0b1u << 3u);
        curr |= (USGFAULTACT & 0b1u) << 3u;
        curr &= ~(0b1u << 1u);
        curr |= (BUSFAULTACT & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (MEMFAULTACT & 0b1u) << 0u;

        SHCSR = curr;
    }

    /**
     * Get CFSR's DIVBYZERO bit.
     *
     * Divide by zero UsageFault
     */
    inline bool get_CFSR_DIVBYZERO() volatile
    {
        return CFSR & (1u << 25u);
    }

    /**
     * Set CFSR's DIVBYZERO bit.
     *
     * Divide by zero UsageFault
     */
    inline void set_CFSR_DIVBYZERO() volatile
    {
        CFSR |= 1u << 25u;
    }

    /**
     * Clear CFSR's DIVBYZERO bit.
     *
     * Divide by zero UsageFault
     */
    inline void clear_CFSR_DIVBYZERO() volatile
    {
        CFSR &= ~(1u << 25u);
    }

    /**
     * Toggle CFSR's DIVBYZERO bit.
     *
     * Divide by zero UsageFault
     */
    inline void toggle_CFSR_DIVBYZERO() volatile
    {
        CFSR ^= 1u << 25u;
    }

    /**
     * Get CFSR's UNALIGNED bit.
     *
     * Unaligned access UsageFault
     */
    inline bool get_CFSR_UNALIGNED() volatile
    {
        return CFSR & (1u << 24u);
    }

    /**
     * Set CFSR's UNALIGNED bit.
     *
     * Unaligned access UsageFault
     */
    inline void set_CFSR_UNALIGNED() volatile
    {
        CFSR |= 1u << 24u;
    }

    /**
     * Clear CFSR's UNALIGNED bit.
     *
     * Unaligned access UsageFault
     */
    inline void clear_CFSR_UNALIGNED() volatile
    {
        CFSR &= ~(1u << 24u);
    }

    /**
     * Toggle CFSR's UNALIGNED bit.
     *
     * Unaligned access UsageFault
     */
    inline void toggle_CFSR_UNALIGNED() volatile
    {
        CFSR ^= 1u << 24u;
    }

    /**
     * Get CFSR's NOCP bit.
     *
     * No coprocessor UsageFault
     */
    inline bool get_CFSR_NOCP() volatile
    {
        return CFSR & (1u << 19u);
    }

    /**
     * Set CFSR's NOCP bit.
     *
     * No coprocessor UsageFault
     */
    inline void set_CFSR_NOCP() volatile
    {
        CFSR |= 1u << 19u;
    }

    /**
     * Clear CFSR's NOCP bit.
     *
     * No coprocessor UsageFault
     */
    inline void clear_CFSR_NOCP() volatile
    {
        CFSR &= ~(1u << 19u);
    }

    /**
     * Toggle CFSR's NOCP bit.
     *
     * No coprocessor UsageFault
     */
    inline void toggle_CFSR_NOCP() volatile
    {
        CFSR ^= 1u << 19u;
    }

    /**
     * Get CFSR's INVPC bit.
     *
     * Invalid PC load UsageFault
     */
    inline bool get_CFSR_INVPC() volatile
    {
        return CFSR & (1u << 18u);
    }

    /**
     * Set CFSR's INVPC bit.
     *
     * Invalid PC load UsageFault
     */
    inline void set_CFSR_INVPC() volatile
    {
        CFSR |= 1u << 18u;
    }

    /**
     * Clear CFSR's INVPC bit.
     *
     * Invalid PC load UsageFault
     */
    inline void clear_CFSR_INVPC() volatile
    {
        CFSR &= ~(1u << 18u);
    }

    /**
     * Toggle CFSR's INVPC bit.
     *
     * Invalid PC load UsageFault
     */
    inline void toggle_CFSR_INVPC() volatile
    {
        CFSR ^= 1u << 18u;
    }

    /**
     * Get CFSR's INVSTATE bit.
     *
     * Invalid state UsageFault
     */
    inline bool get_CFSR_INVSTATE() volatile
    {
        return CFSR & (1u << 17u);
    }

    /**
     * Set CFSR's INVSTATE bit.
     *
     * Invalid state UsageFault
     */
    inline void set_CFSR_INVSTATE() volatile
    {
        CFSR |= 1u << 17u;
    }

    /**
     * Clear CFSR's INVSTATE bit.
     *
     * Invalid state UsageFault
     */
    inline void clear_CFSR_INVSTATE() volatile
    {
        CFSR &= ~(1u << 17u);
    }

    /**
     * Toggle CFSR's INVSTATE bit.
     *
     * Invalid state UsageFault
     */
    inline void toggle_CFSR_INVSTATE() volatile
    {
        CFSR ^= 1u << 17u;
    }

    /**
     * Get CFSR's UNDEFINSTR bit.
     *
     * Undefined instruction UsageFault
     */
    inline bool get_CFSR_UNDEFINSTR() volatile
    {
        return CFSR & (1u << 16u);
    }

    /**
     * Set CFSR's UNDEFINSTR bit.
     *
     * Undefined instruction UsageFault
     */
    inline void set_CFSR_UNDEFINSTR() volatile
    {
        CFSR |= 1u << 16u;
    }

    /**
     * Clear CFSR's UNDEFINSTR bit.
     *
     * Undefined instruction UsageFault
     */
    inline void clear_CFSR_UNDEFINSTR() volatile
    {
        CFSR &= ~(1u << 16u);
    }

    /**
     * Toggle CFSR's UNDEFINSTR bit.
     *
     * Undefined instruction UsageFault
     */
    inline void toggle_CFSR_UNDEFINSTR() volatile
    {
        CFSR ^= 1u << 16u;
    }

    /**
     * Get CFSR's BFARVALID bit.
     *
     * BusFault Address Register (BFAR) valid flag
     */
    inline bool get_CFSR_BFARVALID() volatile
    {
        return CFSR & (1u << 15u);
    }

    /**
     * Set CFSR's BFARVALID bit.
     *
     * BusFault Address Register (BFAR) valid flag
     */
    inline void set_CFSR_BFARVALID() volatile
    {
        CFSR |= 1u << 15u;
    }

    /**
     * Clear CFSR's BFARVALID bit.
     *
     * BusFault Address Register (BFAR) valid flag
     */
    inline void clear_CFSR_BFARVALID() volatile
    {
        CFSR &= ~(1u << 15u);
    }

    /**
     * Toggle CFSR's BFARVALID bit.
     *
     * BusFault Address Register (BFAR) valid flag
     */
    inline void toggle_CFSR_BFARVALID() volatile
    {
        CFSR ^= 1u << 15u;
    }

    /**
     * Get CFSR's LSPERR bit.
     *
     * BusFault during floating point lazy state preservation
     */
    inline bool get_CFSR_LSPERR() volatile
    {
        return CFSR & (1u << 13u);
    }

    /**
     * Set CFSR's LSPERR bit.
     *
     * BusFault during floating point lazy state preservation
     */
    inline void set_CFSR_LSPERR() volatile
    {
        CFSR |= 1u << 13u;
    }

    /**
     * Clear CFSR's LSPERR bit.
     *
     * BusFault during floating point lazy state preservation
     */
    inline void clear_CFSR_LSPERR() volatile
    {
        CFSR &= ~(1u << 13u);
    }

    /**
     * Toggle CFSR's LSPERR bit.
     *
     * BusFault during floating point lazy state preservation
     */
    inline void toggle_CFSR_LSPERR() volatile
    {
        CFSR ^= 1u << 13u;
    }

    /**
     * Get CFSR's STKERR bit.
     *
     * BusFault on stacking for exception entry
     */
    inline bool get_CFSR_STKERR() volatile
    {
        return CFSR & (1u << 12u);
    }

    /**
     * Set CFSR's STKERR bit.
     *
     * BusFault on stacking for exception entry
     */
    inline void set_CFSR_STKERR() volatile
    {
        CFSR |= 1u << 12u;
    }

    /**
     * Clear CFSR's STKERR bit.
     *
     * BusFault on stacking for exception entry
     */
    inline void clear_CFSR_STKERR() volatile
    {
        CFSR &= ~(1u << 12u);
    }

    /**
     * Toggle CFSR's STKERR bit.
     *
     * BusFault on stacking for exception entry
     */
    inline void toggle_CFSR_STKERR() volatile
    {
        CFSR ^= 1u << 12u;
    }

    /**
     * Get CFSR's UNSTKERR bit.
     *
     * BusFault on unstacking for a return from exception
     */
    inline bool get_CFSR_UNSTKERR() volatile
    {
        return CFSR & (1u << 11u);
    }

    /**
     * Set CFSR's UNSTKERR bit.
     *
     * BusFault on unstacking for a return from exception
     */
    inline void set_CFSR_UNSTKERR() volatile
    {
        CFSR |= 1u << 11u;
    }

    /**
     * Clear CFSR's UNSTKERR bit.
     *
     * BusFault on unstacking for a return from exception
     */
    inline void clear_CFSR_UNSTKERR() volatile
    {
        CFSR &= ~(1u << 11u);
    }

    /**
     * Toggle CFSR's UNSTKERR bit.
     *
     * BusFault on unstacking for a return from exception
     */
    inline void toggle_CFSR_UNSTKERR() volatile
    {
        CFSR ^= 1u << 11u;
    }

    /**
     * Get CFSR's IMPRECISERR bit.
     *
     * Imprecise data bus error
     */
    inline bool get_CFSR_IMPRECISERR() volatile
    {
        return CFSR & (1u << 10u);
    }

    /**
     * Set CFSR's IMPRECISERR bit.
     *
     * Imprecise data bus error
     */
    inline void set_CFSR_IMPRECISERR() volatile
    {
        CFSR |= 1u << 10u;
    }

    /**
     * Clear CFSR's IMPRECISERR bit.
     *
     * Imprecise data bus error
     */
    inline void clear_CFSR_IMPRECISERR() volatile
    {
        CFSR &= ~(1u << 10u);
    }

    /**
     * Toggle CFSR's IMPRECISERR bit.
     *
     * Imprecise data bus error
     */
    inline void toggle_CFSR_IMPRECISERR() volatile
    {
        CFSR ^= 1u << 10u;
    }

    /**
     * Get CFSR's PRECISERR bit.
     *
     * Precise data bus error
     */
    inline bool get_CFSR_PRECISERR() volatile
    {
        return CFSR & (1u << 9u);
    }

    /**
     * Set CFSR's PRECISERR bit.
     *
     * Precise data bus error
     */
    inline void set_CFSR_PRECISERR() volatile
    {
        CFSR |= 1u << 9u;
    }

    /**
     * Clear CFSR's PRECISERR bit.
     *
     * Precise data bus error
     */
    inline void clear_CFSR_PRECISERR() volatile
    {
        CFSR &= ~(1u << 9u);
    }

    /**
     * Toggle CFSR's PRECISERR bit.
     *
     * Precise data bus error
     */
    inline void toggle_CFSR_PRECISERR() volatile
    {
        CFSR ^= 1u << 9u;
    }

    /**
     * Get CFSR's IBUSERR bit.
     *
     * Instruction bus error
     */
    inline bool get_CFSR_IBUSERR() volatile
    {
        return CFSR & (1u << 8u);
    }

    /**
     * Set CFSR's IBUSERR bit.
     *
     * Instruction bus error
     */
    inline void set_CFSR_IBUSERR() volatile
    {
        CFSR |= 1u << 8u;
    }

    /**
     * Clear CFSR's IBUSERR bit.
     *
     * Instruction bus error
     */
    inline void clear_CFSR_IBUSERR() volatile
    {
        CFSR &= ~(1u << 8u);
    }

    /**
     * Toggle CFSR's IBUSERR bit.
     *
     * Instruction bus error
     */
    inline void toggle_CFSR_IBUSERR() volatile
    {
        CFSR ^= 1u << 8u;
    }

    /**
     * Get CFSR's MMARVALID bit.
     *
     * MemManage Fault Address Register (MMFAR) valid flag
     */
    inline bool get_CFSR_MMARVALID() volatile
    {
        return CFSR & (1u << 7u);
    }

    /**
     * Set CFSR's MMARVALID bit.
     *
     * MemManage Fault Address Register (MMFAR) valid flag
     */
    inline void set_CFSR_MMARVALID() volatile
    {
        CFSR |= 1u << 7u;
    }

    /**
     * Clear CFSR's MMARVALID bit.
     *
     * MemManage Fault Address Register (MMFAR) valid flag
     */
    inline void clear_CFSR_MMARVALID() volatile
    {
        CFSR &= ~(1u << 7u);
    }

    /**
     * Toggle CFSR's MMARVALID bit.
     *
     * MemManage Fault Address Register (MMFAR) valid flag
     */
    inline void toggle_CFSR_MMARVALID() volatile
    {
        CFSR ^= 1u << 7u;
    }

    /**
     * Get CFSR's MLSPERR bit.
     *
     * MemManage fault during floating point lazy state preservation
     */
    inline bool get_CFSR_MLSPERR() volatile
    {
        return CFSR & (1u << 5u);
    }

    /**
     * Set CFSR's MLSPERR bit.
     *
     * MemManage fault during floating point lazy state preservation
     */
    inline void set_CFSR_MLSPERR() volatile
    {
        CFSR |= 1u << 5u;
    }

    /**
     * Clear CFSR's MLSPERR bit.
     *
     * MemManage fault during floating point lazy state preservation
     */
    inline void clear_CFSR_MLSPERR() volatile
    {
        CFSR &= ~(1u << 5u);
    }

    /**
     * Toggle CFSR's MLSPERR bit.
     *
     * MemManage fault during floating point lazy state preservation
     */
    inline void toggle_CFSR_MLSPERR() volatile
    {
        CFSR ^= 1u << 5u;
    }

    /**
     * Get CFSR's MSTKERR bit.
     *
     * MemManage fault on stacking for exception entry
     */
    inline bool get_CFSR_MSTKERR() volatile
    {
        return CFSR & (1u << 4u);
    }

    /**
     * Set CFSR's MSTKERR bit.
     *
     * MemManage fault on stacking for exception entry
     */
    inline void set_CFSR_MSTKERR() volatile
    {
        CFSR |= 1u << 4u;
    }

    /**
     * Clear CFSR's MSTKERR bit.
     *
     * MemManage fault on stacking for exception entry
     */
    inline void clear_CFSR_MSTKERR() volatile
    {
        CFSR &= ~(1u << 4u);
    }

    /**
     * Toggle CFSR's MSTKERR bit.
     *
     * MemManage fault on stacking for exception entry
     */
    inline void toggle_CFSR_MSTKERR() volatile
    {
        CFSR ^= 1u << 4u;
    }

    /**
     * Get CFSR's MUNSTKERR bit.
     *
     * MemManage fault on unstacking for a return from exception
     */
    inline bool get_CFSR_MUNSTKERR() volatile
    {
        return CFSR & (1u << 3u);
    }

    /**
     * Set CFSR's MUNSTKERR bit.
     *
     * MemManage fault on unstacking for a return from exception
     */
    inline void set_CFSR_MUNSTKERR() volatile
    {
        CFSR |= 1u << 3u;
    }

    /**
     * Clear CFSR's MUNSTKERR bit.
     *
     * MemManage fault on unstacking for a return from exception
     */
    inline void clear_CFSR_MUNSTKERR() volatile
    {
        CFSR &= ~(1u << 3u);
    }

    /**
     * Toggle CFSR's MUNSTKERR bit.
     *
     * MemManage fault on unstacking for a return from exception
     */
    inline void toggle_CFSR_MUNSTKERR() volatile
    {
        CFSR ^= 1u << 3u;
    }

    /**
     * Get CFSR's DACCVIOL bit.
     *
     * Data access violation flag
     */
    inline bool get_CFSR_DACCVIOL() volatile
    {
        return CFSR & (1u << 1u);
    }

    /**
     * Set CFSR's DACCVIOL bit.
     *
     * Data access violation flag
     */
    inline void set_CFSR_DACCVIOL() volatile
    {
        CFSR |= 1u << 1u;
    }

    /**
     * Clear CFSR's DACCVIOL bit.
     *
     * Data access violation flag
     */
    inline void clear_CFSR_DACCVIOL() volatile
    {
        CFSR &= ~(1u << 1u);
    }

    /**
     * Toggle CFSR's DACCVIOL bit.
     *
     * Data access violation flag
     */
    inline void toggle_CFSR_DACCVIOL() volatile
    {
        CFSR ^= 1u << 1u;
    }

    /**
     * Get CFSR's IACCVIOL bit.
     *
     * Instruction access violation flag
     */
    inline bool get_CFSR_IACCVIOL() volatile
    {
        return CFSR & (1u << 0u);
    }

    /**
     * Set CFSR's IACCVIOL bit.
     *
     * Instruction access violation flag
     */
    inline void set_CFSR_IACCVIOL() volatile
    {
        CFSR |= 1u << 0u;
    }

    /**
     * Clear CFSR's IACCVIOL bit.
     *
     * Instruction access violation flag
     */
    inline void clear_CFSR_IACCVIOL() volatile
    {
        CFSR &= ~(1u << 0u);
    }

    /**
     * Toggle CFSR's IACCVIOL bit.
     *
     * Instruction access violation flag
     */
    inline void toggle_CFSR_IACCVIOL() volatile
    {
        CFSR ^= 1u << 0u;
    }

    /**
     * Get all of CFSR's bit fields.
     *
     * (read-write) Configurable Fault Status Register
     */
    inline void get_CFSR(bool &DIVBYZERO, bool &UNALIGNED, bool &NOCP,
                         bool &INVPC, bool &INVSTATE, bool &UNDEFINSTR,
                         bool &BFARVALID, bool &LSPERR, bool &STKERR,
                         bool &UNSTKERR, bool &IMPRECISERR, bool &PRECISERR,
                         bool &IBUSERR, bool &MMARVALID, bool &MLSPERR,
                         bool &MSTKERR, bool &MUNSTKERR, bool &DACCVIOL,
                         bool &IACCVIOL) volatile
    {
        uint32_t curr = CFSR;

        DIVBYZERO = curr & (1u << 25u);
        UNALIGNED = curr & (1u << 24u);
        NOCP = curr & (1u << 19u);
        INVPC = curr & (1u << 18u);
        INVSTATE = curr & (1u << 17u);
        UNDEFINSTR = curr & (1u << 16u);
        BFARVALID = curr & (1u << 15u);
        LSPERR = curr & (1u << 13u);
        STKERR = curr & (1u << 12u);
        UNSTKERR = curr & (1u << 11u);
        IMPRECISERR = curr & (1u << 10u);
        PRECISERR = curr & (1u << 9u);
        IBUSERR = curr & (1u << 8u);
        MMARVALID = curr & (1u << 7u);
        MLSPERR = curr & (1u << 5u);
        MSTKERR = curr & (1u << 4u);
        MUNSTKERR = curr & (1u << 3u);
        DACCVIOL = curr & (1u << 1u);
        IACCVIOL = curr & (1u << 0u);
    }

    /**
     * Set all of CFSR's bit fields.
     *
     * (read-write) Configurable Fault Status Register
     */
    inline void set_CFSR(bool DIVBYZERO, bool UNALIGNED, bool NOCP, bool INVPC,
                         bool INVSTATE, bool UNDEFINSTR, bool BFARVALID,
                         bool LSPERR, bool STKERR, bool UNSTKERR,
                         bool IMPRECISERR, bool PRECISERR, bool IBUSERR,
                         bool MMARVALID, bool MLSPERR, bool MSTKERR,
                         bool MUNSTKERR, bool DACCVIOL, bool IACCVIOL) volatile
    {
        uint32_t curr = CFSR;

        curr &= ~(0b1u << 25u);
        curr |= (DIVBYZERO & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (UNALIGNED & 0b1u) << 24u;
        curr &= ~(0b1u << 19u);
        curr |= (NOCP & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (INVPC & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (INVSTATE & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (UNDEFINSTR & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (BFARVALID & 0b1u) << 15u;
        curr &= ~(0b1u << 13u);
        curr |= (LSPERR & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (STKERR & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (UNSTKERR & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (IMPRECISERR & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (PRECISERR & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (IBUSERR & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (MMARVALID & 0b1u) << 7u;
        curr &= ~(0b1u << 5u);
        curr |= (MLSPERR & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (MSTKERR & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (MUNSTKERR & 0b1u) << 3u;
        curr &= ~(0b1u << 1u);
        curr |= (DACCVIOL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IACCVIOL & 0b1u) << 0u;

        CFSR = curr;
    }

    /**
     * Get HFSR's DEBUGEVT bit.
     *
     * Reserved for Debug use
     */
    inline bool get_HFSR_DEBUGEVT() volatile
    {
        return HFSR & (1u << 31u);
    }

    /**
     * Set HFSR's DEBUGEVT bit.
     *
     * Reserved for Debug use
     */
    inline void set_HFSR_DEBUGEVT() volatile
    {
        HFSR |= 1u << 31u;
    }

    /**
     * Clear HFSR's DEBUGEVT bit.
     *
     * Reserved for Debug use
     */
    inline void clear_HFSR_DEBUGEVT() volatile
    {
        HFSR &= ~(1u << 31u);
    }

    /**
     * Toggle HFSR's DEBUGEVT bit.
     *
     * Reserved for Debug use
     */
    inline void toggle_HFSR_DEBUGEVT() volatile
    {
        HFSR ^= 1u << 31u;
    }

    /**
     * Get HFSR's FORCED bit.
     *
     * Forced HardFault
     */
    inline bool get_HFSR_FORCED() volatile
    {
        return HFSR & (1u << 30u);
    }

    /**
     * Set HFSR's FORCED bit.
     *
     * Forced HardFault
     */
    inline void set_HFSR_FORCED() volatile
    {
        HFSR |= 1u << 30u;
    }

    /**
     * Clear HFSR's FORCED bit.
     *
     * Forced HardFault
     */
    inline void clear_HFSR_FORCED() volatile
    {
        HFSR &= ~(1u << 30u);
    }

    /**
     * Toggle HFSR's FORCED bit.
     *
     * Forced HardFault
     */
    inline void toggle_HFSR_FORCED() volatile
    {
        HFSR ^= 1u << 30u;
    }

    /**
     * Get HFSR's VECTTBL bit.
     *
     * BusFault on vector table read
     */
    inline bool get_HFSR_VECTTBL() volatile
    {
        return HFSR & (1u << 1u);
    }

    /**
     * Set HFSR's VECTTBL bit.
     *
     * BusFault on vector table read
     */
    inline void set_HFSR_VECTTBL() volatile
    {
        HFSR |= 1u << 1u;
    }

    /**
     * Clear HFSR's VECTTBL bit.
     *
     * BusFault on vector table read
     */
    inline void clear_HFSR_VECTTBL() volatile
    {
        HFSR &= ~(1u << 1u);
    }

    /**
     * Toggle HFSR's VECTTBL bit.
     *
     * BusFault on vector table read
     */
    inline void toggle_HFSR_VECTTBL() volatile
    {
        HFSR ^= 1u << 1u;
    }

    /**
     * Get all of HFSR's bit fields.
     *
     * (read-write) HardFault Status Register
     */
    inline void get_HFSR(bool &DEBUGEVT, bool &FORCED, bool &VECTTBL) volatile
    {
        uint32_t curr = HFSR;

        DEBUGEVT = curr & (1u << 31u);
        FORCED = curr & (1u << 30u);
        VECTTBL = curr & (1u << 1u);
    }

    /**
     * Set all of HFSR's bit fields.
     *
     * (read-write) HardFault Status Register
     */
    inline void set_HFSR(bool DEBUGEVT, bool FORCED, bool VECTTBL) volatile
    {
        uint32_t curr = HFSR;

        curr &= ~(0b1u << 31u);
        curr |= (DEBUGEVT & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (FORCED & 0b1u) << 30u;
        curr &= ~(0b1u << 1u);
        curr |= (VECTTBL & 0b1u) << 1u;

        HFSR = curr;
    }

    /**
     * Get MMFAR's ADDRESS field.
     *
     * Address causing the fault
     */
    inline uint32_t get_MMFAR_ADDRESS() volatile
    {
        return (MMFAR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MMFAR's ADDRESS field.
     *
     * Address causing the fault
     */
    inline void set_MMFAR_ADDRESS(uint32_t value) volatile
    {
        uint32_t curr = MMFAR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MMFAR = curr;
    }

    /**
     * Get BFAR's ADDRESS field.
     *
     * Address causing the fault
     */
    inline uint32_t get_BFAR_ADDRESS() volatile
    {
        return (BFAR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set BFAR's ADDRESS field.
     *
     * Address causing the fault
     */
    inline void set_BFAR_ADDRESS(uint32_t value) volatile
    {
        uint32_t curr = BFAR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        BFAR = curr;
    }

    /**
     * Get AFSR's VALUE field.
     *
     * Reserved
     */
    inline uint32_t get_AFSR_VALUE() volatile
    {
        return (AFSR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set AFSR's VALUE field.
     *
     * Reserved
     */
    inline void set_AFSR_VALUE(uint32_t value) volatile
    {
        uint32_t curr = AFSR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        AFSR = curr;
    }

    /**
     * Get CPACR's CP11 field.
     *
     * Access privileges for coprocessor 11
     */
    inline PPB_CPACR_CP11 get_CPACR_CP11() volatile
    {
        return PPB_CPACR_CP11((CPACR >> 22u) & 0b11u);
    }

    /**
     * Set CPACR's CP11 field.
     *
     * Access privileges for coprocessor 11
     */
    inline void set_CPACR_CP11(PPB_CPACR_CP11 value) volatile
    {
        uint32_t curr = CPACR;

        curr &= ~(0b11u << 22u);
        curr |= (std::to_underlying(value) & 0b11u) << 22u;

        CPACR = curr;
    }

    /**
     * Get CPACR's CP10 field.
     *
     * Access privileges for coprocessor 10
     */
    inline PPB_CPACR_CP11 get_CPACR_CP10() volatile
    {
        return PPB_CPACR_CP11((CPACR >> 20u) & 0b11u);
    }

    /**
     * Set CPACR's CP10 field.
     *
     * Access privileges for coprocessor 10
     */
    inline void set_CPACR_CP10(PPB_CPACR_CP11 value) volatile
    {
        uint32_t curr = CPACR;

        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(value) & 0b11u) << 20u;

        CPACR = curr;
    }

    /**
     * Get all of CPACR's bit fields.
     *
     * (read-write) Coprocessor Access Control Register
     */
    inline void get_CPACR(PPB_CPACR_CP11 &CP11, PPB_CPACR_CP11 &CP10) volatile
    {
        uint32_t curr = CPACR;

        CP11 = PPB_CPACR_CP11((curr >> 22u) & 0b11u);
        CP10 = PPB_CPACR_CP11((curr >> 20u) & 0b11u);
    }

    /**
     * Set all of CPACR's bit fields.
     *
     * (read-write) Coprocessor Access Control Register
     */
    inline void set_CPACR(PPB_CPACR_CP11 CP11, PPB_CPACR_CP11 CP10) volatile
    {
        uint32_t curr = CPACR;

        curr &= ~(0b11u << 22u);
        curr |= (std::to_underlying(CP11) & 0b11u) << 22u;
        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(CP10) & 0b11u) << 20u;

        CPACR = curr;
    }

    /**
     * Get MPU_TYPE's IREGION field.
     *
     * Number of supported MPU instruction regions
     */
    inline uint8_t get_MPU_TYPE_IREGION() volatile
    {
        return (MPU_TYPE >> 16u) & 0b11111111u;
    }

    /**
     * Get MPU_TYPE's DREGION field.
     *
     * Number of supported MPU data regions
     */
    inline uint8_t get_MPU_TYPE_DREGION() volatile
    {
        return (MPU_TYPE >> 8u) & 0b11111111u;
    }

    /**
     * Get MPU_TYPE's SEPARATE bit.
     *
     * Support for unified or separate instruction and date memory maps
     */
    inline bool get_MPU_TYPE_SEPARATE() volatile
    {
        return MPU_TYPE & (1u << 0u);
    }

    /**
     * Get all of MPU_TYPE's bit fields.
     *
     * (read-only) MPU Type Register
     */
    inline void get_MPU_TYPE(uint8_t &IREGION, uint8_t &DREGION,
                             bool &SEPARATE) volatile
    {
        uint32_t curr = MPU_TYPE;

        IREGION = (curr >> 16u) & 0b11111111u;
        DREGION = (curr >> 8u) & 0b11111111u;
        SEPARATE = curr & (1u << 0u);
    }

    /**
     * Get MPU_CTRL's PRIVDEFENA bit.
     *
     * Enables privileged software access to the default memory map
     */
    inline bool get_MPU_CTRL_PRIVDEFENA() volatile
    {
        return MPU_CTRL & (1u << 2u);
    }

    /**
     * Set MPU_CTRL's PRIVDEFENA bit.
     *
     * Enables privileged software access to the default memory map
     */
    inline void set_MPU_CTRL_PRIVDEFENA() volatile
    {
        MPU_CTRL |= 1u << 2u;
    }

    /**
     * Clear MPU_CTRL's PRIVDEFENA bit.
     *
     * Enables privileged software access to the default memory map
     */
    inline void clear_MPU_CTRL_PRIVDEFENA() volatile
    {
        MPU_CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle MPU_CTRL's PRIVDEFENA bit.
     *
     * Enables privileged software access to the default memory map
     */
    inline void toggle_MPU_CTRL_PRIVDEFENA() volatile
    {
        MPU_CTRL ^= 1u << 2u;
    }

    /**
     * Get MPU_CTRL's HFNMIENA bit.
     *
     * Enable the operation of MPU during hard fault, NMI, and FAULTMASK
     * handlers
     */
    inline bool get_MPU_CTRL_HFNMIENA() volatile
    {
        return MPU_CTRL & (1u << 1u);
    }

    /**
     * Set MPU_CTRL's HFNMIENA bit.
     *
     * Enable the operation of MPU during hard fault, NMI, and FAULTMASK
     * handlers
     */
    inline void set_MPU_CTRL_HFNMIENA() volatile
    {
        MPU_CTRL |= 1u << 1u;
    }

    /**
     * Clear MPU_CTRL's HFNMIENA bit.
     *
     * Enable the operation of MPU during hard fault, NMI, and FAULTMASK
     * handlers
     */
    inline void clear_MPU_CTRL_HFNMIENA() volatile
    {
        MPU_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle MPU_CTRL's HFNMIENA bit.
     *
     * Enable the operation of MPU during hard fault, NMI, and FAULTMASK
     * handlers
     */
    inline void toggle_MPU_CTRL_HFNMIENA() volatile
    {
        MPU_CTRL ^= 1u << 1u;
    }

    /**
     * Get MPU_CTRL's ENABLE bit.
     *
     * Enable MPU
     */
    inline bool get_MPU_CTRL_ENABLE() volatile
    {
        return MPU_CTRL & (1u << 0u);
    }

    /**
     * Set MPU_CTRL's ENABLE bit.
     *
     * Enable MPU
     */
    inline void set_MPU_CTRL_ENABLE() volatile
    {
        MPU_CTRL |= 1u << 0u;
    }

    /**
     * Clear MPU_CTRL's ENABLE bit.
     *
     * Enable MPU
     */
    inline void clear_MPU_CTRL_ENABLE() volatile
    {
        MPU_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle MPU_CTRL's ENABLE bit.
     *
     * Enable MPU
     */
    inline void toggle_MPU_CTRL_ENABLE() volatile
    {
        MPU_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of MPU_CTRL's bit fields.
     *
     * (read-write) MPU Control Register
     */
    inline void get_MPU_CTRL(bool &PRIVDEFENA, bool &HFNMIENA,
                             bool &ENABLE) volatile
    {
        uint32_t curr = MPU_CTRL;

        PRIVDEFENA = curr & (1u << 2u);
        HFNMIENA = curr & (1u << 1u);
        ENABLE = curr & (1u << 0u);
    }

    /**
     * Set all of MPU_CTRL's bit fields.
     *
     * (read-write) MPU Control Register
     */
    inline void set_MPU_CTRL(bool PRIVDEFENA, bool HFNMIENA,
                             bool ENABLE) volatile
    {
        uint32_t curr = MPU_CTRL;

        curr &= ~(0b1u << 2u);
        curr |= (PRIVDEFENA & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (HFNMIENA & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ENABLE & 0b1u) << 0u;

        MPU_CTRL = curr;
    }

    /**
     * Get MPU_RNR's REGION field.
     *
     * Region
     */
    inline uint8_t get_MPU_RNR_REGION() volatile
    {
        return (MPU_RNR >> 0u) & 0b11111111u;
    }

    /**
     * Set MPU_RNR's REGION field.
     *
     * Region
     */
    inline void set_MPU_RNR_REGION(uint8_t value) volatile
    {
        uint32_t curr = MPU_RNR;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        MPU_RNR = curr;
    }

    /**
     * Get MPU_RBAR's ADDR field.
     *
     * Region base address field
     */
    inline uint32_t get_MPU_RBAR_ADDR() volatile
    {
        return (MPU_RBAR >> 9u) & 0b11111111111111111111111u;
    }

    /**
     * Set MPU_RBAR's ADDR field.
     *
     * Region base address field
     */
    inline void set_MPU_RBAR_ADDR(uint32_t value) volatile
    {
        uint32_t curr = MPU_RBAR;

        curr &= ~(0b11111111111111111111111u << 9u);
        curr |= (value & 0b11111111111111111111111u) << 9u;

        MPU_RBAR = curr;
    }

    /**
     * Get MPU_RBAR's VALID bit.
     *
     * MPU Region Number valid bit
     */
    inline bool get_MPU_RBAR_VALID() volatile
    {
        return MPU_RBAR & (1u << 4u);
    }

    /**
     * Set MPU_RBAR's VALID bit.
     *
     * MPU Region Number valid bit
     */
    inline void set_MPU_RBAR_VALID() volatile
    {
        MPU_RBAR |= 1u << 4u;
    }

    /**
     * Clear MPU_RBAR's VALID bit.
     *
     * MPU Region Number valid bit
     */
    inline void clear_MPU_RBAR_VALID() volatile
    {
        MPU_RBAR &= ~(1u << 4u);
    }

    /**
     * Toggle MPU_RBAR's VALID bit.
     *
     * MPU Region Number valid bit
     */
    inline void toggle_MPU_RBAR_VALID() volatile
    {
        MPU_RBAR ^= 1u << 4u;
    }

    /**
     * Get MPU_RBAR's REGION field.
     *
     * MPU region field
     */
    inline uint8_t get_MPU_RBAR_REGION() volatile
    {
        return (MPU_RBAR >> 0u) & 0b1111u;
    }

    /**
     * Set MPU_RBAR's REGION field.
     *
     * MPU region field
     */
    inline void set_MPU_RBAR_REGION(uint8_t value) volatile
    {
        uint32_t curr = MPU_RBAR;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        MPU_RBAR = curr;
    }

    /**
     * Get all of MPU_RBAR's bit fields.
     *
     * (read-write) MPU Region Base Address Register
     */
    inline void get_MPU_RBAR(uint32_t &ADDR, bool &VALID,
                             uint8_t &REGION) volatile
    {
        uint32_t curr = MPU_RBAR;

        ADDR = (curr >> 9u) & 0b11111111111111111111111u;
        VALID = curr & (1u << 4u);
        REGION = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of MPU_RBAR's bit fields.
     *
     * (read-write) MPU Region Base Address Register
     */
    inline void set_MPU_RBAR(uint32_t ADDR, bool VALID,
                             uint8_t REGION) volatile
    {
        uint32_t curr = MPU_RBAR;

        curr &= ~(0b11111111111111111111111u << 9u);
        curr |= (ADDR & 0b11111111111111111111111u) << 9u;
        curr &= ~(0b1u << 4u);
        curr |= (VALID & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (REGION & 0b1111u) << 0u;

        MPU_RBAR = curr;
    }

    /**
     * Get MPU_RASR's XN bit.
     *
     * Instruction access disable bit
     */
    inline bool get_MPU_RASR_XN() volatile
    {
        return MPU_RASR & (1u << 28u);
    }

    /**
     * Set MPU_RASR's XN bit.
     *
     * Instruction access disable bit
     */
    inline void set_MPU_RASR_XN() volatile
    {
        MPU_RASR |= 1u << 28u;
    }

    /**
     * Clear MPU_RASR's XN bit.
     *
     * Instruction access disable bit
     */
    inline void clear_MPU_RASR_XN() volatile
    {
        MPU_RASR &= ~(1u << 28u);
    }

    /**
     * Toggle MPU_RASR's XN bit.
     *
     * Instruction access disable bit
     */
    inline void toggle_MPU_RASR_XN() volatile
    {
        MPU_RASR ^= 1u << 28u;
    }

    /**
     * Get MPU_RASR's AP field.
     *
     * Access permission field
     */
    inline uint8_t get_MPU_RASR_AP() volatile
    {
        return (MPU_RASR >> 24u) & 0b111u;
    }

    /**
     * Set MPU_RASR's AP field.
     *
     * Access permission field
     */
    inline void set_MPU_RASR_AP(uint8_t value) volatile
    {
        uint32_t curr = MPU_RASR;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        MPU_RASR = curr;
    }

    /**
     * Get MPU_RASR's TEX field.
     *
     * Memory access attribute
     */
    inline uint8_t get_MPU_RASR_TEX() volatile
    {
        return (MPU_RASR >> 19u) & 0b111u;
    }

    /**
     * Set MPU_RASR's TEX field.
     *
     * Memory access attribute
     */
    inline void set_MPU_RASR_TEX(uint8_t value) volatile
    {
        uint32_t curr = MPU_RASR;

        curr &= ~(0b111u << 19u);
        curr |= (value & 0b111u) << 19u;

        MPU_RASR = curr;
    }

    /**
     * Get MPU_RASR's S bit.
     *
     * Shareable bit
     */
    inline bool get_MPU_RASR_S() volatile
    {
        return MPU_RASR & (1u << 18u);
    }

    /**
     * Set MPU_RASR's S bit.
     *
     * Shareable bit
     */
    inline void set_MPU_RASR_S() volatile
    {
        MPU_RASR |= 1u << 18u;
    }

    /**
     * Clear MPU_RASR's S bit.
     *
     * Shareable bit
     */
    inline void clear_MPU_RASR_S() volatile
    {
        MPU_RASR &= ~(1u << 18u);
    }

    /**
     * Toggle MPU_RASR's S bit.
     *
     * Shareable bit
     */
    inline void toggle_MPU_RASR_S() volatile
    {
        MPU_RASR ^= 1u << 18u;
    }

    /**
     * Get MPU_RASR's C bit.
     *
     * Memory access attribute
     */
    inline bool get_MPU_RASR_C() volatile
    {
        return MPU_RASR & (1u << 17u);
    }

    /**
     * Set MPU_RASR's C bit.
     *
     * Memory access attribute
     */
    inline void set_MPU_RASR_C() volatile
    {
        MPU_RASR |= 1u << 17u;
    }

    /**
     * Clear MPU_RASR's C bit.
     *
     * Memory access attribute
     */
    inline void clear_MPU_RASR_C() volatile
    {
        MPU_RASR &= ~(1u << 17u);
    }

    /**
     * Toggle MPU_RASR's C bit.
     *
     * Memory access attribute
     */
    inline void toggle_MPU_RASR_C() volatile
    {
        MPU_RASR ^= 1u << 17u;
    }

    /**
     * Get MPU_RASR's B bit.
     *
     * Memory access attribute
     */
    inline bool get_MPU_RASR_B() volatile
    {
        return MPU_RASR & (1u << 16u);
    }

    /**
     * Set MPU_RASR's B bit.
     *
     * Memory access attribute
     */
    inline void set_MPU_RASR_B() volatile
    {
        MPU_RASR |= 1u << 16u;
    }

    /**
     * Clear MPU_RASR's B bit.
     *
     * Memory access attribute
     */
    inline void clear_MPU_RASR_B() volatile
    {
        MPU_RASR &= ~(1u << 16u);
    }

    /**
     * Toggle MPU_RASR's B bit.
     *
     * Memory access attribute
     */
    inline void toggle_MPU_RASR_B() volatile
    {
        MPU_RASR ^= 1u << 16u;
    }

    /**
     * Get MPU_RASR's SRD field.
     *
     * Subregion disable bits
     */
    inline PPB_MPU_RASR_SRD get_MPU_RASR_SRD() volatile
    {
        return PPB_MPU_RASR_SRD((MPU_RASR >> 8u) & 0b11111111u);
    }

    /**
     * Set MPU_RASR's SRD field.
     *
     * Subregion disable bits
     */
    inline void set_MPU_RASR_SRD(PPB_MPU_RASR_SRD value) volatile
    {
        uint32_t curr = MPU_RASR;

        curr &= ~(0b11111111u << 8u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 8u;

        MPU_RASR = curr;
    }

    /**
     * Get MPU_RASR's SIZE field.
     *
     * MPU protection region size
     */
    inline uint8_t get_MPU_RASR_SIZE() volatile
    {
        return (MPU_RASR >> 1u) & 0b11111u;
    }

    /**
     * Set MPU_RASR's SIZE field.
     *
     * MPU protection region size
     */
    inline void set_MPU_RASR_SIZE(uint8_t value) volatile
    {
        uint32_t curr = MPU_RASR;

        curr &= ~(0b11111u << 1u);
        curr |= (value & 0b11111u) << 1u;

        MPU_RASR = curr;
    }

    /**
     * Get MPU_RASR's ENABLE bit.
     *
     * Region enable bit.
     */
    inline bool get_MPU_RASR_ENABLE() volatile
    {
        return MPU_RASR & (1u << 0u);
    }

    /**
     * Set MPU_RASR's ENABLE bit.
     *
     * Region enable bit.
     */
    inline void set_MPU_RASR_ENABLE() volatile
    {
        MPU_RASR |= 1u << 0u;
    }

    /**
     * Clear MPU_RASR's ENABLE bit.
     *
     * Region enable bit.
     */
    inline void clear_MPU_RASR_ENABLE() volatile
    {
        MPU_RASR &= ~(1u << 0u);
    }

    /**
     * Toggle MPU_RASR's ENABLE bit.
     *
     * Region enable bit.
     */
    inline void toggle_MPU_RASR_ENABLE() volatile
    {
        MPU_RASR ^= 1u << 0u;
    }

    /**
     * Get all of MPU_RASR's bit fields.
     *
     * (read-write) MPU Region Attribute and Size Register
     */
    inline void get_MPU_RASR(bool &XN, uint8_t &AP, uint8_t &TEX, bool &S,
                             bool &C, bool &B, PPB_MPU_RASR_SRD &SRD,
                             uint8_t &SIZE, bool &ENABLE) volatile
    {
        uint32_t curr = MPU_RASR;

        XN = curr & (1u << 28u);
        AP = (curr >> 24u) & 0b111u;
        TEX = (curr >> 19u) & 0b111u;
        S = curr & (1u << 18u);
        C = curr & (1u << 17u);
        B = curr & (1u << 16u);
        SRD = PPB_MPU_RASR_SRD((curr >> 8u) & 0b11111111u);
        SIZE = (curr >> 1u) & 0b11111u;
        ENABLE = curr & (1u << 0u);
    }

    /**
     * Set all of MPU_RASR's bit fields.
     *
     * (read-write) MPU Region Attribute and Size Register
     */
    inline void set_MPU_RASR(bool XN, uint8_t AP, uint8_t TEX, bool S, bool C,
                             bool B, PPB_MPU_RASR_SRD SRD, uint8_t SIZE,
                             bool ENABLE) volatile
    {
        uint32_t curr = MPU_RASR;

        curr &= ~(0b1u << 28u);
        curr |= (XN & 0b1u) << 28u;
        curr &= ~(0b111u << 24u);
        curr |= (AP & 0b111u) << 24u;
        curr &= ~(0b111u << 19u);
        curr |= (TEX & 0b111u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (S & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (C & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (B & 0b1u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (std::to_underlying(SRD) & 0b11111111u) << 8u;
        curr &= ~(0b11111u << 1u);
        curr |= (SIZE & 0b11111u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ENABLE & 0b1u) << 0u;

        MPU_RASR = curr;
    }

    /**
     * Get MPU_RBAR_A1's ADDR field.
     *
     * Region base address field
     */
    inline uint32_t get_MPU_RBAR_A1_ADDR() volatile
    {
        return (MPU_RBAR_A1 >> 9u) & 0b11111111111111111111111u;
    }

    /**
     * Set MPU_RBAR_A1's ADDR field.
     *
     * Region base address field
     */
    inline void set_MPU_RBAR_A1_ADDR(uint32_t value) volatile
    {
        uint32_t curr = MPU_RBAR_A1;

        curr &= ~(0b11111111111111111111111u << 9u);
        curr |= (value & 0b11111111111111111111111u) << 9u;

        MPU_RBAR_A1 = curr;
    }

    /**
     * Get MPU_RBAR_A1's VALID bit.
     *
     * MPU Region Number valid bit
     */
    inline bool get_MPU_RBAR_A1_VALID() volatile
    {
        return MPU_RBAR_A1 & (1u << 4u);
    }

    /**
     * Set MPU_RBAR_A1's VALID bit.
     *
     * MPU Region Number valid bit
     */
    inline void set_MPU_RBAR_A1_VALID() volatile
    {
        MPU_RBAR_A1 |= 1u << 4u;
    }

    /**
     * Clear MPU_RBAR_A1's VALID bit.
     *
     * MPU Region Number valid bit
     */
    inline void clear_MPU_RBAR_A1_VALID() volatile
    {
        MPU_RBAR_A1 &= ~(1u << 4u);
    }

    /**
     * Toggle MPU_RBAR_A1's VALID bit.
     *
     * MPU Region Number valid bit
     */
    inline void toggle_MPU_RBAR_A1_VALID() volatile
    {
        MPU_RBAR_A1 ^= 1u << 4u;
    }

    /**
     * Get MPU_RBAR_A1's REGION field.
     *
     * MPU region field
     */
    inline uint8_t get_MPU_RBAR_A1_REGION() volatile
    {
        return (MPU_RBAR_A1 >> 0u) & 0b1111u;
    }

    /**
     * Set MPU_RBAR_A1's REGION field.
     *
     * MPU region field
     */
    inline void set_MPU_RBAR_A1_REGION(uint8_t value) volatile
    {
        uint32_t curr = MPU_RBAR_A1;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        MPU_RBAR_A1 = curr;
    }

    /**
     * Get all of MPU_RBAR_A1's bit fields.
     *
     * (read-write) MPU Region Base Address Register A1
     */
    inline void get_MPU_RBAR_A1(uint32_t &ADDR, bool &VALID,
                                uint8_t &REGION) volatile
    {
        uint32_t curr = MPU_RBAR_A1;

        ADDR = (curr >> 9u) & 0b11111111111111111111111u;
        VALID = curr & (1u << 4u);
        REGION = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of MPU_RBAR_A1's bit fields.
     *
     * (read-write) MPU Region Base Address Register A1
     */
    inline void set_MPU_RBAR_A1(uint32_t ADDR, bool VALID,
                                uint8_t REGION) volatile
    {
        uint32_t curr = MPU_RBAR_A1;

        curr &= ~(0b11111111111111111111111u << 9u);
        curr |= (ADDR & 0b11111111111111111111111u) << 9u;
        curr &= ~(0b1u << 4u);
        curr |= (VALID & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (REGION & 0b1111u) << 0u;

        MPU_RBAR_A1 = curr;
    }

    /**
     * Get MPU_RASR_A1's XN bit.
     *
     * Instruction access disable bit
     */
    inline bool get_MPU_RASR_A1_XN() volatile
    {
        return MPU_RASR_A1 & (1u << 28u);
    }

    /**
     * Set MPU_RASR_A1's XN bit.
     *
     * Instruction access disable bit
     */
    inline void set_MPU_RASR_A1_XN() volatile
    {
        MPU_RASR_A1 |= 1u << 28u;
    }

    /**
     * Clear MPU_RASR_A1's XN bit.
     *
     * Instruction access disable bit
     */
    inline void clear_MPU_RASR_A1_XN() volatile
    {
        MPU_RASR_A1 &= ~(1u << 28u);
    }

    /**
     * Toggle MPU_RASR_A1's XN bit.
     *
     * Instruction access disable bit
     */
    inline void toggle_MPU_RASR_A1_XN() volatile
    {
        MPU_RASR_A1 ^= 1u << 28u;
    }

    /**
     * Get MPU_RASR_A1's AP field.
     *
     * Access permission field
     */
    inline uint8_t get_MPU_RASR_A1_AP() volatile
    {
        return (MPU_RASR_A1 >> 24u) & 0b111u;
    }

    /**
     * Set MPU_RASR_A1's AP field.
     *
     * Access permission field
     */
    inline void set_MPU_RASR_A1_AP(uint8_t value) volatile
    {
        uint32_t curr = MPU_RASR_A1;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        MPU_RASR_A1 = curr;
    }

    /**
     * Get MPU_RASR_A1's TEX field.
     *
     * Memory access attribute
     */
    inline uint8_t get_MPU_RASR_A1_TEX() volatile
    {
        return (MPU_RASR_A1 >> 19u) & 0b111u;
    }

    /**
     * Set MPU_RASR_A1's TEX field.
     *
     * Memory access attribute
     */
    inline void set_MPU_RASR_A1_TEX(uint8_t value) volatile
    {
        uint32_t curr = MPU_RASR_A1;

        curr &= ~(0b111u << 19u);
        curr |= (value & 0b111u) << 19u;

        MPU_RASR_A1 = curr;
    }

    /**
     * Get MPU_RASR_A1's S bit.
     *
     * Shareable bit
     */
    inline bool get_MPU_RASR_A1_S() volatile
    {
        return MPU_RASR_A1 & (1u << 18u);
    }

    /**
     * Set MPU_RASR_A1's S bit.
     *
     * Shareable bit
     */
    inline void set_MPU_RASR_A1_S() volatile
    {
        MPU_RASR_A1 |= 1u << 18u;
    }

    /**
     * Clear MPU_RASR_A1's S bit.
     *
     * Shareable bit
     */
    inline void clear_MPU_RASR_A1_S() volatile
    {
        MPU_RASR_A1 &= ~(1u << 18u);
    }

    /**
     * Toggle MPU_RASR_A1's S bit.
     *
     * Shareable bit
     */
    inline void toggle_MPU_RASR_A1_S() volatile
    {
        MPU_RASR_A1 ^= 1u << 18u;
    }

    /**
     * Get MPU_RASR_A1's C bit.
     *
     * Memory access attribute
     */
    inline bool get_MPU_RASR_A1_C() volatile
    {
        return MPU_RASR_A1 & (1u << 17u);
    }

    /**
     * Set MPU_RASR_A1's C bit.
     *
     * Memory access attribute
     */
    inline void set_MPU_RASR_A1_C() volatile
    {
        MPU_RASR_A1 |= 1u << 17u;
    }

    /**
     * Clear MPU_RASR_A1's C bit.
     *
     * Memory access attribute
     */
    inline void clear_MPU_RASR_A1_C() volatile
    {
        MPU_RASR_A1 &= ~(1u << 17u);
    }

    /**
     * Toggle MPU_RASR_A1's C bit.
     *
     * Memory access attribute
     */
    inline void toggle_MPU_RASR_A1_C() volatile
    {
        MPU_RASR_A1 ^= 1u << 17u;
    }

    /**
     * Get MPU_RASR_A1's B bit.
     *
     * Memory access attribute
     */
    inline bool get_MPU_RASR_A1_B() volatile
    {
        return MPU_RASR_A1 & (1u << 16u);
    }

    /**
     * Set MPU_RASR_A1's B bit.
     *
     * Memory access attribute
     */
    inline void set_MPU_RASR_A1_B() volatile
    {
        MPU_RASR_A1 |= 1u << 16u;
    }

    /**
     * Clear MPU_RASR_A1's B bit.
     *
     * Memory access attribute
     */
    inline void clear_MPU_RASR_A1_B() volatile
    {
        MPU_RASR_A1 &= ~(1u << 16u);
    }

    /**
     * Toggle MPU_RASR_A1's B bit.
     *
     * Memory access attribute
     */
    inline void toggle_MPU_RASR_A1_B() volatile
    {
        MPU_RASR_A1 ^= 1u << 16u;
    }

    /**
     * Get MPU_RASR_A1's SRD field.
     *
     * Subregion disable bits
     */
    inline PPB_MPU_RASR_SRD get_MPU_RASR_A1_SRD() volatile
    {
        return PPB_MPU_RASR_SRD((MPU_RASR_A1 >> 8u) & 0b11111111u);
    }

    /**
     * Set MPU_RASR_A1's SRD field.
     *
     * Subregion disable bits
     */
    inline void set_MPU_RASR_A1_SRD(PPB_MPU_RASR_SRD value) volatile
    {
        uint32_t curr = MPU_RASR_A1;

        curr &= ~(0b11111111u << 8u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 8u;

        MPU_RASR_A1 = curr;
    }

    /**
     * Get MPU_RASR_A1's SIZE field.
     *
     * MPU protection region size
     */
    inline uint8_t get_MPU_RASR_A1_SIZE() volatile
    {
        return (MPU_RASR_A1 >> 1u) & 0b11111u;
    }

    /**
     * Set MPU_RASR_A1's SIZE field.
     *
     * MPU protection region size
     */
    inline void set_MPU_RASR_A1_SIZE(uint8_t value) volatile
    {
        uint32_t curr = MPU_RASR_A1;

        curr &= ~(0b11111u << 1u);
        curr |= (value & 0b11111u) << 1u;

        MPU_RASR_A1 = curr;
    }

    /**
     * Get MPU_RASR_A1's ENABLE bit.
     *
     * Region enable bit.
     */
    inline bool get_MPU_RASR_A1_ENABLE() volatile
    {
        return MPU_RASR_A1 & (1u << 0u);
    }

    /**
     * Set MPU_RASR_A1's ENABLE bit.
     *
     * Region enable bit.
     */
    inline void set_MPU_RASR_A1_ENABLE() volatile
    {
        MPU_RASR_A1 |= 1u << 0u;
    }

    /**
     * Clear MPU_RASR_A1's ENABLE bit.
     *
     * Region enable bit.
     */
    inline void clear_MPU_RASR_A1_ENABLE() volatile
    {
        MPU_RASR_A1 &= ~(1u << 0u);
    }

    /**
     * Toggle MPU_RASR_A1's ENABLE bit.
     *
     * Region enable bit.
     */
    inline void toggle_MPU_RASR_A1_ENABLE() volatile
    {
        MPU_RASR_A1 ^= 1u << 0u;
    }

    /**
     * Get all of MPU_RASR_A1's bit fields.
     *
     * (read-write) MPU Region Attribute and Size Register A1
     */
    inline void get_MPU_RASR_A1(bool &XN, uint8_t &AP, uint8_t &TEX, bool &S,
                                bool &C, bool &B, PPB_MPU_RASR_SRD &SRD,
                                uint8_t &SIZE, bool &ENABLE) volatile
    {
        uint32_t curr = MPU_RASR_A1;

        XN = curr & (1u << 28u);
        AP = (curr >> 24u) & 0b111u;
        TEX = (curr >> 19u) & 0b111u;
        S = curr & (1u << 18u);
        C = curr & (1u << 17u);
        B = curr & (1u << 16u);
        SRD = PPB_MPU_RASR_SRD((curr >> 8u) & 0b11111111u);
        SIZE = (curr >> 1u) & 0b11111u;
        ENABLE = curr & (1u << 0u);
    }

    /**
     * Set all of MPU_RASR_A1's bit fields.
     *
     * (read-write) MPU Region Attribute and Size Register A1
     */
    inline void set_MPU_RASR_A1(bool XN, uint8_t AP, uint8_t TEX, bool S,
                                bool C, bool B, PPB_MPU_RASR_SRD SRD,
                                uint8_t SIZE, bool ENABLE) volatile
    {
        uint32_t curr = MPU_RASR_A1;

        curr &= ~(0b1u << 28u);
        curr |= (XN & 0b1u) << 28u;
        curr &= ~(0b111u << 24u);
        curr |= (AP & 0b111u) << 24u;
        curr &= ~(0b111u << 19u);
        curr |= (TEX & 0b111u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (S & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (C & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (B & 0b1u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (std::to_underlying(SRD) & 0b11111111u) << 8u;
        curr &= ~(0b11111u << 1u);
        curr |= (SIZE & 0b11111u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ENABLE & 0b1u) << 0u;

        MPU_RASR_A1 = curr;
    }

    /**
     * Get MPU_RBAR_A2's ADDR field.
     *
     * Region base address field
     */
    inline uint32_t get_MPU_RBAR_A2_ADDR() volatile
    {
        return (MPU_RBAR_A2 >> 9u) & 0b11111111111111111111111u;
    }

    /**
     * Set MPU_RBAR_A2's ADDR field.
     *
     * Region base address field
     */
    inline void set_MPU_RBAR_A2_ADDR(uint32_t value) volatile
    {
        uint32_t curr = MPU_RBAR_A2;

        curr &= ~(0b11111111111111111111111u << 9u);
        curr |= (value & 0b11111111111111111111111u) << 9u;

        MPU_RBAR_A2 = curr;
    }

    /**
     * Get MPU_RBAR_A2's VALID bit.
     *
     * MPU Region Number valid bit
     */
    inline bool get_MPU_RBAR_A2_VALID() volatile
    {
        return MPU_RBAR_A2 & (1u << 4u);
    }

    /**
     * Set MPU_RBAR_A2's VALID bit.
     *
     * MPU Region Number valid bit
     */
    inline void set_MPU_RBAR_A2_VALID() volatile
    {
        MPU_RBAR_A2 |= 1u << 4u;
    }

    /**
     * Clear MPU_RBAR_A2's VALID bit.
     *
     * MPU Region Number valid bit
     */
    inline void clear_MPU_RBAR_A2_VALID() volatile
    {
        MPU_RBAR_A2 &= ~(1u << 4u);
    }

    /**
     * Toggle MPU_RBAR_A2's VALID bit.
     *
     * MPU Region Number valid bit
     */
    inline void toggle_MPU_RBAR_A2_VALID() volatile
    {
        MPU_RBAR_A2 ^= 1u << 4u;
    }

    /**
     * Get MPU_RBAR_A2's REGION field.
     *
     * MPU region field
     */
    inline uint8_t get_MPU_RBAR_A2_REGION() volatile
    {
        return (MPU_RBAR_A2 >> 0u) & 0b1111u;
    }

    /**
     * Set MPU_RBAR_A2's REGION field.
     *
     * MPU region field
     */
    inline void set_MPU_RBAR_A2_REGION(uint8_t value) volatile
    {
        uint32_t curr = MPU_RBAR_A2;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        MPU_RBAR_A2 = curr;
    }

    /**
     * Get all of MPU_RBAR_A2's bit fields.
     *
     * (read-write) MPU Region Base Address Register A2
     */
    inline void get_MPU_RBAR_A2(uint32_t &ADDR, bool &VALID,
                                uint8_t &REGION) volatile
    {
        uint32_t curr = MPU_RBAR_A2;

        ADDR = (curr >> 9u) & 0b11111111111111111111111u;
        VALID = curr & (1u << 4u);
        REGION = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of MPU_RBAR_A2's bit fields.
     *
     * (read-write) MPU Region Base Address Register A2
     */
    inline void set_MPU_RBAR_A2(uint32_t ADDR, bool VALID,
                                uint8_t REGION) volatile
    {
        uint32_t curr = MPU_RBAR_A2;

        curr &= ~(0b11111111111111111111111u << 9u);
        curr |= (ADDR & 0b11111111111111111111111u) << 9u;
        curr &= ~(0b1u << 4u);
        curr |= (VALID & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (REGION & 0b1111u) << 0u;

        MPU_RBAR_A2 = curr;
    }

    /**
     * Get MPU_RASR_A2's XN bit.
     *
     * Instruction access disable bit
     */
    inline bool get_MPU_RASR_A2_XN() volatile
    {
        return MPU_RASR_A2 & (1u << 28u);
    }

    /**
     * Set MPU_RASR_A2's XN bit.
     *
     * Instruction access disable bit
     */
    inline void set_MPU_RASR_A2_XN() volatile
    {
        MPU_RASR_A2 |= 1u << 28u;
    }

    /**
     * Clear MPU_RASR_A2's XN bit.
     *
     * Instruction access disable bit
     */
    inline void clear_MPU_RASR_A2_XN() volatile
    {
        MPU_RASR_A2 &= ~(1u << 28u);
    }

    /**
     * Toggle MPU_RASR_A2's XN bit.
     *
     * Instruction access disable bit
     */
    inline void toggle_MPU_RASR_A2_XN() volatile
    {
        MPU_RASR_A2 ^= 1u << 28u;
    }

    /**
     * Get MPU_RASR_A2's AP field.
     *
     * Access permission field
     */
    inline uint8_t get_MPU_RASR_A2_AP() volatile
    {
        return (MPU_RASR_A2 >> 24u) & 0b111u;
    }

    /**
     * Set MPU_RASR_A2's AP field.
     *
     * Access permission field
     */
    inline void set_MPU_RASR_A2_AP(uint8_t value) volatile
    {
        uint32_t curr = MPU_RASR_A2;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        MPU_RASR_A2 = curr;
    }

    /**
     * Get MPU_RASR_A2's TEX field.
     *
     * Memory access attribute
     */
    inline uint8_t get_MPU_RASR_A2_TEX() volatile
    {
        return (MPU_RASR_A2 >> 19u) & 0b111u;
    }

    /**
     * Set MPU_RASR_A2's TEX field.
     *
     * Memory access attribute
     */
    inline void set_MPU_RASR_A2_TEX(uint8_t value) volatile
    {
        uint32_t curr = MPU_RASR_A2;

        curr &= ~(0b111u << 19u);
        curr |= (value & 0b111u) << 19u;

        MPU_RASR_A2 = curr;
    }

    /**
     * Get MPU_RASR_A2's S bit.
     *
     * Shareable bit
     */
    inline bool get_MPU_RASR_A2_S() volatile
    {
        return MPU_RASR_A2 & (1u << 18u);
    }

    /**
     * Set MPU_RASR_A2's S bit.
     *
     * Shareable bit
     */
    inline void set_MPU_RASR_A2_S() volatile
    {
        MPU_RASR_A2 |= 1u << 18u;
    }

    /**
     * Clear MPU_RASR_A2's S bit.
     *
     * Shareable bit
     */
    inline void clear_MPU_RASR_A2_S() volatile
    {
        MPU_RASR_A2 &= ~(1u << 18u);
    }

    /**
     * Toggle MPU_RASR_A2's S bit.
     *
     * Shareable bit
     */
    inline void toggle_MPU_RASR_A2_S() volatile
    {
        MPU_RASR_A2 ^= 1u << 18u;
    }

    /**
     * Get MPU_RASR_A2's C bit.
     *
     * Memory access attribute
     */
    inline bool get_MPU_RASR_A2_C() volatile
    {
        return MPU_RASR_A2 & (1u << 17u);
    }

    /**
     * Set MPU_RASR_A2's C bit.
     *
     * Memory access attribute
     */
    inline void set_MPU_RASR_A2_C() volatile
    {
        MPU_RASR_A2 |= 1u << 17u;
    }

    /**
     * Clear MPU_RASR_A2's C bit.
     *
     * Memory access attribute
     */
    inline void clear_MPU_RASR_A2_C() volatile
    {
        MPU_RASR_A2 &= ~(1u << 17u);
    }

    /**
     * Toggle MPU_RASR_A2's C bit.
     *
     * Memory access attribute
     */
    inline void toggle_MPU_RASR_A2_C() volatile
    {
        MPU_RASR_A2 ^= 1u << 17u;
    }

    /**
     * Get MPU_RASR_A2's B bit.
     *
     * Memory access attribute
     */
    inline bool get_MPU_RASR_A2_B() volatile
    {
        return MPU_RASR_A2 & (1u << 16u);
    }

    /**
     * Set MPU_RASR_A2's B bit.
     *
     * Memory access attribute
     */
    inline void set_MPU_RASR_A2_B() volatile
    {
        MPU_RASR_A2 |= 1u << 16u;
    }

    /**
     * Clear MPU_RASR_A2's B bit.
     *
     * Memory access attribute
     */
    inline void clear_MPU_RASR_A2_B() volatile
    {
        MPU_RASR_A2 &= ~(1u << 16u);
    }

    /**
     * Toggle MPU_RASR_A2's B bit.
     *
     * Memory access attribute
     */
    inline void toggle_MPU_RASR_A2_B() volatile
    {
        MPU_RASR_A2 ^= 1u << 16u;
    }

    /**
     * Get MPU_RASR_A2's SRD field.
     *
     * Subregion disable bits
     */
    inline PPB_MPU_RASR_SRD get_MPU_RASR_A2_SRD() volatile
    {
        return PPB_MPU_RASR_SRD((MPU_RASR_A2 >> 8u) & 0b11111111u);
    }

    /**
     * Set MPU_RASR_A2's SRD field.
     *
     * Subregion disable bits
     */
    inline void set_MPU_RASR_A2_SRD(PPB_MPU_RASR_SRD value) volatile
    {
        uint32_t curr = MPU_RASR_A2;

        curr &= ~(0b11111111u << 8u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 8u;

        MPU_RASR_A2 = curr;
    }

    /**
     * Get MPU_RASR_A2's SIZE field.
     *
     * MPU protection region size
     */
    inline uint8_t get_MPU_RASR_A2_SIZE() volatile
    {
        return (MPU_RASR_A2 >> 1u) & 0b11111u;
    }

    /**
     * Set MPU_RASR_A2's SIZE field.
     *
     * MPU protection region size
     */
    inline void set_MPU_RASR_A2_SIZE(uint8_t value) volatile
    {
        uint32_t curr = MPU_RASR_A2;

        curr &= ~(0b11111u << 1u);
        curr |= (value & 0b11111u) << 1u;

        MPU_RASR_A2 = curr;
    }

    /**
     * Get MPU_RASR_A2's ENABLE bit.
     *
     * Region enable bit.
     */
    inline bool get_MPU_RASR_A2_ENABLE() volatile
    {
        return MPU_RASR_A2 & (1u << 0u);
    }

    /**
     * Set MPU_RASR_A2's ENABLE bit.
     *
     * Region enable bit.
     */
    inline void set_MPU_RASR_A2_ENABLE() volatile
    {
        MPU_RASR_A2 |= 1u << 0u;
    }

    /**
     * Clear MPU_RASR_A2's ENABLE bit.
     *
     * Region enable bit.
     */
    inline void clear_MPU_RASR_A2_ENABLE() volatile
    {
        MPU_RASR_A2 &= ~(1u << 0u);
    }

    /**
     * Toggle MPU_RASR_A2's ENABLE bit.
     *
     * Region enable bit.
     */
    inline void toggle_MPU_RASR_A2_ENABLE() volatile
    {
        MPU_RASR_A2 ^= 1u << 0u;
    }

    /**
     * Get all of MPU_RASR_A2's bit fields.
     *
     * (read-write) MPU Region Attribute and Size Register A2
     */
    inline void get_MPU_RASR_A2(bool &XN, uint8_t &AP, uint8_t &TEX, bool &S,
                                bool &C, bool &B, PPB_MPU_RASR_SRD &SRD,
                                uint8_t &SIZE, bool &ENABLE) volatile
    {
        uint32_t curr = MPU_RASR_A2;

        XN = curr & (1u << 28u);
        AP = (curr >> 24u) & 0b111u;
        TEX = (curr >> 19u) & 0b111u;
        S = curr & (1u << 18u);
        C = curr & (1u << 17u);
        B = curr & (1u << 16u);
        SRD = PPB_MPU_RASR_SRD((curr >> 8u) & 0b11111111u);
        SIZE = (curr >> 1u) & 0b11111u;
        ENABLE = curr & (1u << 0u);
    }

    /**
     * Set all of MPU_RASR_A2's bit fields.
     *
     * (read-write) MPU Region Attribute and Size Register A2
     */
    inline void set_MPU_RASR_A2(bool XN, uint8_t AP, uint8_t TEX, bool S,
                                bool C, bool B, PPB_MPU_RASR_SRD SRD,
                                uint8_t SIZE, bool ENABLE) volatile
    {
        uint32_t curr = MPU_RASR_A2;

        curr &= ~(0b1u << 28u);
        curr |= (XN & 0b1u) << 28u;
        curr &= ~(0b111u << 24u);
        curr |= (AP & 0b111u) << 24u;
        curr &= ~(0b111u << 19u);
        curr |= (TEX & 0b111u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (S & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (C & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (B & 0b1u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (std::to_underlying(SRD) & 0b11111111u) << 8u;
        curr &= ~(0b11111u << 1u);
        curr |= (SIZE & 0b11111u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ENABLE & 0b1u) << 0u;

        MPU_RASR_A2 = curr;
    }

    /**
     * Get MPU_RBAR_A3's ADDR field.
     *
     * Region base address field
     */
    inline uint32_t get_MPU_RBAR_A3_ADDR() volatile
    {
        return (MPU_RBAR_A3 >> 9u) & 0b11111111111111111111111u;
    }

    /**
     * Set MPU_RBAR_A3's ADDR field.
     *
     * Region base address field
     */
    inline void set_MPU_RBAR_A3_ADDR(uint32_t value) volatile
    {
        uint32_t curr = MPU_RBAR_A3;

        curr &= ~(0b11111111111111111111111u << 9u);
        curr |= (value & 0b11111111111111111111111u) << 9u;

        MPU_RBAR_A3 = curr;
    }

    /**
     * Get MPU_RBAR_A3's VALID bit.
     *
     * MPU Region Number valid bit
     */
    inline bool get_MPU_RBAR_A3_VALID() volatile
    {
        return MPU_RBAR_A3 & (1u << 4u);
    }

    /**
     * Set MPU_RBAR_A3's VALID bit.
     *
     * MPU Region Number valid bit
     */
    inline void set_MPU_RBAR_A3_VALID() volatile
    {
        MPU_RBAR_A3 |= 1u << 4u;
    }

    /**
     * Clear MPU_RBAR_A3's VALID bit.
     *
     * MPU Region Number valid bit
     */
    inline void clear_MPU_RBAR_A3_VALID() volatile
    {
        MPU_RBAR_A3 &= ~(1u << 4u);
    }

    /**
     * Toggle MPU_RBAR_A3's VALID bit.
     *
     * MPU Region Number valid bit
     */
    inline void toggle_MPU_RBAR_A3_VALID() volatile
    {
        MPU_RBAR_A3 ^= 1u << 4u;
    }

    /**
     * Get MPU_RBAR_A3's REGION field.
     *
     * MPU region field
     */
    inline uint8_t get_MPU_RBAR_A3_REGION() volatile
    {
        return (MPU_RBAR_A3 >> 0u) & 0b1111u;
    }

    /**
     * Set MPU_RBAR_A3's REGION field.
     *
     * MPU region field
     */
    inline void set_MPU_RBAR_A3_REGION(uint8_t value) volatile
    {
        uint32_t curr = MPU_RBAR_A3;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        MPU_RBAR_A3 = curr;
    }

    /**
     * Get all of MPU_RBAR_A3's bit fields.
     *
     * (read-write) MPU Region Base Address Register A3
     */
    inline void get_MPU_RBAR_A3(uint32_t &ADDR, bool &VALID,
                                uint8_t &REGION) volatile
    {
        uint32_t curr = MPU_RBAR_A3;

        ADDR = (curr >> 9u) & 0b11111111111111111111111u;
        VALID = curr & (1u << 4u);
        REGION = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of MPU_RBAR_A3's bit fields.
     *
     * (read-write) MPU Region Base Address Register A3
     */
    inline void set_MPU_RBAR_A3(uint32_t ADDR, bool VALID,
                                uint8_t REGION) volatile
    {
        uint32_t curr = MPU_RBAR_A3;

        curr &= ~(0b11111111111111111111111u << 9u);
        curr |= (ADDR & 0b11111111111111111111111u) << 9u;
        curr &= ~(0b1u << 4u);
        curr |= (VALID & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (REGION & 0b1111u) << 0u;

        MPU_RBAR_A3 = curr;
    }

    /**
     * Get MPU_RASR_A3's XN bit.
     *
     * Instruction access disable bit
     */
    inline bool get_MPU_RASR_A3_XN() volatile
    {
        return MPU_RASR_A3 & (1u << 28u);
    }

    /**
     * Set MPU_RASR_A3's XN bit.
     *
     * Instruction access disable bit
     */
    inline void set_MPU_RASR_A3_XN() volatile
    {
        MPU_RASR_A3 |= 1u << 28u;
    }

    /**
     * Clear MPU_RASR_A3's XN bit.
     *
     * Instruction access disable bit
     */
    inline void clear_MPU_RASR_A3_XN() volatile
    {
        MPU_RASR_A3 &= ~(1u << 28u);
    }

    /**
     * Toggle MPU_RASR_A3's XN bit.
     *
     * Instruction access disable bit
     */
    inline void toggle_MPU_RASR_A3_XN() volatile
    {
        MPU_RASR_A3 ^= 1u << 28u;
    }

    /**
     * Get MPU_RASR_A3's AP field.
     *
     * Access permission field
     */
    inline uint8_t get_MPU_RASR_A3_AP() volatile
    {
        return (MPU_RASR_A3 >> 24u) & 0b111u;
    }

    /**
     * Set MPU_RASR_A3's AP field.
     *
     * Access permission field
     */
    inline void set_MPU_RASR_A3_AP(uint8_t value) volatile
    {
        uint32_t curr = MPU_RASR_A3;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        MPU_RASR_A3 = curr;
    }

    /**
     * Get MPU_RASR_A3's TEX field.
     *
     * Memory access attribute
     */
    inline uint8_t get_MPU_RASR_A3_TEX() volatile
    {
        return (MPU_RASR_A3 >> 19u) & 0b111u;
    }

    /**
     * Set MPU_RASR_A3's TEX field.
     *
     * Memory access attribute
     */
    inline void set_MPU_RASR_A3_TEX(uint8_t value) volatile
    {
        uint32_t curr = MPU_RASR_A3;

        curr &= ~(0b111u << 19u);
        curr |= (value & 0b111u) << 19u;

        MPU_RASR_A3 = curr;
    }

    /**
     * Get MPU_RASR_A3's S bit.
     *
     * Shareable bit
     */
    inline bool get_MPU_RASR_A3_S() volatile
    {
        return MPU_RASR_A3 & (1u << 18u);
    }

    /**
     * Set MPU_RASR_A3's S bit.
     *
     * Shareable bit
     */
    inline void set_MPU_RASR_A3_S() volatile
    {
        MPU_RASR_A3 |= 1u << 18u;
    }

    /**
     * Clear MPU_RASR_A3's S bit.
     *
     * Shareable bit
     */
    inline void clear_MPU_RASR_A3_S() volatile
    {
        MPU_RASR_A3 &= ~(1u << 18u);
    }

    /**
     * Toggle MPU_RASR_A3's S bit.
     *
     * Shareable bit
     */
    inline void toggle_MPU_RASR_A3_S() volatile
    {
        MPU_RASR_A3 ^= 1u << 18u;
    }

    /**
     * Get MPU_RASR_A3's C bit.
     *
     * Memory access attribute
     */
    inline bool get_MPU_RASR_A3_C() volatile
    {
        return MPU_RASR_A3 & (1u << 17u);
    }

    /**
     * Set MPU_RASR_A3's C bit.
     *
     * Memory access attribute
     */
    inline void set_MPU_RASR_A3_C() volatile
    {
        MPU_RASR_A3 |= 1u << 17u;
    }

    /**
     * Clear MPU_RASR_A3's C bit.
     *
     * Memory access attribute
     */
    inline void clear_MPU_RASR_A3_C() volatile
    {
        MPU_RASR_A3 &= ~(1u << 17u);
    }

    /**
     * Toggle MPU_RASR_A3's C bit.
     *
     * Memory access attribute
     */
    inline void toggle_MPU_RASR_A3_C() volatile
    {
        MPU_RASR_A3 ^= 1u << 17u;
    }

    /**
     * Get MPU_RASR_A3's B bit.
     *
     * Memory access attribute
     */
    inline bool get_MPU_RASR_A3_B() volatile
    {
        return MPU_RASR_A3 & (1u << 16u);
    }

    /**
     * Set MPU_RASR_A3's B bit.
     *
     * Memory access attribute
     */
    inline void set_MPU_RASR_A3_B() volatile
    {
        MPU_RASR_A3 |= 1u << 16u;
    }

    /**
     * Clear MPU_RASR_A3's B bit.
     *
     * Memory access attribute
     */
    inline void clear_MPU_RASR_A3_B() volatile
    {
        MPU_RASR_A3 &= ~(1u << 16u);
    }

    /**
     * Toggle MPU_RASR_A3's B bit.
     *
     * Memory access attribute
     */
    inline void toggle_MPU_RASR_A3_B() volatile
    {
        MPU_RASR_A3 ^= 1u << 16u;
    }

    /**
     * Get MPU_RASR_A3's SRD field.
     *
     * Subregion disable bits
     */
    inline PPB_MPU_RASR_SRD get_MPU_RASR_A3_SRD() volatile
    {
        return PPB_MPU_RASR_SRD((MPU_RASR_A3 >> 8u) & 0b11111111u);
    }

    /**
     * Set MPU_RASR_A3's SRD field.
     *
     * Subregion disable bits
     */
    inline void set_MPU_RASR_A3_SRD(PPB_MPU_RASR_SRD value) volatile
    {
        uint32_t curr = MPU_RASR_A3;

        curr &= ~(0b11111111u << 8u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 8u;

        MPU_RASR_A3 = curr;
    }

    /**
     * Get MPU_RASR_A3's SIZE field.
     *
     * MPU protection region size
     */
    inline uint8_t get_MPU_RASR_A3_SIZE() volatile
    {
        return (MPU_RASR_A3 >> 1u) & 0b11111u;
    }

    /**
     * Set MPU_RASR_A3's SIZE field.
     *
     * MPU protection region size
     */
    inline void set_MPU_RASR_A3_SIZE(uint8_t value) volatile
    {
        uint32_t curr = MPU_RASR_A3;

        curr &= ~(0b11111u << 1u);
        curr |= (value & 0b11111u) << 1u;

        MPU_RASR_A3 = curr;
    }

    /**
     * Get MPU_RASR_A3's ENABLE bit.
     *
     * Region enable bit.
     */
    inline bool get_MPU_RASR_A3_ENABLE() volatile
    {
        return MPU_RASR_A3 & (1u << 0u);
    }

    /**
     * Set MPU_RASR_A3's ENABLE bit.
     *
     * Region enable bit.
     */
    inline void set_MPU_RASR_A3_ENABLE() volatile
    {
        MPU_RASR_A3 |= 1u << 0u;
    }

    /**
     * Clear MPU_RASR_A3's ENABLE bit.
     *
     * Region enable bit.
     */
    inline void clear_MPU_RASR_A3_ENABLE() volatile
    {
        MPU_RASR_A3 &= ~(1u << 0u);
    }

    /**
     * Toggle MPU_RASR_A3's ENABLE bit.
     *
     * Region enable bit.
     */
    inline void toggle_MPU_RASR_A3_ENABLE() volatile
    {
        MPU_RASR_A3 ^= 1u << 0u;
    }

    /**
     * Get all of MPU_RASR_A3's bit fields.
     *
     * (read-write) MPU Region Attribute and Size Register A3
     */
    inline void get_MPU_RASR_A3(bool &XN, uint8_t &AP, uint8_t &TEX, bool &S,
                                bool &C, bool &B, PPB_MPU_RASR_SRD &SRD,
                                uint8_t &SIZE, bool &ENABLE) volatile
    {
        uint32_t curr = MPU_RASR_A3;

        XN = curr & (1u << 28u);
        AP = (curr >> 24u) & 0b111u;
        TEX = (curr >> 19u) & 0b111u;
        S = curr & (1u << 18u);
        C = curr & (1u << 17u);
        B = curr & (1u << 16u);
        SRD = PPB_MPU_RASR_SRD((curr >> 8u) & 0b11111111u);
        SIZE = (curr >> 1u) & 0b11111u;
        ENABLE = curr & (1u << 0u);
    }

    /**
     * Set all of MPU_RASR_A3's bit fields.
     *
     * (read-write) MPU Region Attribute and Size Register A3
     */
    inline void set_MPU_RASR_A3(bool XN, uint8_t AP, uint8_t TEX, bool S,
                                bool C, bool B, PPB_MPU_RASR_SRD SRD,
                                uint8_t SIZE, bool ENABLE) volatile
    {
        uint32_t curr = MPU_RASR_A3;

        curr &= ~(0b1u << 28u);
        curr |= (XN & 0b1u) << 28u;
        curr &= ~(0b111u << 24u);
        curr |= (AP & 0b111u) << 24u;
        curr &= ~(0b111u << 19u);
        curr |= (TEX & 0b111u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (S & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (C & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (B & 0b1u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (std::to_underlying(SRD) & 0b11111111u) << 8u;
        curr &= ~(0b11111u << 1u);
        curr |= (SIZE & 0b11111u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ENABLE & 0b1u) << 0u;

        MPU_RASR_A3 = curr;
    }

    /**
     * Set STIR's INTID field.
     *
     * Interrupt ID of the interrupt to trigger
     */
    inline void set_STIR_INTID(uint16_t value) volatile
    {
        uint32_t curr = STIR;

        curr &= ~(0b111111111u << 0u);
        curr |= (value & 0b111111111u) << 0u;

        STIR = curr;
    }

    /**
     * Get FPCCR's ASPEN bit.
     *
     * Automatic State Preservation
     */
    inline bool get_FPCCR_ASPEN() volatile
    {
        return FPCCR & (1u << 31u);
    }

    /**
     * Set FPCCR's ASPEN bit.
     *
     * Automatic State Preservation
     */
    inline void set_FPCCR_ASPEN() volatile
    {
        FPCCR |= 1u << 31u;
    }

    /**
     * Clear FPCCR's ASPEN bit.
     *
     * Automatic State Preservation
     */
    inline void clear_FPCCR_ASPEN() volatile
    {
        FPCCR &= ~(1u << 31u);
    }

    /**
     * Toggle FPCCR's ASPEN bit.
     *
     * Automatic State Preservation
     */
    inline void toggle_FPCCR_ASPEN() volatile
    {
        FPCCR ^= 1u << 31u;
    }

    /**
     * Get FPCCR's LSPEN bit.
     *
     * Lazy State Preservation Enabled
     */
    inline bool get_FPCCR_LSPEN() volatile
    {
        return FPCCR & (1u << 30u);
    }

    /**
     * Set FPCCR's LSPEN bit.
     *
     * Lazy State Preservation Enabled
     */
    inline void set_FPCCR_LSPEN() volatile
    {
        FPCCR |= 1u << 30u;
    }

    /**
     * Clear FPCCR's LSPEN bit.
     *
     * Lazy State Preservation Enabled
     */
    inline void clear_FPCCR_LSPEN() volatile
    {
        FPCCR &= ~(1u << 30u);
    }

    /**
     * Toggle FPCCR's LSPEN bit.
     *
     * Lazy State Preservation Enabled
     */
    inline void toggle_FPCCR_LSPEN() volatile
    {
        FPCCR ^= 1u << 30u;
    }

    /**
     * Get FPCCR's MONRDY bit.
     *
     * Monitor Ready
     */
    inline bool get_FPCCR_MONRDY() volatile
    {
        return FPCCR & (1u << 8u);
    }

    /**
     * Set FPCCR's MONRDY bit.
     *
     * Monitor Ready
     */
    inline void set_FPCCR_MONRDY() volatile
    {
        FPCCR |= 1u << 8u;
    }

    /**
     * Clear FPCCR's MONRDY bit.
     *
     * Monitor Ready
     */
    inline void clear_FPCCR_MONRDY() volatile
    {
        FPCCR &= ~(1u << 8u);
    }

    /**
     * Toggle FPCCR's MONRDY bit.
     *
     * Monitor Ready
     */
    inline void toggle_FPCCR_MONRDY() volatile
    {
        FPCCR ^= 1u << 8u;
    }

    /**
     * Get FPCCR's BFRDY bit.
     *
     * BusFault Ready
     */
    inline bool get_FPCCR_BFRDY() volatile
    {
        return FPCCR & (1u << 6u);
    }

    /**
     * Set FPCCR's BFRDY bit.
     *
     * BusFault Ready
     */
    inline void set_FPCCR_BFRDY() volatile
    {
        FPCCR |= 1u << 6u;
    }

    /**
     * Clear FPCCR's BFRDY bit.
     *
     * BusFault Ready
     */
    inline void clear_FPCCR_BFRDY() volatile
    {
        FPCCR &= ~(1u << 6u);
    }

    /**
     * Toggle FPCCR's BFRDY bit.
     *
     * BusFault Ready
     */
    inline void toggle_FPCCR_BFRDY() volatile
    {
        FPCCR ^= 1u << 6u;
    }

    /**
     * Get FPCCR's MMRDY bit.
     *
     * MemManage Ready
     */
    inline bool get_FPCCR_MMRDY() volatile
    {
        return FPCCR & (1u << 5u);
    }

    /**
     * Set FPCCR's MMRDY bit.
     *
     * MemManage Ready
     */
    inline void set_FPCCR_MMRDY() volatile
    {
        FPCCR |= 1u << 5u;
    }

    /**
     * Clear FPCCR's MMRDY bit.
     *
     * MemManage Ready
     */
    inline void clear_FPCCR_MMRDY() volatile
    {
        FPCCR &= ~(1u << 5u);
    }

    /**
     * Toggle FPCCR's MMRDY bit.
     *
     * MemManage Ready
     */
    inline void toggle_FPCCR_MMRDY() volatile
    {
        FPCCR ^= 1u << 5u;
    }

    /**
     * Get FPCCR's HFRDY bit.
     *
     * HardFault Ready
     */
    inline bool get_FPCCR_HFRDY() volatile
    {
        return FPCCR & (1u << 4u);
    }

    /**
     * Set FPCCR's HFRDY bit.
     *
     * HardFault Ready
     */
    inline void set_FPCCR_HFRDY() volatile
    {
        FPCCR |= 1u << 4u;
    }

    /**
     * Clear FPCCR's HFRDY bit.
     *
     * HardFault Ready
     */
    inline void clear_FPCCR_HFRDY() volatile
    {
        FPCCR &= ~(1u << 4u);
    }

    /**
     * Toggle FPCCR's HFRDY bit.
     *
     * HardFault Ready
     */
    inline void toggle_FPCCR_HFRDY() volatile
    {
        FPCCR ^= 1u << 4u;
    }

    /**
     * Get FPCCR's THREAD bit.
     *
     * Thread Mode allocated Stack Frame
     */
    inline bool get_FPCCR_THREAD() volatile
    {
        return FPCCR & (1u << 3u);
    }

    /**
     * Set FPCCR's THREAD bit.
     *
     * Thread Mode allocated Stack Frame
     */
    inline void set_FPCCR_THREAD() volatile
    {
        FPCCR |= 1u << 3u;
    }

    /**
     * Clear FPCCR's THREAD bit.
     *
     * Thread Mode allocated Stack Frame
     */
    inline void clear_FPCCR_THREAD() volatile
    {
        FPCCR &= ~(1u << 3u);
    }

    /**
     * Toggle FPCCR's THREAD bit.
     *
     * Thread Mode allocated Stack Frame
     */
    inline void toggle_FPCCR_THREAD() volatile
    {
        FPCCR ^= 1u << 3u;
    }

    /**
     * Get FPCCR's USER bit.
     *
     * User allocated Stack Frame
     */
    inline bool get_FPCCR_USER() volatile
    {
        return FPCCR & (1u << 1u);
    }

    /**
     * Set FPCCR's USER bit.
     *
     * User allocated Stack Frame
     */
    inline void set_FPCCR_USER() volatile
    {
        FPCCR |= 1u << 1u;
    }

    /**
     * Clear FPCCR's USER bit.
     *
     * User allocated Stack Frame
     */
    inline void clear_FPCCR_USER() volatile
    {
        FPCCR &= ~(1u << 1u);
    }

    /**
     * Toggle FPCCR's USER bit.
     *
     * User allocated Stack Frame
     */
    inline void toggle_FPCCR_USER() volatile
    {
        FPCCR ^= 1u << 1u;
    }

    /**
     * Get FPCCR's LSPACT bit.
     *
     * Lazy State Preservation Active
     */
    inline bool get_FPCCR_LSPACT() volatile
    {
        return FPCCR & (1u << 0u);
    }

    /**
     * Set FPCCR's LSPACT bit.
     *
     * Lazy State Preservation Active
     */
    inline void set_FPCCR_LSPACT() volatile
    {
        FPCCR |= 1u << 0u;
    }

    /**
     * Clear FPCCR's LSPACT bit.
     *
     * Lazy State Preservation Active
     */
    inline void clear_FPCCR_LSPACT() volatile
    {
        FPCCR &= ~(1u << 0u);
    }

    /**
     * Toggle FPCCR's LSPACT bit.
     *
     * Lazy State Preservation Active
     */
    inline void toggle_FPCCR_LSPACT() volatile
    {
        FPCCR ^= 1u << 0u;
    }

    /**
     * Get all of FPCCR's bit fields.
     *
     * (read-write) Floating-point Context Control Register
     */
    inline void get_FPCCR(bool &ASPEN, bool &LSPEN, bool &MONRDY, bool &BFRDY,
                          bool &MMRDY, bool &HFRDY, bool &THREAD, bool &USER,
                          bool &LSPACT) volatile
    {
        uint32_t curr = FPCCR;

        ASPEN = curr & (1u << 31u);
        LSPEN = curr & (1u << 30u);
        MONRDY = curr & (1u << 8u);
        BFRDY = curr & (1u << 6u);
        MMRDY = curr & (1u << 5u);
        HFRDY = curr & (1u << 4u);
        THREAD = curr & (1u << 3u);
        USER = curr & (1u << 1u);
        LSPACT = curr & (1u << 0u);
    }

    /**
     * Set all of FPCCR's bit fields.
     *
     * (read-write) Floating-point Context Control Register
     */
    inline void set_FPCCR(bool ASPEN, bool LSPEN, bool MONRDY, bool BFRDY,
                          bool MMRDY, bool HFRDY, bool THREAD, bool USER,
                          bool LSPACT) volatile
    {
        uint32_t curr = FPCCR;

        curr &= ~(0b1u << 31u);
        curr |= (ASPEN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (LSPEN & 0b1u) << 30u;
        curr &= ~(0b1u << 8u);
        curr |= (MONRDY & 0b1u) << 8u;
        curr &= ~(0b1u << 6u);
        curr |= (BFRDY & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (MMRDY & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (HFRDY & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (THREAD & 0b1u) << 3u;
        curr &= ~(0b1u << 1u);
        curr |= (USER & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (LSPACT & 0b1u) << 0u;

        FPCCR = curr;
    }

    /**
     * Get FPCAR's ADDRESS field.
     *
     * Address
     */
    inline uint32_t get_FPCAR_ADDRESS() volatile
    {
        return (FPCAR >> 3u) & 0b11111111111111111111111111111u;
    }

    /**
     * Set FPCAR's ADDRESS field.
     *
     * Address
     */
    inline void set_FPCAR_ADDRESS(uint32_t value) volatile
    {
        uint32_t curr = FPCAR;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        FPCAR = curr;
    }

    /**
     * Get FPDSCR's AHP bit.
     *
     * Default value for FPSCR.AHP
     */
    inline bool get_FPDSCR_AHP() volatile
    {
        return FPDSCR & (1u << 26u);
    }

    /**
     * Set FPDSCR's AHP bit.
     *
     * Default value for FPSCR.AHP
     */
    inline void set_FPDSCR_AHP() volatile
    {
        FPDSCR |= 1u << 26u;
    }

    /**
     * Clear FPDSCR's AHP bit.
     *
     * Default value for FPSCR.AHP
     */
    inline void clear_FPDSCR_AHP() volatile
    {
        FPDSCR &= ~(1u << 26u);
    }

    /**
     * Toggle FPDSCR's AHP bit.
     *
     * Default value for FPSCR.AHP
     */
    inline void toggle_FPDSCR_AHP() volatile
    {
        FPDSCR ^= 1u << 26u;
    }

    /**
     * Get FPDSCR's DN bit.
     *
     * Default value for FPSCR.DN
     */
    inline bool get_FPDSCR_DN() volatile
    {
        return FPDSCR & (1u << 25u);
    }

    /**
     * Set FPDSCR's DN bit.
     *
     * Default value for FPSCR.DN
     */
    inline void set_FPDSCR_DN() volatile
    {
        FPDSCR |= 1u << 25u;
    }

    /**
     * Clear FPDSCR's DN bit.
     *
     * Default value for FPSCR.DN
     */
    inline void clear_FPDSCR_DN() volatile
    {
        FPDSCR &= ~(1u << 25u);
    }

    /**
     * Toggle FPDSCR's DN bit.
     *
     * Default value for FPSCR.DN
     */
    inline void toggle_FPDSCR_DN() volatile
    {
        FPDSCR ^= 1u << 25u;
    }

    /**
     * Get FPDSCR's FZ bit.
     *
     * Default value for FPSCR.FZ
     */
    inline bool get_FPDSCR_FZ() volatile
    {
        return FPDSCR & (1u << 24u);
    }

    /**
     * Set FPDSCR's FZ bit.
     *
     * Default value for FPSCR.FZ
     */
    inline void set_FPDSCR_FZ() volatile
    {
        FPDSCR |= 1u << 24u;
    }

    /**
     * Clear FPDSCR's FZ bit.
     *
     * Default value for FPSCR.FZ
     */
    inline void clear_FPDSCR_FZ() volatile
    {
        FPDSCR &= ~(1u << 24u);
    }

    /**
     * Toggle FPDSCR's FZ bit.
     *
     * Default value for FPSCR.FZ
     */
    inline void toggle_FPDSCR_FZ() volatile
    {
        FPDSCR ^= 1u << 24u;
    }

    /**
     * Get FPDSCR's RMode field.
     *
     * Default value for FPSCR.RMode
     */
    inline uint8_t get_FPDSCR_RMode() volatile
    {
        return (FPDSCR >> 22u) & 0b11u;
    }

    /**
     * Set FPDSCR's RMode field.
     *
     * Default value for FPSCR.RMode
     */
    inline void set_FPDSCR_RMode(uint8_t value) volatile
    {
        uint32_t curr = FPDSCR;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        FPDSCR = curr;
    }

    /**
     * Get all of FPDSCR's bit fields.
     *
     * (read-write) Floating-point Default Status Control Register
     */
    inline void get_FPDSCR(bool &AHP, bool &DN, bool &FZ,
                           uint8_t &RMode) volatile
    {
        uint32_t curr = FPDSCR;

        AHP = curr & (1u << 26u);
        DN = curr & (1u << 25u);
        FZ = curr & (1u << 24u);
        RMode = (curr >> 22u) & 0b11u;
    }

    /**
     * Set all of FPDSCR's bit fields.
     *
     * (read-write) Floating-point Default Status Control Register
     */
    inline void set_FPDSCR(bool AHP, bool DN, bool FZ, uint8_t RMode) volatile
    {
        uint32_t curr = FPDSCR;

        curr &= ~(0b1u << 26u);
        curr |= (AHP & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (DN & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (FZ & 0b1u) << 24u;
        curr &= ~(0b11u << 22u);
        curr |= (RMode & 0b11u) << 22u;

        FPDSCR = curr;
    }
};

static_assert(sizeof(ppb) == ppb::size);

static volatile ppb *const PPB = reinterpret_cast<ppb *>(0xE000E000);

}; // namespace XMC4700
