/**
 * \file
 * \brief Generated by ifgen (3.1.2).
 */
#pragma once

#include "../enums/SCU_POWER_EVRSTAT_OV13.h"
#include "../enums/SCU_POWER_PWRCLR_HIB.h"
#include "../enums/SCU_POWER_PWRCLR_USBOTGEN.h"
#include "../enums/SCU_POWER_PWRCLR_USBPUWQ.h"
#include "../enums/SCU_POWER_PWRSET_HIB.h"
#include "../enums/SCU_POWER_PWRSET_USBOTGEN.h"
#include "../enums/SCU_POWER_PWRSET_USBPUWQ.h"
#include "../enums/SCU_POWER_PWRSTAT_HIBEN.h"
#include "../enums/SCU_POWER_PWRSTAT_USBOTGEN.h"
#include "../enums/SCU_POWER_PWRSTAT_USBPUWQ.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * System Control Unit
 */
struct [[gnu::packed]] scu_power
{
    /* Constant attributes. */
    static constexpr std::size_t size = 48; /*!< scu_power's size in bytes. */

    /* Fields. */
    const uint32_t PWRSTAT = {}; /*!< (read-only) PCU Status Register */
    uint32_t PWRSET;             /*!< (write-only) PCU Set Control Register */
    uint32_t PWRCLR; /*!< (write-only) PCU Clear Control Register */
    const uint32_t reserved_padding0 = {};
    const uint32_t EVRSTAT = {}; /*!< (read-only) EVR Status Register */
    const uint32_t EVRVADCSTAT =
        {}; /*!< (read-only) EVR VADC Status Register */
    static constexpr std::size_t reserved_padding1_length = 5;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t PWRMON; /*!< (read-write) Power Monitor Control */

    /* Methods. */

    /**
     * Get PWRSTAT's USBPUWQ bit.
     */
    inline SCU_POWER_PWRSTAT_USBPUWQ get_PWRSTAT_USBPUWQ() volatile
    {
        return SCU_POWER_PWRSTAT_USBPUWQ(PWRSTAT & (1u << 18u));
    }

    /**
     * Get PWRSTAT's USBOTGEN bit.
     */
    inline SCU_POWER_PWRSTAT_USBOTGEN get_PWRSTAT_USBOTGEN() volatile
    {
        return SCU_POWER_PWRSTAT_USBOTGEN(PWRSTAT & (1u << 17u));
    }

    /**
     * Get PWRSTAT's USBPHYPDQ bit.
     */
    inline SCU_POWER_PWRSTAT_USBOTGEN get_PWRSTAT_USBPHYPDQ() volatile
    {
        return SCU_POWER_PWRSTAT_USBOTGEN(PWRSTAT & (1u << 16u));
    }

    /**
     * Get PWRSTAT's HIBEN bit.
     */
    inline SCU_POWER_PWRSTAT_HIBEN get_PWRSTAT_HIBEN() volatile
    {
        return SCU_POWER_PWRSTAT_HIBEN(PWRSTAT & (1u << 0u));
    }

    /**
     * Get all of PWRSTAT's bit fields.
     */
    inline void get_PWRSTAT(SCU_POWER_PWRSTAT_USBPUWQ &USBPUWQ,
                            SCU_POWER_PWRSTAT_USBOTGEN &USBOTGEN,
                            SCU_POWER_PWRSTAT_USBOTGEN &USBPHYPDQ,
                            SCU_POWER_PWRSTAT_HIBEN &HIBEN) volatile
    {
        uint32_t curr = PWRSTAT;

        USBPUWQ = SCU_POWER_PWRSTAT_USBPUWQ(curr & (1u << 18u));
        USBOTGEN = SCU_POWER_PWRSTAT_USBOTGEN(curr & (1u << 17u));
        USBPHYPDQ = SCU_POWER_PWRSTAT_USBOTGEN(curr & (1u << 16u));
        HIBEN = SCU_POWER_PWRSTAT_HIBEN(curr & (1u << 0u));
    }

    /**
     * Set PWRSET's USBPUWQ bit.
     */
    inline void set_PWRSET_USBPUWQ() volatile
    {
        PWRSET |= 1u << 18u;
    }

    /**
     * Clear PWRSET's USBPUWQ bit.
     */
    inline void clear_PWRSET_USBPUWQ() volatile
    {
        PWRSET &= ~(1u << 18u);
    }

    /**
     * Toggle PWRSET's USBPUWQ bit.
     */
    inline void toggle_PWRSET_USBPUWQ() volatile
    {
        PWRSET ^= 1u << 18u;
    }

    /**
     * Set PWRSET's USBOTGEN bit.
     */
    inline void set_PWRSET_USBOTGEN() volatile
    {
        PWRSET |= 1u << 17u;
    }

    /**
     * Clear PWRSET's USBOTGEN bit.
     */
    inline void clear_PWRSET_USBOTGEN() volatile
    {
        PWRSET &= ~(1u << 17u);
    }

    /**
     * Toggle PWRSET's USBOTGEN bit.
     */
    inline void toggle_PWRSET_USBOTGEN() volatile
    {
        PWRSET ^= 1u << 17u;
    }

    /**
     * Set PWRSET's USBPHYPDQ bit.
     */
    inline void set_PWRSET_USBPHYPDQ() volatile
    {
        PWRSET |= 1u << 16u;
    }

    /**
     * Clear PWRSET's USBPHYPDQ bit.
     */
    inline void clear_PWRSET_USBPHYPDQ() volatile
    {
        PWRSET &= ~(1u << 16u);
    }

    /**
     * Toggle PWRSET's USBPHYPDQ bit.
     */
    inline void toggle_PWRSET_USBPHYPDQ() volatile
    {
        PWRSET ^= 1u << 16u;
    }

    /**
     * Set PWRSET's HIB bit.
     */
    inline void set_PWRSET_HIB() volatile
    {
        PWRSET |= 1u << 0u;
    }

    /**
     * Clear PWRSET's HIB bit.
     */
    inline void clear_PWRSET_HIB() volatile
    {
        PWRSET &= ~(1u << 0u);
    }

    /**
     * Toggle PWRSET's HIB bit.
     */
    inline void toggle_PWRSET_HIB() volatile
    {
        PWRSET ^= 1u << 0u;
    }

    /**
     * Set all of PWRSET's bit fields.
     */
    inline void set_PWRSET(SCU_POWER_PWRSET_USBPUWQ USBPUWQ,
                           SCU_POWER_PWRSET_USBOTGEN USBOTGEN,
                           SCU_POWER_PWRSET_USBOTGEN USBPHYPDQ,
                           SCU_POWER_PWRSET_HIB HIB) volatile
    {
        uint32_t curr = PWRSET;

        curr &= ~(0b1u << 18u);
        curr |= (std::to_underlying(USBPUWQ) & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(USBOTGEN) & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (std::to_underlying(USBPHYPDQ) & 0b1u) << 16u;
        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(HIB) & 0b1u) << 0u;

        PWRSET = curr;
    }

    /**
     * Set PWRCLR's USBPUWQ bit.
     */
    inline void set_PWRCLR_USBPUWQ() volatile
    {
        PWRCLR |= 1u << 18u;
    }

    /**
     * Clear PWRCLR's USBPUWQ bit.
     */
    inline void clear_PWRCLR_USBPUWQ() volatile
    {
        PWRCLR &= ~(1u << 18u);
    }

    /**
     * Toggle PWRCLR's USBPUWQ bit.
     */
    inline void toggle_PWRCLR_USBPUWQ() volatile
    {
        PWRCLR ^= 1u << 18u;
    }

    /**
     * Set PWRCLR's USBOTGEN bit.
     */
    inline void set_PWRCLR_USBOTGEN() volatile
    {
        PWRCLR |= 1u << 17u;
    }

    /**
     * Clear PWRCLR's USBOTGEN bit.
     */
    inline void clear_PWRCLR_USBOTGEN() volatile
    {
        PWRCLR &= ~(1u << 17u);
    }

    /**
     * Toggle PWRCLR's USBOTGEN bit.
     */
    inline void toggle_PWRCLR_USBOTGEN() volatile
    {
        PWRCLR ^= 1u << 17u;
    }

    /**
     * Set PWRCLR's USBPHYPDQ bit.
     */
    inline void set_PWRCLR_USBPHYPDQ() volatile
    {
        PWRCLR |= 1u << 16u;
    }

    /**
     * Clear PWRCLR's USBPHYPDQ bit.
     */
    inline void clear_PWRCLR_USBPHYPDQ() volatile
    {
        PWRCLR &= ~(1u << 16u);
    }

    /**
     * Toggle PWRCLR's USBPHYPDQ bit.
     */
    inline void toggle_PWRCLR_USBPHYPDQ() volatile
    {
        PWRCLR ^= 1u << 16u;
    }

    /**
     * Set PWRCLR's HIB bit.
     */
    inline void set_PWRCLR_HIB() volatile
    {
        PWRCLR |= 1u << 0u;
    }

    /**
     * Clear PWRCLR's HIB bit.
     */
    inline void clear_PWRCLR_HIB() volatile
    {
        PWRCLR &= ~(1u << 0u);
    }

    /**
     * Toggle PWRCLR's HIB bit.
     */
    inline void toggle_PWRCLR_HIB() volatile
    {
        PWRCLR ^= 1u << 0u;
    }

    /**
     * Set all of PWRCLR's bit fields.
     */
    inline void set_PWRCLR(SCU_POWER_PWRCLR_USBPUWQ USBPUWQ,
                           SCU_POWER_PWRCLR_USBOTGEN USBOTGEN,
                           SCU_POWER_PWRCLR_USBOTGEN USBPHYPDQ,
                           SCU_POWER_PWRCLR_HIB HIB) volatile
    {
        uint32_t curr = PWRCLR;

        curr &= ~(0b1u << 18u);
        curr |= (std::to_underlying(USBPUWQ) & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(USBOTGEN) & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (std::to_underlying(USBPHYPDQ) & 0b1u) << 16u;
        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(HIB) & 0b1u) << 0u;

        PWRCLR = curr;
    }

    /**
     * Get EVRSTAT's OV13 bit.
     */
    inline SCU_POWER_EVRSTAT_OV13 get_EVRSTAT_OV13() volatile
    {
        return SCU_POWER_EVRSTAT_OV13(EVRSTAT & (1u << 1u));
    }

    /**
     * Get EVRVADCSTAT's VADC33V field.
     */
    inline uint8_t get_EVRVADCSTAT_VADC33V() volatile
    {
        return (EVRVADCSTAT >> 8u) & 0b11111111u;
    }

    /**
     * Get EVRVADCSTAT's VADC13V field.
     */
    inline uint8_t get_EVRVADCSTAT_VADC13V() volatile
    {
        return (EVRVADCSTAT >> 0u) & 0b11111111u;
    }

    /**
     * Get all of EVRVADCSTAT's bit fields.
     */
    inline void get_EVRVADCSTAT(uint8_t &VADC33V, uint8_t &VADC13V) volatile
    {
        uint32_t curr = EVRVADCSTAT;

        VADC33V = (curr >> 8u) & 0b11111111u;
        VADC13V = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get PWRMON's ENB bit.
     */
    inline bool get_PWRMON_ENB() volatile
    {
        return PWRMON & (1u << 16u);
    }

    /**
     * Set PWRMON's ENB bit.
     */
    inline void set_PWRMON_ENB() volatile
    {
        PWRMON |= 1u << 16u;
    }

    /**
     * Clear PWRMON's ENB bit.
     */
    inline void clear_PWRMON_ENB() volatile
    {
        PWRMON &= ~(1u << 16u);
    }

    /**
     * Toggle PWRMON's ENB bit.
     */
    inline void toggle_PWRMON_ENB() volatile
    {
        PWRMON ^= 1u << 16u;
    }

    /**
     * Get PWRMON's INTV field.
     */
    inline uint8_t get_PWRMON_INTV() volatile
    {
        return (PWRMON >> 8u) & 0b11111111u;
    }

    /**
     * Set PWRMON's INTV field.
     */
    inline void set_PWRMON_INTV(uint8_t value) volatile
    {
        uint32_t curr = PWRMON;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        PWRMON = curr;
    }

    /**
     * Get PWRMON's THRS field.
     */
    inline uint8_t get_PWRMON_THRS() volatile
    {
        return (PWRMON >> 0u) & 0b11111111u;
    }

    /**
     * Set PWRMON's THRS field.
     */
    inline void set_PWRMON_THRS(uint8_t value) volatile
    {
        uint32_t curr = PWRMON;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        PWRMON = curr;
    }

    /**
     * Get all of PWRMON's bit fields.
     */
    inline void get_PWRMON(bool &ENB, uint8_t &INTV, uint8_t &THRS) volatile
    {
        uint32_t curr = PWRMON;

        ENB = curr & (1u << 16u);
        INTV = (curr >> 8u) & 0b11111111u;
        THRS = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of PWRMON's bit fields.
     */
    inline void set_PWRMON(bool ENB, uint8_t INTV, uint8_t THRS) volatile
    {
        uint32_t curr = PWRMON;

        curr &= ~(0b1u << 16u);
        curr |= (ENB & 0b1u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (INTV & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (THRS & 0b11111111u) << 0u;

        PWRMON = curr;
    }
};

static_assert(sizeof(scu_power) == scu_power::size);

static volatile scu_power *const SCU_POWER =
    reinterpret_cast<scu_power *>(0x50004200);

}; // namespace XMC4700
