/**
 * \file
 * \brief Generated by ifgen (3.2.0).
 */
#pragma once

#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * System Control Unit
 */
struct [[gnu::packed]] scu_power
{
    /* Constant attributes. */
    static constexpr std::size_t size = 48; /*!< scu_power's size in bytes. */

    /* Fields. */
    const uint32_t PWRSTAT = {}; /*!< (read-only) PCU Status Register */
    uint32_t PWRSET;             /*!< (write-only) PCU Set Control Register */
    uint32_t PWRCLR; /*!< (write-only) PCU Clear Control Register */
    const uint32_t reserved_padding0 = {};
    const uint32_t EVRSTAT = {}; /*!< (read-only) EVR Status Register */
    const uint32_t EVRVADCSTAT =
        {}; /*!< (read-only) EVR VADC Status Register */
    static constexpr std::size_t reserved_padding1_length = 5;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t PWRMON; /*!< (read-write) Power Monitor Control */

    /* Methods. */

    /**
     * Get PWRSTAT's USBPUWQ bit.
     *
     * USB Weak Pull-Up at PADN State
     */
    inline bool get_PWRSTAT_USBPUWQ() volatile
    {
        return PWRSTAT & (1u << 18u);
    }

    /**
     * Get PWRSTAT's USBOTGEN bit.
     *
     * USB On-The-Go Comparators State
     */
    inline bool get_PWRSTAT_USBOTGEN() volatile
    {
        return PWRSTAT & (1u << 17u);
    }

    /**
     * Get PWRSTAT's USBPHYPDQ bit.
     *
     * USB PHY Transceiver State
     */
    inline bool get_PWRSTAT_USBPHYPDQ() volatile
    {
        return PWRSTAT & (1u << 16u);
    }

    /**
     * Get PWRSTAT's HIBEN bit.
     *
     * Hibernate Domain Enable Status
     */
    inline bool get_PWRSTAT_HIBEN() volatile
    {
        return PWRSTAT & (1u << 0u);
    }

    /**
     * Get all of PWRSTAT's bit fields.
     *
     * (read-only) PCU Status Register
     */
    inline void get_PWRSTAT(bool &USBPUWQ, bool &USBOTGEN, bool &USBPHYPDQ,
                            bool &HIBEN) volatile
    {
        uint32_t curr = PWRSTAT;

        USBPUWQ = curr & (1u << 18u);
        USBOTGEN = curr & (1u << 17u);
        USBPHYPDQ = curr & (1u << 16u);
        HIBEN = curr & (1u << 0u);
    }

    /**
     * Set PWRSET's USBPUWQ bit.
     *
     * Set USB Weak Pull-Up at PADN Enable
     */
    inline void set_PWRSET_USBPUWQ() volatile
    {
        PWRSET |= 1u << 18u;
    }

    /**
     * Clear PWRSET's USBPUWQ bit.
     *
     * Set USB Weak Pull-Up at PADN Enable
     */
    inline void clear_PWRSET_USBPUWQ() volatile
    {
        PWRSET &= ~(1u << 18u);
    }

    /**
     * Toggle PWRSET's USBPUWQ bit.
     *
     * Set USB Weak Pull-Up at PADN Enable
     */
    inline void toggle_PWRSET_USBPUWQ() volatile
    {
        PWRSET ^= 1u << 18u;
    }

    /**
     * Set PWRSET's USBOTGEN bit.
     *
     * Set USB On-The-Go Comparators Enable
     */
    inline void set_PWRSET_USBOTGEN() volatile
    {
        PWRSET |= 1u << 17u;
    }

    /**
     * Clear PWRSET's USBOTGEN bit.
     *
     * Set USB On-The-Go Comparators Enable
     */
    inline void clear_PWRSET_USBOTGEN() volatile
    {
        PWRSET &= ~(1u << 17u);
    }

    /**
     * Toggle PWRSET's USBOTGEN bit.
     *
     * Set USB On-The-Go Comparators Enable
     */
    inline void toggle_PWRSET_USBOTGEN() volatile
    {
        PWRSET ^= 1u << 17u;
    }

    /**
     * Set PWRSET's USBPHYPDQ bit.
     *
     * Set USB PHY Transceiver Disable
     */
    inline void set_PWRSET_USBPHYPDQ() volatile
    {
        PWRSET |= 1u << 16u;
    }

    /**
     * Clear PWRSET's USBPHYPDQ bit.
     *
     * Set USB PHY Transceiver Disable
     */
    inline void clear_PWRSET_USBPHYPDQ() volatile
    {
        PWRSET &= ~(1u << 16u);
    }

    /**
     * Toggle PWRSET's USBPHYPDQ bit.
     *
     * Set USB PHY Transceiver Disable
     */
    inline void toggle_PWRSET_USBPHYPDQ() volatile
    {
        PWRSET ^= 1u << 16u;
    }

    /**
     * Set PWRSET's HIB bit.
     *
     * Set Hibernate Domain Enable
     */
    inline void set_PWRSET_HIB() volatile
    {
        PWRSET |= 1u << 0u;
    }

    /**
     * Clear PWRSET's HIB bit.
     *
     * Set Hibernate Domain Enable
     */
    inline void clear_PWRSET_HIB() volatile
    {
        PWRSET &= ~(1u << 0u);
    }

    /**
     * Toggle PWRSET's HIB bit.
     *
     * Set Hibernate Domain Enable
     */
    inline void toggle_PWRSET_HIB() volatile
    {
        PWRSET ^= 1u << 0u;
    }

    /**
     * Set all of PWRSET's bit fields.
     *
     * (write-only) PCU Set Control Register
     */
    inline void set_PWRSET(bool USBPUWQ, bool USBOTGEN, bool USBPHYPDQ,
                           bool HIB) volatile
    {
        uint32_t curr = PWRSET;

        curr &= ~(0b1u << 18u);
        curr |= (USBPUWQ & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (USBOTGEN & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (USBPHYPDQ & 0b1u) << 16u;
        curr &= ~(0b1u << 0u);
        curr |= (HIB & 0b1u) << 0u;

        PWRSET = curr;
    }

    /**
     * Set PWRCLR's USBPUWQ bit.
     *
     * Clear USB Weak Pull-Up at PADN Enable
     */
    inline void set_PWRCLR_USBPUWQ() volatile
    {
        PWRCLR |= 1u << 18u;
    }

    /**
     * Clear PWRCLR's USBPUWQ bit.
     *
     * Clear USB Weak Pull-Up at PADN Enable
     */
    inline void clear_PWRCLR_USBPUWQ() volatile
    {
        PWRCLR &= ~(1u << 18u);
    }

    /**
     * Toggle PWRCLR's USBPUWQ bit.
     *
     * Clear USB Weak Pull-Up at PADN Enable
     */
    inline void toggle_PWRCLR_USBPUWQ() volatile
    {
        PWRCLR ^= 1u << 18u;
    }

    /**
     * Set PWRCLR's USBOTGEN bit.
     *
     * Clear USB On-The-Go Comparators Enable
     */
    inline void set_PWRCLR_USBOTGEN() volatile
    {
        PWRCLR |= 1u << 17u;
    }

    /**
     * Clear PWRCLR's USBOTGEN bit.
     *
     * Clear USB On-The-Go Comparators Enable
     */
    inline void clear_PWRCLR_USBOTGEN() volatile
    {
        PWRCLR &= ~(1u << 17u);
    }

    /**
     * Toggle PWRCLR's USBOTGEN bit.
     *
     * Clear USB On-The-Go Comparators Enable
     */
    inline void toggle_PWRCLR_USBOTGEN() volatile
    {
        PWRCLR ^= 1u << 17u;
    }

    /**
     * Set PWRCLR's USBPHYPDQ bit.
     *
     * Clear USB PHY Transceiver Disable
     */
    inline void set_PWRCLR_USBPHYPDQ() volatile
    {
        PWRCLR |= 1u << 16u;
    }

    /**
     * Clear PWRCLR's USBPHYPDQ bit.
     *
     * Clear USB PHY Transceiver Disable
     */
    inline void clear_PWRCLR_USBPHYPDQ() volatile
    {
        PWRCLR &= ~(1u << 16u);
    }

    /**
     * Toggle PWRCLR's USBPHYPDQ bit.
     *
     * Clear USB PHY Transceiver Disable
     */
    inline void toggle_PWRCLR_USBPHYPDQ() volatile
    {
        PWRCLR ^= 1u << 16u;
    }

    /**
     * Set PWRCLR's HIB bit.
     *
     * Clear Disable Hibernate Domain
     */
    inline void set_PWRCLR_HIB() volatile
    {
        PWRCLR |= 1u << 0u;
    }

    /**
     * Clear PWRCLR's HIB bit.
     *
     * Clear Disable Hibernate Domain
     */
    inline void clear_PWRCLR_HIB() volatile
    {
        PWRCLR &= ~(1u << 0u);
    }

    /**
     * Toggle PWRCLR's HIB bit.
     *
     * Clear Disable Hibernate Domain
     */
    inline void toggle_PWRCLR_HIB() volatile
    {
        PWRCLR ^= 1u << 0u;
    }

    /**
     * Set all of PWRCLR's bit fields.
     *
     * (write-only) PCU Clear Control Register
     */
    inline void set_PWRCLR(bool USBPUWQ, bool USBOTGEN, bool USBPHYPDQ,
                           bool HIB) volatile
    {
        uint32_t curr = PWRCLR;

        curr &= ~(0b1u << 18u);
        curr |= (USBPUWQ & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (USBOTGEN & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (USBPHYPDQ & 0b1u) << 16u;
        curr &= ~(0b1u << 0u);
        curr |= (HIB & 0b1u) << 0u;

        PWRCLR = curr;
    }

    /**
     * Get EVRSTAT's OV13 bit.
     *
     * Regulator Overvoltage for 1.3 V
     */
    inline bool get_EVRSTAT_OV13() volatile
    {
        return EVRSTAT & (1u << 1u);
    }

    /**
     * Get EVRVADCSTAT's VADC33V field.
     *
     * VADC 3.3 V Conversion Result
     */
    inline uint8_t get_EVRVADCSTAT_VADC33V() volatile
    {
        return (EVRVADCSTAT >> 8u) & 0b11111111u;
    }

    /**
     * Get EVRVADCSTAT's VADC13V field.
     *
     * VADC 1.3 V Conversion Result
     */
    inline uint8_t get_EVRVADCSTAT_VADC13V() volatile
    {
        return (EVRVADCSTAT >> 0u) & 0b11111111u;
    }

    /**
     * Get all of EVRVADCSTAT's bit fields.
     *
     * (read-only) EVR VADC Status Register
     */
    inline void get_EVRVADCSTAT(uint8_t &VADC33V, uint8_t &VADC13V) volatile
    {
        uint32_t curr = EVRVADCSTAT;

        VADC33V = (curr >> 8u) & 0b11111111u;
        VADC13V = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get PWRMON's ENB bit.
     *
     * Enable
     */
    inline bool get_PWRMON_ENB() volatile
    {
        return PWRMON & (1u << 16u);
    }

    /**
     * Set PWRMON's ENB bit.
     *
     * Enable
     */
    inline void set_PWRMON_ENB() volatile
    {
        PWRMON |= 1u << 16u;
    }

    /**
     * Clear PWRMON's ENB bit.
     *
     * Enable
     */
    inline void clear_PWRMON_ENB() volatile
    {
        PWRMON &= ~(1u << 16u);
    }

    /**
     * Toggle PWRMON's ENB bit.
     *
     * Enable
     */
    inline void toggle_PWRMON_ENB() volatile
    {
        PWRMON ^= 1u << 16u;
    }

    /**
     * Get PWRMON's INTV field.
     *
     * Interval
     */
    inline uint8_t get_PWRMON_INTV() volatile
    {
        return (PWRMON >> 8u) & 0b11111111u;
    }

    /**
     * Set PWRMON's INTV field.
     *
     * Interval
     */
    inline void set_PWRMON_INTV(uint8_t value) volatile
    {
        uint32_t curr = PWRMON;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        PWRMON = curr;
    }

    /**
     * Get PWRMON's THRS field.
     *
     * Threshold
     */
    inline uint8_t get_PWRMON_THRS() volatile
    {
        return (PWRMON >> 0u) & 0b11111111u;
    }

    /**
     * Set PWRMON's THRS field.
     *
     * Threshold
     */
    inline void set_PWRMON_THRS(uint8_t value) volatile
    {
        uint32_t curr = PWRMON;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        PWRMON = curr;
    }

    /**
     * Get all of PWRMON's bit fields.
     *
     * (read-write) Power Monitor Control
     */
    inline void get_PWRMON(bool &ENB, uint8_t &INTV, uint8_t &THRS) volatile
    {
        uint32_t curr = PWRMON;

        ENB = curr & (1u << 16u);
        INTV = (curr >> 8u) & 0b11111111u;
        THRS = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of PWRMON's bit fields.
     *
     * (read-write) Power Monitor Control
     */
    inline void set_PWRMON(bool ENB, uint8_t INTV, uint8_t THRS) volatile
    {
        uint32_t curr = PWRMON;

        curr &= ~(0b1u << 16u);
        curr |= (ENB & 0b1u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (INTV & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (THRS & 0b11111111u) << 0u;

        PWRMON = curr;
    }
};

static_assert(sizeof(scu_power) == scu_power::size);

static volatile scu_power *const SCU_POWER =
    reinterpret_cast<scu_power *>(0x50004200);

}; // namespace XMC4700
