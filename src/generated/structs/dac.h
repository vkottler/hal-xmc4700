/**
 * \file
 * \brief Generated by ifgen (3.2.0).
 */
#pragma once

#include "../enums/DAC_DAC0CFG0_MODE.h"
#include "../enums/DAC_DAC0CFG1_SCALE.h"
#include "../enums/DAC_DAC0CFG1_TRIGMOD.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * Digital to Analog Converter
 */
struct [[gnu::packed]] dac
{
    /* Constant attributes. */
    static constexpr std::size_t size = 48; /*!< dac's size in bytes. */

    /* Fields. */
    const uint32_t ID = {}; /*!< (read-only) Module Identification Register */
    uint32_t DAC0CFG0;      /*!< (read-write) DAC0 Configuration Register 0 */
    uint32_t DAC0CFG1;      /*!< (read-write) DAC0 Configuration Register 1 */
    uint32_t DAC1CFG0;      /*!< (read-write) DAC1 Configuration Register 0 */
    uint32_t DAC1CFG1;      /*!< (read-write) DAC1 Configuration Register 1 */
    uint32_t DAC0DATA;      /*!< (read-write) DAC0 Data Register */
    uint32_t DAC1DATA;      /*!< (read-write) DAC1 Data Register */
    uint32_t DAC01DATA;     /*!< (read-write) DAC01 Data Register */
    uint32_t DAC0PATL;      /*!< (read-write) DAC0 Lower Pattern Register */
    uint32_t DAC0PATH;      /*!< (read-write) DAC0 Higher Pattern Register */
    uint32_t DAC1PATL;      /*!< (read-write) DAC1 Lower Pattern Register */
    uint32_t DAC1PATH;      /*!< (read-write) DAC1 Higher Pattern Register */

    /* Methods. */

    /**
     * Get ID's MODN field.
     *
     * Module Number
     */
    inline uint16_t get_ID_MODN() volatile
    {
        return (ID >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get ID's MODT field.
     *
     * Module Type
     */
    inline uint8_t get_ID_MODT() volatile
    {
        return (ID >> 8u) & 0b11111111u;
    }

    /**
     * Get ID's MODR field.
     *
     * Module Revision
     */
    inline uint8_t get_ID_MODR() volatile
    {
        return (ID >> 0u) & 0b11111111u;
    }

    /**
     * Get all of ID's bit fields.
     *
     * (read-only) Module Identification Register
     */
    inline void get_ID(uint16_t &MODN, uint8_t &MODT, uint8_t &MODR) volatile
    {
        uint32_t curr = ID;

        MODN = (curr >> 16u) & 0b1111111111111111u;
        MODT = (curr >> 8u) & 0b11111111u;
        MODR = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get DAC0CFG0's RUN bit.
     *
     * RUN indicates the current DAC0 operation status
     */
    inline bool get_DAC0CFG0_RUN() volatile
    {
        return DAC0CFG0 & (1u << 31u);
    }

    /**
     * Get DAC0CFG0's SREN bit.
     *
     * Enable DAC0 service request interrupt generation
     */
    inline bool get_DAC0CFG0_SREN() volatile
    {
        return DAC0CFG0 & (1u << 30u);
    }

    /**
     * Set DAC0CFG0's SREN bit.
     *
     * Enable DAC0 service request interrupt generation
     */
    inline void set_DAC0CFG0_SREN() volatile
    {
        DAC0CFG0 |= 1u << 30u;
    }

    /**
     * Clear DAC0CFG0's SREN bit.
     *
     * Enable DAC0 service request interrupt generation
     */
    inline void clear_DAC0CFG0_SREN() volatile
    {
        DAC0CFG0 &= ~(1u << 30u);
    }

    /**
     * Toggle DAC0CFG0's SREN bit.
     *
     * Enable DAC0 service request interrupt generation
     */
    inline void toggle_DAC0CFG0_SREN() volatile
    {
        DAC0CFG0 ^= 1u << 30u;
    }

    /**
     * Get DAC0CFG0's SIGNEN bit.
     *
     * Enable Sign Output of DAC0 Pattern Generator
     */
    inline bool get_DAC0CFG0_SIGNEN() volatile
    {
        return DAC0CFG0 & (1u << 29u);
    }

    /**
     * Set DAC0CFG0's SIGNEN bit.
     *
     * Enable Sign Output of DAC0 Pattern Generator
     */
    inline void set_DAC0CFG0_SIGNEN() volatile
    {
        DAC0CFG0 |= 1u << 29u;
    }

    /**
     * Clear DAC0CFG0's SIGNEN bit.
     *
     * Enable Sign Output of DAC0 Pattern Generator
     */
    inline void clear_DAC0CFG0_SIGNEN() volatile
    {
        DAC0CFG0 &= ~(1u << 29u);
    }

    /**
     * Toggle DAC0CFG0's SIGNEN bit.
     *
     * Enable Sign Output of DAC0 Pattern Generator
     */
    inline void toggle_DAC0CFG0_SIGNEN() volatile
    {
        DAC0CFG0 ^= 1u << 29u;
    }

    /**
     * Get DAC0CFG0's NEGATE bit.
     *
     * Negates the DAC0 output
     */
    inline bool get_DAC0CFG0_NEGATE() volatile
    {
        return DAC0CFG0 & (1u << 28u);
    }

    /**
     * Set DAC0CFG0's NEGATE bit.
     *
     * Negates the DAC0 output
     */
    inline void set_DAC0CFG0_NEGATE() volatile
    {
        DAC0CFG0 |= 1u << 28u;
    }

    /**
     * Clear DAC0CFG0's NEGATE bit.
     *
     * Negates the DAC0 output
     */
    inline void clear_DAC0CFG0_NEGATE() volatile
    {
        DAC0CFG0 &= ~(1u << 28u);
    }

    /**
     * Toggle DAC0CFG0's NEGATE bit.
     *
     * Negates the DAC0 output
     */
    inline void toggle_DAC0CFG0_NEGATE() volatile
    {
        DAC0CFG0 ^= 1u << 28u;
    }

    /**
     * Get DAC0CFG0's FIFOFUL bit.
     *
     * Indicate if the FIFO is full
     */
    inline bool get_DAC0CFG0_FIFOFUL() volatile
    {
        return DAC0CFG0 & (1u << 27u);
    }

    /**
     * Get DAC0CFG0's FIFOEMP bit.
     *
     * Indicate if the FIFO is empty
     */
    inline bool get_DAC0CFG0_FIFOEMP() volatile
    {
        return DAC0CFG0 & (1u << 26u);
    }

    /**
     * Get DAC0CFG0's FIFOIND field.
     *
     * Current write position inside the data FIFO
     */
    inline uint8_t get_DAC0CFG0_FIFOIND() volatile
    {
        return (DAC0CFG0 >> 24u) & 0b11u;
    }

    /**
     * Get DAC0CFG0's SIGN bit.
     *
     * Selects Between Signed and Unsigned DAC0 Mode
     */
    inline bool get_DAC0CFG0_SIGN() volatile
    {
        return DAC0CFG0 & (1u << 23u);
    }

    /**
     * Set DAC0CFG0's SIGN bit.
     *
     * Selects Between Signed and Unsigned DAC0 Mode
     */
    inline void set_DAC0CFG0_SIGN() volatile
    {
        DAC0CFG0 |= 1u << 23u;
    }

    /**
     * Clear DAC0CFG0's SIGN bit.
     *
     * Selects Between Signed and Unsigned DAC0 Mode
     */
    inline void clear_DAC0CFG0_SIGN() volatile
    {
        DAC0CFG0 &= ~(1u << 23u);
    }

    /**
     * Toggle DAC0CFG0's SIGN bit.
     *
     * Selects Between Signed and Unsigned DAC0 Mode
     */
    inline void toggle_DAC0CFG0_SIGN() volatile
    {
        DAC0CFG0 ^= 1u << 23u;
    }

    /**
     * Get DAC0CFG0's MODE field.
     *
     * Enables and Sets the Mode for DAC0
     */
    inline DAC_DAC0CFG0_MODE get_DAC0CFG0_MODE() volatile
    {
        return DAC_DAC0CFG0_MODE((DAC0CFG0 >> 20u) & 0b111u);
    }

    /**
     * Set DAC0CFG0's MODE field.
     *
     * Enables and Sets the Mode for DAC0
     */
    inline void set_DAC0CFG0_MODE(DAC_DAC0CFG0_MODE value) volatile
    {
        uint32_t curr = DAC0CFG0;

        curr &= ~(0b111u << 20u);
        curr |= (std::to_underlying(value) & 0b111u) << 20u;

        DAC0CFG0 = curr;
    }

    /**
     * Get DAC0CFG0's FREQ field.
     *
     * Integer Frequency Divider Value
     */
    inline uint32_t get_DAC0CFG0_FREQ() volatile
    {
        return (DAC0CFG0 >> 0u) & 0b11111111111111111111u;
    }

    /**
     * Set DAC0CFG0's FREQ field.
     *
     * Integer Frequency Divider Value
     */
    inline void set_DAC0CFG0_FREQ(uint32_t value) volatile
    {
        uint32_t curr = DAC0CFG0;

        curr &= ~(0b11111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111u) << 0u;

        DAC0CFG0 = curr;
    }

    /**
     * Get all of DAC0CFG0's bit fields.
     *
     * (read-write) DAC0 Configuration Register 0
     */
    inline void get_DAC0CFG0(bool &RUN, bool &SREN, bool &SIGNEN, bool &NEGATE,
                             bool &FIFOFUL, bool &FIFOEMP, uint8_t &FIFOIND,
                             bool &SIGN, DAC_DAC0CFG0_MODE &MODE,
                             uint32_t &FREQ) volatile
    {
        uint32_t curr = DAC0CFG0;

        RUN = curr & (1u << 31u);
        SREN = curr & (1u << 30u);
        SIGNEN = curr & (1u << 29u);
        NEGATE = curr & (1u << 28u);
        FIFOFUL = curr & (1u << 27u);
        FIFOEMP = curr & (1u << 26u);
        FIFOIND = (curr >> 24u) & 0b11u;
        SIGN = curr & (1u << 23u);
        MODE = DAC_DAC0CFG0_MODE((curr >> 20u) & 0b111u);
        FREQ = (curr >> 0u) & 0b11111111111111111111u;
    }

    /**
     * Set all of DAC0CFG0's bit fields.
     *
     * (read-write) DAC0 Configuration Register 0
     */
    inline void set_DAC0CFG0(bool SREN, bool SIGNEN, bool NEGATE, bool SIGN,
                             DAC_DAC0CFG0_MODE MODE, uint32_t FREQ) volatile
    {
        uint32_t curr = DAC0CFG0;

        curr &= ~(0b1u << 30u);
        curr |= (SREN & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (SIGNEN & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (NEGATE & 0b1u) << 28u;
        curr &= ~(0b1u << 23u);
        curr |= (SIGN & 0b1u) << 23u;
        curr &= ~(0b111u << 20u);
        curr |= (std::to_underlying(MODE) & 0b111u) << 20u;
        curr &= ~(0b11111111111111111111u << 0u);
        curr |= (FREQ & 0b11111111111111111111u) << 0u;

        DAC0CFG0 = curr;
    }

    /**
     * Get DAC0CFG1's REFCFGL field.
     *
     * Lower 4 band-gap configuration/calibration parameters
     */
    inline uint8_t get_DAC0CFG1_REFCFGL() volatile
    {
        return (DAC0CFG1 >> 28u) & 0b1111u;
    }

    /**
     * Set DAC0CFG1's REFCFGL field.
     *
     * Lower 4 band-gap configuration/calibration parameters
     */
    inline void set_DAC0CFG1_REFCFGL(uint8_t value) volatile
    {
        uint32_t curr = DAC0CFG1;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        DAC0CFG1 = curr;
    }

    /**
     * Get DAC0CFG1's ANAEN bit.
     *
     * Enable analog DAC for channel 0
     */
    inline bool get_DAC0CFG1_ANAEN() volatile
    {
        return DAC0CFG1 & (1u << 24u);
    }

    /**
     * Set DAC0CFG1's ANAEN bit.
     *
     * Enable analog DAC for channel 0
     */
    inline void set_DAC0CFG1_ANAEN() volatile
    {
        DAC0CFG1 |= 1u << 24u;
    }

    /**
     * Clear DAC0CFG1's ANAEN bit.
     *
     * Enable analog DAC for channel 0
     */
    inline void clear_DAC0CFG1_ANAEN() volatile
    {
        DAC0CFG1 &= ~(1u << 24u);
    }

    /**
     * Toggle DAC0CFG1's ANAEN bit.
     *
     * Enable analog DAC for channel 0
     */
    inline void toggle_DAC0CFG1_ANAEN() volatile
    {
        DAC0CFG1 ^= 1u << 24u;
    }

    /**
     * Get DAC0CFG1's ANACFG field.
     *
     * DAC0 analog configuration/calibration parameters
     */
    inline uint8_t get_DAC0CFG1_ANACFG() volatile
    {
        return (DAC0CFG1 >> 19u) & 0b11111u;
    }

    /**
     * Set DAC0CFG1's ANACFG field.
     *
     * DAC0 analog configuration/calibration parameters
     */
    inline void set_DAC0CFG1_ANACFG(uint8_t value) volatile
    {
        uint32_t curr = DAC0CFG1;

        curr &= ~(0b11111u << 19u);
        curr |= (value & 0b11111u) << 19u;

        DAC0CFG1 = curr;
    }

    /**
     * Get DAC0CFG1's TRIGMOD field.
     *
     * Select the trigger source for channel 0
     */
    inline DAC_DAC0CFG1_TRIGMOD get_DAC0CFG1_TRIGMOD() volatile
    {
        return DAC_DAC0CFG1_TRIGMOD((DAC0CFG1 >> 17u) & 0b11u);
    }

    /**
     * Set DAC0CFG1's TRIGMOD field.
     *
     * Select the trigger source for channel 0
     */
    inline void set_DAC0CFG1_TRIGMOD(DAC_DAC0CFG1_TRIGMOD value) volatile
    {
        uint32_t curr = DAC0CFG1;

        curr &= ~(0b11u << 17u);
        curr |= (std::to_underlying(value) & 0b11u) << 17u;

        DAC0CFG1 = curr;
    }

    /**
     * Get DAC0CFG1's SWTRIG bit.
     *
     * Software Trigger
     */
    inline bool get_DAC0CFG1_SWTRIG() volatile
    {
        return DAC0CFG1 & (1u << 16u);
    }

    /**
     * Set DAC0CFG1's SWTRIG bit.
     *
     * Software Trigger
     */
    inline void set_DAC0CFG1_SWTRIG() volatile
    {
        DAC0CFG1 |= 1u << 16u;
    }

    /**
     * Clear DAC0CFG1's SWTRIG bit.
     *
     * Software Trigger
     */
    inline void clear_DAC0CFG1_SWTRIG() volatile
    {
        DAC0CFG1 &= ~(1u << 16u);
    }

    /**
     * Toggle DAC0CFG1's SWTRIG bit.
     *
     * Software Trigger
     */
    inline void toggle_DAC0CFG1_SWTRIG() volatile
    {
        DAC0CFG1 ^= 1u << 16u;
    }

    /**
     * Get DAC0CFG1's DATMOD bit.
     *
     * Switch between independent or simultaneous DAC mode and select the input
     * data register for DAC0 and DAC1
     */
    inline bool get_DAC0CFG1_DATMOD() volatile
    {
        return DAC0CFG1 & (1u << 15u);
    }

    /**
     * Set DAC0CFG1's DATMOD bit.
     *
     * Switch between independent or simultaneous DAC mode and select the input
     * data register for DAC0 and DAC1
     */
    inline void set_DAC0CFG1_DATMOD() volatile
    {
        DAC0CFG1 |= 1u << 15u;
    }

    /**
     * Clear DAC0CFG1's DATMOD bit.
     *
     * Switch between independent or simultaneous DAC mode and select the input
     * data register for DAC0 and DAC1
     */
    inline void clear_DAC0CFG1_DATMOD() volatile
    {
        DAC0CFG1 &= ~(1u << 15u);
    }

    /**
     * Toggle DAC0CFG1's DATMOD bit.
     *
     * Switch between independent or simultaneous DAC mode and select the input
     * data register for DAC0 and DAC1
     */
    inline void toggle_DAC0CFG1_DATMOD() volatile
    {
        DAC0CFG1 ^= 1u << 15u;
    }

    /**
     * Get DAC0CFG1's TRIGSEL field.
     *
     * Selects one of the eight external trigger sources for DAC0
     */
    inline uint8_t get_DAC0CFG1_TRIGSEL() volatile
    {
        return (DAC0CFG1 >> 12u) & 0b111u;
    }

    /**
     * Set DAC0CFG1's TRIGSEL field.
     *
     * Selects one of the eight external trigger sources for DAC0
     */
    inline void set_DAC0CFG1_TRIGSEL(uint8_t value) volatile
    {
        uint32_t curr = DAC0CFG1;

        curr &= ~(0b111u << 12u);
        curr |= (value & 0b111u) << 12u;

        DAC0CFG1 = curr;
    }

    /**
     * Get DAC0CFG1's OFFS field.
     *
     * 8-bit offset value addition
     */
    inline uint8_t get_DAC0CFG1_OFFS() volatile
    {
        return (DAC0CFG1 >> 4u) & 0b11111111u;
    }

    /**
     * Set DAC0CFG1's OFFS field.
     *
     * 8-bit offset value addition
     */
    inline void set_DAC0CFG1_OFFS(uint8_t value) volatile
    {
        uint32_t curr = DAC0CFG1;

        curr &= ~(0b11111111u << 4u);
        curr |= (value & 0b11111111u) << 4u;

        DAC0CFG1 = curr;
    }

    /**
     * Get DAC0CFG1's MULDIV bit.
     *
     * Switch between up- and downscale of the DAC0 input data values
     */
    inline bool get_DAC0CFG1_MULDIV() volatile
    {
        return DAC0CFG1 & (1u << 3u);
    }

    /**
     * Set DAC0CFG1's MULDIV bit.
     *
     * Switch between up- and downscale of the DAC0 input data values
     */
    inline void set_DAC0CFG1_MULDIV() volatile
    {
        DAC0CFG1 |= 1u << 3u;
    }

    /**
     * Clear DAC0CFG1's MULDIV bit.
     *
     * Switch between up- and downscale of the DAC0 input data values
     */
    inline void clear_DAC0CFG1_MULDIV() volatile
    {
        DAC0CFG1 &= ~(1u << 3u);
    }

    /**
     * Toggle DAC0CFG1's MULDIV bit.
     *
     * Switch between up- and downscale of the DAC0 input data values
     */
    inline void toggle_DAC0CFG1_MULDIV() volatile
    {
        DAC0CFG1 ^= 1u << 3u;
    }

    /**
     * Get DAC0CFG1's SCALE field.
     *
     * Scale value for up- or downscale of the DAC0 input data in steps by the
     * power of 2 (=shift operation)
     */
    inline DAC_DAC0CFG1_SCALE get_DAC0CFG1_SCALE() volatile
    {
        return DAC_DAC0CFG1_SCALE((DAC0CFG1 >> 0u) & 0b111u);
    }

    /**
     * Set DAC0CFG1's SCALE field.
     *
     * Scale value for up- or downscale of the DAC0 input data in steps by the
     * power of 2 (=shift operation)
     */
    inline void set_DAC0CFG1_SCALE(DAC_DAC0CFG1_SCALE value) volatile
    {
        uint32_t curr = DAC0CFG1;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        DAC0CFG1 = curr;
    }

    /**
     * Get all of DAC0CFG1's bit fields.
     *
     * (read-write) DAC0 Configuration Register 1
     */
    inline void get_DAC0CFG1(uint8_t &REFCFGL, bool &ANAEN, uint8_t &ANACFG,
                             DAC_DAC0CFG1_TRIGMOD &TRIGMOD, bool &SWTRIG,
                             bool &DATMOD, uint8_t &TRIGSEL, uint8_t &OFFS,
                             bool &MULDIV, DAC_DAC0CFG1_SCALE &SCALE) volatile
    {
        uint32_t curr = DAC0CFG1;

        REFCFGL = (curr >> 28u) & 0b1111u;
        ANAEN = curr & (1u << 24u);
        ANACFG = (curr >> 19u) & 0b11111u;
        TRIGMOD = DAC_DAC0CFG1_TRIGMOD((curr >> 17u) & 0b11u);
        SWTRIG = curr & (1u << 16u);
        DATMOD = curr & (1u << 15u);
        TRIGSEL = (curr >> 12u) & 0b111u;
        OFFS = (curr >> 4u) & 0b11111111u;
        MULDIV = curr & (1u << 3u);
        SCALE = DAC_DAC0CFG1_SCALE((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of DAC0CFG1's bit fields.
     *
     * (read-write) DAC0 Configuration Register 1
     */
    inline void set_DAC0CFG1(uint8_t REFCFGL, bool ANAEN, uint8_t ANACFG,
                             DAC_DAC0CFG1_TRIGMOD TRIGMOD, bool SWTRIG,
                             bool DATMOD, uint8_t TRIGSEL, uint8_t OFFS,
                             bool MULDIV, DAC_DAC0CFG1_SCALE SCALE) volatile
    {
        uint32_t curr = DAC0CFG1;

        curr &= ~(0b1111u << 28u);
        curr |= (REFCFGL & 0b1111u) << 28u;
        curr &= ~(0b1u << 24u);
        curr |= (ANAEN & 0b1u) << 24u;
        curr &= ~(0b11111u << 19u);
        curr |= (ANACFG & 0b11111u) << 19u;
        curr &= ~(0b11u << 17u);
        curr |= (std::to_underlying(TRIGMOD) & 0b11u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (SWTRIG & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (DATMOD & 0b1u) << 15u;
        curr &= ~(0b111u << 12u);
        curr |= (TRIGSEL & 0b111u) << 12u;
        curr &= ~(0b11111111u << 4u);
        curr |= (OFFS & 0b11111111u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (MULDIV & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(SCALE) & 0b111u) << 0u;

        DAC0CFG1 = curr;
    }

    /**
     * Get DAC1CFG0's RUN bit.
     *
     * RUN indicates the current DAC1 operation status
     */
    inline bool get_DAC1CFG0_RUN() volatile
    {
        return DAC1CFG0 & (1u << 31u);
    }

    /**
     * Get DAC1CFG0's SREN bit.
     *
     * Enable DAC1 service request interrupt generation
     */
    inline bool get_DAC1CFG0_SREN() volatile
    {
        return DAC1CFG0 & (1u << 30u);
    }

    /**
     * Set DAC1CFG0's SREN bit.
     *
     * Enable DAC1 service request interrupt generation
     */
    inline void set_DAC1CFG0_SREN() volatile
    {
        DAC1CFG0 |= 1u << 30u;
    }

    /**
     * Clear DAC1CFG0's SREN bit.
     *
     * Enable DAC1 service request interrupt generation
     */
    inline void clear_DAC1CFG0_SREN() volatile
    {
        DAC1CFG0 &= ~(1u << 30u);
    }

    /**
     * Toggle DAC1CFG0's SREN bit.
     *
     * Enable DAC1 service request interrupt generation
     */
    inline void toggle_DAC1CFG0_SREN() volatile
    {
        DAC1CFG0 ^= 1u << 30u;
    }

    /**
     * Get DAC1CFG0's SIGNEN bit.
     *
     * Enable sign output of DAC1 pattern generator
     */
    inline bool get_DAC1CFG0_SIGNEN() volatile
    {
        return DAC1CFG0 & (1u << 29u);
    }

    /**
     * Set DAC1CFG0's SIGNEN bit.
     *
     * Enable sign output of DAC1 pattern generator
     */
    inline void set_DAC1CFG0_SIGNEN() volatile
    {
        DAC1CFG0 |= 1u << 29u;
    }

    /**
     * Clear DAC1CFG0's SIGNEN bit.
     *
     * Enable sign output of DAC1 pattern generator
     */
    inline void clear_DAC1CFG0_SIGNEN() volatile
    {
        DAC1CFG0 &= ~(1u << 29u);
    }

    /**
     * Toggle DAC1CFG0's SIGNEN bit.
     *
     * Enable sign output of DAC1 pattern generator
     */
    inline void toggle_DAC1CFG0_SIGNEN() volatile
    {
        DAC1CFG0 ^= 1u << 29u;
    }

    /**
     * Get DAC1CFG0's NEGATE bit.
     *
     * Negates the DAC1 output
     */
    inline bool get_DAC1CFG0_NEGATE() volatile
    {
        return DAC1CFG0 & (1u << 28u);
    }

    /**
     * Set DAC1CFG0's NEGATE bit.
     *
     * Negates the DAC1 output
     */
    inline void set_DAC1CFG0_NEGATE() volatile
    {
        DAC1CFG0 |= 1u << 28u;
    }

    /**
     * Clear DAC1CFG0's NEGATE bit.
     *
     * Negates the DAC1 output
     */
    inline void clear_DAC1CFG0_NEGATE() volatile
    {
        DAC1CFG0 &= ~(1u << 28u);
    }

    /**
     * Toggle DAC1CFG0's NEGATE bit.
     *
     * Negates the DAC1 output
     */
    inline void toggle_DAC1CFG0_NEGATE() volatile
    {
        DAC1CFG0 ^= 1u << 28u;
    }

    /**
     * Get DAC1CFG0's FIFOFUL bit.
     *
     * Indicate if the FIFO is full
     */
    inline bool get_DAC1CFG0_FIFOFUL() volatile
    {
        return DAC1CFG0 & (1u << 27u);
    }

    /**
     * Get DAC1CFG0's FIFOEMP bit.
     *
     * Indicate if the FIFO is empty
     */
    inline bool get_DAC1CFG0_FIFOEMP() volatile
    {
        return DAC1CFG0 & (1u << 26u);
    }

    /**
     * Get DAC1CFG0's FIFOIND field.
     *
     * Current write position inside the data FIFO
     */
    inline uint8_t get_DAC1CFG0_FIFOIND() volatile
    {
        return (DAC1CFG0 >> 24u) & 0b11u;
    }

    /**
     * Get DAC1CFG0's SIGN bit.
     *
     * Selects between signed and unsigned DAC1 mode
     */
    inline bool get_DAC1CFG0_SIGN() volatile
    {
        return DAC1CFG0 & (1u << 23u);
    }

    /**
     * Set DAC1CFG0's SIGN bit.
     *
     * Selects between signed and unsigned DAC1 mode
     */
    inline void set_DAC1CFG0_SIGN() volatile
    {
        DAC1CFG0 |= 1u << 23u;
    }

    /**
     * Clear DAC1CFG0's SIGN bit.
     *
     * Selects between signed and unsigned DAC1 mode
     */
    inline void clear_DAC1CFG0_SIGN() volatile
    {
        DAC1CFG0 &= ~(1u << 23u);
    }

    /**
     * Toggle DAC1CFG0's SIGN bit.
     *
     * Selects between signed and unsigned DAC1 mode
     */
    inline void toggle_DAC1CFG0_SIGN() volatile
    {
        DAC1CFG0 ^= 1u << 23u;
    }

    /**
     * Get DAC1CFG0's MODE field.
     *
     * Enables and sets the Mode for DAC1
     */
    inline DAC_DAC0CFG0_MODE get_DAC1CFG0_MODE() volatile
    {
        return DAC_DAC0CFG0_MODE((DAC1CFG0 >> 20u) & 0b111u);
    }

    /**
     * Set DAC1CFG0's MODE field.
     *
     * Enables and sets the Mode for DAC1
     */
    inline void set_DAC1CFG0_MODE(DAC_DAC0CFG0_MODE value) volatile
    {
        uint32_t curr = DAC1CFG0;

        curr &= ~(0b111u << 20u);
        curr |= (std::to_underlying(value) & 0b111u) << 20u;

        DAC1CFG0 = curr;
    }

    /**
     * Get DAC1CFG0's FREQ field.
     *
     * Integer Frequency Divider Value
     */
    inline uint32_t get_DAC1CFG0_FREQ() volatile
    {
        return (DAC1CFG0 >> 0u) & 0b11111111111111111111u;
    }

    /**
     * Set DAC1CFG0's FREQ field.
     *
     * Integer Frequency Divider Value
     */
    inline void set_DAC1CFG0_FREQ(uint32_t value) volatile
    {
        uint32_t curr = DAC1CFG0;

        curr &= ~(0b11111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111u) << 0u;

        DAC1CFG0 = curr;
    }

    /**
     * Get all of DAC1CFG0's bit fields.
     *
     * (read-write) DAC1 Configuration Register 0
     */
    inline void get_DAC1CFG0(bool &RUN, bool &SREN, bool &SIGNEN, bool &NEGATE,
                             bool &FIFOFUL, bool &FIFOEMP, uint8_t &FIFOIND,
                             bool &SIGN, DAC_DAC0CFG0_MODE &MODE,
                             uint32_t &FREQ) volatile
    {
        uint32_t curr = DAC1CFG0;

        RUN = curr & (1u << 31u);
        SREN = curr & (1u << 30u);
        SIGNEN = curr & (1u << 29u);
        NEGATE = curr & (1u << 28u);
        FIFOFUL = curr & (1u << 27u);
        FIFOEMP = curr & (1u << 26u);
        FIFOIND = (curr >> 24u) & 0b11u;
        SIGN = curr & (1u << 23u);
        MODE = DAC_DAC0CFG0_MODE((curr >> 20u) & 0b111u);
        FREQ = (curr >> 0u) & 0b11111111111111111111u;
    }

    /**
     * Set all of DAC1CFG0's bit fields.
     *
     * (read-write) DAC1 Configuration Register 0
     */
    inline void set_DAC1CFG0(bool SREN, bool SIGNEN, bool NEGATE, bool SIGN,
                             DAC_DAC0CFG0_MODE MODE, uint32_t FREQ) volatile
    {
        uint32_t curr = DAC1CFG0;

        curr &= ~(0b1u << 30u);
        curr |= (SREN & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (SIGNEN & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (NEGATE & 0b1u) << 28u;
        curr &= ~(0b1u << 23u);
        curr |= (SIGN & 0b1u) << 23u;
        curr &= ~(0b111u << 20u);
        curr |= (std::to_underlying(MODE) & 0b111u) << 20u;
        curr &= ~(0b11111111111111111111u << 0u);
        curr |= (FREQ & 0b11111111111111111111u) << 0u;

        DAC1CFG0 = curr;
    }

    /**
     * Get DAC1CFG1's REFCFGH field.
     *
     * Higher 4 band-gap configuration/calibration parameters
     */
    inline uint8_t get_DAC1CFG1_REFCFGH() volatile
    {
        return (DAC1CFG1 >> 28u) & 0b1111u;
    }

    /**
     * Set DAC1CFG1's REFCFGH field.
     *
     * Higher 4 band-gap configuration/calibration parameters
     */
    inline void set_DAC1CFG1_REFCFGH(uint8_t value) volatile
    {
        uint32_t curr = DAC1CFG1;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        DAC1CFG1 = curr;
    }

    /**
     * Get DAC1CFG1's ANAEN bit.
     *
     * Enable analog DAC for channel 1
     */
    inline bool get_DAC1CFG1_ANAEN() volatile
    {
        return DAC1CFG1 & (1u << 24u);
    }

    /**
     * Set DAC1CFG1's ANAEN bit.
     *
     * Enable analog DAC for channel 1
     */
    inline void set_DAC1CFG1_ANAEN() volatile
    {
        DAC1CFG1 |= 1u << 24u;
    }

    /**
     * Clear DAC1CFG1's ANAEN bit.
     *
     * Enable analog DAC for channel 1
     */
    inline void clear_DAC1CFG1_ANAEN() volatile
    {
        DAC1CFG1 &= ~(1u << 24u);
    }

    /**
     * Toggle DAC1CFG1's ANAEN bit.
     *
     * Enable analog DAC for channel 1
     */
    inline void toggle_DAC1CFG1_ANAEN() volatile
    {
        DAC1CFG1 ^= 1u << 24u;
    }

    /**
     * Get DAC1CFG1's ANACFG field.
     *
     * DAC1 analog configuration/calibration parameters
     */
    inline uint8_t get_DAC1CFG1_ANACFG() volatile
    {
        return (DAC1CFG1 >> 19u) & 0b11111u;
    }

    /**
     * Set DAC1CFG1's ANACFG field.
     *
     * DAC1 analog configuration/calibration parameters
     */
    inline void set_DAC1CFG1_ANACFG(uint8_t value) volatile
    {
        uint32_t curr = DAC1CFG1;

        curr &= ~(0b11111u << 19u);
        curr |= (value & 0b11111u) << 19u;

        DAC1CFG1 = curr;
    }

    /**
     * Get DAC1CFG1's TRIGMOD field.
     *
     * Select the trigger source for channel 1
     */
    inline DAC_DAC0CFG1_TRIGMOD get_DAC1CFG1_TRIGMOD() volatile
    {
        return DAC_DAC0CFG1_TRIGMOD((DAC1CFG1 >> 17u) & 0b11u);
    }

    /**
     * Set DAC1CFG1's TRIGMOD field.
     *
     * Select the trigger source for channel 1
     */
    inline void set_DAC1CFG1_TRIGMOD(DAC_DAC0CFG1_TRIGMOD value) volatile
    {
        uint32_t curr = DAC1CFG1;

        curr &= ~(0b11u << 17u);
        curr |= (std::to_underlying(value) & 0b11u) << 17u;

        DAC1CFG1 = curr;
    }

    /**
     * Get DAC1CFG1's SWTRIG bit.
     *
     * Software Trigger
     */
    inline bool get_DAC1CFG1_SWTRIG() volatile
    {
        return DAC1CFG1 & (1u << 16u);
    }

    /**
     * Set DAC1CFG1's SWTRIG bit.
     *
     * Software Trigger
     */
    inline void set_DAC1CFG1_SWTRIG() volatile
    {
        DAC1CFG1 |= 1u << 16u;
    }

    /**
     * Clear DAC1CFG1's SWTRIG bit.
     *
     * Software Trigger
     */
    inline void clear_DAC1CFG1_SWTRIG() volatile
    {
        DAC1CFG1 &= ~(1u << 16u);
    }

    /**
     * Toggle DAC1CFG1's SWTRIG bit.
     *
     * Software Trigger
     */
    inline void toggle_DAC1CFG1_SWTRIG() volatile
    {
        DAC1CFG1 ^= 1u << 16u;
    }

    /**
     * Get DAC1CFG1's TRIGSEL field.
     *
     * Selects one of the eight external trigger sources for DAC1
     */
    inline uint8_t get_DAC1CFG1_TRIGSEL() volatile
    {
        return (DAC1CFG1 >> 12u) & 0b111u;
    }

    /**
     * Set DAC1CFG1's TRIGSEL field.
     *
     * Selects one of the eight external trigger sources for DAC1
     */
    inline void set_DAC1CFG1_TRIGSEL(uint8_t value) volatile
    {
        uint32_t curr = DAC1CFG1;

        curr &= ~(0b111u << 12u);
        curr |= (value & 0b111u) << 12u;

        DAC1CFG1 = curr;
    }

    /**
     * Get DAC1CFG1's OFFS field.
     *
     * 8-bit offset value addition
     */
    inline uint8_t get_DAC1CFG1_OFFS() volatile
    {
        return (DAC1CFG1 >> 4u) & 0b11111111u;
    }

    /**
     * Set DAC1CFG1's OFFS field.
     *
     * 8-bit offset value addition
     */
    inline void set_DAC1CFG1_OFFS(uint8_t value) volatile
    {
        uint32_t curr = DAC1CFG1;

        curr &= ~(0b11111111u << 4u);
        curr |= (value & 0b11111111u) << 4u;

        DAC1CFG1 = curr;
    }

    /**
     * Get DAC1CFG1's MULDIV bit.
     *
     * Switch between up- and downscale of the DAC1 input data values
     */
    inline bool get_DAC1CFG1_MULDIV() volatile
    {
        return DAC1CFG1 & (1u << 3u);
    }

    /**
     * Set DAC1CFG1's MULDIV bit.
     *
     * Switch between up- and downscale of the DAC1 input data values
     */
    inline void set_DAC1CFG1_MULDIV() volatile
    {
        DAC1CFG1 |= 1u << 3u;
    }

    /**
     * Clear DAC1CFG1's MULDIV bit.
     *
     * Switch between up- and downscale of the DAC1 input data values
     */
    inline void clear_DAC1CFG1_MULDIV() volatile
    {
        DAC1CFG1 &= ~(1u << 3u);
    }

    /**
     * Toggle DAC1CFG1's MULDIV bit.
     *
     * Switch between up- and downscale of the DAC1 input data values
     */
    inline void toggle_DAC1CFG1_MULDIV() volatile
    {
        DAC1CFG1 ^= 1u << 3u;
    }

    /**
     * Get DAC1CFG1's SCALE field.
     *
     * Scale value for up- or downscale of the DAC1 input data in steps by the
     * power of 2 (=shift operation)
     */
    inline DAC_DAC0CFG1_SCALE get_DAC1CFG1_SCALE() volatile
    {
        return DAC_DAC0CFG1_SCALE((DAC1CFG1 >> 0u) & 0b111u);
    }

    /**
     * Set DAC1CFG1's SCALE field.
     *
     * Scale value for up- or downscale of the DAC1 input data in steps by the
     * power of 2 (=shift operation)
     */
    inline void set_DAC1CFG1_SCALE(DAC_DAC0CFG1_SCALE value) volatile
    {
        uint32_t curr = DAC1CFG1;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        DAC1CFG1 = curr;
    }

    /**
     * Get all of DAC1CFG1's bit fields.
     *
     * (read-write) DAC1 Configuration Register 1
     */
    inline void get_DAC1CFG1(uint8_t &REFCFGH, bool &ANAEN, uint8_t &ANACFG,
                             DAC_DAC0CFG1_TRIGMOD &TRIGMOD, bool &SWTRIG,
                             uint8_t &TRIGSEL, uint8_t &OFFS, bool &MULDIV,
                             DAC_DAC0CFG1_SCALE &SCALE) volatile
    {
        uint32_t curr = DAC1CFG1;

        REFCFGH = (curr >> 28u) & 0b1111u;
        ANAEN = curr & (1u << 24u);
        ANACFG = (curr >> 19u) & 0b11111u;
        TRIGMOD = DAC_DAC0CFG1_TRIGMOD((curr >> 17u) & 0b11u);
        SWTRIG = curr & (1u << 16u);
        TRIGSEL = (curr >> 12u) & 0b111u;
        OFFS = (curr >> 4u) & 0b11111111u;
        MULDIV = curr & (1u << 3u);
        SCALE = DAC_DAC0CFG1_SCALE((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of DAC1CFG1's bit fields.
     *
     * (read-write) DAC1 Configuration Register 1
     */
    inline void set_DAC1CFG1(uint8_t REFCFGH, bool ANAEN, uint8_t ANACFG,
                             DAC_DAC0CFG1_TRIGMOD TRIGMOD, bool SWTRIG,
                             uint8_t TRIGSEL, uint8_t OFFS, bool MULDIV,
                             DAC_DAC0CFG1_SCALE SCALE) volatile
    {
        uint32_t curr = DAC1CFG1;

        curr &= ~(0b1111u << 28u);
        curr |= (REFCFGH & 0b1111u) << 28u;
        curr &= ~(0b1u << 24u);
        curr |= (ANAEN & 0b1u) << 24u;
        curr &= ~(0b11111u << 19u);
        curr |= (ANACFG & 0b11111u) << 19u;
        curr &= ~(0b11u << 17u);
        curr |= (std::to_underlying(TRIGMOD) & 0b11u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (SWTRIG & 0b1u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (TRIGSEL & 0b111u) << 12u;
        curr &= ~(0b11111111u << 4u);
        curr |= (OFFS & 0b11111111u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (MULDIV & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(SCALE) & 0b111u) << 0u;

        DAC1CFG1 = curr;
    }

    /**
     * Get DAC0DATA's DATA0 field.
     *
     * DAC0 Data Bits
     */
    inline uint16_t get_DAC0DATA_DATA0() volatile
    {
        return (DAC0DATA >> 0u) & 0b111111111111u;
    }

    /**
     * Set DAC0DATA's DATA0 field.
     *
     * DAC0 Data Bits
     */
    inline void set_DAC0DATA_DATA0(uint16_t value) volatile
    {
        uint32_t curr = DAC0DATA;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        DAC0DATA = curr;
    }

    /**
     * Get DAC1DATA's DATA1 field.
     *
     * DAC1 Data Bits
     */
    inline uint16_t get_DAC1DATA_DATA1() volatile
    {
        return (DAC1DATA >> 0u) & 0b111111111111u;
    }

    /**
     * Set DAC1DATA's DATA1 field.
     *
     * DAC1 Data Bits
     */
    inline void set_DAC1DATA_DATA1(uint16_t value) volatile
    {
        uint32_t curr = DAC1DATA;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        DAC1DATA = curr;
    }

    /**
     * Get DAC01DATA's DATA1 field.
     *
     * DAC1 Data Bits
     */
    inline uint16_t get_DAC01DATA_DATA1() volatile
    {
        return (DAC01DATA >> 16u) & 0b111111111111u;
    }

    /**
     * Set DAC01DATA's DATA1 field.
     *
     * DAC1 Data Bits
     */
    inline void set_DAC01DATA_DATA1(uint16_t value) volatile
    {
        uint32_t curr = DAC01DATA;

        curr &= ~(0b111111111111u << 16u);
        curr |= (value & 0b111111111111u) << 16u;

        DAC01DATA = curr;
    }

    /**
     * Get DAC01DATA's DATA0 field.
     *
     * DAC0 Data Bits
     */
    inline uint16_t get_DAC01DATA_DATA0() volatile
    {
        return (DAC01DATA >> 0u) & 0b111111111111u;
    }

    /**
     * Set DAC01DATA's DATA0 field.
     *
     * DAC0 Data Bits
     */
    inline void set_DAC01DATA_DATA0(uint16_t value) volatile
    {
        uint32_t curr = DAC01DATA;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        DAC01DATA = curr;
    }

    /**
     * Get all of DAC01DATA's bit fields.
     *
     * (read-write) DAC01 Data Register
     */
    inline void get_DAC01DATA(uint16_t &DATA1, uint16_t &DATA0) volatile
    {
        uint32_t curr = DAC01DATA;

        DATA1 = (curr >> 16u) & 0b111111111111u;
        DATA0 = (curr >> 0u) & 0b111111111111u;
    }

    /**
     * Set all of DAC01DATA's bit fields.
     *
     * (read-write) DAC01 Data Register
     */
    inline void set_DAC01DATA(uint16_t DATA1, uint16_t DATA0) volatile
    {
        uint32_t curr = DAC01DATA;

        curr &= ~(0b111111111111u << 16u);
        curr |= (DATA1 & 0b111111111111u) << 16u;
        curr &= ~(0b111111111111u << 0u);
        curr |= (DATA0 & 0b111111111111u) << 0u;

        DAC01DATA = curr;
    }

    /**
     * Get DAC0PATL's PAT5 field.
     *
     * Pattern Number 5 for PATGEN of DAC0
     */
    inline uint8_t get_DAC0PATL_PAT5() volatile
    {
        return (DAC0PATL >> 25u) & 0b11111u;
    }

    /**
     * Set DAC0PATL's PAT5 field.
     *
     * Pattern Number 5 for PATGEN of DAC0
     */
    inline void set_DAC0PATL_PAT5(uint8_t value) volatile
    {
        uint32_t curr = DAC0PATL;

        curr &= ~(0b11111u << 25u);
        curr |= (value & 0b11111u) << 25u;

        DAC0PATL = curr;
    }

    /**
     * Get DAC0PATL's PAT4 field.
     *
     * Pattern Number 4 for PATGEN of DAC0
     */
    inline uint8_t get_DAC0PATL_PAT4() volatile
    {
        return (DAC0PATL >> 20u) & 0b11111u;
    }

    /**
     * Set DAC0PATL's PAT4 field.
     *
     * Pattern Number 4 for PATGEN of DAC0
     */
    inline void set_DAC0PATL_PAT4(uint8_t value) volatile
    {
        uint32_t curr = DAC0PATL;

        curr &= ~(0b11111u << 20u);
        curr |= (value & 0b11111u) << 20u;

        DAC0PATL = curr;
    }

    /**
     * Get DAC0PATL's PAT3 field.
     *
     * Pattern Number 3 for PATGEN of DAC0
     */
    inline uint8_t get_DAC0PATL_PAT3() volatile
    {
        return (DAC0PATL >> 15u) & 0b11111u;
    }

    /**
     * Set DAC0PATL's PAT3 field.
     *
     * Pattern Number 3 for PATGEN of DAC0
     */
    inline void set_DAC0PATL_PAT3(uint8_t value) volatile
    {
        uint32_t curr = DAC0PATL;

        curr &= ~(0b11111u << 15u);
        curr |= (value & 0b11111u) << 15u;

        DAC0PATL = curr;
    }

    /**
     * Get DAC0PATL's PAT2 field.
     *
     * Pattern Number 2 for PATGEN of DAC0
     */
    inline uint8_t get_DAC0PATL_PAT2() volatile
    {
        return (DAC0PATL >> 10u) & 0b11111u;
    }

    /**
     * Set DAC0PATL's PAT2 field.
     *
     * Pattern Number 2 for PATGEN of DAC0
     */
    inline void set_DAC0PATL_PAT2(uint8_t value) volatile
    {
        uint32_t curr = DAC0PATL;

        curr &= ~(0b11111u << 10u);
        curr |= (value & 0b11111u) << 10u;

        DAC0PATL = curr;
    }

    /**
     * Get DAC0PATL's PAT1 field.
     *
     * Pattern Number 1 for PATGEN of DAC0
     */
    inline uint8_t get_DAC0PATL_PAT1() volatile
    {
        return (DAC0PATL >> 5u) & 0b11111u;
    }

    /**
     * Set DAC0PATL's PAT1 field.
     *
     * Pattern Number 1 for PATGEN of DAC0
     */
    inline void set_DAC0PATL_PAT1(uint8_t value) volatile
    {
        uint32_t curr = DAC0PATL;

        curr &= ~(0b11111u << 5u);
        curr |= (value & 0b11111u) << 5u;

        DAC0PATL = curr;
    }

    /**
     * Get DAC0PATL's PAT0 field.
     *
     * Pattern Number 0 for PATGEN of DAC0
     */
    inline uint8_t get_DAC0PATL_PAT0() volatile
    {
        return (DAC0PATL >> 0u) & 0b11111u;
    }

    /**
     * Set DAC0PATL's PAT0 field.
     *
     * Pattern Number 0 for PATGEN of DAC0
     */
    inline void set_DAC0PATL_PAT0(uint8_t value) volatile
    {
        uint32_t curr = DAC0PATL;

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        DAC0PATL = curr;
    }

    /**
     * Get all of DAC0PATL's bit fields.
     *
     * (read-write) DAC0 Lower Pattern Register
     */
    inline void get_DAC0PATL(uint8_t &PAT5, uint8_t &PAT4, uint8_t &PAT3,
                             uint8_t &PAT2, uint8_t &PAT1,
                             uint8_t &PAT0) volatile
    {
        uint32_t curr = DAC0PATL;

        PAT5 = (curr >> 25u) & 0b11111u;
        PAT4 = (curr >> 20u) & 0b11111u;
        PAT3 = (curr >> 15u) & 0b11111u;
        PAT2 = (curr >> 10u) & 0b11111u;
        PAT1 = (curr >> 5u) & 0b11111u;
        PAT0 = (curr >> 0u) & 0b11111u;
    }

    /**
     * Set all of DAC0PATL's bit fields.
     *
     * (read-write) DAC0 Lower Pattern Register
     */
    inline void set_DAC0PATL(uint8_t PAT5, uint8_t PAT4, uint8_t PAT3,
                             uint8_t PAT2, uint8_t PAT1, uint8_t PAT0) volatile
    {
        uint32_t curr = DAC0PATL;

        curr &= ~(0b11111u << 25u);
        curr |= (PAT5 & 0b11111u) << 25u;
        curr &= ~(0b11111u << 20u);
        curr |= (PAT4 & 0b11111u) << 20u;
        curr &= ~(0b11111u << 15u);
        curr |= (PAT3 & 0b11111u) << 15u;
        curr &= ~(0b11111u << 10u);
        curr |= (PAT2 & 0b11111u) << 10u;
        curr &= ~(0b11111u << 5u);
        curr |= (PAT1 & 0b11111u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (PAT0 & 0b11111u) << 0u;

        DAC0PATL = curr;
    }

    /**
     * Get DAC0PATH's PAT8 field.
     *
     * Pattern Number 8 for PATGEN of DAC0
     */
    inline uint8_t get_DAC0PATH_PAT8() volatile
    {
        return (DAC0PATH >> 10u) & 0b11111u;
    }

    /**
     * Set DAC0PATH's PAT8 field.
     *
     * Pattern Number 8 for PATGEN of DAC0
     */
    inline void set_DAC0PATH_PAT8(uint8_t value) volatile
    {
        uint32_t curr = DAC0PATH;

        curr &= ~(0b11111u << 10u);
        curr |= (value & 0b11111u) << 10u;

        DAC0PATH = curr;
    }

    /**
     * Get DAC0PATH's PAT7 field.
     *
     * Pattern Number 7 for PATGEN of DAC0
     */
    inline uint8_t get_DAC0PATH_PAT7() volatile
    {
        return (DAC0PATH >> 5u) & 0b11111u;
    }

    /**
     * Set DAC0PATH's PAT7 field.
     *
     * Pattern Number 7 for PATGEN of DAC0
     */
    inline void set_DAC0PATH_PAT7(uint8_t value) volatile
    {
        uint32_t curr = DAC0PATH;

        curr &= ~(0b11111u << 5u);
        curr |= (value & 0b11111u) << 5u;

        DAC0PATH = curr;
    }

    /**
     * Get DAC0PATH's PAT6 field.
     *
     * Pattern Number 6 for PATGEN of DAC0
     */
    inline uint8_t get_DAC0PATH_PAT6() volatile
    {
        return (DAC0PATH >> 0u) & 0b11111u;
    }

    /**
     * Set DAC0PATH's PAT6 field.
     *
     * Pattern Number 6 for PATGEN of DAC0
     */
    inline void set_DAC0PATH_PAT6(uint8_t value) volatile
    {
        uint32_t curr = DAC0PATH;

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        DAC0PATH = curr;
    }

    /**
     * Get all of DAC0PATH's bit fields.
     *
     * (read-write) DAC0 Higher Pattern Register
     */
    inline void get_DAC0PATH(uint8_t &PAT8, uint8_t &PAT7,
                             uint8_t &PAT6) volatile
    {
        uint32_t curr = DAC0PATH;

        PAT8 = (curr >> 10u) & 0b11111u;
        PAT7 = (curr >> 5u) & 0b11111u;
        PAT6 = (curr >> 0u) & 0b11111u;
    }

    /**
     * Set all of DAC0PATH's bit fields.
     *
     * (read-write) DAC0 Higher Pattern Register
     */
    inline void set_DAC0PATH(uint8_t PAT8, uint8_t PAT7, uint8_t PAT6) volatile
    {
        uint32_t curr = DAC0PATH;

        curr &= ~(0b11111u << 10u);
        curr |= (PAT8 & 0b11111u) << 10u;
        curr &= ~(0b11111u << 5u);
        curr |= (PAT7 & 0b11111u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (PAT6 & 0b11111u) << 0u;

        DAC0PATH = curr;
    }

    /**
     * Get DAC1PATL's PAT5 field.
     *
     * Pattern Number 5 for PATGEN of DAC1
     */
    inline uint8_t get_DAC1PATL_PAT5() volatile
    {
        return (DAC1PATL >> 25u) & 0b11111u;
    }

    /**
     * Set DAC1PATL's PAT5 field.
     *
     * Pattern Number 5 for PATGEN of DAC1
     */
    inline void set_DAC1PATL_PAT5(uint8_t value) volatile
    {
        uint32_t curr = DAC1PATL;

        curr &= ~(0b11111u << 25u);
        curr |= (value & 0b11111u) << 25u;

        DAC1PATL = curr;
    }

    /**
     * Get DAC1PATL's PAT4 field.
     *
     * Pattern Number 4 for PATGEN of DAC1
     */
    inline uint8_t get_DAC1PATL_PAT4() volatile
    {
        return (DAC1PATL >> 20u) & 0b11111u;
    }

    /**
     * Set DAC1PATL's PAT4 field.
     *
     * Pattern Number 4 for PATGEN of DAC1
     */
    inline void set_DAC1PATL_PAT4(uint8_t value) volatile
    {
        uint32_t curr = DAC1PATL;

        curr &= ~(0b11111u << 20u);
        curr |= (value & 0b11111u) << 20u;

        DAC1PATL = curr;
    }

    /**
     * Get DAC1PATL's PAT3 field.
     *
     * Pattern Number 3 for PATGEN of DAC1
     */
    inline uint8_t get_DAC1PATL_PAT3() volatile
    {
        return (DAC1PATL >> 15u) & 0b11111u;
    }

    /**
     * Set DAC1PATL's PAT3 field.
     *
     * Pattern Number 3 for PATGEN of DAC1
     */
    inline void set_DAC1PATL_PAT3(uint8_t value) volatile
    {
        uint32_t curr = DAC1PATL;

        curr &= ~(0b11111u << 15u);
        curr |= (value & 0b11111u) << 15u;

        DAC1PATL = curr;
    }

    /**
     * Get DAC1PATL's PAT2 field.
     *
     * Pattern Number 2 for PATGEN of DAC1
     */
    inline uint8_t get_DAC1PATL_PAT2() volatile
    {
        return (DAC1PATL >> 10u) & 0b11111u;
    }

    /**
     * Set DAC1PATL's PAT2 field.
     *
     * Pattern Number 2 for PATGEN of DAC1
     */
    inline void set_DAC1PATL_PAT2(uint8_t value) volatile
    {
        uint32_t curr = DAC1PATL;

        curr &= ~(0b11111u << 10u);
        curr |= (value & 0b11111u) << 10u;

        DAC1PATL = curr;
    }

    /**
     * Get DAC1PATL's PAT1 field.
     *
     * Pattern Number 1 for PATGEN of DAC1
     */
    inline uint8_t get_DAC1PATL_PAT1() volatile
    {
        return (DAC1PATL >> 5u) & 0b11111u;
    }

    /**
     * Set DAC1PATL's PAT1 field.
     *
     * Pattern Number 1 for PATGEN of DAC1
     */
    inline void set_DAC1PATL_PAT1(uint8_t value) volatile
    {
        uint32_t curr = DAC1PATL;

        curr &= ~(0b11111u << 5u);
        curr |= (value & 0b11111u) << 5u;

        DAC1PATL = curr;
    }

    /**
     * Get DAC1PATL's PAT0 field.
     *
     * Pattern Number 0 for PATGEN of DAC1
     */
    inline uint8_t get_DAC1PATL_PAT0() volatile
    {
        return (DAC1PATL >> 0u) & 0b11111u;
    }

    /**
     * Set DAC1PATL's PAT0 field.
     *
     * Pattern Number 0 for PATGEN of DAC1
     */
    inline void set_DAC1PATL_PAT0(uint8_t value) volatile
    {
        uint32_t curr = DAC1PATL;

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        DAC1PATL = curr;
    }

    /**
     * Get all of DAC1PATL's bit fields.
     *
     * (read-write) DAC1 Lower Pattern Register
     */
    inline void get_DAC1PATL(uint8_t &PAT5, uint8_t &PAT4, uint8_t &PAT3,
                             uint8_t &PAT2, uint8_t &PAT1,
                             uint8_t &PAT0) volatile
    {
        uint32_t curr = DAC1PATL;

        PAT5 = (curr >> 25u) & 0b11111u;
        PAT4 = (curr >> 20u) & 0b11111u;
        PAT3 = (curr >> 15u) & 0b11111u;
        PAT2 = (curr >> 10u) & 0b11111u;
        PAT1 = (curr >> 5u) & 0b11111u;
        PAT0 = (curr >> 0u) & 0b11111u;
    }

    /**
     * Set all of DAC1PATL's bit fields.
     *
     * (read-write) DAC1 Lower Pattern Register
     */
    inline void set_DAC1PATL(uint8_t PAT5, uint8_t PAT4, uint8_t PAT3,
                             uint8_t PAT2, uint8_t PAT1, uint8_t PAT0) volatile
    {
        uint32_t curr = DAC1PATL;

        curr &= ~(0b11111u << 25u);
        curr |= (PAT5 & 0b11111u) << 25u;
        curr &= ~(0b11111u << 20u);
        curr |= (PAT4 & 0b11111u) << 20u;
        curr &= ~(0b11111u << 15u);
        curr |= (PAT3 & 0b11111u) << 15u;
        curr &= ~(0b11111u << 10u);
        curr |= (PAT2 & 0b11111u) << 10u;
        curr &= ~(0b11111u << 5u);
        curr |= (PAT1 & 0b11111u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (PAT0 & 0b11111u) << 0u;

        DAC1PATL = curr;
    }

    /**
     * Get DAC1PATH's PAT8 field.
     *
     * Pattern Number 8 for PATGEN of DAC1
     */
    inline uint8_t get_DAC1PATH_PAT8() volatile
    {
        return (DAC1PATH >> 10u) & 0b11111u;
    }

    /**
     * Set DAC1PATH's PAT8 field.
     *
     * Pattern Number 8 for PATGEN of DAC1
     */
    inline void set_DAC1PATH_PAT8(uint8_t value) volatile
    {
        uint32_t curr = DAC1PATH;

        curr &= ~(0b11111u << 10u);
        curr |= (value & 0b11111u) << 10u;

        DAC1PATH = curr;
    }

    /**
     * Get DAC1PATH's PAT7 field.
     *
     * Pattern Number 7 for PATGEN of DAC1
     */
    inline uint8_t get_DAC1PATH_PAT7() volatile
    {
        return (DAC1PATH >> 5u) & 0b11111u;
    }

    /**
     * Set DAC1PATH's PAT7 field.
     *
     * Pattern Number 7 for PATGEN of DAC1
     */
    inline void set_DAC1PATH_PAT7(uint8_t value) volatile
    {
        uint32_t curr = DAC1PATH;

        curr &= ~(0b11111u << 5u);
        curr |= (value & 0b11111u) << 5u;

        DAC1PATH = curr;
    }

    /**
     * Get DAC1PATH's PAT6 field.
     *
     * Pattern Number 6 for PATGEN of DAC1
     */
    inline uint8_t get_DAC1PATH_PAT6() volatile
    {
        return (DAC1PATH >> 0u) & 0b11111u;
    }

    /**
     * Set DAC1PATH's PAT6 field.
     *
     * Pattern Number 6 for PATGEN of DAC1
     */
    inline void set_DAC1PATH_PAT6(uint8_t value) volatile
    {
        uint32_t curr = DAC1PATH;

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        DAC1PATH = curr;
    }

    /**
     * Get all of DAC1PATH's bit fields.
     *
     * (read-write) DAC1 Higher Pattern Register
     */
    inline void get_DAC1PATH(uint8_t &PAT8, uint8_t &PAT7,
                             uint8_t &PAT6) volatile
    {
        uint32_t curr = DAC1PATH;

        PAT8 = (curr >> 10u) & 0b11111u;
        PAT7 = (curr >> 5u) & 0b11111u;
        PAT6 = (curr >> 0u) & 0b11111u;
    }

    /**
     * Set all of DAC1PATH's bit fields.
     *
     * (read-write) DAC1 Higher Pattern Register
     */
    inline void set_DAC1PATH(uint8_t PAT8, uint8_t PAT7, uint8_t PAT6) volatile
    {
        uint32_t curr = DAC1PATH;

        curr &= ~(0b11111u << 10u);
        curr |= (PAT8 & 0b11111u) << 10u;
        curr &= ~(0b11111u << 5u);
        curr |= (PAT7 & 0b11111u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (PAT6 & 0b11111u) << 0u;

        DAC1PATH = curr;
    }
};

static_assert(sizeof(dac) == dac::size);

static volatile dac *const DAC = reinterpret_cast<dac *>(0x48018000);

}; // namespace XMC4700
