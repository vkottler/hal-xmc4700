/**
 * \file
 * \brief Generated by ifgen (3.1.7).
 */
#pragma once

#include "../enums/GPDMA0_CH0_CFGH_FCMODE.h"
#include "../enums/GPDMA0_CH0_CFGH_FIFO_MODE.h"
#include "../enums/GPDMA0_CH0_CFGL_CH_SUSP.h"
#include "../enums/GPDMA0_CH0_CFGL_DST_HS_POL.h"
#include "../enums/GPDMA0_CH0_CFGL_FIFO_EMPTY.h"
#include "../enums/GPDMA0_CH0_CFGL_HS_SEL_DST.h"
#include "../enums/GPDMA0_CH0_CFGL_HS_SEL_SRC.h"
#include "../enums/GPDMA0_CH0_CFGL_LOCK_CH_L.h"
#include "../enums/GPDMA0_CH0_CTLL_DINC.h"
#include "../enums/GPDMA0_CH0_CTLL_SRC_GATHER_EN.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * General Purpose DMA Unit 0
 */
struct [[gnu::packed]] gpdma0_ch0
{
    /* Constant attributes. */
    static constexpr std::size_t size = 84; /*!< gpdma0_ch0's size in bytes. */

    /* Fields. */
    uint32_t SAR; /*!< (read-write) Source Address Register */
    const uint32_t reserved_padding0 = {};
    uint32_t DAR; /*!< (read-write) Destination Address Register */
    const uint32_t reserved_padding1 = {};
    uint32_t LLP; /*!< (read-write) Linked List Pointer Register */
    const uint32_t reserved_padding2 = {};
    uint32_t CTLL;  /*!< (read-write) Control Register Low */
    uint32_t CTLH;  /*!< (read-write) Control Register High */
    uint32_t SSTAT; /*!< (read-write) Source Status Register */
    const uint32_t reserved_padding3 = {};
    uint32_t DSTAT; /*!< (read-write) Destination Status Register */
    const uint32_t reserved_padding4 = {};
    uint32_t SSTATAR; /*!< (read-write) Source Status Address Register */
    const uint32_t reserved_padding5 = {};
    uint32_t DSTATAR; /*!< (read-write) Destination Status Address Register */
    const uint32_t reserved_padding6 = {};
    uint32_t CFGL; /*!< (read-write) Configuration Register Low */
    uint32_t CFGH; /*!< (read-write) Configuration Register High */
    uint32_t SGR;  /*!< (read-write) Source Gather Register */
    const uint32_t reserved_padding7 = {};
    uint32_t DSR; /*!< (read-write) Destination Scatter Register */

    /* Methods. */

    /**
     * Get SAR's SAR field.
     *
     * Current Source Address of DMA transfer
     */
    inline uint32_t get_SAR_SAR() volatile
    {
        return (SAR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set SAR's SAR field.
     *
     * Current Source Address of DMA transfer
     */
    inline void set_SAR_SAR(uint32_t value) volatile
    {
        uint32_t curr = SAR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        SAR = curr;
    }

    /**
     * Get DAR's DAR field.
     *
     * Current Destination address of DMA transfer
     */
    inline uint32_t get_DAR_DAR() volatile
    {
        return (DAR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set DAR's DAR field.
     *
     * Current Destination address of DMA transfer
     */
    inline void set_DAR_DAR(uint32_t value) volatile
    {
        uint32_t curr = DAR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DAR = curr;
    }

    /**
     * Get LLP's LOC field.
     *
     * Starting Address In Memory
     */
    inline uint32_t get_LLP_LOC() volatile
    {
        return (LLP >> 2u) & 0b111111111111111111111111111111u;
    }

    /**
     * Set LLP's LOC field.
     *
     * Starting Address In Memory
     */
    inline void set_LLP_LOC(uint32_t value) volatile
    {
        uint32_t curr = LLP;

        curr &= ~(0b111111111111111111111111111111u << 2u);
        curr |= (value & 0b111111111111111111111111111111u) << 2u;

        LLP = curr;
    }

    /**
     * Get CTLL's INT_EN bit.
     *
     * Interrupt Enable Bit
     */
    inline bool get_CTLL_INT_EN() volatile
    {
        return CTLL & (1u << 0u);
    }

    /**
     * Set CTLL's INT_EN bit.
     *
     * Interrupt Enable Bit
     */
    inline void set_CTLL_INT_EN() volatile
    {
        CTLL |= 1u << 0u;
    }

    /**
     * Clear CTLL's INT_EN bit.
     *
     * Interrupt Enable Bit
     */
    inline void clear_CTLL_INT_EN() volatile
    {
        CTLL &= ~(1u << 0u);
    }

    /**
     * Toggle CTLL's INT_EN bit.
     *
     * Interrupt Enable Bit
     */
    inline void toggle_CTLL_INT_EN() volatile
    {
        CTLL ^= 1u << 0u;
    }

    /**
     * Get CTLL's DST_TR_WIDTH field.
     *
     * Destination Transfer Width
     */
    inline uint8_t get_CTLL_DST_TR_WIDTH() volatile
    {
        return (CTLL >> 1u) & 0b111u;
    }

    /**
     * Set CTLL's DST_TR_WIDTH field.
     *
     * Destination Transfer Width
     */
    inline void set_CTLL_DST_TR_WIDTH(uint8_t value) volatile
    {
        uint32_t curr = CTLL;

        curr &= ~(0b111u << 1u);
        curr |= (value & 0b111u) << 1u;

        CTLL = curr;
    }

    /**
     * Get CTLL's SRC_TR_WIDTH field.
     *
     * Source Transfer Width
     */
    inline uint8_t get_CTLL_SRC_TR_WIDTH() volatile
    {
        return (CTLL >> 4u) & 0b111u;
    }

    /**
     * Set CTLL's SRC_TR_WIDTH field.
     *
     * Source Transfer Width
     */
    inline void set_CTLL_SRC_TR_WIDTH(uint8_t value) volatile
    {
        uint32_t curr = CTLL;

        curr &= ~(0b111u << 4u);
        curr |= (value & 0b111u) << 4u;

        CTLL = curr;
    }

    /**
     * Get CTLL's DINC field.
     *
     * Destination Address Increment
     */
    inline GPDMA0_CH0_CTLL_DINC get_CTLL_DINC() volatile
    {
        return GPDMA0_CH0_CTLL_DINC((CTLL >> 7u) & 0b11u);
    }

    /**
     * Set CTLL's DINC field.
     *
     * Destination Address Increment
     */
    inline void set_CTLL_DINC(GPDMA0_CH0_CTLL_DINC value) volatile
    {
        uint32_t curr = CTLL;

        curr &= ~(0b11u << 7u);
        curr |= (std::to_underlying(value) & 0b11u) << 7u;

        CTLL = curr;
    }

    /**
     * Get CTLL's SINC field.
     *
     * Source Address Increment
     */
    inline GPDMA0_CH0_CTLL_DINC get_CTLL_SINC() volatile
    {
        return GPDMA0_CH0_CTLL_DINC((CTLL >> 9u) & 0b11u);
    }

    /**
     * Set CTLL's SINC field.
     *
     * Source Address Increment
     */
    inline void set_CTLL_SINC(GPDMA0_CH0_CTLL_DINC value) volatile
    {
        uint32_t curr = CTLL;

        curr &= ~(0b11u << 9u);
        curr |= (std::to_underlying(value) & 0b11u) << 9u;

        CTLL = curr;
    }

    /**
     * Get CTLL's DEST_MSIZE field.
     *
     * Destination Burst Transaction Length
     */
    inline uint8_t get_CTLL_DEST_MSIZE() volatile
    {
        return (CTLL >> 11u) & 0b111u;
    }

    /**
     * Set CTLL's DEST_MSIZE field.
     *
     * Destination Burst Transaction Length
     */
    inline void set_CTLL_DEST_MSIZE(uint8_t value) volatile
    {
        uint32_t curr = CTLL;

        curr &= ~(0b111u << 11u);
        curr |= (value & 0b111u) << 11u;

        CTLL = curr;
    }

    /**
     * Get CTLL's SRC_MSIZE field.
     *
     * Source Burst Transaction Length
     */
    inline uint8_t get_CTLL_SRC_MSIZE() volatile
    {
        return (CTLL >> 14u) & 0b111u;
    }

    /**
     * Set CTLL's SRC_MSIZE field.
     *
     * Source Burst Transaction Length
     */
    inline void set_CTLL_SRC_MSIZE(uint8_t value) volatile
    {
        uint32_t curr = CTLL;

        curr &= ~(0b111u << 14u);
        curr |= (value & 0b111u) << 14u;

        CTLL = curr;
    }

    /**
     * Get CTLL's SRC_GATHER_EN bit.
     *
     * Source gather enable
     */
    inline GPDMA0_CH0_CTLL_SRC_GATHER_EN get_CTLL_SRC_GATHER_EN() volatile
    {
        return GPDMA0_CH0_CTLL_SRC_GATHER_EN(CTLL & (1u << 17u));
    }

    /**
     * Set CTLL's SRC_GATHER_EN bit.
     *
     * Source gather enable
     */
    inline void set_CTLL_SRC_GATHER_EN() volatile
    {
        CTLL |= 1u << 17u;
    }

    /**
     * Clear CTLL's SRC_GATHER_EN bit.
     *
     * Source gather enable
     */
    inline void clear_CTLL_SRC_GATHER_EN() volatile
    {
        CTLL &= ~(1u << 17u);
    }

    /**
     * Toggle CTLL's SRC_GATHER_EN bit.
     *
     * Source gather enable
     */
    inline void toggle_CTLL_SRC_GATHER_EN() volatile
    {
        CTLL ^= 1u << 17u;
    }

    /**
     * Get CTLL's DST_SCATTER_EN bit.
     *
     * Destination scatter enable
     */
    inline GPDMA0_CH0_CTLL_SRC_GATHER_EN get_CTLL_DST_SCATTER_EN() volatile
    {
        return GPDMA0_CH0_CTLL_SRC_GATHER_EN(CTLL & (1u << 18u));
    }

    /**
     * Set CTLL's DST_SCATTER_EN bit.
     *
     * Destination scatter enable
     */
    inline void set_CTLL_DST_SCATTER_EN() volatile
    {
        CTLL |= 1u << 18u;
    }

    /**
     * Clear CTLL's DST_SCATTER_EN bit.
     *
     * Destination scatter enable
     */
    inline void clear_CTLL_DST_SCATTER_EN() volatile
    {
        CTLL &= ~(1u << 18u);
    }

    /**
     * Toggle CTLL's DST_SCATTER_EN bit.
     *
     * Destination scatter enable
     */
    inline void toggle_CTLL_DST_SCATTER_EN() volatile
    {
        CTLL ^= 1u << 18u;
    }

    /**
     * Get CTLL's TT_FC field.
     *
     * Transfer Type and Flow Control
     */
    inline uint8_t get_CTLL_TT_FC() volatile
    {
        return (CTLL >> 20u) & 0b111u;
    }

    /**
     * Set CTLL's TT_FC field.
     *
     * Transfer Type and Flow Control
     */
    inline void set_CTLL_TT_FC(uint8_t value) volatile
    {
        uint32_t curr = CTLL;

        curr &= ~(0b111u << 20u);
        curr |= (value & 0b111u) << 20u;

        CTLL = curr;
    }

    /**
     * Get CTLL's LLP_DST_EN bit.
     *
     * Linked List Pointer for Destination Enable
     */
    inline bool get_CTLL_LLP_DST_EN() volatile
    {
        return CTLL & (1u << 27u);
    }

    /**
     * Set CTLL's LLP_DST_EN bit.
     *
     * Linked List Pointer for Destination Enable
     */
    inline void set_CTLL_LLP_DST_EN() volatile
    {
        CTLL |= 1u << 27u;
    }

    /**
     * Clear CTLL's LLP_DST_EN bit.
     *
     * Linked List Pointer for Destination Enable
     */
    inline void clear_CTLL_LLP_DST_EN() volatile
    {
        CTLL &= ~(1u << 27u);
    }

    /**
     * Toggle CTLL's LLP_DST_EN bit.
     *
     * Linked List Pointer for Destination Enable
     */
    inline void toggle_CTLL_LLP_DST_EN() volatile
    {
        CTLL ^= 1u << 27u;
    }

    /**
     * Get CTLL's LLP_SRC_EN bit.
     *
     * Linked List Pointer for Source Enable
     */
    inline bool get_CTLL_LLP_SRC_EN() volatile
    {
        return CTLL & (1u << 28u);
    }

    /**
     * Set CTLL's LLP_SRC_EN bit.
     *
     * Linked List Pointer for Source Enable
     */
    inline void set_CTLL_LLP_SRC_EN() volatile
    {
        CTLL |= 1u << 28u;
    }

    /**
     * Clear CTLL's LLP_SRC_EN bit.
     *
     * Linked List Pointer for Source Enable
     */
    inline void clear_CTLL_LLP_SRC_EN() volatile
    {
        CTLL &= ~(1u << 28u);
    }

    /**
     * Toggle CTLL's LLP_SRC_EN bit.
     *
     * Linked List Pointer for Source Enable
     */
    inline void toggle_CTLL_LLP_SRC_EN() volatile
    {
        CTLL ^= 1u << 28u;
    }

    /**
     * Get all of CTLL's bit fields.
     *
     * (read-write) Control Register Low
     */
    inline void get_CTLL(bool &INT_EN, uint8_t &DST_TR_WIDTH,
                         uint8_t &SRC_TR_WIDTH, GPDMA0_CH0_CTLL_DINC &DINC,
                         GPDMA0_CH0_CTLL_DINC &SINC, uint8_t &DEST_MSIZE,
                         uint8_t &SRC_MSIZE,
                         GPDMA0_CH0_CTLL_SRC_GATHER_EN &SRC_GATHER_EN,
                         GPDMA0_CH0_CTLL_SRC_GATHER_EN &DST_SCATTER_EN,
                         uint8_t &TT_FC, bool &LLP_DST_EN,
                         bool &LLP_SRC_EN) volatile
    {
        uint32_t curr = CTLL;

        INT_EN = curr & (1u << 0u);
        DST_TR_WIDTH = (curr >> 1u) & 0b111u;
        SRC_TR_WIDTH = (curr >> 4u) & 0b111u;
        DINC = GPDMA0_CH0_CTLL_DINC((curr >> 7u) & 0b11u);
        SINC = GPDMA0_CH0_CTLL_DINC((curr >> 9u) & 0b11u);
        DEST_MSIZE = (curr >> 11u) & 0b111u;
        SRC_MSIZE = (curr >> 14u) & 0b111u;
        SRC_GATHER_EN = GPDMA0_CH0_CTLL_SRC_GATHER_EN(curr & (1u << 17u));
        DST_SCATTER_EN = GPDMA0_CH0_CTLL_SRC_GATHER_EN(curr & (1u << 18u));
        TT_FC = (curr >> 20u) & 0b111u;
        LLP_DST_EN = curr & (1u << 27u);
        LLP_SRC_EN = curr & (1u << 28u);
    }

    /**
     * Set all of CTLL's bit fields.
     *
     * (read-write) Control Register Low
     */
    inline void set_CTLL(bool INT_EN, uint8_t DST_TR_WIDTH,
                         uint8_t SRC_TR_WIDTH, GPDMA0_CH0_CTLL_DINC DINC,
                         GPDMA0_CH0_CTLL_DINC SINC, uint8_t DEST_MSIZE,
                         uint8_t SRC_MSIZE,
                         GPDMA0_CH0_CTLL_SRC_GATHER_EN SRC_GATHER_EN,
                         GPDMA0_CH0_CTLL_SRC_GATHER_EN DST_SCATTER_EN,
                         uint8_t TT_FC, bool LLP_DST_EN,
                         bool LLP_SRC_EN) volatile
    {
        uint32_t curr = CTLL;

        curr &= ~(0b1u << 0u);
        curr |= (INT_EN & 0b1u) << 0u;
        curr &= ~(0b111u << 1u);
        curr |= (DST_TR_WIDTH & 0b111u) << 1u;
        curr &= ~(0b111u << 4u);
        curr |= (SRC_TR_WIDTH & 0b111u) << 4u;
        curr &= ~(0b11u << 7u);
        curr |= (std::to_underlying(DINC) & 0b11u) << 7u;
        curr &= ~(0b11u << 9u);
        curr |= (std::to_underlying(SINC) & 0b11u) << 9u;
        curr &= ~(0b111u << 11u);
        curr |= (DEST_MSIZE & 0b111u) << 11u;
        curr &= ~(0b111u << 14u);
        curr |= (SRC_MSIZE & 0b111u) << 14u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(SRC_GATHER_EN) & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (std::to_underlying(DST_SCATTER_EN) & 0b1u) << 18u;
        curr &= ~(0b111u << 20u);
        curr |= (TT_FC & 0b111u) << 20u;
        curr &= ~(0b1u << 27u);
        curr |= (LLP_DST_EN & 0b1u) << 27u;
        curr &= ~(0b1u << 28u);
        curr |= (LLP_SRC_EN & 0b1u) << 28u;

        CTLL = curr;
    }

    /**
     * Get CTLH's BLOCK_TS field.
     *
     * Block Transfer Size
     */
    inline uint16_t get_CTLH_BLOCK_TS() volatile
    {
        return (CTLH >> 0u) & 0b111111111111u;
    }

    /**
     * Set CTLH's BLOCK_TS field.
     *
     * Block Transfer Size
     */
    inline void set_CTLH_BLOCK_TS(uint16_t value) volatile
    {
        uint32_t curr = CTLH;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        CTLH = curr;
    }

    /**
     * Get CTLH's DONE bit.
     *
     * Done bit
     */
    inline bool get_CTLH_DONE() volatile
    {
        return CTLH & (1u << 12u);
    }

    /**
     * Set CTLH's DONE bit.
     *
     * Done bit
     */
    inline void set_CTLH_DONE() volatile
    {
        CTLH |= 1u << 12u;
    }

    /**
     * Clear CTLH's DONE bit.
     *
     * Done bit
     */
    inline void clear_CTLH_DONE() volatile
    {
        CTLH &= ~(1u << 12u);
    }

    /**
     * Toggle CTLH's DONE bit.
     *
     * Done bit
     */
    inline void toggle_CTLH_DONE() volatile
    {
        CTLH ^= 1u << 12u;
    }

    /**
     * Get all of CTLH's bit fields.
     *
     * (read-write) Control Register High
     */
    inline void get_CTLH(uint16_t &BLOCK_TS, bool &DONE) volatile
    {
        uint32_t curr = CTLH;

        BLOCK_TS = (curr >> 0u) & 0b111111111111u;
        DONE = curr & (1u << 12u);
    }

    /**
     * Set all of CTLH's bit fields.
     *
     * (read-write) Control Register High
     */
    inline void set_CTLH(uint16_t BLOCK_TS, bool DONE) volatile
    {
        uint32_t curr = CTLH;

        curr &= ~(0b111111111111u << 0u);
        curr |= (BLOCK_TS & 0b111111111111u) << 0u;
        curr &= ~(0b1u << 12u);
        curr |= (DONE & 0b1u) << 12u;

        CTLH = curr;
    }

    /**
     * Get SSTAT's SSTAT field.
     *
     * Source Status
     */
    inline uint32_t get_SSTAT_SSTAT() volatile
    {
        return (SSTAT >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set SSTAT's SSTAT field.
     *
     * Source Status
     */
    inline void set_SSTAT_SSTAT(uint32_t value) volatile
    {
        uint32_t curr = SSTAT;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        SSTAT = curr;
    }

    /**
     * Get DSTAT's DSTAT field.
     *
     * Destination Status
     */
    inline uint32_t get_DSTAT_DSTAT() volatile
    {
        return (DSTAT >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set DSTAT's DSTAT field.
     *
     * Destination Status
     */
    inline void set_DSTAT_DSTAT(uint32_t value) volatile
    {
        uint32_t curr = DSTAT;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DSTAT = curr;
    }

    /**
     * Get SSTATAR's SSTATAR field.
     *
     * Source Status Address
     */
    inline uint32_t get_SSTATAR_SSTATAR() volatile
    {
        return (SSTATAR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set SSTATAR's SSTATAR field.
     *
     * Source Status Address
     */
    inline void set_SSTATAR_SSTATAR(uint32_t value) volatile
    {
        uint32_t curr = SSTATAR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        SSTATAR = curr;
    }

    /**
     * Get DSTATAR's DSTATAR field.
     *
     * Destination Status Address
     */
    inline uint32_t get_DSTATAR_DSTATAR() volatile
    {
        return (DSTATAR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set DSTATAR's DSTATAR field.
     *
     * Destination Status Address
     */
    inline void set_DSTATAR_DSTATAR(uint32_t value) volatile
    {
        uint32_t curr = DSTATAR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DSTATAR = curr;
    }

    /**
     * Get CFGL's CH_PRIOR field.
     *
     * Channel priority
     */
    inline uint8_t get_CFGL_CH_PRIOR() volatile
    {
        return (CFGL >> 5u) & 0b111u;
    }

    /**
     * Set CFGL's CH_PRIOR field.
     *
     * Channel priority
     */
    inline void set_CFGL_CH_PRIOR(uint8_t value) volatile
    {
        uint32_t curr = CFGL;

        curr &= ~(0b111u << 5u);
        curr |= (value & 0b111u) << 5u;

        CFGL = curr;
    }

    /**
     * Get CFGL's CH_SUSP bit.
     *
     * Channel Suspend
     */
    inline GPDMA0_CH0_CFGL_CH_SUSP get_CFGL_CH_SUSP() volatile
    {
        return GPDMA0_CH0_CFGL_CH_SUSP(CFGL & (1u << 8u));
    }

    /**
     * Set CFGL's CH_SUSP bit.
     *
     * Channel Suspend
     */
    inline void set_CFGL_CH_SUSP() volatile
    {
        CFGL |= 1u << 8u;
    }

    /**
     * Clear CFGL's CH_SUSP bit.
     *
     * Channel Suspend
     */
    inline void clear_CFGL_CH_SUSP() volatile
    {
        CFGL &= ~(1u << 8u);
    }

    /**
     * Toggle CFGL's CH_SUSP bit.
     *
     * Channel Suspend
     */
    inline void toggle_CFGL_CH_SUSP() volatile
    {
        CFGL ^= 1u << 8u;
    }

    /**
     * Get CFGL's FIFO_EMPTY bit.
     *
     * Indicates if there is data left in the channel FIFO
     */
    inline GPDMA0_CH0_CFGL_FIFO_EMPTY get_CFGL_FIFO_EMPTY() volatile
    {
        return GPDMA0_CH0_CFGL_FIFO_EMPTY(CFGL & (1u << 9u));
    }

    /**
     * Get CFGL's HS_SEL_DST bit.
     *
     * Destination Software or Hardware Handshaking Select
     */
    inline GPDMA0_CH0_CFGL_HS_SEL_DST get_CFGL_HS_SEL_DST() volatile
    {
        return GPDMA0_CH0_CFGL_HS_SEL_DST(CFGL & (1u << 10u));
    }

    /**
     * Set CFGL's HS_SEL_DST bit.
     *
     * Destination Software or Hardware Handshaking Select
     */
    inline void set_CFGL_HS_SEL_DST() volatile
    {
        CFGL |= 1u << 10u;
    }

    /**
     * Clear CFGL's HS_SEL_DST bit.
     *
     * Destination Software or Hardware Handshaking Select
     */
    inline void clear_CFGL_HS_SEL_DST() volatile
    {
        CFGL &= ~(1u << 10u);
    }

    /**
     * Toggle CFGL's HS_SEL_DST bit.
     *
     * Destination Software or Hardware Handshaking Select
     */
    inline void toggle_CFGL_HS_SEL_DST() volatile
    {
        CFGL ^= 1u << 10u;
    }

    /**
     * Get CFGL's HS_SEL_SRC bit.
     *
     * Source Software or Hardware Handshaking Select
     */
    inline GPDMA0_CH0_CFGL_HS_SEL_SRC get_CFGL_HS_SEL_SRC() volatile
    {
        return GPDMA0_CH0_CFGL_HS_SEL_SRC(CFGL & (1u << 11u));
    }

    /**
     * Set CFGL's HS_SEL_SRC bit.
     *
     * Source Software or Hardware Handshaking Select
     */
    inline void set_CFGL_HS_SEL_SRC() volatile
    {
        CFGL |= 1u << 11u;
    }

    /**
     * Clear CFGL's HS_SEL_SRC bit.
     *
     * Source Software or Hardware Handshaking Select
     */
    inline void clear_CFGL_HS_SEL_SRC() volatile
    {
        CFGL &= ~(1u << 11u);
    }

    /**
     * Toggle CFGL's HS_SEL_SRC bit.
     *
     * Source Software or Hardware Handshaking Select
     */
    inline void toggle_CFGL_HS_SEL_SRC() volatile
    {
        CFGL ^= 1u << 11u;
    }

    /**
     * Get CFGL's LOCK_CH_L field.
     *
     * Channel Lock Level
     */
    inline GPDMA0_CH0_CFGL_LOCK_CH_L get_CFGL_LOCK_CH_L() volatile
    {
        return GPDMA0_CH0_CFGL_LOCK_CH_L((CFGL >> 12u) & 0b11u);
    }

    /**
     * Set CFGL's LOCK_CH_L field.
     *
     * Channel Lock Level
     */
    inline void set_CFGL_LOCK_CH_L(GPDMA0_CH0_CFGL_LOCK_CH_L value) volatile
    {
        uint32_t curr = CFGL;

        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(value) & 0b11u) << 12u;

        CFGL = curr;
    }

    /**
     * Get CFGL's LOCK_B_L field.
     *
     * Bus Lock Level
     */
    inline GPDMA0_CH0_CFGL_LOCK_CH_L get_CFGL_LOCK_B_L() volatile
    {
        return GPDMA0_CH0_CFGL_LOCK_CH_L((CFGL >> 14u) & 0b11u);
    }

    /**
     * Set CFGL's LOCK_B_L field.
     *
     * Bus Lock Level
     */
    inline void set_CFGL_LOCK_B_L(GPDMA0_CH0_CFGL_LOCK_CH_L value) volatile
    {
        uint32_t curr = CFGL;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(value) & 0b11u) << 14u;

        CFGL = curr;
    }

    /**
     * Get CFGL's LOCK_CH bit.
     *
     * Channel Lock Bit
     */
    inline bool get_CFGL_LOCK_CH() volatile
    {
        return CFGL & (1u << 16u);
    }

    /**
     * Set CFGL's LOCK_CH bit.
     *
     * Channel Lock Bit
     */
    inline void set_CFGL_LOCK_CH() volatile
    {
        CFGL |= 1u << 16u;
    }

    /**
     * Clear CFGL's LOCK_CH bit.
     *
     * Channel Lock Bit
     */
    inline void clear_CFGL_LOCK_CH() volatile
    {
        CFGL &= ~(1u << 16u);
    }

    /**
     * Toggle CFGL's LOCK_CH bit.
     *
     * Channel Lock Bit
     */
    inline void toggle_CFGL_LOCK_CH() volatile
    {
        CFGL ^= 1u << 16u;
    }

    /**
     * Get CFGL's LOCK_B bit.
     *
     * Bus Lock Bit
     */
    inline bool get_CFGL_LOCK_B() volatile
    {
        return CFGL & (1u << 17u);
    }

    /**
     * Set CFGL's LOCK_B bit.
     *
     * Bus Lock Bit
     */
    inline void set_CFGL_LOCK_B() volatile
    {
        CFGL |= 1u << 17u;
    }

    /**
     * Clear CFGL's LOCK_B bit.
     *
     * Bus Lock Bit
     */
    inline void clear_CFGL_LOCK_B() volatile
    {
        CFGL &= ~(1u << 17u);
    }

    /**
     * Toggle CFGL's LOCK_B bit.
     *
     * Bus Lock Bit
     */
    inline void toggle_CFGL_LOCK_B() volatile
    {
        CFGL ^= 1u << 17u;
    }

    /**
     * Get CFGL's DST_HS_POL bit.
     *
     * Destination Handshaking Interface Polarity
     */
    inline GPDMA0_CH0_CFGL_DST_HS_POL get_CFGL_DST_HS_POL() volatile
    {
        return GPDMA0_CH0_CFGL_DST_HS_POL(CFGL & (1u << 18u));
    }

    /**
     * Set CFGL's DST_HS_POL bit.
     *
     * Destination Handshaking Interface Polarity
     */
    inline void set_CFGL_DST_HS_POL() volatile
    {
        CFGL |= 1u << 18u;
    }

    /**
     * Clear CFGL's DST_HS_POL bit.
     *
     * Destination Handshaking Interface Polarity
     */
    inline void clear_CFGL_DST_HS_POL() volatile
    {
        CFGL &= ~(1u << 18u);
    }

    /**
     * Toggle CFGL's DST_HS_POL bit.
     *
     * Destination Handshaking Interface Polarity
     */
    inline void toggle_CFGL_DST_HS_POL() volatile
    {
        CFGL ^= 1u << 18u;
    }

    /**
     * Get CFGL's SRC_HS_POL bit.
     *
     * Source Handshaking Interface Polarity
     */
    inline GPDMA0_CH0_CFGL_DST_HS_POL get_CFGL_SRC_HS_POL() volatile
    {
        return GPDMA0_CH0_CFGL_DST_HS_POL(CFGL & (1u << 19u));
    }

    /**
     * Set CFGL's SRC_HS_POL bit.
     *
     * Source Handshaking Interface Polarity
     */
    inline void set_CFGL_SRC_HS_POL() volatile
    {
        CFGL |= 1u << 19u;
    }

    /**
     * Clear CFGL's SRC_HS_POL bit.
     *
     * Source Handshaking Interface Polarity
     */
    inline void clear_CFGL_SRC_HS_POL() volatile
    {
        CFGL &= ~(1u << 19u);
    }

    /**
     * Toggle CFGL's SRC_HS_POL bit.
     *
     * Source Handshaking Interface Polarity
     */
    inline void toggle_CFGL_SRC_HS_POL() volatile
    {
        CFGL ^= 1u << 19u;
    }

    /**
     * Get CFGL's MAX_ABRST field.
     *
     * Maximum AMBA Burst Length
     */
    inline uint16_t get_CFGL_MAX_ABRST() volatile
    {
        return (CFGL >> 20u) & 0b1111111111u;
    }

    /**
     * Set CFGL's MAX_ABRST field.
     *
     * Maximum AMBA Burst Length
     */
    inline void set_CFGL_MAX_ABRST(uint16_t value) volatile
    {
        uint32_t curr = CFGL;

        curr &= ~(0b1111111111u << 20u);
        curr |= (value & 0b1111111111u) << 20u;

        CFGL = curr;
    }

    /**
     * Get CFGL's RELOAD_SRC bit.
     *
     * Automatic Source Reload
     */
    inline bool get_CFGL_RELOAD_SRC() volatile
    {
        return CFGL & (1u << 30u);
    }

    /**
     * Set CFGL's RELOAD_SRC bit.
     *
     * Automatic Source Reload
     */
    inline void set_CFGL_RELOAD_SRC() volatile
    {
        CFGL |= 1u << 30u;
    }

    /**
     * Clear CFGL's RELOAD_SRC bit.
     *
     * Automatic Source Reload
     */
    inline void clear_CFGL_RELOAD_SRC() volatile
    {
        CFGL &= ~(1u << 30u);
    }

    /**
     * Toggle CFGL's RELOAD_SRC bit.
     *
     * Automatic Source Reload
     */
    inline void toggle_CFGL_RELOAD_SRC() volatile
    {
        CFGL ^= 1u << 30u;
    }

    /**
     * Get CFGL's RELOAD_DST bit.
     *
     * Automatic Destination Reload
     */
    inline bool get_CFGL_RELOAD_DST() volatile
    {
        return CFGL & (1u << 31u);
    }

    /**
     * Set CFGL's RELOAD_DST bit.
     *
     * Automatic Destination Reload
     */
    inline void set_CFGL_RELOAD_DST() volatile
    {
        CFGL |= 1u << 31u;
    }

    /**
     * Clear CFGL's RELOAD_DST bit.
     *
     * Automatic Destination Reload
     */
    inline void clear_CFGL_RELOAD_DST() volatile
    {
        CFGL &= ~(1u << 31u);
    }

    /**
     * Toggle CFGL's RELOAD_DST bit.
     *
     * Automatic Destination Reload
     */
    inline void toggle_CFGL_RELOAD_DST() volatile
    {
        CFGL ^= 1u << 31u;
    }

    /**
     * Get all of CFGL's bit fields.
     *
     * (read-write) Configuration Register Low
     */
    inline void get_CFGL(uint8_t &CH_PRIOR, GPDMA0_CH0_CFGL_CH_SUSP &CH_SUSP,
                         GPDMA0_CH0_CFGL_FIFO_EMPTY &FIFO_EMPTY,
                         GPDMA0_CH0_CFGL_HS_SEL_DST &HS_SEL_DST,
                         GPDMA0_CH0_CFGL_HS_SEL_SRC &HS_SEL_SRC,
                         GPDMA0_CH0_CFGL_LOCK_CH_L &LOCK_CH_L,
                         GPDMA0_CH0_CFGL_LOCK_CH_L &LOCK_B_L, bool &LOCK_CH,
                         bool &LOCK_B, GPDMA0_CH0_CFGL_DST_HS_POL &DST_HS_POL,
                         GPDMA0_CH0_CFGL_DST_HS_POL &SRC_HS_POL,
                         uint16_t &MAX_ABRST, bool &RELOAD_SRC,
                         bool &RELOAD_DST) volatile
    {
        uint32_t curr = CFGL;

        CH_PRIOR = (curr >> 5u) & 0b111u;
        CH_SUSP = GPDMA0_CH0_CFGL_CH_SUSP(curr & (1u << 8u));
        FIFO_EMPTY = GPDMA0_CH0_CFGL_FIFO_EMPTY(curr & (1u << 9u));
        HS_SEL_DST = GPDMA0_CH0_CFGL_HS_SEL_DST(curr & (1u << 10u));
        HS_SEL_SRC = GPDMA0_CH0_CFGL_HS_SEL_SRC(curr & (1u << 11u));
        LOCK_CH_L = GPDMA0_CH0_CFGL_LOCK_CH_L((curr >> 12u) & 0b11u);
        LOCK_B_L = GPDMA0_CH0_CFGL_LOCK_CH_L((curr >> 14u) & 0b11u);
        LOCK_CH = curr & (1u << 16u);
        LOCK_B = curr & (1u << 17u);
        DST_HS_POL = GPDMA0_CH0_CFGL_DST_HS_POL(curr & (1u << 18u));
        SRC_HS_POL = GPDMA0_CH0_CFGL_DST_HS_POL(curr & (1u << 19u));
        MAX_ABRST = (curr >> 20u) & 0b1111111111u;
        RELOAD_SRC = curr & (1u << 30u);
        RELOAD_DST = curr & (1u << 31u);
    }

    /**
     * Set all of CFGL's bit fields.
     *
     * (read-write) Configuration Register Low
     */
    inline void set_CFGL(uint8_t CH_PRIOR, GPDMA0_CH0_CFGL_CH_SUSP CH_SUSP,
                         GPDMA0_CH0_CFGL_HS_SEL_DST HS_SEL_DST,
                         GPDMA0_CH0_CFGL_HS_SEL_SRC HS_SEL_SRC,
                         GPDMA0_CH0_CFGL_LOCK_CH_L LOCK_CH_L,
                         GPDMA0_CH0_CFGL_LOCK_CH_L LOCK_B_L, bool LOCK_CH,
                         bool LOCK_B, GPDMA0_CH0_CFGL_DST_HS_POL DST_HS_POL,
                         GPDMA0_CH0_CFGL_DST_HS_POL SRC_HS_POL,
                         uint16_t MAX_ABRST, bool RELOAD_SRC,
                         bool RELOAD_DST) volatile
    {
        uint32_t curr = CFGL;

        curr &= ~(0b111u << 5u);
        curr |= (CH_PRIOR & 0b111u) << 5u;
        curr &= ~(0b1u << 8u);
        curr |= (std::to_underlying(CH_SUSP) & 0b1u) << 8u;
        curr &= ~(0b1u << 10u);
        curr |= (std::to_underlying(HS_SEL_DST) & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (std::to_underlying(HS_SEL_SRC) & 0b1u) << 11u;
        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(LOCK_CH_L) & 0b11u) << 12u;
        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(LOCK_B_L) & 0b11u) << 14u;
        curr &= ~(0b1u << 16u);
        curr |= (LOCK_CH & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (LOCK_B & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (std::to_underlying(DST_HS_POL) & 0b1u) << 18u;
        curr &= ~(0b1u << 19u);
        curr |= (std::to_underlying(SRC_HS_POL) & 0b1u) << 19u;
        curr &= ~(0b1111111111u << 20u);
        curr |= (MAX_ABRST & 0b1111111111u) << 20u;
        curr &= ~(0b1u << 30u);
        curr |= (RELOAD_SRC & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (RELOAD_DST & 0b1u) << 31u;

        CFGL = curr;
    }

    /**
     * Get CFGH's FCMODE bit.
     *
     * Flow Control Mode
     */
    inline GPDMA0_CH0_CFGH_FCMODE get_CFGH_FCMODE() volatile
    {
        return GPDMA0_CH0_CFGH_FCMODE(CFGH & (1u << 0u));
    }

    /**
     * Set CFGH's FCMODE bit.
     *
     * Flow Control Mode
     */
    inline void set_CFGH_FCMODE() volatile
    {
        CFGH |= 1u << 0u;
    }

    /**
     * Clear CFGH's FCMODE bit.
     *
     * Flow Control Mode
     */
    inline void clear_CFGH_FCMODE() volatile
    {
        CFGH &= ~(1u << 0u);
    }

    /**
     * Toggle CFGH's FCMODE bit.
     *
     * Flow Control Mode
     */
    inline void toggle_CFGH_FCMODE() volatile
    {
        CFGH ^= 1u << 0u;
    }

    /**
     * Get CFGH's FIFO_MODE bit.
     *
     * FIFO Mode Select
     */
    inline GPDMA0_CH0_CFGH_FIFO_MODE get_CFGH_FIFO_MODE() volatile
    {
        return GPDMA0_CH0_CFGH_FIFO_MODE(CFGH & (1u << 1u));
    }

    /**
     * Set CFGH's FIFO_MODE bit.
     *
     * FIFO Mode Select
     */
    inline void set_CFGH_FIFO_MODE() volatile
    {
        CFGH |= 1u << 1u;
    }

    /**
     * Clear CFGH's FIFO_MODE bit.
     *
     * FIFO Mode Select
     */
    inline void clear_CFGH_FIFO_MODE() volatile
    {
        CFGH &= ~(1u << 1u);
    }

    /**
     * Toggle CFGH's FIFO_MODE bit.
     *
     * FIFO Mode Select
     */
    inline void toggle_CFGH_FIFO_MODE() volatile
    {
        CFGH ^= 1u << 1u;
    }

    /**
     * Get CFGH's PROTCTL field.
     *
     * Protection Control
     */
    inline uint8_t get_CFGH_PROTCTL() volatile
    {
        return (CFGH >> 2u) & 0b111u;
    }

    /**
     * Set CFGH's PROTCTL field.
     *
     * Protection Control
     */
    inline void set_CFGH_PROTCTL(uint8_t value) volatile
    {
        uint32_t curr = CFGH;

        curr &= ~(0b111u << 2u);
        curr |= (value & 0b111u) << 2u;

        CFGH = curr;
    }

    /**
     * Get CFGH's DS_UPD_EN bit.
     *
     * Destination Status Update Enable
     */
    inline bool get_CFGH_DS_UPD_EN() volatile
    {
        return CFGH & (1u << 5u);
    }

    /**
     * Set CFGH's DS_UPD_EN bit.
     *
     * Destination Status Update Enable
     */
    inline void set_CFGH_DS_UPD_EN() volatile
    {
        CFGH |= 1u << 5u;
    }

    /**
     * Clear CFGH's DS_UPD_EN bit.
     *
     * Destination Status Update Enable
     */
    inline void clear_CFGH_DS_UPD_EN() volatile
    {
        CFGH &= ~(1u << 5u);
    }

    /**
     * Toggle CFGH's DS_UPD_EN bit.
     *
     * Destination Status Update Enable
     */
    inline void toggle_CFGH_DS_UPD_EN() volatile
    {
        CFGH ^= 1u << 5u;
    }

    /**
     * Get CFGH's SS_UPD_EN bit.
     *
     * Source Status Update Enable
     */
    inline bool get_CFGH_SS_UPD_EN() volatile
    {
        return CFGH & (1u << 6u);
    }

    /**
     * Set CFGH's SS_UPD_EN bit.
     *
     * Source Status Update Enable
     */
    inline void set_CFGH_SS_UPD_EN() volatile
    {
        CFGH |= 1u << 6u;
    }

    /**
     * Clear CFGH's SS_UPD_EN bit.
     *
     * Source Status Update Enable
     */
    inline void clear_CFGH_SS_UPD_EN() volatile
    {
        CFGH &= ~(1u << 6u);
    }

    /**
     * Toggle CFGH's SS_UPD_EN bit.
     *
     * Source Status Update Enable
     */
    inline void toggle_CFGH_SS_UPD_EN() volatile
    {
        CFGH ^= 1u << 6u;
    }

    /**
     * Get CFGH's SRC_PER field.
     *
     * Source Peripheral
     */
    inline uint8_t get_CFGH_SRC_PER() volatile
    {
        return (CFGH >> 7u) & 0b1111u;
    }

    /**
     * Set CFGH's SRC_PER field.
     *
     * Source Peripheral
     */
    inline void set_CFGH_SRC_PER(uint8_t value) volatile
    {
        uint32_t curr = CFGH;

        curr &= ~(0b1111u << 7u);
        curr |= (value & 0b1111u) << 7u;

        CFGH = curr;
    }

    /**
     * Get CFGH's DEST_PER field.
     *
     * Destination Peripheral
     */
    inline uint8_t get_CFGH_DEST_PER() volatile
    {
        return (CFGH >> 11u) & 0b1111u;
    }

    /**
     * Set CFGH's DEST_PER field.
     *
     * Destination Peripheral
     */
    inline void set_CFGH_DEST_PER(uint8_t value) volatile
    {
        uint32_t curr = CFGH;

        curr &= ~(0b1111u << 11u);
        curr |= (value & 0b1111u) << 11u;

        CFGH = curr;
    }

    /**
     * Get all of CFGH's bit fields.
     *
     * (read-write) Configuration Register High
     */
    inline void get_CFGH(GPDMA0_CH0_CFGH_FCMODE &FCMODE,
                         GPDMA0_CH0_CFGH_FIFO_MODE &FIFO_MODE,
                         uint8_t &PROTCTL, bool &DS_UPD_EN, bool &SS_UPD_EN,
                         uint8_t &SRC_PER, uint8_t &DEST_PER) volatile
    {
        uint32_t curr = CFGH;

        FCMODE = GPDMA0_CH0_CFGH_FCMODE(curr & (1u << 0u));
        FIFO_MODE = GPDMA0_CH0_CFGH_FIFO_MODE(curr & (1u << 1u));
        PROTCTL = (curr >> 2u) & 0b111u;
        DS_UPD_EN = curr & (1u << 5u);
        SS_UPD_EN = curr & (1u << 6u);
        SRC_PER = (curr >> 7u) & 0b1111u;
        DEST_PER = (curr >> 11u) & 0b1111u;
    }

    /**
     * Set all of CFGH's bit fields.
     *
     * (read-write) Configuration Register High
     */
    inline void set_CFGH(GPDMA0_CH0_CFGH_FCMODE FCMODE,
                         GPDMA0_CH0_CFGH_FIFO_MODE FIFO_MODE, uint8_t PROTCTL,
                         bool DS_UPD_EN, bool SS_UPD_EN, uint8_t SRC_PER,
                         uint8_t DEST_PER) volatile
    {
        uint32_t curr = CFGH;

        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(FCMODE) & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(FIFO_MODE) & 0b1u) << 1u;
        curr &= ~(0b111u << 2u);
        curr |= (PROTCTL & 0b111u) << 2u;
        curr &= ~(0b1u << 5u);
        curr |= (DS_UPD_EN & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (SS_UPD_EN & 0b1u) << 6u;
        curr &= ~(0b1111u << 7u);
        curr |= (SRC_PER & 0b1111u) << 7u;
        curr &= ~(0b1111u << 11u);
        curr |= (DEST_PER & 0b1111u) << 11u;

        CFGH = curr;
    }

    /**
     * Get SGR's SGI field.
     *
     * Source gather interval
     */
    inline uint32_t get_SGR_SGI() volatile
    {
        return (SGR >> 0u) & 0b11111111111111111111u;
    }

    /**
     * Set SGR's SGI field.
     *
     * Source gather interval
     */
    inline void set_SGR_SGI(uint32_t value) volatile
    {
        uint32_t curr = SGR;

        curr &= ~(0b11111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111u) << 0u;

        SGR = curr;
    }

    /**
     * Get SGR's SGC field.
     *
     * Source gather count
     */
    inline uint16_t get_SGR_SGC() volatile
    {
        return (SGR >> 20u) & 0b111111111111u;
    }

    /**
     * Set SGR's SGC field.
     *
     * Source gather count
     */
    inline void set_SGR_SGC(uint16_t value) volatile
    {
        uint32_t curr = SGR;

        curr &= ~(0b111111111111u << 20u);
        curr |= (value & 0b111111111111u) << 20u;

        SGR = curr;
    }

    /**
     * Get all of SGR's bit fields.
     *
     * (read-write) Source Gather Register
     */
    inline void get_SGR(uint32_t &SGI, uint16_t &SGC) volatile
    {
        uint32_t curr = SGR;

        SGI = (curr >> 0u) & 0b11111111111111111111u;
        SGC = (curr >> 20u) & 0b111111111111u;
    }

    /**
     * Set all of SGR's bit fields.
     *
     * (read-write) Source Gather Register
     */
    inline void set_SGR(uint32_t SGI, uint16_t SGC) volatile
    {
        uint32_t curr = SGR;

        curr &= ~(0b11111111111111111111u << 0u);
        curr |= (SGI & 0b11111111111111111111u) << 0u;
        curr &= ~(0b111111111111u << 20u);
        curr |= (SGC & 0b111111111111u) << 20u;

        SGR = curr;
    }

    /**
     * Get DSR's DSI field.
     *
     * Destination scatter interval
     */
    inline uint32_t get_DSR_DSI() volatile
    {
        return (DSR >> 0u) & 0b11111111111111111111u;
    }

    /**
     * Set DSR's DSI field.
     *
     * Destination scatter interval
     */
    inline void set_DSR_DSI(uint32_t value) volatile
    {
        uint32_t curr = DSR;

        curr &= ~(0b11111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111u) << 0u;

        DSR = curr;
    }

    /**
     * Get DSR's DSC field.
     *
     * Destination scatter count
     */
    inline uint16_t get_DSR_DSC() volatile
    {
        return (DSR >> 20u) & 0b111111111111u;
    }

    /**
     * Set DSR's DSC field.
     *
     * Destination scatter count
     */
    inline void set_DSR_DSC(uint16_t value) volatile
    {
        uint32_t curr = DSR;

        curr &= ~(0b111111111111u << 20u);
        curr |= (value & 0b111111111111u) << 20u;

        DSR = curr;
    }

    /**
     * Get all of DSR's bit fields.
     *
     * (read-write) Destination Scatter Register
     */
    inline void get_DSR(uint32_t &DSI, uint16_t &DSC) volatile
    {
        uint32_t curr = DSR;

        DSI = (curr >> 0u) & 0b11111111111111111111u;
        DSC = (curr >> 20u) & 0b111111111111u;
    }

    /**
     * Set all of DSR's bit fields.
     *
     * (read-write) Destination Scatter Register
     */
    inline void set_DSR(uint32_t DSI, uint16_t DSC) volatile
    {
        uint32_t curr = DSR;

        curr &= ~(0b11111111111111111111u << 0u);
        curr |= (DSI & 0b11111111111111111111u) << 0u;
        curr &= ~(0b111111111111u << 20u);
        curr |= (DSC & 0b111111111111u) << 20u;

        DSR = curr;
    }
};

static_assert(sizeof(gpdma0_ch0) == gpdma0_ch0::size);

static volatile gpdma0_ch0 *const GPDMA0_CH0 =
    reinterpret_cast<gpdma0_ch0 *>(0x50014000);

static volatile gpdma0_ch0 *const GPDMA0_CH1 =
    reinterpret_cast<gpdma0_ch0 *>(0x50014058);

}; // namespace XMC4700
