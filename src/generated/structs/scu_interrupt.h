/**
 * \file
 * \brief Generated by ifgen (3.1.7).
 */
#pragma once

#include "../enums/SCU_INTERRUPT_SRCLR_RMX.h"
#include "../enums/SCU_INTERRUPT_SRMSK_RMX.h"
#include "../enums/SCU_INTERRUPT_SRSET_RMX.h"
#include "../enums/SCU_INTERRUPT_SRSTAT_PRWARN.h"
#include "../enums/SCU_INTERRUPT_SRSTAT_RMX.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * System Control Unit
 */
struct [[gnu::packed]] scu_interrupt
{
    /* Constant attributes. */
    static constexpr std::size_t size =
        24; /*!< scu_interrupt's size in bytes. */

    /* Fields. */
    const uint32_t SRSTAT = {}; /*!< (read-only) SCU Service Request Status */
    const uint32_t SRRAW =
        {};            /*!< (read-only) SCU Raw Service Request Status */
    uint32_t SRMSK;    /*!< (read-write) SCU Service Request Mask */
    uint32_t SRCLR;    /*!< (write-only) SCU Service Request Clear */
    uint32_t SRSET;    /*!< (write-only) SCU Service Request Set */
    uint32_t NMIREQEN; /*!< (read-write) SCU Service Request Mask */

    /* Methods. */

    /**
     * Get SRSTAT's RMX bit.
     *
     * Retention Memory Mirror Register Update Status
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRSTAT_RMX() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRSTAT & (1u << 29u));
    }

    /**
     * Get SRSTAT's RTC_TIM1 bit.
     *
     * RTC TIM1 Mirror Register Update Status
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRSTAT_RTC_TIM1() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRSTAT & (1u << 28u));
    }

    /**
     * Get SRSTAT's RTC_TIM0 bit.
     *
     * RTC TIM0 Mirror Register Update Status
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRSTAT_RTC_TIM0() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRSTAT & (1u << 27u));
    }

    /**
     * Get SRSTAT's RTC_ATIM1 bit.
     *
     * RTC ATIM1 Mirror Register Update Status
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRSTAT_RTC_ATIM1() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRSTAT & (1u << 26u));
    }

    /**
     * Get SRSTAT's RTC_ATIM0 bit.
     *
     * RTC ATIM0 Mirror Register Update Status
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRSTAT_RTC_ATIM0() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRSTAT & (1u << 25u));
    }

    /**
     * Get SRSTAT's RTC_CTR bit.
     *
     * RTC CTR Mirror Register Update Status
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRSTAT_RTC_CTR() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRSTAT & (1u << 24u));
    }

    /**
     * Get SRSTAT's OSCULCTRL bit.
     *
     * OSCULCTRL Mirror Register Update Status
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRSTAT_OSCULCTRL() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRSTAT & (1u << 23u));
    }

    /**
     * Get SRSTAT's OSCSICTRL bit.
     *
     * OSCSICTRL Mirror Register Update Status
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRSTAT_OSCSICTRL() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRSTAT & (1u << 21u));
    }

    /**
     * Get SRSTAT's HDCR bit.
     *
     * HDCR Mirror Register Update Status
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRSTAT_HDCR() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRSTAT & (1u << 19u));
    }

    /**
     * Get SRSTAT's HDSET bit.
     *
     * HDSET Mirror Register Update Status
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRSTAT_HDSET() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRSTAT & (1u << 18u));
    }

    /**
     * Get SRSTAT's HDCLR bit.
     *
     * HDCLR Mirror Register Update Status
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRSTAT_HDCLR() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRSTAT & (1u << 17u));
    }

    /**
     * Get SRSTAT's DLROVR bit.
     *
     * DLR Request Overrun Interrupt Status
     */
    inline bool get_SRSTAT_DLROVR() volatile
    {
        return SRSTAT & (1u << 3u);
    }

    /**
     * Get SRSTAT's AI bit.
     *
     * Alarm Interrupt Status
     */
    inline bool get_SRSTAT_AI() volatile
    {
        return SRSTAT & (1u << 2u);
    }

    /**
     * Get SRSTAT's PI bit.
     *
     * RTC Periodic Interrupt Status
     */
    inline bool get_SRSTAT_PI() volatile
    {
        return SRSTAT & (1u << 1u);
    }

    /**
     * Get SRSTAT's PRWARN bit.
     *
     * WDT pre-warning Interrupt Status
     */
    inline SCU_INTERRUPT_SRSTAT_PRWARN get_SRSTAT_PRWARN() volatile
    {
        return SCU_INTERRUPT_SRSTAT_PRWARN(SRSTAT & (1u << 0u));
    }

    /**
     * Get all of SRSTAT's bit fields.
     *
     * (read-only) SCU Service Request Status
     */
    inline void get_SRSTAT(
        SCU_INTERRUPT_SRSTAT_RMX &RMX, SCU_INTERRUPT_SRSTAT_RMX &RTC_TIM1,
        SCU_INTERRUPT_SRSTAT_RMX &RTC_TIM0,
        SCU_INTERRUPT_SRSTAT_RMX &RTC_ATIM1,
        SCU_INTERRUPT_SRSTAT_RMX &RTC_ATIM0, SCU_INTERRUPT_SRSTAT_RMX &RTC_CTR,
        SCU_INTERRUPT_SRSTAT_RMX &OSCULCTRL,
        SCU_INTERRUPT_SRSTAT_RMX &OSCSICTRL, SCU_INTERRUPT_SRSTAT_RMX &HDCR,
        SCU_INTERRUPT_SRSTAT_RMX &HDSET, SCU_INTERRUPT_SRSTAT_RMX &HDCLR,
        bool &DLROVR, bool &AI, bool &PI,
        SCU_INTERRUPT_SRSTAT_PRWARN &PRWARN) volatile
    {
        uint32_t curr = SRSTAT;

        RMX = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 29u));
        RTC_TIM1 = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 28u));
        RTC_TIM0 = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 27u));
        RTC_ATIM1 = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 26u));
        RTC_ATIM0 = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 25u));
        RTC_CTR = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 24u));
        OSCULCTRL = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 23u));
        OSCSICTRL = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 21u));
        HDCR = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 19u));
        HDSET = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 18u));
        HDCLR = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 17u));
        DLROVR = curr & (1u << 3u);
        AI = curr & (1u << 2u);
        PI = curr & (1u << 1u);
        PRWARN = SCU_INTERRUPT_SRSTAT_PRWARN(curr & (1u << 0u));
    }

    /**
     * Get SRRAW's RMX bit.
     *
     * Retention Memory Mirror Register Update Status Before Masking
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRRAW_RMX() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRRAW & (1u << 29u));
    }

    /**
     * Get SRRAW's RTC_TIM1 bit.
     *
     * RTC TIM1 Mirror Register Update Status Before Masking
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRRAW_RTC_TIM1() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRRAW & (1u << 28u));
    }

    /**
     * Get SRRAW's RTC_TIM0 bit.
     *
     * RTC TIM0 Mirror Register Update Before Masking Status
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRRAW_RTC_TIM0() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRRAW & (1u << 27u));
    }

    /**
     * Get SRRAW's RTC_ATIM1 bit.
     *
     * RTC ATIM1 Mirror Register Update Status Before Masking
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRRAW_RTC_ATIM1() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRRAW & (1u << 26u));
    }

    /**
     * Get SRRAW's RTC_ATIM0 bit.
     *
     * RTC ATIM0 Mirror Register Update Status Before Masking
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRRAW_RTC_ATIM0() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRRAW & (1u << 25u));
    }

    /**
     * Get SRRAW's RTC_CTR bit.
     *
     * RTC CTR Mirror Register Update Status Before Masking
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRRAW_RTC_CTR() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRRAW & (1u << 24u));
    }

    /**
     * Get SRRAW's OSCULCTRL bit.
     *
     * OSCULCTRL Mirror Register Update Status Before Masking
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRRAW_OSCULCTRL() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRRAW & (1u << 23u));
    }

    /**
     * Get SRRAW's OSCSICTRL bit.
     *
     * OSCSICTRL Mirror Register Update Status Before Masking
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRRAW_OSCSICTRL() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRRAW & (1u << 21u));
    }

    /**
     * Get SRRAW's HDCR bit.
     *
     * HDCR Mirror Register Update Status Before Masking
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRRAW_HDCR() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRRAW & (1u << 19u));
    }

    /**
     * Get SRRAW's HDSET bit.
     *
     * HDSET Mirror Register Update Status Before Masking
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRRAW_HDSET() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRRAW & (1u << 18u));
    }

    /**
     * Get SRRAW's HDCLR bit.
     *
     * HDCLR Mirror Register Update Status Before Masking
     */
    inline SCU_INTERRUPT_SRSTAT_RMX get_SRRAW_HDCLR() volatile
    {
        return SCU_INTERRUPT_SRSTAT_RMX(SRRAW & (1u << 17u));
    }

    /**
     * Get SRRAW's DLROVR bit.
     *
     * DLR Request Overrun Interrupt Status Before Masking
     */
    inline bool get_SRRAW_DLROVR() volatile
    {
        return SRRAW & (1u << 3u);
    }

    /**
     * Get SRRAW's AI bit.
     *
     * RTC Raw Alarm Interrupt Status Before Masking
     */
    inline bool get_SRRAW_AI() volatile
    {
        return SRRAW & (1u << 2u);
    }

    /**
     * Get SRRAW's PI bit.
     *
     * RTC Raw Periodic Interrupt Status Before Masking
     */
    inline bool get_SRRAW_PI() volatile
    {
        return SRRAW & (1u << 1u);
    }

    /**
     * Get SRRAW's PRWARN bit.
     *
     * WDT pre-warning Interrupt Status Before Masking
     */
    inline SCU_INTERRUPT_SRSTAT_PRWARN get_SRRAW_PRWARN() volatile
    {
        return SCU_INTERRUPT_SRSTAT_PRWARN(SRRAW & (1u << 0u));
    }

    /**
     * Get all of SRRAW's bit fields.
     *
     * (read-only) SCU Raw Service Request Status
     */
    inline void get_SRRAW(
        SCU_INTERRUPT_SRSTAT_RMX &RMX, SCU_INTERRUPT_SRSTAT_RMX &RTC_TIM1,
        SCU_INTERRUPT_SRSTAT_RMX &RTC_TIM0,
        SCU_INTERRUPT_SRSTAT_RMX &RTC_ATIM1,
        SCU_INTERRUPT_SRSTAT_RMX &RTC_ATIM0, SCU_INTERRUPT_SRSTAT_RMX &RTC_CTR,
        SCU_INTERRUPT_SRSTAT_RMX &OSCULCTRL,
        SCU_INTERRUPT_SRSTAT_RMX &OSCSICTRL, SCU_INTERRUPT_SRSTAT_RMX &HDCR,
        SCU_INTERRUPT_SRSTAT_RMX &HDSET, SCU_INTERRUPT_SRSTAT_RMX &HDCLR,
        bool &DLROVR, bool &AI, bool &PI,
        SCU_INTERRUPT_SRSTAT_PRWARN &PRWARN) volatile
    {
        uint32_t curr = SRRAW;

        RMX = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 29u));
        RTC_TIM1 = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 28u));
        RTC_TIM0 = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 27u));
        RTC_ATIM1 = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 26u));
        RTC_ATIM0 = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 25u));
        RTC_CTR = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 24u));
        OSCULCTRL = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 23u));
        OSCSICTRL = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 21u));
        HDCR = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 19u));
        HDSET = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 18u));
        HDCLR = SCU_INTERRUPT_SRSTAT_RMX(curr & (1u << 17u));
        DLROVR = curr & (1u << 3u);
        AI = curr & (1u << 2u);
        PI = curr & (1u << 1u);
        PRWARN = SCU_INTERRUPT_SRSTAT_PRWARN(curr & (1u << 0u));
    }

    /**
     * Get SRMSK's RMX bit.
     *
     * Retention Memory Mirror Register Update Mask
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_SRMSK_RMX() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(SRMSK & (1u << 29u));
    }

    /**
     * Set SRMSK's RMX bit.
     *
     * Retention Memory Mirror Register Update Mask
     */
    inline void set_SRMSK_RMX() volatile
    {
        SRMSK |= 1u << 29u;
    }

    /**
     * Clear SRMSK's RMX bit.
     *
     * Retention Memory Mirror Register Update Mask
     */
    inline void clear_SRMSK_RMX() volatile
    {
        SRMSK &= ~(1u << 29u);
    }

    /**
     * Toggle SRMSK's RMX bit.
     *
     * Retention Memory Mirror Register Update Mask
     */
    inline void toggle_SRMSK_RMX() volatile
    {
        SRMSK ^= 1u << 29u;
    }

    /**
     * Get SRMSK's RTC_TIM1 bit.
     *
     * RTC TIM1 Mirror Register Update Mask
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_SRMSK_RTC_TIM1() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(SRMSK & (1u << 28u));
    }

    /**
     * Set SRMSK's RTC_TIM1 bit.
     *
     * RTC TIM1 Mirror Register Update Mask
     */
    inline void set_SRMSK_RTC_TIM1() volatile
    {
        SRMSK |= 1u << 28u;
    }

    /**
     * Clear SRMSK's RTC_TIM1 bit.
     *
     * RTC TIM1 Mirror Register Update Mask
     */
    inline void clear_SRMSK_RTC_TIM1() volatile
    {
        SRMSK &= ~(1u << 28u);
    }

    /**
     * Toggle SRMSK's RTC_TIM1 bit.
     *
     * RTC TIM1 Mirror Register Update Mask
     */
    inline void toggle_SRMSK_RTC_TIM1() volatile
    {
        SRMSK ^= 1u << 28u;
    }

    /**
     * Get SRMSK's RTC_TIM0 bit.
     *
     * RTC TIM0 Mirror Register Update Mask
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_SRMSK_RTC_TIM0() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(SRMSK & (1u << 27u));
    }

    /**
     * Set SRMSK's RTC_TIM0 bit.
     *
     * RTC TIM0 Mirror Register Update Mask
     */
    inline void set_SRMSK_RTC_TIM0() volatile
    {
        SRMSK |= 1u << 27u;
    }

    /**
     * Clear SRMSK's RTC_TIM0 bit.
     *
     * RTC TIM0 Mirror Register Update Mask
     */
    inline void clear_SRMSK_RTC_TIM0() volatile
    {
        SRMSK &= ~(1u << 27u);
    }

    /**
     * Toggle SRMSK's RTC_TIM0 bit.
     *
     * RTC TIM0 Mirror Register Update Mask
     */
    inline void toggle_SRMSK_RTC_TIM0() volatile
    {
        SRMSK ^= 1u << 27u;
    }

    /**
     * Get SRMSK's RTC_ATIM1 bit.
     *
     * RTC ATIM1 Mirror Register Update Mask
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_SRMSK_RTC_ATIM1() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(SRMSK & (1u << 26u));
    }

    /**
     * Set SRMSK's RTC_ATIM1 bit.
     *
     * RTC ATIM1 Mirror Register Update Mask
     */
    inline void set_SRMSK_RTC_ATIM1() volatile
    {
        SRMSK |= 1u << 26u;
    }

    /**
     * Clear SRMSK's RTC_ATIM1 bit.
     *
     * RTC ATIM1 Mirror Register Update Mask
     */
    inline void clear_SRMSK_RTC_ATIM1() volatile
    {
        SRMSK &= ~(1u << 26u);
    }

    /**
     * Toggle SRMSK's RTC_ATIM1 bit.
     *
     * RTC ATIM1 Mirror Register Update Mask
     */
    inline void toggle_SRMSK_RTC_ATIM1() volatile
    {
        SRMSK ^= 1u << 26u;
    }

    /**
     * Get SRMSK's RTC_ATIM0 bit.
     *
     * RTC ATIM0 Mirror Register Update Mask
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_SRMSK_RTC_ATIM0() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(SRMSK & (1u << 25u));
    }

    /**
     * Set SRMSK's RTC_ATIM0 bit.
     *
     * RTC ATIM0 Mirror Register Update Mask
     */
    inline void set_SRMSK_RTC_ATIM0() volatile
    {
        SRMSK |= 1u << 25u;
    }

    /**
     * Clear SRMSK's RTC_ATIM0 bit.
     *
     * RTC ATIM0 Mirror Register Update Mask
     */
    inline void clear_SRMSK_RTC_ATIM0() volatile
    {
        SRMSK &= ~(1u << 25u);
    }

    /**
     * Toggle SRMSK's RTC_ATIM0 bit.
     *
     * RTC ATIM0 Mirror Register Update Mask
     */
    inline void toggle_SRMSK_RTC_ATIM0() volatile
    {
        SRMSK ^= 1u << 25u;
    }

    /**
     * Get SRMSK's RTC_CTR bit.
     *
     * RTC CTR Mirror Register Update Mask
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_SRMSK_RTC_CTR() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(SRMSK & (1u << 24u));
    }

    /**
     * Set SRMSK's RTC_CTR bit.
     *
     * RTC CTR Mirror Register Update Mask
     */
    inline void set_SRMSK_RTC_CTR() volatile
    {
        SRMSK |= 1u << 24u;
    }

    /**
     * Clear SRMSK's RTC_CTR bit.
     *
     * RTC CTR Mirror Register Update Mask
     */
    inline void clear_SRMSK_RTC_CTR() volatile
    {
        SRMSK &= ~(1u << 24u);
    }

    /**
     * Toggle SRMSK's RTC_CTR bit.
     *
     * RTC CTR Mirror Register Update Mask
     */
    inline void toggle_SRMSK_RTC_CTR() volatile
    {
        SRMSK ^= 1u << 24u;
    }

    /**
     * Get SRMSK's OSCULCTRL bit.
     *
     * OSCULCTRL Mirror Register Update Mask
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_SRMSK_OSCULCTRL() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(SRMSK & (1u << 23u));
    }

    /**
     * Set SRMSK's OSCULCTRL bit.
     *
     * OSCULCTRL Mirror Register Update Mask
     */
    inline void set_SRMSK_OSCULCTRL() volatile
    {
        SRMSK |= 1u << 23u;
    }

    /**
     * Clear SRMSK's OSCULCTRL bit.
     *
     * OSCULCTRL Mirror Register Update Mask
     */
    inline void clear_SRMSK_OSCULCTRL() volatile
    {
        SRMSK &= ~(1u << 23u);
    }

    /**
     * Toggle SRMSK's OSCULCTRL bit.
     *
     * OSCULCTRL Mirror Register Update Mask
     */
    inline void toggle_SRMSK_OSCULCTRL() volatile
    {
        SRMSK ^= 1u << 23u;
    }

    /**
     * Get SRMSK's OSCSICTRL bit.
     *
     * OSCSICTRL Mirror Register Update Mask
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_SRMSK_OSCSICTRL() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(SRMSK & (1u << 21u));
    }

    /**
     * Set SRMSK's OSCSICTRL bit.
     *
     * OSCSICTRL Mirror Register Update Mask
     */
    inline void set_SRMSK_OSCSICTRL() volatile
    {
        SRMSK |= 1u << 21u;
    }

    /**
     * Clear SRMSK's OSCSICTRL bit.
     *
     * OSCSICTRL Mirror Register Update Mask
     */
    inline void clear_SRMSK_OSCSICTRL() volatile
    {
        SRMSK &= ~(1u << 21u);
    }

    /**
     * Toggle SRMSK's OSCSICTRL bit.
     *
     * OSCSICTRL Mirror Register Update Mask
     */
    inline void toggle_SRMSK_OSCSICTRL() volatile
    {
        SRMSK ^= 1u << 21u;
    }

    /**
     * Get SRMSK's HDCR bit.
     *
     * HDCR Mirror Register Update Mask
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_SRMSK_HDCR() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(SRMSK & (1u << 19u));
    }

    /**
     * Set SRMSK's HDCR bit.
     *
     * HDCR Mirror Register Update Mask
     */
    inline void set_SRMSK_HDCR() volatile
    {
        SRMSK |= 1u << 19u;
    }

    /**
     * Clear SRMSK's HDCR bit.
     *
     * HDCR Mirror Register Update Mask
     */
    inline void clear_SRMSK_HDCR() volatile
    {
        SRMSK &= ~(1u << 19u);
    }

    /**
     * Toggle SRMSK's HDCR bit.
     *
     * HDCR Mirror Register Update Mask
     */
    inline void toggle_SRMSK_HDCR() volatile
    {
        SRMSK ^= 1u << 19u;
    }

    /**
     * Get SRMSK's HDSET bit.
     *
     * HDSET Mirror Register Update Mask
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_SRMSK_HDSET() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(SRMSK & (1u << 18u));
    }

    /**
     * Set SRMSK's HDSET bit.
     *
     * HDSET Mirror Register Update Mask
     */
    inline void set_SRMSK_HDSET() volatile
    {
        SRMSK |= 1u << 18u;
    }

    /**
     * Clear SRMSK's HDSET bit.
     *
     * HDSET Mirror Register Update Mask
     */
    inline void clear_SRMSK_HDSET() volatile
    {
        SRMSK &= ~(1u << 18u);
    }

    /**
     * Toggle SRMSK's HDSET bit.
     *
     * HDSET Mirror Register Update Mask
     */
    inline void toggle_SRMSK_HDSET() volatile
    {
        SRMSK ^= 1u << 18u;
    }

    /**
     * Get SRMSK's HDCLR bit.
     *
     * HDCLR Mirror Register Update Mask
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_SRMSK_HDCLR() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(SRMSK & (1u << 17u));
    }

    /**
     * Set SRMSK's HDCLR bit.
     *
     * HDCLR Mirror Register Update Mask
     */
    inline void set_SRMSK_HDCLR() volatile
    {
        SRMSK |= 1u << 17u;
    }

    /**
     * Clear SRMSK's HDCLR bit.
     *
     * HDCLR Mirror Register Update Mask
     */
    inline void clear_SRMSK_HDCLR() volatile
    {
        SRMSK &= ~(1u << 17u);
    }

    /**
     * Toggle SRMSK's HDCLR bit.
     *
     * HDCLR Mirror Register Update Mask
     */
    inline void toggle_SRMSK_HDCLR() volatile
    {
        SRMSK ^= 1u << 17u;
    }

    /**
     * Get SRMSK's DLROVR bit.
     *
     * DLR Request Overrun Interrupt Mask
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_SRMSK_DLROVR() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(SRMSK & (1u << 3u));
    }

    /**
     * Set SRMSK's DLROVR bit.
     *
     * DLR Request Overrun Interrupt Mask
     */
    inline void set_SRMSK_DLROVR() volatile
    {
        SRMSK |= 1u << 3u;
    }

    /**
     * Clear SRMSK's DLROVR bit.
     *
     * DLR Request Overrun Interrupt Mask
     */
    inline void clear_SRMSK_DLROVR() volatile
    {
        SRMSK &= ~(1u << 3u);
    }

    /**
     * Toggle SRMSK's DLROVR bit.
     *
     * DLR Request Overrun Interrupt Mask
     */
    inline void toggle_SRMSK_DLROVR() volatile
    {
        SRMSK ^= 1u << 3u;
    }

    /**
     * Get SRMSK's AI bit.
     *
     * RTC Alarm Interrupt Mask
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_SRMSK_AI() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(SRMSK & (1u << 2u));
    }

    /**
     * Set SRMSK's AI bit.
     *
     * RTC Alarm Interrupt Mask
     */
    inline void set_SRMSK_AI() volatile
    {
        SRMSK |= 1u << 2u;
    }

    /**
     * Clear SRMSK's AI bit.
     *
     * RTC Alarm Interrupt Mask
     */
    inline void clear_SRMSK_AI() volatile
    {
        SRMSK &= ~(1u << 2u);
    }

    /**
     * Toggle SRMSK's AI bit.
     *
     * RTC Alarm Interrupt Mask
     */
    inline void toggle_SRMSK_AI() volatile
    {
        SRMSK ^= 1u << 2u;
    }

    /**
     * Get SRMSK's PI bit.
     *
     * RTC Periodic Interrupt Mask
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_SRMSK_PI() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(SRMSK & (1u << 1u));
    }

    /**
     * Set SRMSK's PI bit.
     *
     * RTC Periodic Interrupt Mask
     */
    inline void set_SRMSK_PI() volatile
    {
        SRMSK |= 1u << 1u;
    }

    /**
     * Clear SRMSK's PI bit.
     *
     * RTC Periodic Interrupt Mask
     */
    inline void clear_SRMSK_PI() volatile
    {
        SRMSK &= ~(1u << 1u);
    }

    /**
     * Toggle SRMSK's PI bit.
     *
     * RTC Periodic Interrupt Mask
     */
    inline void toggle_SRMSK_PI() volatile
    {
        SRMSK ^= 1u << 1u;
    }

    /**
     * Get SRMSK's PRWARN bit.
     *
     * WDT pre-warning Interrupt Mask
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_SRMSK_PRWARN() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(SRMSK & (1u << 0u));
    }

    /**
     * Set SRMSK's PRWARN bit.
     *
     * WDT pre-warning Interrupt Mask
     */
    inline void set_SRMSK_PRWARN() volatile
    {
        SRMSK |= 1u << 0u;
    }

    /**
     * Clear SRMSK's PRWARN bit.
     *
     * WDT pre-warning Interrupt Mask
     */
    inline void clear_SRMSK_PRWARN() volatile
    {
        SRMSK &= ~(1u << 0u);
    }

    /**
     * Toggle SRMSK's PRWARN bit.
     *
     * WDT pre-warning Interrupt Mask
     */
    inline void toggle_SRMSK_PRWARN() volatile
    {
        SRMSK ^= 1u << 0u;
    }

    /**
     * Get all of SRMSK's bit fields.
     *
     * (read-write) SCU Service Request Mask
     */
    inline void get_SRMSK(
        SCU_INTERRUPT_SRMSK_RMX &RMX, SCU_INTERRUPT_SRMSK_RMX &RTC_TIM1,
        SCU_INTERRUPT_SRMSK_RMX &RTC_TIM0, SCU_INTERRUPT_SRMSK_RMX &RTC_ATIM1,
        SCU_INTERRUPT_SRMSK_RMX &RTC_ATIM0, SCU_INTERRUPT_SRMSK_RMX &RTC_CTR,
        SCU_INTERRUPT_SRMSK_RMX &OSCULCTRL, SCU_INTERRUPT_SRMSK_RMX &OSCSICTRL,
        SCU_INTERRUPT_SRMSK_RMX &HDCR, SCU_INTERRUPT_SRMSK_RMX &HDSET,
        SCU_INTERRUPT_SRMSK_RMX &HDCLR, SCU_INTERRUPT_SRMSK_RMX &DLROVR,
        SCU_INTERRUPT_SRMSK_RMX &AI, SCU_INTERRUPT_SRMSK_RMX &PI,
        SCU_INTERRUPT_SRMSK_RMX &PRWARN) volatile
    {
        uint32_t curr = SRMSK;

        RMX = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 29u));
        RTC_TIM1 = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 28u));
        RTC_TIM0 = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 27u));
        RTC_ATIM1 = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 26u));
        RTC_ATIM0 = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 25u));
        RTC_CTR = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 24u));
        OSCULCTRL = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 23u));
        OSCSICTRL = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 21u));
        HDCR = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 19u));
        HDSET = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 18u));
        HDCLR = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 17u));
        DLROVR = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 3u));
        AI = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 2u));
        PI = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 1u));
        PRWARN = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 0u));
    }

    /**
     * Set all of SRMSK's bit fields.
     *
     * (read-write) SCU Service Request Mask
     */
    inline void set_SRMSK(
        SCU_INTERRUPT_SRMSK_RMX RMX, SCU_INTERRUPT_SRMSK_RMX RTC_TIM1,
        SCU_INTERRUPT_SRMSK_RMX RTC_TIM0, SCU_INTERRUPT_SRMSK_RMX RTC_ATIM1,
        SCU_INTERRUPT_SRMSK_RMX RTC_ATIM0, SCU_INTERRUPT_SRMSK_RMX RTC_CTR,
        SCU_INTERRUPT_SRMSK_RMX OSCULCTRL, SCU_INTERRUPT_SRMSK_RMX OSCSICTRL,
        SCU_INTERRUPT_SRMSK_RMX HDCR, SCU_INTERRUPT_SRMSK_RMX HDSET,
        SCU_INTERRUPT_SRMSK_RMX HDCLR, SCU_INTERRUPT_SRMSK_RMX DLROVR,
        SCU_INTERRUPT_SRMSK_RMX AI, SCU_INTERRUPT_SRMSK_RMX PI,
        SCU_INTERRUPT_SRMSK_RMX PRWARN) volatile
    {
        uint32_t curr = SRMSK;

        curr &= ~(0b1u << 29u);
        curr |= (std::to_underlying(RMX) & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (std::to_underlying(RTC_TIM1) & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (std::to_underlying(RTC_TIM0) & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (std::to_underlying(RTC_ATIM1) & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (std::to_underlying(RTC_ATIM0) & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (std::to_underlying(RTC_CTR) & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (std::to_underlying(OSCULCTRL) & 0b1u) << 23u;
        curr &= ~(0b1u << 21u);
        curr |= (std::to_underlying(OSCSICTRL) & 0b1u) << 21u;
        curr &= ~(0b1u << 19u);
        curr |= (std::to_underlying(HDCR) & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (std::to_underlying(HDSET) & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(HDCLR) & 0b1u) << 17u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(DLROVR) & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (std::to_underlying(AI) & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(PI) & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(PRWARN) & 0b1u) << 0u;

        SRMSK = curr;
    }

    /**
     * Set SRCLR's RMX bit.
     *
     * Retention Memory Mirror Register Update Clear
     */
    inline void set_SRCLR_RMX() volatile
    {
        SRCLR |= 1u << 29u;
    }

    /**
     * Clear SRCLR's RMX bit.
     *
     * Retention Memory Mirror Register Update Clear
     */
    inline void clear_SRCLR_RMX() volatile
    {
        SRCLR &= ~(1u << 29u);
    }

    /**
     * Toggle SRCLR's RMX bit.
     *
     * Retention Memory Mirror Register Update Clear
     */
    inline void toggle_SRCLR_RMX() volatile
    {
        SRCLR ^= 1u << 29u;
    }

    /**
     * Set SRCLR's RTC_TIM1 bit.
     *
     * RTC TIM1 Mirror Register Update Clear
     */
    inline void set_SRCLR_RTC_TIM1() volatile
    {
        SRCLR |= 1u << 28u;
    }

    /**
     * Clear SRCLR's RTC_TIM1 bit.
     *
     * RTC TIM1 Mirror Register Update Clear
     */
    inline void clear_SRCLR_RTC_TIM1() volatile
    {
        SRCLR &= ~(1u << 28u);
    }

    /**
     * Toggle SRCLR's RTC_TIM1 bit.
     *
     * RTC TIM1 Mirror Register Update Clear
     */
    inline void toggle_SRCLR_RTC_TIM1() volatile
    {
        SRCLR ^= 1u << 28u;
    }

    /**
     * Set SRCLR's RTC_TIM0 bit.
     *
     * RTC TIM0 Mirror Register Update Clear
     */
    inline void set_SRCLR_RTC_TIM0() volatile
    {
        SRCLR |= 1u << 27u;
    }

    /**
     * Clear SRCLR's RTC_TIM0 bit.
     *
     * RTC TIM0 Mirror Register Update Clear
     */
    inline void clear_SRCLR_RTC_TIM0() volatile
    {
        SRCLR &= ~(1u << 27u);
    }

    /**
     * Toggle SRCLR's RTC_TIM0 bit.
     *
     * RTC TIM0 Mirror Register Update Clear
     */
    inline void toggle_SRCLR_RTC_TIM0() volatile
    {
        SRCLR ^= 1u << 27u;
    }

    /**
     * Set SRCLR's RTC_ATIM1 bit.
     *
     * RTC ATIM1 Mirror Register Update Clear
     */
    inline void set_SRCLR_RTC_ATIM1() volatile
    {
        SRCLR |= 1u << 26u;
    }

    /**
     * Clear SRCLR's RTC_ATIM1 bit.
     *
     * RTC ATIM1 Mirror Register Update Clear
     */
    inline void clear_SRCLR_RTC_ATIM1() volatile
    {
        SRCLR &= ~(1u << 26u);
    }

    /**
     * Toggle SRCLR's RTC_ATIM1 bit.
     *
     * RTC ATIM1 Mirror Register Update Clear
     */
    inline void toggle_SRCLR_RTC_ATIM1() volatile
    {
        SRCLR ^= 1u << 26u;
    }

    /**
     * Set SRCLR's RTC_ATIM0 bit.
     *
     * RTC ATIM0 Mirror Register Update Clear
     */
    inline void set_SRCLR_RTC_ATIM0() volatile
    {
        SRCLR |= 1u << 25u;
    }

    /**
     * Clear SRCLR's RTC_ATIM0 bit.
     *
     * RTC ATIM0 Mirror Register Update Clear
     */
    inline void clear_SRCLR_RTC_ATIM0() volatile
    {
        SRCLR &= ~(1u << 25u);
    }

    /**
     * Toggle SRCLR's RTC_ATIM0 bit.
     *
     * RTC ATIM0 Mirror Register Update Clear
     */
    inline void toggle_SRCLR_RTC_ATIM0() volatile
    {
        SRCLR ^= 1u << 25u;
    }

    /**
     * Set SRCLR's RTC_CTR bit.
     *
     * RTC CTR Mirror Register Update Clear
     */
    inline void set_SRCLR_RTC_CTR() volatile
    {
        SRCLR |= 1u << 24u;
    }

    /**
     * Clear SRCLR's RTC_CTR bit.
     *
     * RTC CTR Mirror Register Update Clear
     */
    inline void clear_SRCLR_RTC_CTR() volatile
    {
        SRCLR &= ~(1u << 24u);
    }

    /**
     * Toggle SRCLR's RTC_CTR bit.
     *
     * RTC CTR Mirror Register Update Clear
     */
    inline void toggle_SRCLR_RTC_CTR() volatile
    {
        SRCLR ^= 1u << 24u;
    }

    /**
     * Set SRCLR's OSCULCTRL bit.
     *
     * OSCULCTRL Mirror Register Update Clear
     */
    inline void set_SRCLR_OSCULCTRL() volatile
    {
        SRCLR |= 1u << 23u;
    }

    /**
     * Clear SRCLR's OSCULCTRL bit.
     *
     * OSCULCTRL Mirror Register Update Clear
     */
    inline void clear_SRCLR_OSCULCTRL() volatile
    {
        SRCLR &= ~(1u << 23u);
    }

    /**
     * Toggle SRCLR's OSCULCTRL bit.
     *
     * OSCULCTRL Mirror Register Update Clear
     */
    inline void toggle_SRCLR_OSCULCTRL() volatile
    {
        SRCLR ^= 1u << 23u;
    }

    /**
     * Set SRCLR's OSCSICTRL bit.
     *
     * OSCSICTRL Mirror Register Update Clear
     */
    inline void set_SRCLR_OSCSICTRL() volatile
    {
        SRCLR |= 1u << 21u;
    }

    /**
     * Clear SRCLR's OSCSICTRL bit.
     *
     * OSCSICTRL Mirror Register Update Clear
     */
    inline void clear_SRCLR_OSCSICTRL() volatile
    {
        SRCLR &= ~(1u << 21u);
    }

    /**
     * Toggle SRCLR's OSCSICTRL bit.
     *
     * OSCSICTRL Mirror Register Update Clear
     */
    inline void toggle_SRCLR_OSCSICTRL() volatile
    {
        SRCLR ^= 1u << 21u;
    }

    /**
     * Set SRCLR's HDCR bit.
     *
     * HDCR Mirror Register Update Clear
     */
    inline void set_SRCLR_HDCR() volatile
    {
        SRCLR |= 1u << 19u;
    }

    /**
     * Clear SRCLR's HDCR bit.
     *
     * HDCR Mirror Register Update Clear
     */
    inline void clear_SRCLR_HDCR() volatile
    {
        SRCLR &= ~(1u << 19u);
    }

    /**
     * Toggle SRCLR's HDCR bit.
     *
     * HDCR Mirror Register Update Clear
     */
    inline void toggle_SRCLR_HDCR() volatile
    {
        SRCLR ^= 1u << 19u;
    }

    /**
     * Set SRCLR's HDSET bit.
     *
     * HDSET Mirror Register Update Clear
     */
    inline void set_SRCLR_HDSET() volatile
    {
        SRCLR |= 1u << 18u;
    }

    /**
     * Clear SRCLR's HDSET bit.
     *
     * HDSET Mirror Register Update Clear
     */
    inline void clear_SRCLR_HDSET() volatile
    {
        SRCLR &= ~(1u << 18u);
    }

    /**
     * Toggle SRCLR's HDSET bit.
     *
     * HDSET Mirror Register Update Clear
     */
    inline void toggle_SRCLR_HDSET() volatile
    {
        SRCLR ^= 1u << 18u;
    }

    /**
     * Set SRCLR's HDCLR bit.
     *
     * HDCLR Mirror Register Update Clear
     */
    inline void set_SRCLR_HDCLR() volatile
    {
        SRCLR |= 1u << 17u;
    }

    /**
     * Clear SRCLR's HDCLR bit.
     *
     * HDCLR Mirror Register Update Clear
     */
    inline void clear_SRCLR_HDCLR() volatile
    {
        SRCLR &= ~(1u << 17u);
    }

    /**
     * Toggle SRCLR's HDCLR bit.
     *
     * HDCLR Mirror Register Update Clear
     */
    inline void toggle_SRCLR_HDCLR() volatile
    {
        SRCLR ^= 1u << 17u;
    }

    /**
     * Set SRCLR's DLROVR bit.
     *
     * DLR Request Overrun Interrupt clear
     */
    inline void set_SRCLR_DLROVR() volatile
    {
        SRCLR |= 1u << 3u;
    }

    /**
     * Clear SRCLR's DLROVR bit.
     *
     * DLR Request Overrun Interrupt clear
     */
    inline void clear_SRCLR_DLROVR() volatile
    {
        SRCLR &= ~(1u << 3u);
    }

    /**
     * Toggle SRCLR's DLROVR bit.
     *
     * DLR Request Overrun Interrupt clear
     */
    inline void toggle_SRCLR_DLROVR() volatile
    {
        SRCLR ^= 1u << 3u;
    }

    /**
     * Set SRCLR's AI bit.
     *
     * RTC Alarm Interrupt Clear
     */
    inline void set_SRCLR_AI() volatile
    {
        SRCLR |= 1u << 2u;
    }

    /**
     * Clear SRCLR's AI bit.
     *
     * RTC Alarm Interrupt Clear
     */
    inline void clear_SRCLR_AI() volatile
    {
        SRCLR &= ~(1u << 2u);
    }

    /**
     * Toggle SRCLR's AI bit.
     *
     * RTC Alarm Interrupt Clear
     */
    inline void toggle_SRCLR_AI() volatile
    {
        SRCLR ^= 1u << 2u;
    }

    /**
     * Set SRCLR's PI bit.
     *
     * RTC Periodic Interrupt Clear
     */
    inline void set_SRCLR_PI() volatile
    {
        SRCLR |= 1u << 1u;
    }

    /**
     * Clear SRCLR's PI bit.
     *
     * RTC Periodic Interrupt Clear
     */
    inline void clear_SRCLR_PI() volatile
    {
        SRCLR &= ~(1u << 1u);
    }

    /**
     * Toggle SRCLR's PI bit.
     *
     * RTC Periodic Interrupt Clear
     */
    inline void toggle_SRCLR_PI() volatile
    {
        SRCLR ^= 1u << 1u;
    }

    /**
     * Set SRCLR's PRWARN bit.
     *
     * WDT pre-warning Interrupt Clear
     */
    inline void set_SRCLR_PRWARN() volatile
    {
        SRCLR |= 1u << 0u;
    }

    /**
     * Clear SRCLR's PRWARN bit.
     *
     * WDT pre-warning Interrupt Clear
     */
    inline void clear_SRCLR_PRWARN() volatile
    {
        SRCLR &= ~(1u << 0u);
    }

    /**
     * Toggle SRCLR's PRWARN bit.
     *
     * WDT pre-warning Interrupt Clear
     */
    inline void toggle_SRCLR_PRWARN() volatile
    {
        SRCLR ^= 1u << 0u;
    }

    /**
     * Set all of SRCLR's bit fields.
     *
     * (write-only) SCU Service Request Clear
     */
    inline void set_SRCLR(
        SCU_INTERRUPT_SRCLR_RMX RMX, SCU_INTERRUPT_SRCLR_RMX RTC_TIM1,
        SCU_INTERRUPT_SRCLR_RMX RTC_TIM0, SCU_INTERRUPT_SRCLR_RMX RTC_ATIM1,
        SCU_INTERRUPT_SRCLR_RMX RTC_ATIM0, SCU_INTERRUPT_SRCLR_RMX RTC_CTR,
        SCU_INTERRUPT_SRCLR_RMX OSCULCTRL, SCU_INTERRUPT_SRCLR_RMX OSCSICTRL,
        SCU_INTERRUPT_SRCLR_RMX HDCR, SCU_INTERRUPT_SRCLR_RMX HDSET,
        SCU_INTERRUPT_SRCLR_RMX HDCLR, SCU_INTERRUPT_SRCLR_RMX DLROVR,
        SCU_INTERRUPT_SRCLR_RMX AI, SCU_INTERRUPT_SRCLR_RMX PI,
        SCU_INTERRUPT_SRCLR_RMX PRWARN) volatile
    {
        uint32_t curr = SRCLR;

        curr &= ~(0b1u << 29u);
        curr |= (std::to_underlying(RMX) & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (std::to_underlying(RTC_TIM1) & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (std::to_underlying(RTC_TIM0) & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (std::to_underlying(RTC_ATIM1) & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (std::to_underlying(RTC_ATIM0) & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (std::to_underlying(RTC_CTR) & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (std::to_underlying(OSCULCTRL) & 0b1u) << 23u;
        curr &= ~(0b1u << 21u);
        curr |= (std::to_underlying(OSCSICTRL) & 0b1u) << 21u;
        curr &= ~(0b1u << 19u);
        curr |= (std::to_underlying(HDCR) & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (std::to_underlying(HDSET) & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(HDCLR) & 0b1u) << 17u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(DLROVR) & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (std::to_underlying(AI) & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(PI) & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(PRWARN) & 0b1u) << 0u;

        SRCLR = curr;
    }

    /**
     * Set SRSET's RMX bit.
     *
     * Retention Memory Mirror Register Update Set
     */
    inline void set_SRSET_RMX() volatile
    {
        SRSET |= 1u << 29u;
    }

    /**
     * Clear SRSET's RMX bit.
     *
     * Retention Memory Mirror Register Update Set
     */
    inline void clear_SRSET_RMX() volatile
    {
        SRSET &= ~(1u << 29u);
    }

    /**
     * Toggle SRSET's RMX bit.
     *
     * Retention Memory Mirror Register Update Set
     */
    inline void toggle_SRSET_RMX() volatile
    {
        SRSET ^= 1u << 29u;
    }

    /**
     * Set SRSET's RTC_TIM1 bit.
     *
     * RTC TIM1 Mirror Register Update Set
     */
    inline void set_SRSET_RTC_TIM1() volatile
    {
        SRSET |= 1u << 28u;
    }

    /**
     * Clear SRSET's RTC_TIM1 bit.
     *
     * RTC TIM1 Mirror Register Update Set
     */
    inline void clear_SRSET_RTC_TIM1() volatile
    {
        SRSET &= ~(1u << 28u);
    }

    /**
     * Toggle SRSET's RTC_TIM1 bit.
     *
     * RTC TIM1 Mirror Register Update Set
     */
    inline void toggle_SRSET_RTC_TIM1() volatile
    {
        SRSET ^= 1u << 28u;
    }

    /**
     * Set SRSET's RTC_TIM0 bit.
     *
     * RTC TIM0 Mirror Register Update Set
     */
    inline void set_SRSET_RTC_TIM0() volatile
    {
        SRSET |= 1u << 27u;
    }

    /**
     * Clear SRSET's RTC_TIM0 bit.
     *
     * RTC TIM0 Mirror Register Update Set
     */
    inline void clear_SRSET_RTC_TIM0() volatile
    {
        SRSET &= ~(1u << 27u);
    }

    /**
     * Toggle SRSET's RTC_TIM0 bit.
     *
     * RTC TIM0 Mirror Register Update Set
     */
    inline void toggle_SRSET_RTC_TIM0() volatile
    {
        SRSET ^= 1u << 27u;
    }

    /**
     * Set SRSET's RTC_ATIM1 bit.
     *
     * RTC ATIM1 Mirror Register Update Set
     */
    inline void set_SRSET_RTC_ATIM1() volatile
    {
        SRSET |= 1u << 26u;
    }

    /**
     * Clear SRSET's RTC_ATIM1 bit.
     *
     * RTC ATIM1 Mirror Register Update Set
     */
    inline void clear_SRSET_RTC_ATIM1() volatile
    {
        SRSET &= ~(1u << 26u);
    }

    /**
     * Toggle SRSET's RTC_ATIM1 bit.
     *
     * RTC ATIM1 Mirror Register Update Set
     */
    inline void toggle_SRSET_RTC_ATIM1() volatile
    {
        SRSET ^= 1u << 26u;
    }

    /**
     * Set SRSET's RTC_ATIM0 bit.
     *
     * RTC ATIM0 Mirror Register Update Set
     */
    inline void set_SRSET_RTC_ATIM0() volatile
    {
        SRSET |= 1u << 25u;
    }

    /**
     * Clear SRSET's RTC_ATIM0 bit.
     *
     * RTC ATIM0 Mirror Register Update Set
     */
    inline void clear_SRSET_RTC_ATIM0() volatile
    {
        SRSET &= ~(1u << 25u);
    }

    /**
     * Toggle SRSET's RTC_ATIM0 bit.
     *
     * RTC ATIM0 Mirror Register Update Set
     */
    inline void toggle_SRSET_RTC_ATIM0() volatile
    {
        SRSET ^= 1u << 25u;
    }

    /**
     * Set SRSET's RTC_CTR bit.
     *
     * RTC CTR Mirror Register Update Set
     */
    inline void set_SRSET_RTC_CTR() volatile
    {
        SRSET |= 1u << 24u;
    }

    /**
     * Clear SRSET's RTC_CTR bit.
     *
     * RTC CTR Mirror Register Update Set
     */
    inline void clear_SRSET_RTC_CTR() volatile
    {
        SRSET &= ~(1u << 24u);
    }

    /**
     * Toggle SRSET's RTC_CTR bit.
     *
     * RTC CTR Mirror Register Update Set
     */
    inline void toggle_SRSET_RTC_CTR() volatile
    {
        SRSET ^= 1u << 24u;
    }

    /**
     * Set SRSET's OSCULCTRL bit.
     *
     * OSCULCTRL Mirror Register Update Set
     */
    inline void set_SRSET_OSCULCTRL() volatile
    {
        SRSET |= 1u << 23u;
    }

    /**
     * Clear SRSET's OSCULCTRL bit.
     *
     * OSCULCTRL Mirror Register Update Set
     */
    inline void clear_SRSET_OSCULCTRL() volatile
    {
        SRSET &= ~(1u << 23u);
    }

    /**
     * Toggle SRSET's OSCULCTRL bit.
     *
     * OSCULCTRL Mirror Register Update Set
     */
    inline void toggle_SRSET_OSCULCTRL() volatile
    {
        SRSET ^= 1u << 23u;
    }

    /**
     * Set SRSET's OSCSICTRL bit.
     *
     * OSCSICTRL Mirror Register Update Set
     */
    inline void set_SRSET_OSCSICTRL() volatile
    {
        SRSET |= 1u << 21u;
    }

    /**
     * Clear SRSET's OSCSICTRL bit.
     *
     * OSCSICTRL Mirror Register Update Set
     */
    inline void clear_SRSET_OSCSICTRL() volatile
    {
        SRSET &= ~(1u << 21u);
    }

    /**
     * Toggle SRSET's OSCSICTRL bit.
     *
     * OSCSICTRL Mirror Register Update Set
     */
    inline void toggle_SRSET_OSCSICTRL() volatile
    {
        SRSET ^= 1u << 21u;
    }

    /**
     * Set SRSET's HDCR bit.
     *
     * HDCR Mirror Register Update Set
     */
    inline void set_SRSET_HDCR() volatile
    {
        SRSET |= 1u << 19u;
    }

    /**
     * Clear SRSET's HDCR bit.
     *
     * HDCR Mirror Register Update Set
     */
    inline void clear_SRSET_HDCR() volatile
    {
        SRSET &= ~(1u << 19u);
    }

    /**
     * Toggle SRSET's HDCR bit.
     *
     * HDCR Mirror Register Update Set
     */
    inline void toggle_SRSET_HDCR() volatile
    {
        SRSET ^= 1u << 19u;
    }

    /**
     * Set SRSET's HDCRSET bit.
     *
     * HDCRSET Mirror Register Update Set
     */
    inline void set_SRSET_HDCRSET() volatile
    {
        SRSET |= 1u << 18u;
    }

    /**
     * Clear SRSET's HDCRSET bit.
     *
     * HDCRSET Mirror Register Update Set
     */
    inline void clear_SRSET_HDCRSET() volatile
    {
        SRSET &= ~(1u << 18u);
    }

    /**
     * Toggle SRSET's HDCRSET bit.
     *
     * HDCRSET Mirror Register Update Set
     */
    inline void toggle_SRSET_HDCRSET() volatile
    {
        SRSET ^= 1u << 18u;
    }

    /**
     * Set SRSET's HDCRCLR bit.
     *
     * HDCRCLR Mirror Register Update Set
     */
    inline void set_SRSET_HDCRCLR() volatile
    {
        SRSET |= 1u << 17u;
    }

    /**
     * Clear SRSET's HDCRCLR bit.
     *
     * HDCRCLR Mirror Register Update Set
     */
    inline void clear_SRSET_HDCRCLR() volatile
    {
        SRSET &= ~(1u << 17u);
    }

    /**
     * Toggle SRSET's HDCRCLR bit.
     *
     * HDCRCLR Mirror Register Update Set
     */
    inline void toggle_SRSET_HDCRCLR() volatile
    {
        SRSET ^= 1u << 17u;
    }

    /**
     * Set SRSET's DLROVR bit.
     *
     * DLR Request Overrun Interrupt Set
     */
    inline void set_SRSET_DLROVR() volatile
    {
        SRSET |= 1u << 3u;
    }

    /**
     * Clear SRSET's DLROVR bit.
     *
     * DLR Request Overrun Interrupt Set
     */
    inline void clear_SRSET_DLROVR() volatile
    {
        SRSET &= ~(1u << 3u);
    }

    /**
     * Toggle SRSET's DLROVR bit.
     *
     * DLR Request Overrun Interrupt Set
     */
    inline void toggle_SRSET_DLROVR() volatile
    {
        SRSET ^= 1u << 3u;
    }

    /**
     * Set SRSET's AI bit.
     *
     * RTC Alarm Interrupt Set
     */
    inline void set_SRSET_AI() volatile
    {
        SRSET |= 1u << 2u;
    }

    /**
     * Clear SRSET's AI bit.
     *
     * RTC Alarm Interrupt Set
     */
    inline void clear_SRSET_AI() volatile
    {
        SRSET &= ~(1u << 2u);
    }

    /**
     * Toggle SRSET's AI bit.
     *
     * RTC Alarm Interrupt Set
     */
    inline void toggle_SRSET_AI() volatile
    {
        SRSET ^= 1u << 2u;
    }

    /**
     * Set SRSET's PI bit.
     *
     * RTC Periodic Interrupt Set
     */
    inline void set_SRSET_PI() volatile
    {
        SRSET |= 1u << 1u;
    }

    /**
     * Clear SRSET's PI bit.
     *
     * RTC Periodic Interrupt Set
     */
    inline void clear_SRSET_PI() volatile
    {
        SRSET &= ~(1u << 1u);
    }

    /**
     * Toggle SRSET's PI bit.
     *
     * RTC Periodic Interrupt Set
     */
    inline void toggle_SRSET_PI() volatile
    {
        SRSET ^= 1u << 1u;
    }

    /**
     * Set SRSET's PRWARN bit.
     *
     * WDT pre-warning Interrupt Set
     */
    inline void set_SRSET_PRWARN() volatile
    {
        SRSET |= 1u << 0u;
    }

    /**
     * Clear SRSET's PRWARN bit.
     *
     * WDT pre-warning Interrupt Set
     */
    inline void clear_SRSET_PRWARN() volatile
    {
        SRSET &= ~(1u << 0u);
    }

    /**
     * Toggle SRSET's PRWARN bit.
     *
     * WDT pre-warning Interrupt Set
     */
    inline void toggle_SRSET_PRWARN() volatile
    {
        SRSET ^= 1u << 0u;
    }

    /**
     * Set all of SRSET's bit fields.
     *
     * (write-only) SCU Service Request Set
     */
    inline void set_SRSET(
        SCU_INTERRUPT_SRSET_RMX RMX, SCU_INTERRUPT_SRSET_RMX RTC_TIM1,
        SCU_INTERRUPT_SRSET_RMX RTC_TIM0, SCU_INTERRUPT_SRSET_RMX RTC_ATIM1,
        SCU_INTERRUPT_SRSET_RMX RTC_ATIM0, SCU_INTERRUPT_SRSET_RMX RTC_CTR,
        SCU_INTERRUPT_SRSET_RMX OSCULCTRL, SCU_INTERRUPT_SRSET_RMX OSCSICTRL,
        SCU_INTERRUPT_SRSET_RMX HDCR, SCU_INTERRUPT_SRSET_RMX HDCRSET,
        SCU_INTERRUPT_SRSET_RMX HDCRCLR, SCU_INTERRUPT_SRSET_RMX DLROVR,
        SCU_INTERRUPT_SRSET_RMX AI, SCU_INTERRUPT_SRSET_RMX PI,
        SCU_INTERRUPT_SRSET_RMX PRWARN) volatile
    {
        uint32_t curr = SRSET;

        curr &= ~(0b1u << 29u);
        curr |= (std::to_underlying(RMX) & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (std::to_underlying(RTC_TIM1) & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (std::to_underlying(RTC_TIM0) & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (std::to_underlying(RTC_ATIM1) & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (std::to_underlying(RTC_ATIM0) & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (std::to_underlying(RTC_CTR) & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (std::to_underlying(OSCULCTRL) & 0b1u) << 23u;
        curr &= ~(0b1u << 21u);
        curr |= (std::to_underlying(OSCSICTRL) & 0b1u) << 21u;
        curr &= ~(0b1u << 19u);
        curr |= (std::to_underlying(HDCR) & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (std::to_underlying(HDCRSET) & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(HDCRCLR) & 0b1u) << 17u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(DLROVR) & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (std::to_underlying(AI) & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(PI) & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(PRWARN) & 0b1u) << 0u;

        SRSET = curr;
    }

    /**
     * Get NMIREQEN's ERU03 bit.
     *
     * Promote Channel 3 Interrupt of ERU0 Request to NMI Request
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_NMIREQEN_ERU03() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(NMIREQEN & (1u << 19u));
    }

    /**
     * Set NMIREQEN's ERU03 bit.
     *
     * Promote Channel 3 Interrupt of ERU0 Request to NMI Request
     */
    inline void set_NMIREQEN_ERU03() volatile
    {
        NMIREQEN |= 1u << 19u;
    }

    /**
     * Clear NMIREQEN's ERU03 bit.
     *
     * Promote Channel 3 Interrupt of ERU0 Request to NMI Request
     */
    inline void clear_NMIREQEN_ERU03() volatile
    {
        NMIREQEN &= ~(1u << 19u);
    }

    /**
     * Toggle NMIREQEN's ERU03 bit.
     *
     * Promote Channel 3 Interrupt of ERU0 Request to NMI Request
     */
    inline void toggle_NMIREQEN_ERU03() volatile
    {
        NMIREQEN ^= 1u << 19u;
    }

    /**
     * Get NMIREQEN's ERU02 bit.
     *
     * Promote Channel 2 Interrupt of ERU0 Request to NMI Request
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_NMIREQEN_ERU02() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(NMIREQEN & (1u << 18u));
    }

    /**
     * Set NMIREQEN's ERU02 bit.
     *
     * Promote Channel 2 Interrupt of ERU0 Request to NMI Request
     */
    inline void set_NMIREQEN_ERU02() volatile
    {
        NMIREQEN |= 1u << 18u;
    }

    /**
     * Clear NMIREQEN's ERU02 bit.
     *
     * Promote Channel 2 Interrupt of ERU0 Request to NMI Request
     */
    inline void clear_NMIREQEN_ERU02() volatile
    {
        NMIREQEN &= ~(1u << 18u);
    }

    /**
     * Toggle NMIREQEN's ERU02 bit.
     *
     * Promote Channel 2 Interrupt of ERU0 Request to NMI Request
     */
    inline void toggle_NMIREQEN_ERU02() volatile
    {
        NMIREQEN ^= 1u << 18u;
    }

    /**
     * Get NMIREQEN's ERU01 bit.
     *
     * Promote Channel 1 Interrupt of ERU0 Request to NMI Request
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_NMIREQEN_ERU01() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(NMIREQEN & (1u << 17u));
    }

    /**
     * Set NMIREQEN's ERU01 bit.
     *
     * Promote Channel 1 Interrupt of ERU0 Request to NMI Request
     */
    inline void set_NMIREQEN_ERU01() volatile
    {
        NMIREQEN |= 1u << 17u;
    }

    /**
     * Clear NMIREQEN's ERU01 bit.
     *
     * Promote Channel 1 Interrupt of ERU0 Request to NMI Request
     */
    inline void clear_NMIREQEN_ERU01() volatile
    {
        NMIREQEN &= ~(1u << 17u);
    }

    /**
     * Toggle NMIREQEN's ERU01 bit.
     *
     * Promote Channel 1 Interrupt of ERU0 Request to NMI Request
     */
    inline void toggle_NMIREQEN_ERU01() volatile
    {
        NMIREQEN ^= 1u << 17u;
    }

    /**
     * Get NMIREQEN's ERU00 bit.
     *
     * Promote Channel 0 Interrupt of ERU0 Request to NMI Request
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_NMIREQEN_ERU00() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(NMIREQEN & (1u << 16u));
    }

    /**
     * Set NMIREQEN's ERU00 bit.
     *
     * Promote Channel 0 Interrupt of ERU0 Request to NMI Request
     */
    inline void set_NMIREQEN_ERU00() volatile
    {
        NMIREQEN |= 1u << 16u;
    }

    /**
     * Clear NMIREQEN's ERU00 bit.
     *
     * Promote Channel 0 Interrupt of ERU0 Request to NMI Request
     */
    inline void clear_NMIREQEN_ERU00() volatile
    {
        NMIREQEN &= ~(1u << 16u);
    }

    /**
     * Toggle NMIREQEN's ERU00 bit.
     *
     * Promote Channel 0 Interrupt of ERU0 Request to NMI Request
     */
    inline void toggle_NMIREQEN_ERU00() volatile
    {
        NMIREQEN ^= 1u << 16u;
    }

    /**
     * Get NMIREQEN's AI bit.
     *
     * Promote RTC Alarm Interrupt Request to NMI Request
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_NMIREQEN_AI() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(NMIREQEN & (1u << 2u));
    }

    /**
     * Set NMIREQEN's AI bit.
     *
     * Promote RTC Alarm Interrupt Request to NMI Request
     */
    inline void set_NMIREQEN_AI() volatile
    {
        NMIREQEN |= 1u << 2u;
    }

    /**
     * Clear NMIREQEN's AI bit.
     *
     * Promote RTC Alarm Interrupt Request to NMI Request
     */
    inline void clear_NMIREQEN_AI() volatile
    {
        NMIREQEN &= ~(1u << 2u);
    }

    /**
     * Toggle NMIREQEN's AI bit.
     *
     * Promote RTC Alarm Interrupt Request to NMI Request
     */
    inline void toggle_NMIREQEN_AI() volatile
    {
        NMIREQEN ^= 1u << 2u;
    }

    /**
     * Get NMIREQEN's PI bit.
     *
     * Promote RTC Periodic Interrupt request to NMI Request
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_NMIREQEN_PI() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(NMIREQEN & (1u << 1u));
    }

    /**
     * Set NMIREQEN's PI bit.
     *
     * Promote RTC Periodic Interrupt request to NMI Request
     */
    inline void set_NMIREQEN_PI() volatile
    {
        NMIREQEN |= 1u << 1u;
    }

    /**
     * Clear NMIREQEN's PI bit.
     *
     * Promote RTC Periodic Interrupt request to NMI Request
     */
    inline void clear_NMIREQEN_PI() volatile
    {
        NMIREQEN &= ~(1u << 1u);
    }

    /**
     * Toggle NMIREQEN's PI bit.
     *
     * Promote RTC Periodic Interrupt request to NMI Request
     */
    inline void toggle_NMIREQEN_PI() volatile
    {
        NMIREQEN ^= 1u << 1u;
    }

    /**
     * Get NMIREQEN's PRWARN bit.
     *
     * Promote Pre-Warning Interrupt Request to NMI Request
     */
    inline SCU_INTERRUPT_SRMSK_RMX get_NMIREQEN_PRWARN() volatile
    {
        return SCU_INTERRUPT_SRMSK_RMX(NMIREQEN & (1u << 0u));
    }

    /**
     * Set NMIREQEN's PRWARN bit.
     *
     * Promote Pre-Warning Interrupt Request to NMI Request
     */
    inline void set_NMIREQEN_PRWARN() volatile
    {
        NMIREQEN |= 1u << 0u;
    }

    /**
     * Clear NMIREQEN's PRWARN bit.
     *
     * Promote Pre-Warning Interrupt Request to NMI Request
     */
    inline void clear_NMIREQEN_PRWARN() volatile
    {
        NMIREQEN &= ~(1u << 0u);
    }

    /**
     * Toggle NMIREQEN's PRWARN bit.
     *
     * Promote Pre-Warning Interrupt Request to NMI Request
     */
    inline void toggle_NMIREQEN_PRWARN() volatile
    {
        NMIREQEN ^= 1u << 0u;
    }

    /**
     * Get all of NMIREQEN's bit fields.
     *
     * (read-write) SCU Service Request Mask
     */
    inline void get_NMIREQEN(SCU_INTERRUPT_SRMSK_RMX &ERU03,
                             SCU_INTERRUPT_SRMSK_RMX &ERU02,
                             SCU_INTERRUPT_SRMSK_RMX &ERU01,
                             SCU_INTERRUPT_SRMSK_RMX &ERU00,
                             SCU_INTERRUPT_SRMSK_RMX &AI,
                             SCU_INTERRUPT_SRMSK_RMX &PI,
                             SCU_INTERRUPT_SRMSK_RMX &PRWARN) volatile
    {
        uint32_t curr = NMIREQEN;

        ERU03 = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 19u));
        ERU02 = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 18u));
        ERU01 = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 17u));
        ERU00 = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 16u));
        AI = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 2u));
        PI = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 1u));
        PRWARN = SCU_INTERRUPT_SRMSK_RMX(curr & (1u << 0u));
    }

    /**
     * Set all of NMIREQEN's bit fields.
     *
     * (read-write) SCU Service Request Mask
     */
    inline void set_NMIREQEN(SCU_INTERRUPT_SRMSK_RMX ERU03,
                             SCU_INTERRUPT_SRMSK_RMX ERU02,
                             SCU_INTERRUPT_SRMSK_RMX ERU01,
                             SCU_INTERRUPT_SRMSK_RMX ERU00,
                             SCU_INTERRUPT_SRMSK_RMX AI,
                             SCU_INTERRUPT_SRMSK_RMX PI,
                             SCU_INTERRUPT_SRMSK_RMX PRWARN) volatile
    {
        uint32_t curr = NMIREQEN;

        curr &= ~(0b1u << 19u);
        curr |= (std::to_underlying(ERU03) & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (std::to_underlying(ERU02) & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(ERU01) & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (std::to_underlying(ERU00) & 0b1u) << 16u;
        curr &= ~(0b1u << 2u);
        curr |= (std::to_underlying(AI) & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(PI) & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(PRWARN) & 0b1u) << 0u;

        NMIREQEN = curr;
    }
};

static_assert(sizeof(scu_interrupt) == scu_interrupt::size);

static volatile scu_interrupt *const SCU_INTERRUPT =
    reinterpret_cast<scu_interrupt *>(0x50004074);

}; // namespace XMC4700
