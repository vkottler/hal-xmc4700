/**
 * \file
 * \brief Generated by ifgen (3.1.1).
 */
#pragma once

#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * Watch Dog Timer
 */
struct [[gnu::packed]] wdt
{
    /* Constant attributes. */
    static constexpr std::size_t size = 32; /*!< wdt's size in bytes. */

    /* Fields. */
    const uint32_t ID = {};     /*!< (read-only) WDT ID Register */
    uint32_t CTR;               /*!< (read-write) WDT Control Register */
    uint32_t SRV;               /*!< (write-only) WDT Service Register */
    const uint32_t TIM = {};    /*!< (read-only) WDT Timer Register */
    uint32_t WLB;               /*!< (read-write) WDT Window Lower Bound Register */
    uint32_t WUB;               /*!< (read-write) WDT Window Upper Bound Register */
    const uint32_t WDTSTS = {}; /*!< (read-only) WDT Status Register */
    uint32_t WDTCLR;            /*!< (write-only) WDT Clear Register */

    /* Methods. */

    /**
     * Get ID's MOD_NUMBER field.
     */
    inline uint16_t get_ID_MOD_NUMBER() volatile
    {
        return (ID >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get ID's MOD_TYPE field.
     */
    inline uint8_t get_ID_MOD_TYPE() volatile
    {
        return (ID >> 8u) & 0b11111111u;
    }

    /**
     * Get ID's MOD_REV field.
     */
    inline uint8_t get_ID_MOD_REV() volatile
    {
        return (ID >> 0u) & 0b11111111u;
    }

    /**
     * Get all of ID's bit fields.
     */
    inline void get_ID(uint16_t &MOD_NUMBER, uint8_t &MOD_TYPE, uint8_t &MOD_REV) volatile
    {
        uint32_t curr = ID;

        MOD_NUMBER = (curr >> 16u) & 0b1111111111111111u;
        MOD_TYPE = (curr >> 8u) & 0b11111111u;
        MOD_REV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get CTR's SPW field.
     */
    inline uint8_t get_CTR_SPW() volatile
    {
        return (CTR >> 8u) & 0b11111111u;
    }

    /**
     * Set CTR's SPW field.
     */
    inline void set_CTR_SPW(uint8_t value) volatile
    {
        uint32_t curr = CTR;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        CTR = curr;
    }

    /**
     * Get CTR's DSP bit.
     */
    inline bool get_CTR_DSP() volatile
    {
        return CTR & (1u << 4u);
    }

    /**
     * Set CTR's DSP bit.
     */
    inline void set_CTR_DSP() volatile
    {
        CTR |= 1u << 4u;
    }

    /**
     * Clear CTR's DSP bit.
     */
    inline void clear_CTR_DSP() volatile
    {
        CTR &= ~(1u << 4u);
    }

    /**
     * Toggle CTR's DSP bit.
     */
    inline void toggle_CTR_DSP() volatile
    {
        CTR ^= 1u << 4u;
    }

    /**
     * Get CTR's PRE bit.
     */
    inline bool get_CTR_PRE() volatile
    {
        return CTR & (1u << 1u);
    }

    /**
     * Set CTR's PRE bit.
     */
    inline void set_CTR_PRE() volatile
    {
        CTR |= 1u << 1u;
    }

    /**
     * Clear CTR's PRE bit.
     */
    inline void clear_CTR_PRE() volatile
    {
        CTR &= ~(1u << 1u);
    }

    /**
     * Toggle CTR's PRE bit.
     */
    inline void toggle_CTR_PRE() volatile
    {
        CTR ^= 1u << 1u;
    }

    /**
     * Get CTR's ENB bit.
     */
    inline bool get_CTR_ENB() volatile
    {
        return CTR & (1u << 0u);
    }

    /**
     * Set CTR's ENB bit.
     */
    inline void set_CTR_ENB() volatile
    {
        CTR |= 1u << 0u;
    }

    /**
     * Clear CTR's ENB bit.
     */
    inline void clear_CTR_ENB() volatile
    {
        CTR &= ~(1u << 0u);
    }

    /**
     * Toggle CTR's ENB bit.
     */
    inline void toggle_CTR_ENB() volatile
    {
        CTR ^= 1u << 0u;
    }

    /**
     * Get all of CTR's bit fields.
     */
    inline void get_CTR(uint8_t &SPW, bool &DSP, bool &PRE, bool &ENB) volatile
    {
        uint32_t curr = CTR;

        SPW = (curr >> 8u) & 0b11111111u;
        DSP = curr & (1u << 4u);
        PRE = curr & (1u << 1u);
        ENB = curr & (1u << 0u);
    }

    /**
     * Set all of CTR's bit fields.
     */
    inline void set_CTR(uint8_t SPW, bool DSP, bool PRE, bool ENB) volatile
    {
        uint32_t curr = CTR;

        curr &= ~(0b11111111u << 8u);
        curr |= (SPW & 0b11111111u) << 8u;
        curr &= ~(0b1u << 4u);
        curr |= (DSP & 0b1u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (PRE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ENB & 0b1u) << 0u;

        CTR = curr;
    }

    /**
     * Set SRV's SRV field.
     */
    inline void set_SRV_SRV(uint32_t value) volatile
    {
        uint32_t curr = SRV;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        SRV = curr;
    }

    /**
     * Get TIM's TIM field.
     */
    inline uint32_t get_TIM_TIM() volatile
    {
        return (TIM >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get WLB's WLB field.
     */
    inline uint32_t get_WLB_WLB() volatile
    {
        return (WLB >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set WLB's WLB field.
     */
    inline void set_WLB_WLB(uint32_t value) volatile
    {
        uint32_t curr = WLB;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        WLB = curr;
    }

    /**
     * Get WUB's WUB field.
     */
    inline uint32_t get_WUB_WUB() volatile
    {
        return (WUB >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set WUB's WUB field.
     */
    inline void set_WUB_WUB(uint32_t value) volatile
    {
        uint32_t curr = WUB;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        WUB = curr;
    }

    /**
     * Get WDTSTS's ALMS bit.
     */
    inline bool get_WDTSTS_ALMS() volatile
    {
        return WDTSTS & (1u << 0u);
    }

    /**
     * Set WDTCLR's ALMC bit.
     */
    inline void set_WDTCLR_ALMC() volatile
    {
        WDTCLR |= 1u << 0u;
    }

    /**
     * Clear WDTCLR's ALMC bit.
     */
    inline void clear_WDTCLR_ALMC() volatile
    {
        WDTCLR &= ~(1u << 0u);
    }

    /**
     * Toggle WDTCLR's ALMC bit.
     */
    inline void toggle_WDTCLR_ALMC() volatile
    {
        WDTCLR ^= 1u << 0u;
    }
};

static_assert(sizeof(wdt) == wdt::size);

static volatile wdt *const WDT = reinterpret_cast<wdt *>(0x50008000);

}; // namespace XMC4700
