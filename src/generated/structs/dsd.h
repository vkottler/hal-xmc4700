/**
 * \file
 * \brief Generated by ifgen (3.2.0).
 */
#pragma once

#include "../enums/DSD_CGCFG_CGMOD.h"
#include "../enums/DSD_CGCFG_DIVCG.h"
#include "../enums/DSD_GLOBCFG_MCSEL.h"
#include "../enums/DSD_OCS_SUS.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * Delta Sigma Demodulator
 */
struct [[gnu::packed]] dsd
{
    /* Constant attributes. */
    static constexpr std::size_t size = 232; /*!< dsd's size in bytes. */

    /* Fields. */
    uint32_t CLC; /*!< (read-write) Clock Control Register */
    const uint32_t reserved_padding0 = {};
    const uint32_t ID = {}; /*!< (read-only) Module Identification Register */
    static constexpr std::size_t reserved_padding1_length = 7;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t OCS; /*!< (read-write) OCDS Control and Status Register */
    static constexpr std::size_t reserved_padding2_length = 21;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t GLOBCFG; /*!< (read-write) Global Configuration Register */
    const uint32_t reserved_padding3 = {};
    uint32_t GLOBRC; /*!< (read-write) Global Run Control Register */
    static constexpr std::size_t reserved_padding4_length = 5;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t
        CGCFG; /*!< (read-write) Carrier Generator Configuration Register */
    static constexpr std::size_t reserved_padding5_length = 15;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t EVFLAG;    /*!< (read-write) Event Flag Register */
    uint32_t EVFLAGCLR; /*!< (write-only) Event Flag Clear Register */

    /* Methods. */

    /**
     * Get CLC's EDIS bit.
     *
     * Sleep Mode Enable Control
     */
    inline bool get_CLC_EDIS() volatile
    {
        return CLC & (1u << 3u);
    }

    /**
     * Set CLC's EDIS bit.
     *
     * Sleep Mode Enable Control
     */
    inline void set_CLC_EDIS() volatile
    {
        CLC |= 1u << 3u;
    }

    /**
     * Clear CLC's EDIS bit.
     *
     * Sleep Mode Enable Control
     */
    inline void clear_CLC_EDIS() volatile
    {
        CLC &= ~(1u << 3u);
    }

    /**
     * Toggle CLC's EDIS bit.
     *
     * Sleep Mode Enable Control
     */
    inline void toggle_CLC_EDIS() volatile
    {
        CLC ^= 1u << 3u;
    }

    /**
     * Get CLC's DISS bit.
     *
     * Module Disable Status Bit
     */
    inline bool get_CLC_DISS() volatile
    {
        return CLC & (1u << 1u);
    }

    /**
     * Get CLC's DISR bit.
     *
     * Module Disable Request Bit
     */
    inline bool get_CLC_DISR() volatile
    {
        return CLC & (1u << 0u);
    }

    /**
     * Set CLC's DISR bit.
     *
     * Module Disable Request Bit
     */
    inline void set_CLC_DISR() volatile
    {
        CLC |= 1u << 0u;
    }

    /**
     * Clear CLC's DISR bit.
     *
     * Module Disable Request Bit
     */
    inline void clear_CLC_DISR() volatile
    {
        CLC &= ~(1u << 0u);
    }

    /**
     * Toggle CLC's DISR bit.
     *
     * Module Disable Request Bit
     */
    inline void toggle_CLC_DISR() volatile
    {
        CLC ^= 1u << 0u;
    }

    /**
     * Get all of CLC's bit fields.
     *
     * (read-write) Clock Control Register
     */
    inline void get_CLC(bool &EDIS, bool &DISS, bool &DISR) volatile
    {
        uint32_t curr = CLC;

        EDIS = curr & (1u << 3u);
        DISS = curr & (1u << 1u);
        DISR = curr & (1u << 0u);
    }

    /**
     * Set all of CLC's bit fields.
     *
     * (read-write) Clock Control Register
     */
    inline void set_CLC(bool EDIS, bool DISR) volatile
    {
        uint32_t curr = CLC;

        curr &= ~(0b1u << 3u);
        curr |= (EDIS & 0b1u) << 3u;
        curr &= ~(0b1u << 0u);
        curr |= (DISR & 0b1u) << 0u;

        CLC = curr;
    }

    /**
     * Get ID's MOD_NUMBER field.
     *
     * Module Number
     */
    inline uint16_t get_ID_MOD_NUMBER() volatile
    {
        return (ID >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get ID's MOD_TYPE field.
     *
     * Module Type
     */
    inline uint8_t get_ID_MOD_TYPE() volatile
    {
        return (ID >> 8u) & 0b11111111u;
    }

    /**
     * Get ID's MOD_REV field.
     *
     * Module Revision
     */
    inline uint8_t get_ID_MOD_REV() volatile
    {
        return (ID >> 0u) & 0b11111111u;
    }

    /**
     * Get all of ID's bit fields.
     *
     * (read-only) Module Identification Register
     */
    inline void get_ID(uint16_t &MOD_NUMBER, uint8_t &MOD_TYPE,
                       uint8_t &MOD_REV) volatile
    {
        uint32_t curr = ID;

        MOD_NUMBER = (curr >> 16u) & 0b1111111111111111u;
        MOD_TYPE = (curr >> 8u) & 0b11111111u;
        MOD_REV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get OCS's SUSSTA bit.
     *
     * Suspend State
     */
    inline bool get_OCS_SUSSTA() volatile
    {
        return OCS & (1u << 29u);
    }

    /**
     * Set OCS's SUS_P bit.
     *
     * SUS Write Protection
     */
    inline void set_OCS_SUS_P() volatile
    {
        OCS |= 1u << 28u;
    }

    /**
     * Clear OCS's SUS_P bit.
     *
     * SUS Write Protection
     */
    inline void clear_OCS_SUS_P() volatile
    {
        OCS &= ~(1u << 28u);
    }

    /**
     * Toggle OCS's SUS_P bit.
     *
     * SUS Write Protection
     */
    inline void toggle_OCS_SUS_P() volatile
    {
        OCS ^= 1u << 28u;
    }

    /**
     * Get OCS's SUS field.
     *
     * OCDS Suspend Control
     */
    inline DSD_OCS_SUS get_OCS_SUS() volatile
    {
        return DSD_OCS_SUS((OCS >> 24u) & 0b1111u);
    }

    /**
     * Set OCS's SUS field.
     *
     * OCDS Suspend Control
     */
    inline void set_OCS_SUS(DSD_OCS_SUS value) volatile
    {
        uint32_t curr = OCS;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        OCS = curr;
    }

    /**
     * Get all of OCS's bit fields.
     *
     * (read-write) OCDS Control and Status Register
     */
    inline void get_OCS(bool &SUSSTA, DSD_OCS_SUS &SUS) volatile
    {
        uint32_t curr = OCS;

        SUSSTA = curr & (1u << 29u);
        SUS = DSD_OCS_SUS((curr >> 24u) & 0b1111u);
    }

    /**
     * Set all of OCS's bit fields.
     *
     * (read-write) OCDS Control and Status Register
     */
    inline void set_OCS(bool SUS_P, DSD_OCS_SUS SUS) volatile
    {
        uint32_t curr = OCS;

        curr &= ~(0b1u << 28u);
        curr |= (SUS_P & 0b1u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(SUS) & 0b1111u) << 24u;

        OCS = curr;
    }

    /**
     * Get GLOBCFG's MCSEL field.
     *
     * Modulator Clock Select
     */
    inline DSD_GLOBCFG_MCSEL get_GLOBCFG_MCSEL() volatile
    {
        return DSD_GLOBCFG_MCSEL((GLOBCFG >> 0u) & 0b111u);
    }

    /**
     * Set GLOBCFG's MCSEL field.
     *
     * Modulator Clock Select
     */
    inline void set_GLOBCFG_MCSEL(DSD_GLOBCFG_MCSEL value) volatile
    {
        uint32_t curr = GLOBCFG;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        GLOBCFG = curr;
    }

    /**
     * Get GLOBRC's CH3RUN bit.
     *
     * Channel 3 Run Control
     */
    inline bool get_GLOBRC_CH3RUN() volatile
    {
        return GLOBRC & (1u << 3u);
    }

    /**
     * Set GLOBRC's CH3RUN bit.
     *
     * Channel 3 Run Control
     */
    inline void set_GLOBRC_CH3RUN() volatile
    {
        GLOBRC |= 1u << 3u;
    }

    /**
     * Clear GLOBRC's CH3RUN bit.
     *
     * Channel 3 Run Control
     */
    inline void clear_GLOBRC_CH3RUN() volatile
    {
        GLOBRC &= ~(1u << 3u);
    }

    /**
     * Toggle GLOBRC's CH3RUN bit.
     *
     * Channel 3 Run Control
     */
    inline void toggle_GLOBRC_CH3RUN() volatile
    {
        GLOBRC ^= 1u << 3u;
    }

    /**
     * Get GLOBRC's CH2RUN bit.
     *
     * Channel 2 Run Control
     */
    inline bool get_GLOBRC_CH2RUN() volatile
    {
        return GLOBRC & (1u << 2u);
    }

    /**
     * Set GLOBRC's CH2RUN bit.
     *
     * Channel 2 Run Control
     */
    inline void set_GLOBRC_CH2RUN() volatile
    {
        GLOBRC |= 1u << 2u;
    }

    /**
     * Clear GLOBRC's CH2RUN bit.
     *
     * Channel 2 Run Control
     */
    inline void clear_GLOBRC_CH2RUN() volatile
    {
        GLOBRC &= ~(1u << 2u);
    }

    /**
     * Toggle GLOBRC's CH2RUN bit.
     *
     * Channel 2 Run Control
     */
    inline void toggle_GLOBRC_CH2RUN() volatile
    {
        GLOBRC ^= 1u << 2u;
    }

    /**
     * Get GLOBRC's CH1RUN bit.
     *
     * Channel 1 Run Control
     */
    inline bool get_GLOBRC_CH1RUN() volatile
    {
        return GLOBRC & (1u << 1u);
    }

    /**
     * Set GLOBRC's CH1RUN bit.
     *
     * Channel 1 Run Control
     */
    inline void set_GLOBRC_CH1RUN() volatile
    {
        GLOBRC |= 1u << 1u;
    }

    /**
     * Clear GLOBRC's CH1RUN bit.
     *
     * Channel 1 Run Control
     */
    inline void clear_GLOBRC_CH1RUN() volatile
    {
        GLOBRC &= ~(1u << 1u);
    }

    /**
     * Toggle GLOBRC's CH1RUN bit.
     *
     * Channel 1 Run Control
     */
    inline void toggle_GLOBRC_CH1RUN() volatile
    {
        GLOBRC ^= 1u << 1u;
    }

    /**
     * Get GLOBRC's CH0RUN bit.
     *
     * Channel 0 Run Control
     */
    inline bool get_GLOBRC_CH0RUN() volatile
    {
        return GLOBRC & (1u << 0u);
    }

    /**
     * Set GLOBRC's CH0RUN bit.
     *
     * Channel 0 Run Control
     */
    inline void set_GLOBRC_CH0RUN() volatile
    {
        GLOBRC |= 1u << 0u;
    }

    /**
     * Clear GLOBRC's CH0RUN bit.
     *
     * Channel 0 Run Control
     */
    inline void clear_GLOBRC_CH0RUN() volatile
    {
        GLOBRC &= ~(1u << 0u);
    }

    /**
     * Toggle GLOBRC's CH0RUN bit.
     *
     * Channel 0 Run Control
     */
    inline void toggle_GLOBRC_CH0RUN() volatile
    {
        GLOBRC ^= 1u << 0u;
    }

    /**
     * Get all of GLOBRC's bit fields.
     *
     * (read-write) Global Run Control Register
     */
    inline void get_GLOBRC(bool &CH3RUN, bool &CH2RUN, bool &CH1RUN,
                           bool &CH0RUN) volatile
    {
        uint32_t curr = GLOBRC;

        CH3RUN = curr & (1u << 3u);
        CH2RUN = curr & (1u << 2u);
        CH1RUN = curr & (1u << 1u);
        CH0RUN = curr & (1u << 0u);
    }

    /**
     * Set all of GLOBRC's bit fields.
     *
     * (read-write) Global Run Control Register
     */
    inline void set_GLOBRC(bool CH3RUN, bool CH2RUN, bool CH1RUN,
                           bool CH0RUN) volatile
    {
        uint32_t curr = GLOBRC;

        curr &= ~(0b1u << 3u);
        curr |= (CH3RUN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (CH2RUN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (CH1RUN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CH0RUN & 0b1u) << 0u;

        GLOBRC = curr;
    }

    /**
     * Get CGCFG's SGNCG bit.
     *
     * Sign Signal from Carrier Generator
     */
    inline bool get_CGCFG_SGNCG() volatile
    {
        return CGCFG & (1u << 30u);
    }

    /**
     * Get CGCFG's STEPD bit.
     *
     * Step Counter Direction
     */
    inline bool get_CGCFG_STEPD() volatile
    {
        return CGCFG & (1u << 29u);
    }

    /**
     * Get CGCFG's STEPS bit.
     *
     * Step Counter Sign
     */
    inline bool get_CGCFG_STEPS() volatile
    {
        return CGCFG & (1u << 28u);
    }

    /**
     * Get CGCFG's STEPCOUNT field.
     *
     * Step Counter
     */
    inline uint8_t get_CGCFG_STEPCOUNT() volatile
    {
        return (CGCFG >> 24u) & 0b1111u;
    }

    /**
     * Get CGCFG's BITCOUNT field.
     *
     * Bit Counter
     */
    inline uint8_t get_CGCFG_BITCOUNT() volatile
    {
        return (CGCFG >> 16u) & 0b11111u;
    }

    /**
     * Get CGCFG's RUN bit.
     *
     * Run Indicator
     */
    inline bool get_CGCFG_RUN() volatile
    {
        return CGCFG & (1u << 15u);
    }

    /**
     * Get CGCFG's DIVCG field.
     *
     * Divider Factor for the PWM Pattern Signal Generator
     */
    inline DSD_CGCFG_DIVCG get_CGCFG_DIVCG() volatile
    {
        return DSD_CGCFG_DIVCG((CGCFG >> 4u) & 0b1111u);
    }

    /**
     * Set CGCFG's DIVCG field.
     *
     * Divider Factor for the PWM Pattern Signal Generator
     */
    inline void set_CGCFG_DIVCG(DSD_CGCFG_DIVCG value) volatile
    {
        uint32_t curr = CGCFG;

        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(value) & 0b1111u) << 4u;

        CGCFG = curr;
    }

    /**
     * Get CGCFG's SIGPOL bit.
     *
     * Signal Polarity
     */
    inline bool get_CGCFG_SIGPOL() volatile
    {
        return CGCFG & (1u << 3u);
    }

    /**
     * Set CGCFG's SIGPOL bit.
     *
     * Signal Polarity
     */
    inline void set_CGCFG_SIGPOL() volatile
    {
        CGCFG |= 1u << 3u;
    }

    /**
     * Clear CGCFG's SIGPOL bit.
     *
     * Signal Polarity
     */
    inline void clear_CGCFG_SIGPOL() volatile
    {
        CGCFG &= ~(1u << 3u);
    }

    /**
     * Toggle CGCFG's SIGPOL bit.
     *
     * Signal Polarity
     */
    inline void toggle_CGCFG_SIGPOL() volatile
    {
        CGCFG ^= 1u << 3u;
    }

    /**
     * Get CGCFG's BREV bit.
     *
     * Bit-Reverse PWM Generation
     */
    inline bool get_CGCFG_BREV() volatile
    {
        return CGCFG & (1u << 2u);
    }

    /**
     * Set CGCFG's BREV bit.
     *
     * Bit-Reverse PWM Generation
     */
    inline void set_CGCFG_BREV() volatile
    {
        CGCFG |= 1u << 2u;
    }

    /**
     * Clear CGCFG's BREV bit.
     *
     * Bit-Reverse PWM Generation
     */
    inline void clear_CGCFG_BREV() volatile
    {
        CGCFG &= ~(1u << 2u);
    }

    /**
     * Toggle CGCFG's BREV bit.
     *
     * Bit-Reverse PWM Generation
     */
    inline void toggle_CGCFG_BREV() volatile
    {
        CGCFG ^= 1u << 2u;
    }

    /**
     * Get CGCFG's CGMOD field.
     *
     * Carrier Generator Operating Mode
     */
    inline DSD_CGCFG_CGMOD get_CGCFG_CGMOD() volatile
    {
        return DSD_CGCFG_CGMOD((CGCFG >> 0u) & 0b11u);
    }

    /**
     * Set CGCFG's CGMOD field.
     *
     * Carrier Generator Operating Mode
     */
    inline void set_CGCFG_CGMOD(DSD_CGCFG_CGMOD value) volatile
    {
        uint32_t curr = CGCFG;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CGCFG = curr;
    }

    /**
     * Get all of CGCFG's bit fields.
     *
     * (read-write) Carrier Generator Configuration Register
     */
    inline void get_CGCFG(bool &SGNCG, bool &STEPD, bool &STEPS,
                          uint8_t &STEPCOUNT, uint8_t &BITCOUNT, bool &RUN,
                          DSD_CGCFG_DIVCG &DIVCG, bool &SIGPOL, bool &BREV,
                          DSD_CGCFG_CGMOD &CGMOD) volatile
    {
        uint32_t curr = CGCFG;

        SGNCG = curr & (1u << 30u);
        STEPD = curr & (1u << 29u);
        STEPS = curr & (1u << 28u);
        STEPCOUNT = (curr >> 24u) & 0b1111u;
        BITCOUNT = (curr >> 16u) & 0b11111u;
        RUN = curr & (1u << 15u);
        DIVCG = DSD_CGCFG_DIVCG((curr >> 4u) & 0b1111u);
        SIGPOL = curr & (1u << 3u);
        BREV = curr & (1u << 2u);
        CGMOD = DSD_CGCFG_CGMOD((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of CGCFG's bit fields.
     *
     * (read-write) Carrier Generator Configuration Register
     */
    inline void set_CGCFG(DSD_CGCFG_DIVCG DIVCG, bool SIGPOL, bool BREV,
                          DSD_CGCFG_CGMOD CGMOD) volatile
    {
        uint32_t curr = CGCFG;

        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(DIVCG) & 0b1111u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (SIGPOL & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (BREV & 0b1u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(CGMOD) & 0b11u) << 0u;

        CGCFG = curr;
    }

    /**
     * Get EVFLAG's ALEV3 bit.
     *
     * Alarm Event
     */
    inline bool get_EVFLAG_ALEV3() volatile
    {
        return EVFLAG & (1u << 19u);
    }

    /**
     * Set EVFLAG's ALEV3 bit.
     *
     * Alarm Event
     */
    inline void set_EVFLAG_ALEV3() volatile
    {
        EVFLAG |= 1u << 19u;
    }

    /**
     * Clear EVFLAG's ALEV3 bit.
     *
     * Alarm Event
     */
    inline void clear_EVFLAG_ALEV3() volatile
    {
        EVFLAG &= ~(1u << 19u);
    }

    /**
     * Toggle EVFLAG's ALEV3 bit.
     *
     * Alarm Event
     */
    inline void toggle_EVFLAG_ALEV3() volatile
    {
        EVFLAG ^= 1u << 19u;
    }

    /**
     * Get EVFLAG's ALEV2 bit.
     *
     * Alarm Event
     */
    inline bool get_EVFLAG_ALEV2() volatile
    {
        return EVFLAG & (1u << 18u);
    }

    /**
     * Set EVFLAG's ALEV2 bit.
     *
     * Alarm Event
     */
    inline void set_EVFLAG_ALEV2() volatile
    {
        EVFLAG |= 1u << 18u;
    }

    /**
     * Clear EVFLAG's ALEV2 bit.
     *
     * Alarm Event
     */
    inline void clear_EVFLAG_ALEV2() volatile
    {
        EVFLAG &= ~(1u << 18u);
    }

    /**
     * Toggle EVFLAG's ALEV2 bit.
     *
     * Alarm Event
     */
    inline void toggle_EVFLAG_ALEV2() volatile
    {
        EVFLAG ^= 1u << 18u;
    }

    /**
     * Get EVFLAG's ALEV1 bit.
     *
     * Alarm Event
     */
    inline bool get_EVFLAG_ALEV1() volatile
    {
        return EVFLAG & (1u << 17u);
    }

    /**
     * Set EVFLAG's ALEV1 bit.
     *
     * Alarm Event
     */
    inline void set_EVFLAG_ALEV1() volatile
    {
        EVFLAG |= 1u << 17u;
    }

    /**
     * Clear EVFLAG's ALEV1 bit.
     *
     * Alarm Event
     */
    inline void clear_EVFLAG_ALEV1() volatile
    {
        EVFLAG &= ~(1u << 17u);
    }

    /**
     * Toggle EVFLAG's ALEV1 bit.
     *
     * Alarm Event
     */
    inline void toggle_EVFLAG_ALEV1() volatile
    {
        EVFLAG ^= 1u << 17u;
    }

    /**
     * Get EVFLAG's ALEV0 bit.
     *
     * Alarm Event
     */
    inline bool get_EVFLAG_ALEV0() volatile
    {
        return EVFLAG & (1u << 16u);
    }

    /**
     * Set EVFLAG's ALEV0 bit.
     *
     * Alarm Event
     */
    inline void set_EVFLAG_ALEV0() volatile
    {
        EVFLAG |= 1u << 16u;
    }

    /**
     * Clear EVFLAG's ALEV0 bit.
     *
     * Alarm Event
     */
    inline void clear_EVFLAG_ALEV0() volatile
    {
        EVFLAG &= ~(1u << 16u);
    }

    /**
     * Toggle EVFLAG's ALEV0 bit.
     *
     * Alarm Event
     */
    inline void toggle_EVFLAG_ALEV0() volatile
    {
        EVFLAG ^= 1u << 16u;
    }

    /**
     * Get EVFLAG's RESEV3 bit.
     *
     * Result Event
     */
    inline bool get_EVFLAG_RESEV3() volatile
    {
        return EVFLAG & (1u << 3u);
    }

    /**
     * Set EVFLAG's RESEV3 bit.
     *
     * Result Event
     */
    inline void set_EVFLAG_RESEV3() volatile
    {
        EVFLAG |= 1u << 3u;
    }

    /**
     * Clear EVFLAG's RESEV3 bit.
     *
     * Result Event
     */
    inline void clear_EVFLAG_RESEV3() volatile
    {
        EVFLAG &= ~(1u << 3u);
    }

    /**
     * Toggle EVFLAG's RESEV3 bit.
     *
     * Result Event
     */
    inline void toggle_EVFLAG_RESEV3() volatile
    {
        EVFLAG ^= 1u << 3u;
    }

    /**
     * Get EVFLAG's RESEV2 bit.
     *
     * Result Event
     */
    inline bool get_EVFLAG_RESEV2() volatile
    {
        return EVFLAG & (1u << 2u);
    }

    /**
     * Set EVFLAG's RESEV2 bit.
     *
     * Result Event
     */
    inline void set_EVFLAG_RESEV2() volatile
    {
        EVFLAG |= 1u << 2u;
    }

    /**
     * Clear EVFLAG's RESEV2 bit.
     *
     * Result Event
     */
    inline void clear_EVFLAG_RESEV2() volatile
    {
        EVFLAG &= ~(1u << 2u);
    }

    /**
     * Toggle EVFLAG's RESEV2 bit.
     *
     * Result Event
     */
    inline void toggle_EVFLAG_RESEV2() volatile
    {
        EVFLAG ^= 1u << 2u;
    }

    /**
     * Get EVFLAG's RESEV1 bit.
     *
     * Result Event
     */
    inline bool get_EVFLAG_RESEV1() volatile
    {
        return EVFLAG & (1u << 1u);
    }

    /**
     * Set EVFLAG's RESEV1 bit.
     *
     * Result Event
     */
    inline void set_EVFLAG_RESEV1() volatile
    {
        EVFLAG |= 1u << 1u;
    }

    /**
     * Clear EVFLAG's RESEV1 bit.
     *
     * Result Event
     */
    inline void clear_EVFLAG_RESEV1() volatile
    {
        EVFLAG &= ~(1u << 1u);
    }

    /**
     * Toggle EVFLAG's RESEV1 bit.
     *
     * Result Event
     */
    inline void toggle_EVFLAG_RESEV1() volatile
    {
        EVFLAG ^= 1u << 1u;
    }

    /**
     * Get EVFLAG's RESEV0 bit.
     *
     * Result Event
     */
    inline bool get_EVFLAG_RESEV0() volatile
    {
        return EVFLAG & (1u << 0u);
    }

    /**
     * Set EVFLAG's RESEV0 bit.
     *
     * Result Event
     */
    inline void set_EVFLAG_RESEV0() volatile
    {
        EVFLAG |= 1u << 0u;
    }

    /**
     * Clear EVFLAG's RESEV0 bit.
     *
     * Result Event
     */
    inline void clear_EVFLAG_RESEV0() volatile
    {
        EVFLAG &= ~(1u << 0u);
    }

    /**
     * Toggle EVFLAG's RESEV0 bit.
     *
     * Result Event
     */
    inline void toggle_EVFLAG_RESEV0() volatile
    {
        EVFLAG ^= 1u << 0u;
    }

    /**
     * Get all of EVFLAG's bit fields.
     *
     * (read-write) Event Flag Register
     */
    inline void get_EVFLAG(bool &ALEV3, bool &ALEV2, bool &ALEV1, bool &ALEV0,
                           bool &RESEV3, bool &RESEV2, bool &RESEV1,
                           bool &RESEV0) volatile
    {
        uint32_t curr = EVFLAG;

        ALEV3 = curr & (1u << 19u);
        ALEV2 = curr & (1u << 18u);
        ALEV1 = curr & (1u << 17u);
        ALEV0 = curr & (1u << 16u);
        RESEV3 = curr & (1u << 3u);
        RESEV2 = curr & (1u << 2u);
        RESEV1 = curr & (1u << 1u);
        RESEV0 = curr & (1u << 0u);
    }

    /**
     * Set all of EVFLAG's bit fields.
     *
     * (read-write) Event Flag Register
     */
    inline void set_EVFLAG(bool ALEV3, bool ALEV2, bool ALEV1, bool ALEV0,
                           bool RESEV3, bool RESEV2, bool RESEV1,
                           bool RESEV0) volatile
    {
        uint32_t curr = EVFLAG;

        curr &= ~(0b1u << 19u);
        curr |= (ALEV3 & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (ALEV2 & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (ALEV1 & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (ALEV0 & 0b1u) << 16u;
        curr &= ~(0b1u << 3u);
        curr |= (RESEV3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (RESEV2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (RESEV1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (RESEV0 & 0b1u) << 0u;

        EVFLAG = curr;
    }

    /**
     * Set EVFLAGCLR's ALEC3 bit.
     *
     * Alarm Event Clear
     */
    inline void set_EVFLAGCLR_ALEC3() volatile
    {
        EVFLAGCLR |= 1u << 19u;
    }

    /**
     * Clear EVFLAGCLR's ALEC3 bit.
     *
     * Alarm Event Clear
     */
    inline void clear_EVFLAGCLR_ALEC3() volatile
    {
        EVFLAGCLR &= ~(1u << 19u);
    }

    /**
     * Toggle EVFLAGCLR's ALEC3 bit.
     *
     * Alarm Event Clear
     */
    inline void toggle_EVFLAGCLR_ALEC3() volatile
    {
        EVFLAGCLR ^= 1u << 19u;
    }

    /**
     * Set EVFLAGCLR's ALEC2 bit.
     *
     * Alarm Event Clear
     */
    inline void set_EVFLAGCLR_ALEC2() volatile
    {
        EVFLAGCLR |= 1u << 18u;
    }

    /**
     * Clear EVFLAGCLR's ALEC2 bit.
     *
     * Alarm Event Clear
     */
    inline void clear_EVFLAGCLR_ALEC2() volatile
    {
        EVFLAGCLR &= ~(1u << 18u);
    }

    /**
     * Toggle EVFLAGCLR's ALEC2 bit.
     *
     * Alarm Event Clear
     */
    inline void toggle_EVFLAGCLR_ALEC2() volatile
    {
        EVFLAGCLR ^= 1u << 18u;
    }

    /**
     * Set EVFLAGCLR's ALEC1 bit.
     *
     * Alarm Event Clear
     */
    inline void set_EVFLAGCLR_ALEC1() volatile
    {
        EVFLAGCLR |= 1u << 17u;
    }

    /**
     * Clear EVFLAGCLR's ALEC1 bit.
     *
     * Alarm Event Clear
     */
    inline void clear_EVFLAGCLR_ALEC1() volatile
    {
        EVFLAGCLR &= ~(1u << 17u);
    }

    /**
     * Toggle EVFLAGCLR's ALEC1 bit.
     *
     * Alarm Event Clear
     */
    inline void toggle_EVFLAGCLR_ALEC1() volatile
    {
        EVFLAGCLR ^= 1u << 17u;
    }

    /**
     * Set EVFLAGCLR's ALEC0 bit.
     *
     * Alarm Event Clear
     */
    inline void set_EVFLAGCLR_ALEC0() volatile
    {
        EVFLAGCLR |= 1u << 16u;
    }

    /**
     * Clear EVFLAGCLR's ALEC0 bit.
     *
     * Alarm Event Clear
     */
    inline void clear_EVFLAGCLR_ALEC0() volatile
    {
        EVFLAGCLR &= ~(1u << 16u);
    }

    /**
     * Toggle EVFLAGCLR's ALEC0 bit.
     *
     * Alarm Event Clear
     */
    inline void toggle_EVFLAGCLR_ALEC0() volatile
    {
        EVFLAGCLR ^= 1u << 16u;
    }

    /**
     * Set EVFLAGCLR's RESEC3 bit.
     *
     * Result Event Clear
     */
    inline void set_EVFLAGCLR_RESEC3() volatile
    {
        EVFLAGCLR |= 1u << 3u;
    }

    /**
     * Clear EVFLAGCLR's RESEC3 bit.
     *
     * Result Event Clear
     */
    inline void clear_EVFLAGCLR_RESEC3() volatile
    {
        EVFLAGCLR &= ~(1u << 3u);
    }

    /**
     * Toggle EVFLAGCLR's RESEC3 bit.
     *
     * Result Event Clear
     */
    inline void toggle_EVFLAGCLR_RESEC3() volatile
    {
        EVFLAGCLR ^= 1u << 3u;
    }

    /**
     * Set EVFLAGCLR's RESEC2 bit.
     *
     * Result Event Clear
     */
    inline void set_EVFLAGCLR_RESEC2() volatile
    {
        EVFLAGCLR |= 1u << 2u;
    }

    /**
     * Clear EVFLAGCLR's RESEC2 bit.
     *
     * Result Event Clear
     */
    inline void clear_EVFLAGCLR_RESEC2() volatile
    {
        EVFLAGCLR &= ~(1u << 2u);
    }

    /**
     * Toggle EVFLAGCLR's RESEC2 bit.
     *
     * Result Event Clear
     */
    inline void toggle_EVFLAGCLR_RESEC2() volatile
    {
        EVFLAGCLR ^= 1u << 2u;
    }

    /**
     * Set EVFLAGCLR's RESEC1 bit.
     *
     * Result Event Clear
     */
    inline void set_EVFLAGCLR_RESEC1() volatile
    {
        EVFLAGCLR |= 1u << 1u;
    }

    /**
     * Clear EVFLAGCLR's RESEC1 bit.
     *
     * Result Event Clear
     */
    inline void clear_EVFLAGCLR_RESEC1() volatile
    {
        EVFLAGCLR &= ~(1u << 1u);
    }

    /**
     * Toggle EVFLAGCLR's RESEC1 bit.
     *
     * Result Event Clear
     */
    inline void toggle_EVFLAGCLR_RESEC1() volatile
    {
        EVFLAGCLR ^= 1u << 1u;
    }

    /**
     * Set EVFLAGCLR's RESEC0 bit.
     *
     * Result Event Clear
     */
    inline void set_EVFLAGCLR_RESEC0() volatile
    {
        EVFLAGCLR |= 1u << 0u;
    }

    /**
     * Clear EVFLAGCLR's RESEC0 bit.
     *
     * Result Event Clear
     */
    inline void clear_EVFLAGCLR_RESEC0() volatile
    {
        EVFLAGCLR &= ~(1u << 0u);
    }

    /**
     * Toggle EVFLAGCLR's RESEC0 bit.
     *
     * Result Event Clear
     */
    inline void toggle_EVFLAGCLR_RESEC0() volatile
    {
        EVFLAGCLR ^= 1u << 0u;
    }

    /**
     * Set all of EVFLAGCLR's bit fields.
     *
     * (write-only) Event Flag Clear Register
     */
    inline void set_EVFLAGCLR(bool ALEC3, bool ALEC2, bool ALEC1, bool ALEC0,
                              bool RESEC3, bool RESEC2, bool RESEC1,
                              bool RESEC0) volatile
    {
        uint32_t curr = EVFLAGCLR;

        curr &= ~(0b1u << 19u);
        curr |= (ALEC3 & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (ALEC2 & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (ALEC1 & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (ALEC0 & 0b1u) << 16u;
        curr &= ~(0b1u << 3u);
        curr |= (RESEC3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (RESEC2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (RESEC1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (RESEC0 & 0b1u) << 0u;

        EVFLAGCLR = curr;
    }
};

static_assert(sizeof(dsd) == dsd::size);

static volatile dsd *const DSD = reinterpret_cast<dsd *>(0x40008000);

}; // namespace XMC4700
