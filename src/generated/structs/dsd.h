/**
 * \file
 * \brief Generated by ifgen (3.1.6).
 */
#pragma once

#include "../enums/DSD_CGCFG_BREV.h"
#include "../enums/DSD_CGCFG_CGMOD.h"
#include "../enums/DSD_CGCFG_DIVCG.h"
#include "../enums/DSD_CGCFG_RUN.h"
#include "../enums/DSD_CGCFG_SGNCG.h"
#include "../enums/DSD_CGCFG_SIGPOL.h"
#include "../enums/DSD_CGCFG_STEPD.h"
#include "../enums/DSD_CGCFG_STEPS.h"
#include "../enums/DSD_CLC_DISR.h"
#include "../enums/DSD_CLC_DISS.h"
#include "../enums/DSD_CLC_EDIS.h"
#include "../enums/DSD_EVFLAGCLR_ALEC3.h"
#include "../enums/DSD_EVFLAGCLR_RESEC3.h"
#include "../enums/DSD_EVFLAG_ALEV3.h"
#include "../enums/DSD_EVFLAG_RESEV3.h"
#include "../enums/DSD_GLOBCFG_MCSEL.h"
#include "../enums/DSD_GLOBRC_CH3RUN.h"
#include "../enums/DSD_OCS_SUS.h"
#include "../enums/DSD_OCS_SUSSTA.h"
#include "../ifgen/common.h"

namespace XMC4700
{

/**
 * Delta Sigma Demodulator
 */
struct [[gnu::packed]] dsd
{
    /* Constant attributes. */
    static constexpr std::size_t size = 232; /*!< dsd's size in bytes. */

    /* Fields. */
    uint32_t CLC; /*!< (read-write) Clock Control Register */
    const uint32_t reserved_padding0 = {};
    const uint32_t ID = {}; /*!< (read-only) Module Identification Register */
    static constexpr std::size_t reserved_padding1_length = 7;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t OCS; /*!< (read-write) OCDS Control and Status Register */
    static constexpr std::size_t reserved_padding2_length = 21;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t GLOBCFG; /*!< (read-write) Global Configuration Register */
    const uint32_t reserved_padding3 = {};
    uint32_t GLOBRC; /*!< (read-write) Global Run Control Register */
    static constexpr std::size_t reserved_padding4_length = 5;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t
        CGCFG; /*!< (read-write) Carrier Generator Configuration Register */
    static constexpr std::size_t reserved_padding5_length = 15;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t EVFLAG;    /*!< (read-write) Event Flag Register */
    uint32_t EVFLAGCLR; /*!< (write-only) Event Flag Clear Register */

    /* Methods. */

    /**
     * Get CLC's EDIS bit.
     */
    inline DSD_CLC_EDIS get_CLC_EDIS() volatile
    {
        return DSD_CLC_EDIS(CLC & (1u << 3u));
    }

    /**
     * Set CLC's EDIS bit.
     *
     * Sleep Mode Enable Control
     */
    inline void set_CLC_EDIS() volatile
    {
        CLC |= 1u << 3u;
    }

    /**
     * Clear CLC's EDIS bit.
     *
     * Sleep Mode Enable Control
     */
    inline void clear_CLC_EDIS() volatile
    {
        CLC &= ~(1u << 3u);
    }

    /**
     * Toggle CLC's EDIS bit.
     *
     * Sleep Mode Enable Control
     */
    inline void toggle_CLC_EDIS() volatile
    {
        CLC ^= 1u << 3u;
    }

    /**
     * Get CLC's DISS bit.
     */
    inline DSD_CLC_DISS get_CLC_DISS() volatile
    {
        return DSD_CLC_DISS(CLC & (1u << 1u));
    }

    /**
     * Get CLC's DISR bit.
     */
    inline DSD_CLC_DISR get_CLC_DISR() volatile
    {
        return DSD_CLC_DISR(CLC & (1u << 0u));
    }

    /**
     * Set CLC's DISR bit.
     *
     * Module Disable Request Bit
     */
    inline void set_CLC_DISR() volatile
    {
        CLC |= 1u << 0u;
    }

    /**
     * Clear CLC's DISR bit.
     *
     * Module Disable Request Bit
     */
    inline void clear_CLC_DISR() volatile
    {
        CLC &= ~(1u << 0u);
    }

    /**
     * Toggle CLC's DISR bit.
     *
     * Module Disable Request Bit
     */
    inline void toggle_CLC_DISR() volatile
    {
        CLC ^= 1u << 0u;
    }

    /**
     * Get all of CLC's bit fields.
     */
    inline void get_CLC(DSD_CLC_EDIS &EDIS, DSD_CLC_DISS &DISS,
                        DSD_CLC_DISR &DISR) volatile
    {
        uint32_t curr = CLC;

        EDIS = DSD_CLC_EDIS(curr & (1u << 3u));
        DISS = DSD_CLC_DISS(curr & (1u << 1u));
        DISR = DSD_CLC_DISR(curr & (1u << 0u));
    }

    /**
     * Set all of CLC's bit fields.
     *
     * (read-write) Clock Control Register
     */
    inline void set_CLC(DSD_CLC_EDIS EDIS, DSD_CLC_DISR DISR) volatile
    {
        uint32_t curr = CLC;

        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(EDIS) & 0b1u) << 3u;
        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(DISR) & 0b1u) << 0u;

        CLC = curr;
    }

    /**
     * Get ID's MOD_NUMBER field.
     */
    inline uint16_t get_ID_MOD_NUMBER() volatile
    {
        return (ID >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get ID's MOD_TYPE field.
     */
    inline uint8_t get_ID_MOD_TYPE() volatile
    {
        return (ID >> 8u) & 0b11111111u;
    }

    /**
     * Get ID's MOD_REV field.
     */
    inline uint8_t get_ID_MOD_REV() volatile
    {
        return (ID >> 0u) & 0b11111111u;
    }

    /**
     * Get all of ID's bit fields.
     */
    inline void get_ID(uint16_t &MOD_NUMBER, uint8_t &MOD_TYPE,
                       uint8_t &MOD_REV) volatile
    {
        uint32_t curr = ID;

        MOD_NUMBER = (curr >> 16u) & 0b1111111111111111u;
        MOD_TYPE = (curr >> 8u) & 0b11111111u;
        MOD_REV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get OCS's SUSSTA bit.
     */
    inline DSD_OCS_SUSSTA get_OCS_SUSSTA() volatile
    {
        return DSD_OCS_SUSSTA(OCS & (1u << 29u));
    }

    /**
     * Set OCS's SUS_P bit.
     *
     * SUS Write Protection
     */
    inline void set_OCS_SUS_P() volatile
    {
        OCS |= 1u << 28u;
    }

    /**
     * Clear OCS's SUS_P bit.
     *
     * SUS Write Protection
     */
    inline void clear_OCS_SUS_P() volatile
    {
        OCS &= ~(1u << 28u);
    }

    /**
     * Toggle OCS's SUS_P bit.
     *
     * SUS Write Protection
     */
    inline void toggle_OCS_SUS_P() volatile
    {
        OCS ^= 1u << 28u;
    }

    /**
     * Get OCS's SUS field.
     */
    inline DSD_OCS_SUS get_OCS_SUS() volatile
    {
        return DSD_OCS_SUS((OCS >> 24u) & 0b1111u);
    }

    /**
     * Set OCS's SUS field.
     *
     * OCDS Suspend Control
     */
    inline void set_OCS_SUS(DSD_OCS_SUS value) volatile
    {
        uint32_t curr = OCS;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        OCS = curr;
    }

    /**
     * Get all of OCS's bit fields.
     */
    inline void get_OCS(DSD_OCS_SUSSTA &SUSSTA, DSD_OCS_SUS &SUS) volatile
    {
        uint32_t curr = OCS;

        SUSSTA = DSD_OCS_SUSSTA(curr & (1u << 29u));
        SUS = DSD_OCS_SUS((curr >> 24u) & 0b1111u);
    }

    /**
     * Set all of OCS's bit fields.
     *
     * (read-write) OCDS Control and Status Register
     */
    inline void set_OCS(bool SUS_P, DSD_OCS_SUS SUS) volatile
    {
        uint32_t curr = OCS;

        curr &= ~(0b1u << 28u);
        curr |= (SUS_P & 0b1u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(SUS) & 0b1111u) << 24u;

        OCS = curr;
    }

    /**
     * Get GLOBCFG's MCSEL field.
     */
    inline DSD_GLOBCFG_MCSEL get_GLOBCFG_MCSEL() volatile
    {
        return DSD_GLOBCFG_MCSEL((GLOBCFG >> 0u) & 0b111u);
    }

    /**
     * Set GLOBCFG's MCSEL field.
     *
     * Modulator Clock Select
     */
    inline void set_GLOBCFG_MCSEL(DSD_GLOBCFG_MCSEL value) volatile
    {
        uint32_t curr = GLOBCFG;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        GLOBCFG = curr;
    }

    /**
     * Get GLOBRC's CH3RUN bit.
     */
    inline DSD_GLOBRC_CH3RUN get_GLOBRC_CH3RUN() volatile
    {
        return DSD_GLOBRC_CH3RUN(GLOBRC & (1u << 3u));
    }

    /**
     * Set GLOBRC's CH3RUN bit.
     *
     * Channel 3 Run Control
     */
    inline void set_GLOBRC_CH3RUN() volatile
    {
        GLOBRC |= 1u << 3u;
    }

    /**
     * Clear GLOBRC's CH3RUN bit.
     *
     * Channel 3 Run Control
     */
    inline void clear_GLOBRC_CH3RUN() volatile
    {
        GLOBRC &= ~(1u << 3u);
    }

    /**
     * Toggle GLOBRC's CH3RUN bit.
     *
     * Channel 3 Run Control
     */
    inline void toggle_GLOBRC_CH3RUN() volatile
    {
        GLOBRC ^= 1u << 3u;
    }

    /**
     * Get GLOBRC's CH2RUN bit.
     */
    inline DSD_GLOBRC_CH3RUN get_GLOBRC_CH2RUN() volatile
    {
        return DSD_GLOBRC_CH3RUN(GLOBRC & (1u << 2u));
    }

    /**
     * Set GLOBRC's CH2RUN bit.
     *
     * Channel 2 Run Control
     */
    inline void set_GLOBRC_CH2RUN() volatile
    {
        GLOBRC |= 1u << 2u;
    }

    /**
     * Clear GLOBRC's CH2RUN bit.
     *
     * Channel 2 Run Control
     */
    inline void clear_GLOBRC_CH2RUN() volatile
    {
        GLOBRC &= ~(1u << 2u);
    }

    /**
     * Toggle GLOBRC's CH2RUN bit.
     *
     * Channel 2 Run Control
     */
    inline void toggle_GLOBRC_CH2RUN() volatile
    {
        GLOBRC ^= 1u << 2u;
    }

    /**
     * Get GLOBRC's CH1RUN bit.
     */
    inline DSD_GLOBRC_CH3RUN get_GLOBRC_CH1RUN() volatile
    {
        return DSD_GLOBRC_CH3RUN(GLOBRC & (1u << 1u));
    }

    /**
     * Set GLOBRC's CH1RUN bit.
     *
     * Channel 1 Run Control
     */
    inline void set_GLOBRC_CH1RUN() volatile
    {
        GLOBRC |= 1u << 1u;
    }

    /**
     * Clear GLOBRC's CH1RUN bit.
     *
     * Channel 1 Run Control
     */
    inline void clear_GLOBRC_CH1RUN() volatile
    {
        GLOBRC &= ~(1u << 1u);
    }

    /**
     * Toggle GLOBRC's CH1RUN bit.
     *
     * Channel 1 Run Control
     */
    inline void toggle_GLOBRC_CH1RUN() volatile
    {
        GLOBRC ^= 1u << 1u;
    }

    /**
     * Get GLOBRC's CH0RUN bit.
     */
    inline DSD_GLOBRC_CH3RUN get_GLOBRC_CH0RUN() volatile
    {
        return DSD_GLOBRC_CH3RUN(GLOBRC & (1u << 0u));
    }

    /**
     * Set GLOBRC's CH0RUN bit.
     *
     * Channel 0 Run Control
     */
    inline void set_GLOBRC_CH0RUN() volatile
    {
        GLOBRC |= 1u << 0u;
    }

    /**
     * Clear GLOBRC's CH0RUN bit.
     *
     * Channel 0 Run Control
     */
    inline void clear_GLOBRC_CH0RUN() volatile
    {
        GLOBRC &= ~(1u << 0u);
    }

    /**
     * Toggle GLOBRC's CH0RUN bit.
     *
     * Channel 0 Run Control
     */
    inline void toggle_GLOBRC_CH0RUN() volatile
    {
        GLOBRC ^= 1u << 0u;
    }

    /**
     * Get all of GLOBRC's bit fields.
     */
    inline void get_GLOBRC(DSD_GLOBRC_CH3RUN &CH3RUN,
                           DSD_GLOBRC_CH3RUN &CH2RUN,
                           DSD_GLOBRC_CH3RUN &CH1RUN,
                           DSD_GLOBRC_CH3RUN &CH0RUN) volatile
    {
        uint32_t curr = GLOBRC;

        CH3RUN = DSD_GLOBRC_CH3RUN(curr & (1u << 3u));
        CH2RUN = DSD_GLOBRC_CH3RUN(curr & (1u << 2u));
        CH1RUN = DSD_GLOBRC_CH3RUN(curr & (1u << 1u));
        CH0RUN = DSD_GLOBRC_CH3RUN(curr & (1u << 0u));
    }

    /**
     * Set all of GLOBRC's bit fields.
     *
     * (read-write) Global Run Control Register
     */
    inline void set_GLOBRC(DSD_GLOBRC_CH3RUN CH3RUN, DSD_GLOBRC_CH3RUN CH2RUN,
                           DSD_GLOBRC_CH3RUN CH1RUN,
                           DSD_GLOBRC_CH3RUN CH0RUN) volatile
    {
        uint32_t curr = GLOBRC;

        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(CH3RUN) & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (std::to_underlying(CH2RUN) & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(CH1RUN) & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(CH0RUN) & 0b1u) << 0u;

        GLOBRC = curr;
    }

    /**
     * Get CGCFG's SGNCG bit.
     */
    inline DSD_CGCFG_SGNCG get_CGCFG_SGNCG() volatile
    {
        return DSD_CGCFG_SGNCG(CGCFG & (1u << 30u));
    }

    /**
     * Get CGCFG's STEPD bit.
     */
    inline DSD_CGCFG_STEPD get_CGCFG_STEPD() volatile
    {
        return DSD_CGCFG_STEPD(CGCFG & (1u << 29u));
    }

    /**
     * Get CGCFG's STEPS bit.
     */
    inline DSD_CGCFG_STEPS get_CGCFG_STEPS() volatile
    {
        return DSD_CGCFG_STEPS(CGCFG & (1u << 28u));
    }

    /**
     * Get CGCFG's STEPCOUNT field.
     */
    inline uint8_t get_CGCFG_STEPCOUNT() volatile
    {
        return (CGCFG >> 24u) & 0b1111u;
    }

    /**
     * Get CGCFG's BITCOUNT field.
     */
    inline uint8_t get_CGCFG_BITCOUNT() volatile
    {
        return (CGCFG >> 16u) & 0b11111u;
    }

    /**
     * Get CGCFG's RUN bit.
     */
    inline DSD_CGCFG_RUN get_CGCFG_RUN() volatile
    {
        return DSD_CGCFG_RUN(CGCFG & (1u << 15u));
    }

    /**
     * Get CGCFG's DIVCG field.
     */
    inline DSD_CGCFG_DIVCG get_CGCFG_DIVCG() volatile
    {
        return DSD_CGCFG_DIVCG((CGCFG >> 4u) & 0b1111u);
    }

    /**
     * Set CGCFG's DIVCG field.
     *
     * Divider Factor for the PWM Pattern Signal Generator
     */
    inline void set_CGCFG_DIVCG(DSD_CGCFG_DIVCG value) volatile
    {
        uint32_t curr = CGCFG;

        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(value) & 0b1111u) << 4u;

        CGCFG = curr;
    }

    /**
     * Get CGCFG's SIGPOL bit.
     */
    inline DSD_CGCFG_SIGPOL get_CGCFG_SIGPOL() volatile
    {
        return DSD_CGCFG_SIGPOL(CGCFG & (1u << 3u));
    }

    /**
     * Set CGCFG's SIGPOL bit.
     *
     * Signal Polarity
     */
    inline void set_CGCFG_SIGPOL() volatile
    {
        CGCFG |= 1u << 3u;
    }

    /**
     * Clear CGCFG's SIGPOL bit.
     *
     * Signal Polarity
     */
    inline void clear_CGCFG_SIGPOL() volatile
    {
        CGCFG &= ~(1u << 3u);
    }

    /**
     * Toggle CGCFG's SIGPOL bit.
     *
     * Signal Polarity
     */
    inline void toggle_CGCFG_SIGPOL() volatile
    {
        CGCFG ^= 1u << 3u;
    }

    /**
     * Get CGCFG's BREV bit.
     */
    inline DSD_CGCFG_BREV get_CGCFG_BREV() volatile
    {
        return DSD_CGCFG_BREV(CGCFG & (1u << 2u));
    }

    /**
     * Set CGCFG's BREV bit.
     *
     * Bit-Reverse PWM Generation
     */
    inline void set_CGCFG_BREV() volatile
    {
        CGCFG |= 1u << 2u;
    }

    /**
     * Clear CGCFG's BREV bit.
     *
     * Bit-Reverse PWM Generation
     */
    inline void clear_CGCFG_BREV() volatile
    {
        CGCFG &= ~(1u << 2u);
    }

    /**
     * Toggle CGCFG's BREV bit.
     *
     * Bit-Reverse PWM Generation
     */
    inline void toggle_CGCFG_BREV() volatile
    {
        CGCFG ^= 1u << 2u;
    }

    /**
     * Get CGCFG's CGMOD field.
     */
    inline DSD_CGCFG_CGMOD get_CGCFG_CGMOD() volatile
    {
        return DSD_CGCFG_CGMOD((CGCFG >> 0u) & 0b11u);
    }

    /**
     * Set CGCFG's CGMOD field.
     *
     * Carrier Generator Operating Mode
     */
    inline void set_CGCFG_CGMOD(DSD_CGCFG_CGMOD value) volatile
    {
        uint32_t curr = CGCFG;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CGCFG = curr;
    }

    /**
     * Get all of CGCFG's bit fields.
     */
    inline void get_CGCFG(DSD_CGCFG_SGNCG &SGNCG, DSD_CGCFG_STEPD &STEPD,
                          DSD_CGCFG_STEPS &STEPS, uint8_t &STEPCOUNT,
                          uint8_t &BITCOUNT, DSD_CGCFG_RUN &RUN,
                          DSD_CGCFG_DIVCG &DIVCG, DSD_CGCFG_SIGPOL &SIGPOL,
                          DSD_CGCFG_BREV &BREV,
                          DSD_CGCFG_CGMOD &CGMOD) volatile
    {
        uint32_t curr = CGCFG;

        SGNCG = DSD_CGCFG_SGNCG(curr & (1u << 30u));
        STEPD = DSD_CGCFG_STEPD(curr & (1u << 29u));
        STEPS = DSD_CGCFG_STEPS(curr & (1u << 28u));
        STEPCOUNT = (curr >> 24u) & 0b1111u;
        BITCOUNT = (curr >> 16u) & 0b11111u;
        RUN = DSD_CGCFG_RUN(curr & (1u << 15u));
        DIVCG = DSD_CGCFG_DIVCG((curr >> 4u) & 0b1111u);
        SIGPOL = DSD_CGCFG_SIGPOL(curr & (1u << 3u));
        BREV = DSD_CGCFG_BREV(curr & (1u << 2u));
        CGMOD = DSD_CGCFG_CGMOD((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of CGCFG's bit fields.
     *
     * (read-write) Carrier Generator Configuration Register
     */
    inline void set_CGCFG(DSD_CGCFG_DIVCG DIVCG, DSD_CGCFG_SIGPOL SIGPOL,
                          DSD_CGCFG_BREV BREV, DSD_CGCFG_CGMOD CGMOD) volatile
    {
        uint32_t curr = CGCFG;

        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(DIVCG) & 0b1111u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(SIGPOL) & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (std::to_underlying(BREV) & 0b1u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(CGMOD) & 0b11u) << 0u;

        CGCFG = curr;
    }

    /**
     * Get EVFLAG's ALEV3 bit.
     */
    inline DSD_EVFLAG_ALEV3 get_EVFLAG_ALEV3() volatile
    {
        return DSD_EVFLAG_ALEV3(EVFLAG & (1u << 19u));
    }

    /**
     * Set EVFLAG's ALEV3 bit.
     *
     * Alarm Event
     */
    inline void set_EVFLAG_ALEV3() volatile
    {
        EVFLAG |= 1u << 19u;
    }

    /**
     * Clear EVFLAG's ALEV3 bit.
     *
     * Alarm Event
     */
    inline void clear_EVFLAG_ALEV3() volatile
    {
        EVFLAG &= ~(1u << 19u);
    }

    /**
     * Toggle EVFLAG's ALEV3 bit.
     *
     * Alarm Event
     */
    inline void toggle_EVFLAG_ALEV3() volatile
    {
        EVFLAG ^= 1u << 19u;
    }

    /**
     * Get EVFLAG's ALEV2 bit.
     */
    inline DSD_EVFLAG_ALEV3 get_EVFLAG_ALEV2() volatile
    {
        return DSD_EVFLAG_ALEV3(EVFLAG & (1u << 18u));
    }

    /**
     * Set EVFLAG's ALEV2 bit.
     *
     * Alarm Event
     */
    inline void set_EVFLAG_ALEV2() volatile
    {
        EVFLAG |= 1u << 18u;
    }

    /**
     * Clear EVFLAG's ALEV2 bit.
     *
     * Alarm Event
     */
    inline void clear_EVFLAG_ALEV2() volatile
    {
        EVFLAG &= ~(1u << 18u);
    }

    /**
     * Toggle EVFLAG's ALEV2 bit.
     *
     * Alarm Event
     */
    inline void toggle_EVFLAG_ALEV2() volatile
    {
        EVFLAG ^= 1u << 18u;
    }

    /**
     * Get EVFLAG's ALEV1 bit.
     */
    inline DSD_EVFLAG_ALEV3 get_EVFLAG_ALEV1() volatile
    {
        return DSD_EVFLAG_ALEV3(EVFLAG & (1u << 17u));
    }

    /**
     * Set EVFLAG's ALEV1 bit.
     *
     * Alarm Event
     */
    inline void set_EVFLAG_ALEV1() volatile
    {
        EVFLAG |= 1u << 17u;
    }

    /**
     * Clear EVFLAG's ALEV1 bit.
     *
     * Alarm Event
     */
    inline void clear_EVFLAG_ALEV1() volatile
    {
        EVFLAG &= ~(1u << 17u);
    }

    /**
     * Toggle EVFLAG's ALEV1 bit.
     *
     * Alarm Event
     */
    inline void toggle_EVFLAG_ALEV1() volatile
    {
        EVFLAG ^= 1u << 17u;
    }

    /**
     * Get EVFLAG's ALEV0 bit.
     */
    inline DSD_EVFLAG_ALEV3 get_EVFLAG_ALEV0() volatile
    {
        return DSD_EVFLAG_ALEV3(EVFLAG & (1u << 16u));
    }

    /**
     * Set EVFLAG's ALEV0 bit.
     *
     * Alarm Event
     */
    inline void set_EVFLAG_ALEV0() volatile
    {
        EVFLAG |= 1u << 16u;
    }

    /**
     * Clear EVFLAG's ALEV0 bit.
     *
     * Alarm Event
     */
    inline void clear_EVFLAG_ALEV0() volatile
    {
        EVFLAG &= ~(1u << 16u);
    }

    /**
     * Toggle EVFLAG's ALEV0 bit.
     *
     * Alarm Event
     */
    inline void toggle_EVFLAG_ALEV0() volatile
    {
        EVFLAG ^= 1u << 16u;
    }

    /**
     * Get EVFLAG's RESEV3 bit.
     */
    inline DSD_EVFLAG_RESEV3 get_EVFLAG_RESEV3() volatile
    {
        return DSD_EVFLAG_RESEV3(EVFLAG & (1u << 3u));
    }

    /**
     * Set EVFLAG's RESEV3 bit.
     *
     * Result Event
     */
    inline void set_EVFLAG_RESEV3() volatile
    {
        EVFLAG |= 1u << 3u;
    }

    /**
     * Clear EVFLAG's RESEV3 bit.
     *
     * Result Event
     */
    inline void clear_EVFLAG_RESEV3() volatile
    {
        EVFLAG &= ~(1u << 3u);
    }

    /**
     * Toggle EVFLAG's RESEV3 bit.
     *
     * Result Event
     */
    inline void toggle_EVFLAG_RESEV3() volatile
    {
        EVFLAG ^= 1u << 3u;
    }

    /**
     * Get EVFLAG's RESEV2 bit.
     */
    inline DSD_EVFLAG_RESEV3 get_EVFLAG_RESEV2() volatile
    {
        return DSD_EVFLAG_RESEV3(EVFLAG & (1u << 2u));
    }

    /**
     * Set EVFLAG's RESEV2 bit.
     *
     * Result Event
     */
    inline void set_EVFLAG_RESEV2() volatile
    {
        EVFLAG |= 1u << 2u;
    }

    /**
     * Clear EVFLAG's RESEV2 bit.
     *
     * Result Event
     */
    inline void clear_EVFLAG_RESEV2() volatile
    {
        EVFLAG &= ~(1u << 2u);
    }

    /**
     * Toggle EVFLAG's RESEV2 bit.
     *
     * Result Event
     */
    inline void toggle_EVFLAG_RESEV2() volatile
    {
        EVFLAG ^= 1u << 2u;
    }

    /**
     * Get EVFLAG's RESEV1 bit.
     */
    inline DSD_EVFLAG_RESEV3 get_EVFLAG_RESEV1() volatile
    {
        return DSD_EVFLAG_RESEV3(EVFLAG & (1u << 1u));
    }

    /**
     * Set EVFLAG's RESEV1 bit.
     *
     * Result Event
     */
    inline void set_EVFLAG_RESEV1() volatile
    {
        EVFLAG |= 1u << 1u;
    }

    /**
     * Clear EVFLAG's RESEV1 bit.
     *
     * Result Event
     */
    inline void clear_EVFLAG_RESEV1() volatile
    {
        EVFLAG &= ~(1u << 1u);
    }

    /**
     * Toggle EVFLAG's RESEV1 bit.
     *
     * Result Event
     */
    inline void toggle_EVFLAG_RESEV1() volatile
    {
        EVFLAG ^= 1u << 1u;
    }

    /**
     * Get EVFLAG's RESEV0 bit.
     */
    inline DSD_EVFLAG_RESEV3 get_EVFLAG_RESEV0() volatile
    {
        return DSD_EVFLAG_RESEV3(EVFLAG & (1u << 0u));
    }

    /**
     * Set EVFLAG's RESEV0 bit.
     *
     * Result Event
     */
    inline void set_EVFLAG_RESEV0() volatile
    {
        EVFLAG |= 1u << 0u;
    }

    /**
     * Clear EVFLAG's RESEV0 bit.
     *
     * Result Event
     */
    inline void clear_EVFLAG_RESEV0() volatile
    {
        EVFLAG &= ~(1u << 0u);
    }

    /**
     * Toggle EVFLAG's RESEV0 bit.
     *
     * Result Event
     */
    inline void toggle_EVFLAG_RESEV0() volatile
    {
        EVFLAG ^= 1u << 0u;
    }

    /**
     * Get all of EVFLAG's bit fields.
     */
    inline void get_EVFLAG(DSD_EVFLAG_ALEV3 &ALEV3, DSD_EVFLAG_ALEV3 &ALEV2,
                           DSD_EVFLAG_ALEV3 &ALEV1, DSD_EVFLAG_ALEV3 &ALEV0,
                           DSD_EVFLAG_RESEV3 &RESEV3,
                           DSD_EVFLAG_RESEV3 &RESEV2,
                           DSD_EVFLAG_RESEV3 &RESEV1,
                           DSD_EVFLAG_RESEV3 &RESEV0) volatile
    {
        uint32_t curr = EVFLAG;

        ALEV3 = DSD_EVFLAG_ALEV3(curr & (1u << 19u));
        ALEV2 = DSD_EVFLAG_ALEV3(curr & (1u << 18u));
        ALEV1 = DSD_EVFLAG_ALEV3(curr & (1u << 17u));
        ALEV0 = DSD_EVFLAG_ALEV3(curr & (1u << 16u));
        RESEV3 = DSD_EVFLAG_RESEV3(curr & (1u << 3u));
        RESEV2 = DSD_EVFLAG_RESEV3(curr & (1u << 2u));
        RESEV1 = DSD_EVFLAG_RESEV3(curr & (1u << 1u));
        RESEV0 = DSD_EVFLAG_RESEV3(curr & (1u << 0u));
    }

    /**
     * Set all of EVFLAG's bit fields.
     *
     * (read-write) Event Flag Register
     */
    inline void set_EVFLAG(DSD_EVFLAG_ALEV3 ALEV3, DSD_EVFLAG_ALEV3 ALEV2,
                           DSD_EVFLAG_ALEV3 ALEV1, DSD_EVFLAG_ALEV3 ALEV0,
                           DSD_EVFLAG_RESEV3 RESEV3, DSD_EVFLAG_RESEV3 RESEV2,
                           DSD_EVFLAG_RESEV3 RESEV1,
                           DSD_EVFLAG_RESEV3 RESEV0) volatile
    {
        uint32_t curr = EVFLAG;

        curr &= ~(0b1u << 19u);
        curr |= (std::to_underlying(ALEV3) & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (std::to_underlying(ALEV2) & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(ALEV1) & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (std::to_underlying(ALEV0) & 0b1u) << 16u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(RESEV3) & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (std::to_underlying(RESEV2) & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(RESEV1) & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(RESEV0) & 0b1u) << 0u;

        EVFLAG = curr;
    }

    /**
     * Set EVFLAGCLR's ALEC3 bit.
     *
     * Alarm Event Clear
     */
    inline void set_EVFLAGCLR_ALEC3() volatile
    {
        EVFLAGCLR |= 1u << 19u;
    }

    /**
     * Clear EVFLAGCLR's ALEC3 bit.
     *
     * Alarm Event Clear
     */
    inline void clear_EVFLAGCLR_ALEC3() volatile
    {
        EVFLAGCLR &= ~(1u << 19u);
    }

    /**
     * Toggle EVFLAGCLR's ALEC3 bit.
     *
     * Alarm Event Clear
     */
    inline void toggle_EVFLAGCLR_ALEC3() volatile
    {
        EVFLAGCLR ^= 1u << 19u;
    }

    /**
     * Set EVFLAGCLR's ALEC2 bit.
     *
     * Alarm Event Clear
     */
    inline void set_EVFLAGCLR_ALEC2() volatile
    {
        EVFLAGCLR |= 1u << 18u;
    }

    /**
     * Clear EVFLAGCLR's ALEC2 bit.
     *
     * Alarm Event Clear
     */
    inline void clear_EVFLAGCLR_ALEC2() volatile
    {
        EVFLAGCLR &= ~(1u << 18u);
    }

    /**
     * Toggle EVFLAGCLR's ALEC2 bit.
     *
     * Alarm Event Clear
     */
    inline void toggle_EVFLAGCLR_ALEC2() volatile
    {
        EVFLAGCLR ^= 1u << 18u;
    }

    /**
     * Set EVFLAGCLR's ALEC1 bit.
     *
     * Alarm Event Clear
     */
    inline void set_EVFLAGCLR_ALEC1() volatile
    {
        EVFLAGCLR |= 1u << 17u;
    }

    /**
     * Clear EVFLAGCLR's ALEC1 bit.
     *
     * Alarm Event Clear
     */
    inline void clear_EVFLAGCLR_ALEC1() volatile
    {
        EVFLAGCLR &= ~(1u << 17u);
    }

    /**
     * Toggle EVFLAGCLR's ALEC1 bit.
     *
     * Alarm Event Clear
     */
    inline void toggle_EVFLAGCLR_ALEC1() volatile
    {
        EVFLAGCLR ^= 1u << 17u;
    }

    /**
     * Set EVFLAGCLR's ALEC0 bit.
     *
     * Alarm Event Clear
     */
    inline void set_EVFLAGCLR_ALEC0() volatile
    {
        EVFLAGCLR |= 1u << 16u;
    }

    /**
     * Clear EVFLAGCLR's ALEC0 bit.
     *
     * Alarm Event Clear
     */
    inline void clear_EVFLAGCLR_ALEC0() volatile
    {
        EVFLAGCLR &= ~(1u << 16u);
    }

    /**
     * Toggle EVFLAGCLR's ALEC0 bit.
     *
     * Alarm Event Clear
     */
    inline void toggle_EVFLAGCLR_ALEC0() volatile
    {
        EVFLAGCLR ^= 1u << 16u;
    }

    /**
     * Set EVFLAGCLR's RESEC3 bit.
     *
     * Result Event Clear
     */
    inline void set_EVFLAGCLR_RESEC3() volatile
    {
        EVFLAGCLR |= 1u << 3u;
    }

    /**
     * Clear EVFLAGCLR's RESEC3 bit.
     *
     * Result Event Clear
     */
    inline void clear_EVFLAGCLR_RESEC3() volatile
    {
        EVFLAGCLR &= ~(1u << 3u);
    }

    /**
     * Toggle EVFLAGCLR's RESEC3 bit.
     *
     * Result Event Clear
     */
    inline void toggle_EVFLAGCLR_RESEC3() volatile
    {
        EVFLAGCLR ^= 1u << 3u;
    }

    /**
     * Set EVFLAGCLR's RESEC2 bit.
     *
     * Result Event Clear
     */
    inline void set_EVFLAGCLR_RESEC2() volatile
    {
        EVFLAGCLR |= 1u << 2u;
    }

    /**
     * Clear EVFLAGCLR's RESEC2 bit.
     *
     * Result Event Clear
     */
    inline void clear_EVFLAGCLR_RESEC2() volatile
    {
        EVFLAGCLR &= ~(1u << 2u);
    }

    /**
     * Toggle EVFLAGCLR's RESEC2 bit.
     *
     * Result Event Clear
     */
    inline void toggle_EVFLAGCLR_RESEC2() volatile
    {
        EVFLAGCLR ^= 1u << 2u;
    }

    /**
     * Set EVFLAGCLR's RESEC1 bit.
     *
     * Result Event Clear
     */
    inline void set_EVFLAGCLR_RESEC1() volatile
    {
        EVFLAGCLR |= 1u << 1u;
    }

    /**
     * Clear EVFLAGCLR's RESEC1 bit.
     *
     * Result Event Clear
     */
    inline void clear_EVFLAGCLR_RESEC1() volatile
    {
        EVFLAGCLR &= ~(1u << 1u);
    }

    /**
     * Toggle EVFLAGCLR's RESEC1 bit.
     *
     * Result Event Clear
     */
    inline void toggle_EVFLAGCLR_RESEC1() volatile
    {
        EVFLAGCLR ^= 1u << 1u;
    }

    /**
     * Set EVFLAGCLR's RESEC0 bit.
     *
     * Result Event Clear
     */
    inline void set_EVFLAGCLR_RESEC0() volatile
    {
        EVFLAGCLR |= 1u << 0u;
    }

    /**
     * Clear EVFLAGCLR's RESEC0 bit.
     *
     * Result Event Clear
     */
    inline void clear_EVFLAGCLR_RESEC0() volatile
    {
        EVFLAGCLR &= ~(1u << 0u);
    }

    /**
     * Toggle EVFLAGCLR's RESEC0 bit.
     *
     * Result Event Clear
     */
    inline void toggle_EVFLAGCLR_RESEC0() volatile
    {
        EVFLAGCLR ^= 1u << 0u;
    }

    /**
     * Set all of EVFLAGCLR's bit fields.
     *
     * (write-only) Event Flag Clear Register
     */
    inline void set_EVFLAGCLR(
        DSD_EVFLAGCLR_ALEC3 ALEC3, DSD_EVFLAGCLR_ALEC3 ALEC2,
        DSD_EVFLAGCLR_ALEC3 ALEC1, DSD_EVFLAGCLR_ALEC3 ALEC0,
        DSD_EVFLAGCLR_RESEC3 RESEC3, DSD_EVFLAGCLR_RESEC3 RESEC2,
        DSD_EVFLAGCLR_RESEC3 RESEC1, DSD_EVFLAGCLR_RESEC3 RESEC0) volatile
    {
        uint32_t curr = EVFLAGCLR;

        curr &= ~(0b1u << 19u);
        curr |= (std::to_underlying(ALEC3) & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (std::to_underlying(ALEC2) & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (std::to_underlying(ALEC1) & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (std::to_underlying(ALEC0) & 0b1u) << 16u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(RESEC3) & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (std::to_underlying(RESEC2) & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(RESEC1) & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(RESEC0) & 0b1u) << 0u;

        EVFLAGCLR = curr;
    }
};

static_assert(sizeof(dsd) == dsd::size);

static volatile dsd *const DSD = reinterpret_cast<dsd *>(0x40008000);

}; // namespace XMC4700
